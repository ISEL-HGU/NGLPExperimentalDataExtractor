import java.util.concurrent.locks.ReentrantLock;
private ReentrantLock instructionStreamLock;
instructionStreamLock = (ReentrantLock) session.getAttribute("INSTRUCTION_STREAM_LOCK");
instructionStreamLock = new ReentrantLock();
session.setAttribute("INSTRUCTION_STREAM_LOCK", instructionStreamLock);
public ReentrantLock getInstructionStreamLock() {
return instructionStreamLock;
}
import java.util.concurrent.locks.ReentrantLock;
ReentrantLock instructionStreamLock = session.getInstructionStreamLock();
instructionStreamLock.lock();
response.setContentType("text/plain");
OutputStream out = response.getOutputStream();
out = new GZIPOutputStream(out);
out = new DeflaterOutputStream(out);
try {
Client client = session.getClient();
while (message != null) {
byte[] outputBytes = message.toString().getBytes("UTF-8");
out.write(outputBytes);
out.flush();
response.flushBuffer();
if (instructionStreamLock.hasQueuedThreads())
break;
}
}
catch (GuacamoleException e) {
Instruction message = new ErrorInstruction(e.getMessage());
byte[] outputBytes = message.toString().getBytes("UTF-8");
out.write(outputBytes);
out.flush();
response.flushBuffer();
}
out.write(';');
response.flushBuffer();
finally {
instructionStreamLock.unlock();
}
if (blocking) {
try {
synchronized (output) {
output.writeByte(MESSAGE_FRAMEBUFFER_UPDATE_REQUEST);
output.flush();
}
catch (IOException e) {
throw new GuacamoleException("Could not send framebuffer update request to VNC server (network error).", e);
}
import java.util.concurrent.locks.ReentrantLock;
private ReentrantLock instructionStreamLock;
instructionStreamLock = (ReentrantLock) session.getAttribute("INSTRUCTION_STREAM_LOCK");
instructionStreamLock = new ReentrantLock();
session.setAttribute("INSTRUCTION_STREAM_LOCK", instructionStreamLock);
public ReentrantLock getInstructionStreamLock() {
return instructionStreamLock;
}
import java.util.concurrent.locks.ReentrantLock;
ReentrantLock instructionStreamLock = session.getInstructionStreamLock();
instructionStreamLock.lock();
response.setContentType("text/plain");
OutputStream out = response.getOutputStream();
out = new GZIPOutputStream(out);
out = new DeflaterOutputStream(out);
try {
Client client = session.getClient();
while (message != null) {
byte[] outputBytes = message.toString().getBytes("UTF-8");
out.write(outputBytes);
out.flush();
response.flushBuffer();
if (instructionStreamLock.hasQueuedThreads())
break;
}
}
catch (GuacamoleException e) {
Instruction message = new ErrorInstruction(e.getMessage());
byte[] outputBytes = message.toString().getBytes("UTF-8");
out.write(outputBytes);
out.flush();
response.flushBuffer();
}
out.write(';');
response.flushBuffer();
finally {
instructionStreamLock.unlock();
}
if (blocking) {
try {
synchronized (output) {
output.writeByte(MESSAGE_FRAMEBUFFER_UPDATE_REQUEST);
output.flush();
}
catch (IOException e) {
throw new GuacamoleException("Could not send framebuffer update request to VNC server (network error).", e);
}
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.event.KeyEvent;
import net.sourceforge.guacamole.event.PointerEvent;
package net.sourceforge.guacamole;
package net.sourceforge.guacamole.event;
package net.sourceforge.guacamole.event;
package net.sourceforge.guacamole.event;
package net.sourceforge.guacamole.event;
package net.sourceforge.guacamole.event;
import net.sourceforge.guacamole.GuacamoleException;
public PNGImage(BufferedImage image) throws GuacamoleException {
throw new GuacamoleException("I/O Error while creating PNG.", e);
private static void writeImage(BufferedImage image, OutputStream outputStream) throws GuacamoleException, IOException  {
throw new GuacamoleException("No useful image writers found.");
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.GuacamoleException;
private String protocol;
protocol       = readParameter("protocol", "vnc", "vnc");
public String getProtocol() {
return protocol;
}
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.instruction.Instruction;
import net.sourceforge.guacamole.event.KeyEvent;
import net.sourceforge.guacamole.event.PointerEvent;
private class SessionClient extends Client implements HttpSessionBindingListener {
private Client client;
public SessionClient(Client client) {
this.client = client;
public void send(KeyEvent event) throws GuacamoleException {
client.send(event);
}
public void send(PointerEvent event) throws GuacamoleException {
client.send(event);
}
public void setClipboard(String clipboard) throws GuacamoleException {
client.setClipboard(clipboard);
}
public void disconnect() throws GuacamoleException {
client.disconnect();
}
public Instruction nextInstruction(boolean blocking) throws GuacamoleException {
return client.nextInstruction(blocking);
}
String protocol = config.getProtocol();
if (protocol.equals("vnc")) {
try {
ServletContext context = session.getServletContext();
VNCConfiguration vncconfig = new VNCConfiguration(context);
client = new SessionClient(
new VNCClient(
vncconfig.getHostname(),
vncconfig.getPort(),
vncconfig.getPassword(),
vncconfig.getBPP(),
config.getOutputBPP()
)
);
}
catch (VNCException e) {
throw new GuacamoleException(e);
}
else
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.event.KeyEvent;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.event.PointerEvent;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.event.PointerEvent;
import net.sourceforge.guacamole.event.EventQueue;
import net.sourceforge.guacamole.event.KeyEvent;
import net.sourceforge.guacamole.event.EventHandler;
import net.sourceforge.guacamole.GuacamoleException;
private void handleMessages(boolean blocking) throws IOException, VNCException, GuacamoleException {
private void handleFramebufferUpdate() throws IOException, VNCException, GuacamoleException {
import net.sourceforge.guacamole.net.Configuration;
import net.sourceforge.guacamole.GuacamoleException;
private String hostname;
private int port;
hostname       = readParameter("host", null);
port           = readIntParameter("port", null);
public String getHostname() {
return hostname;
}
public int getPort() {
return port;
}
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.event.KeyEvent;
import net.sourceforge.guacamole.event.PointerEvent;
package net.sourceforge.guacamole;
package net.sourceforge.guacamole.event;
package net.sourceforge.guacamole.event;
package net.sourceforge.guacamole.event;
package net.sourceforge.guacamole.event;
package net.sourceforge.guacamole.event;
import net.sourceforge.guacamole.GuacamoleException;
public PNGImage(BufferedImage image) throws GuacamoleException {
throw new GuacamoleException("I/O Error while creating PNG.", e);
private static void writeImage(BufferedImage image, OutputStream outputStream) throws GuacamoleException, IOException  {
throw new GuacamoleException("No useful image writers found.");
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.GuacamoleException;
private String protocol;
protocol       = readParameter("protocol", "vnc", "vnc");
public String getProtocol() {
return protocol;
}
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.instruction.Instruction;
import net.sourceforge.guacamole.event.KeyEvent;
import net.sourceforge.guacamole.event.PointerEvent;
private class SessionClient extends Client implements HttpSessionBindingListener {
private Client client;
public SessionClient(Client client) {
this.client = client;
public void send(KeyEvent event) throws GuacamoleException {
client.send(event);
}
public void send(PointerEvent event) throws GuacamoleException {
client.send(event);
}
public void setClipboard(String clipboard) throws GuacamoleException {
client.setClipboard(clipboard);
}
public void disconnect() throws GuacamoleException {
client.disconnect();
}
public Instruction nextInstruction(boolean blocking) throws GuacamoleException {
return client.nextInstruction(blocking);
}
String protocol = config.getProtocol();
if (protocol.equals("vnc")) {
try {
ServletContext context = session.getServletContext();
VNCConfiguration vncconfig = new VNCConfiguration(context);
client = new SessionClient(
new VNCClient(
vncconfig.getHostname(),
vncconfig.getPort(),
vncconfig.getPassword(),
vncconfig.getBPP(),
config.getOutputBPP()
)
);
}
catch (VNCException e) {
throw new GuacamoleException(e);
}
else
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.event.KeyEvent;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.event.PointerEvent;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.event.PointerEvent;
import net.sourceforge.guacamole.event.EventQueue;
import net.sourceforge.guacamole.event.KeyEvent;
import net.sourceforge.guacamole.event.EventHandler;
import net.sourceforge.guacamole.GuacamoleException;
private void handleMessages(boolean blocking) throws IOException, VNCException, GuacamoleException {
private void handleFramebufferUpdate() throws IOException, VNCException, GuacamoleException {
import net.sourceforge.guacamole.net.Configuration;
import net.sourceforge.guacamole.GuacamoleException;
private String hostname;
private int port;
hostname       = readParameter("host", null);
port           = readIntParameter("port", null);
public String getHostname() {
return hostname;
}
public int getPort() {
return port;
}
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.event.KeyEvent;
import net.sourceforge.guacamole.event.PointerEvent;
package net.sourceforge.guacamole;
package net.sourceforge.guacamole.event;
package net.sourceforge.guacamole.event;
package net.sourceforge.guacamole.event;
package net.sourceforge.guacamole.event;
package net.sourceforge.guacamole.event;
import net.sourceforge.guacamole.GuacamoleException;
public PNGImage(BufferedImage image) throws GuacamoleException {
throw new GuacamoleException("I/O Error while creating PNG.", e);
private static void writeImage(BufferedImage image, OutputStream outputStream) throws GuacamoleException, IOException  {
throw new GuacamoleException("No useful image writers found.");
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.GuacamoleException;
private String protocol;
protocol       = readParameter("protocol", "vnc", "vnc");
public String getProtocol() {
return protocol;
}
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.instruction.Instruction;
import net.sourceforge.guacamole.event.KeyEvent;
import net.sourceforge.guacamole.event.PointerEvent;
private class SessionClient extends Client implements HttpSessionBindingListener {
private Client client;
public SessionClient(Client client) {
this.client = client;
public void send(KeyEvent event) throws GuacamoleException {
client.send(event);
}
public void send(PointerEvent event) throws GuacamoleException {
client.send(event);
}
public void setClipboard(String clipboard) throws GuacamoleException {
client.setClipboard(clipboard);
}
public void disconnect() throws GuacamoleException {
client.disconnect();
}
public Instruction nextInstruction(boolean blocking) throws GuacamoleException {
return client.nextInstruction(blocking);
}
String protocol = config.getProtocol();
if (protocol.equals("vnc")) {
try {
ServletContext context = session.getServletContext();
VNCConfiguration vncconfig = new VNCConfiguration(context);
client = new SessionClient(
new VNCClient(
vncconfig.getHostname(),
vncconfig.getPort(),
vncconfig.getPassword(),
vncconfig.getBPP(),
config.getOutputBPP()
)
);
}
catch (VNCException e) {
throw new GuacamoleException(e);
}
else
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.event.KeyEvent;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.event.PointerEvent;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.event.PointerEvent;
import net.sourceforge.guacamole.event.EventQueue;
import net.sourceforge.guacamole.event.KeyEvent;
import net.sourceforge.guacamole.event.EventHandler;
import net.sourceforge.guacamole.GuacamoleException;
private void handleMessages(boolean blocking) throws IOException, VNCException, GuacamoleException {
private void handleFramebufferUpdate() throws IOException, VNCException, GuacamoleException {
import net.sourceforge.guacamole.net.Configuration;
import net.sourceforge.guacamole.GuacamoleException;
private String hostname;
private int port;
hostname       = readParameter("host", null);
port           = readIntParameter("port", null);
public String getHostname() {
return hostname;
}
public int getPort() {
return port;
}
return false;
greenMax = (1 << greenBits) - 1;
redMax   = (1 << redBits)   - 1;
int green = input.read();
int red   = input.read();
value = Short.reverseBytes(input.readShort());
value = Integer.reverseBytes(input.readInt());
int bpp = input.read();
int depth = input.read();
boolean bigEndian = input.readBoolean();
boolean trueColor = input.readBoolean();
int redMax = input.readUnsignedShort();
int greenMax = input.readUnsignedShort();
int blueMax = input.readUnsignedShort();
int redShift = input.read();
int greenShift = input.read();
int blueShift = input.read();
byte[] padding = new byte[3];
input.readFully(padding);
fullColorReader = new VNCFullColorImageReader(bigEndian, 3, 3, 2, 8);
fullColorReader = new VNCFullColorImageReader(bigEndian, 5, 6, 5, outputBPP);
fullColorReader = new VNCFullColorImageReader(bigEndian, 8, 8, 8, outputBPP);
private boolean bigEndian;
return bigEndian;
public VNCFullColorImageReader(boolean bigEndian, int redBits, int greenBits, int blueBits, int outputBPP) throws VNCException {
int red;
int green;
int blue;
if (bigEndian) {
red   = input.read();
green = input.read();
blue  = input.read();
}
else {
blue  = input.read();
green = input.read();
red   = input.read();
}
short inputShort = input.readShort();
if (!bigEndian) inputShort = Short.reverseBytes(inputShort);
value = inputShort;
int inputInt = input.readInt();
if (!bigEndian) inputInt = Integer.reverseBytes(inputInt);
value = inputInt;
int bpp = input.read();
int depth = input.read();
boolean bigEndian = input.readBoolean();
boolean trueColor = input.readBoolean();
int redMax = input.readUnsignedShort();
int greenMax = input.readUnsignedShort();
int blueMax = input.readUnsignedShort();
int redShift = input.read();
int greenShift = input.read();
int blueShift = input.read();
byte[] padding = new byte[3];
input.readFully(padding);
fullColorReader = new VNCFullColorImageReader(bigEndian, 3, 3, 2, 8);
fullColorReader = new VNCFullColorImageReader(bigEndian, 5, 6, 5, outputBPP);
fullColorReader = new VNCFullColorImageReader(bigEndian, 8, 8, 8, outputBPP);
private boolean bigEndian;
return bigEndian;
public VNCFullColorImageReader(boolean bigEndian, int redBits, int greenBits, int blueBits, int outputBPP) throws VNCException {
greenMax = (1 << greenBits) - 1;
redMax   = (1 << redBits)   - 1;
int red;
int green;
int blue;
if (bigEndian) {
red   = input.read();
green = input.read();
blue  = input.read();
}
else {
blue  = input.read();
green = input.read();
red   = input.read();
}
short inputShort = input.readShort();
if (!bigEndian) inputShort = Short.reverseBytes(inputShort);
value = inputShort;
int inputInt = input.readInt();
if (!bigEndian) inputInt = Integer.reverseBytes(inputInt);
value = inputInt;
private boolean swapRedAndBlue;
swapRedAndBlue = readBooleanParameter("swap-red-blue", false);
public boolean getSwapRedAndBlue() {
return swapRedAndBlue;
}
config.getOutputBPP(),
config.getSwapRedAndBlue()
public VNCClient(String host, int port, String password, int colorBits, int outputBPP, boolean swapRedAndBlue)
fullColorReader = new VNCFullColorImageReader(bigEndian, 3, 3, 2, 8, swapRedAndBlue);
fullColorReader = new VNCFullColorImageReader(bigEndian, 5, 6, 5, outputBPP, swapRedAndBlue);
fullColorReader = new VNCFullColorImageReader(bigEndian, 8, 8, 8, outputBPP, swapRedAndBlue);
private boolean swapRedAndBlue;
public VNCFullColorImageReader(boolean bigEndian, int redBits, int greenBits, int blueBits, int outputBPP, boolean swapRedAndBlue) throws VNCException {
this.swapRedAndBlue = swapRedAndBlue;
if (swapRedAndBlue)
return (blue << 16) | (green << 8) | red;
else
return (red << 16) | (green << 8) | blue;
if (swapRedAndBlue)
return (blue << 16) | (green << 8) | red;
else
return (red << 16) | (green << 8) | blue;
private boolean swapRedAndBlue;
swapRedAndBlue = readBooleanParameter("swap-red-blue", false);
public boolean getSwapRedAndBlue() {
return swapRedAndBlue;
}
config.getOutputBPP(),
config.getSwapRedAndBlue()
public VNCClient(String host, int port, String password, int colorBits, int outputBPP, boolean swapRedAndBlue)
fullColorReader = new VNCFullColorImageReader(bigEndian, 3, 3, 2, 8, swapRedAndBlue);
fullColorReader = new VNCFullColorImageReader(bigEndian, 5, 6, 5, outputBPP, swapRedAndBlue);
fullColorReader = new VNCFullColorImageReader(bigEndian, 8, 8, 8, outputBPP, swapRedAndBlue);
private boolean swapRedAndBlue;
public VNCFullColorImageReader(boolean bigEndian, int redBits, int greenBits, int blueBits, int outputBPP, boolean swapRedAndBlue) throws VNCException {
this.swapRedAndBlue = swapRedAndBlue;
if (swapRedAndBlue)
return (blue << 16) | (green << 8) | red;
else
return (red << 16) | (green << 8) | blue;
if (swapRedAndBlue)
return (blue << 16) | (green << 8) | red;
else
return (red << 16) | (green << 8) | blue;
client = new SessionClient(
);
import net.sourceforge.guacamole.GuacamoleClient;
new GuacamoleClient (
1234
)
private InputStream input;
input = new BufferedInputStream(sock.getInputStream());
while (blocking || input.available() > 0) {
import java.io.Reader;
import java.io.InputStreamReader;
private Reader input;
input = new InputStreamReader(sock.getInputStream());
private int bufferPos = 0;
private char[] buffer = new char[20000];
while (blocking || input.ready()) {
int numRead = input.read(buffer, bufferPos, buffer.length - bufferPos);
if (numRead == -1)
char readChar = buffer[i];
if (readChar == ';') {
return new Instruction() {
public String toString() {
return instruction;
}
};
}
private int usedLength = 0;
if (usedLength > buffer.length/2) {
char[] newbuffer = new char[buffer.length*2];
System.arraycopy(newbuffer, 0, buffer, 0, usedLength);
buffer = newbuffer;
}
int numRead = input.read(buffer, usedLength, buffer.length - usedLength);
int prevLength = usedLength;
for (int i=usedLength-1; i>=prevLength; i--) {
do {
char[] biggerBuffer = new char[buffer.length*2];
System.arraycopy(buffer, 0, biggerBuffer, 0, usedLength);
buffer = biggerBuffer;
import java.io.OutputStream;
import java.io.Writer;
import java.io.OutputStreamWriter;
private Writer output;
output = new OutputStreamWriter(sock.getOutputStream());
try {
int pressed = 0;
if (event.getPressed()) pressed = 1;
output.flush();
}
catch (IOException e) {
throw new GuacamoleException(e);
}
try {
int mask = 0;
if (event.isLeftButtonPressed())   mask |= 1;
if (event.isMiddleButtonPressed()) mask |= 2;
if (event.isRightButtonPressed())  mask |= 4;
if (event.isUpButtonPressed())     mask |= 8;
if (event.isDownButtonPressed())   mask |= 16;
output.flush();
}
catch (IOException e) {
throw new GuacamoleException(e);
}
import net.sourceforge.guacamole.event.EventQueue;
import net.sourceforge.guacamole.event.EventHandler;
private static final int EVENT_DEADLINE = 500;
private EventQueue<KeyEvent> keyEvents = new EventQueue<KeyEvent>(new EventHandler<KeyEvent>() {
public void handle(KeyEvent event) throws IOException {
}, EVENT_DEADLINE);
private EventQueue<PointerEvent> pointerEvents = new EventQueue<PointerEvent>(new EventHandler<PointerEvent>() {
public void handle(PointerEvent event) throws IOException {
}, EVENT_DEADLINE);
public void send(KeyEvent event) throws GuacamoleException {
try {
keyEvents.add(event);
}
catch (IOException e) {
throw new GuacamoleException(e);
}
}
public void send(PointerEvent event) throws GuacamoleException {
try {
pointerEvents.add(event);
}
public abstract void ready() throws GuacamoleException;
public void ready() throws GuacamoleException {
try {
output.write("ready;");
output.flush();
}
catch (IOException e) {
throw new GuacamoleException(e);
}
}
public void ready() throws GuacamoleException {
client.ready();
}
for (;;) {
try {
output.flush();
}
catch (IOException e) {
throw new GuacamoleException(e);
}
public static String escape(String str) {
public abstract void write(char[] chunk, int off, int len) throws GuacamoleException;
public abstract char[] read() throws GuacamoleException;
public void write(char[] chunk, int off, int len) throws GuacamoleException {
output.write(chunk, off, len);
public char[] read() throws GuacamoleException {
return chunk;
public void write(char[] data, int off, int len) throws GuacamoleException {
client.write(data, off, len);
public char[] read() throws GuacamoleException {
return client.read();
import java.io.Reader;
import java.io.IOException;
public class Inbound extends XMLGuacamoleServlet {
Reader input = request.getReader();
char[] buffer = new char[8192];
int length;
while ((length = input.read(buffer, 0, buffer.length)) != -1)
session.getClient().write(buffer, 0, length);
import java.io.Writer;
Writer out = response.getWriter();
char[] message;
while ((message = client.read()) != null) {
out.write(message, 0, message.length);
public boolean isConnected() {
synchronized (session) {
return client != null;
}
}
if (client != null) {
session.removeAttribute("CLIENT");
client = null;
}
protected boolean shouldCreateSession() {
return true;
}
if (!session.isConnected())
session.connect();
protected boolean shouldCreateSession() {
return true;
}
if (!session.isConnected())
session.connect();
if (message == null) {
session.disconnect();
throw new GuacamoleException("Disconnected.");
}
private String hostname;
private int port;
hostname       = context.getInitParameter("hostname");
port           = readIntParameter("port", null);
public int getPort() {
return port;
public String getHostname() {
return hostname;
config.getHostname(),
config.getPort()
package net.sourceforge.guacamole.net.tunnel;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import net.sourceforge.guacamole.net.GuacamoleServlet;
public class Inbound extends GuacamoleServlet {
protected void handleRequest(GuacamoleSession session, HttpServletRequest request, HttpServletResponse response) throws GuacamoleException {
package net.sourceforge.guacamole.net.tunnel;
public class Outbound extends GuacamoleServlet {
private String guacd_hostname;
private int guacd_port;
guacd_hostname       = context.getInitParameter("guacd-hostname");
guacd_port           = readIntParameter("guacd-port", null);
public int getProxyPort() {
return guacd_port;
public String getProxyHostname() {
return guacd_hostname;
config.getProxyHostname(),
config.getProxyPort()
private SessionClient client;
public class SessionClient extends Client implements HttpSessionBindingListener {
private ReentrantLock authorizedLock;
authorizedLock = new ReentrantLock();
authorizedLock.lock();
}
public void authorize() {
authorizedLock.unlock();
}
public void waitForAuthorization() {
if (authorizedLock.isLocked()) {
try {
authorizedLock.lock();
authorizedLock.unlock();
}
catch (Throwable t) {
throw new Error("Internal error waiting for authorization", t);
}
}
client = (SessionClient) session.getAttribute("CLIENT");
public SessionClient getClient() {
String connectString = "connect:vnc,localhost,5901,potato;";
char[] connect = connectString.toCharArray();
session.getClient().authorize();
session.getClient().waitForAuthorization();
session.getClient().waitForAuthorization();
@Override
import java.lang.reflect.InvocationTargetException;
import javax.servlet.http.HttpSession;
private GuacamoleSessionProvider sessionProvider;
try {
String sessionProviderClassName = context.getInitParameter("session-provider");
Object obj = Class.forName(sessionProviderClassName).getConstructor().newInstance();
if (!(obj instanceof GuacamoleSessionProvider))
throw new GuacamoleException("Specified session provider class is not a GuacamoleSessionProvider");
sessionProvider = (GuacamoleSessionProvider) obj;
}
catch (ClassNotFoundException e) {
throw new GuacamoleException("Session provider class not found", e);
}
catch (NoSuchMethodException e) {
throw new GuacamoleException("Default constructor for session provider not present", e);
}
catch (SecurityException e) {
throw new GuacamoleException("Creation of session provider disallowed; check your security settings", e);
}
catch (InstantiationException e) {
throw new GuacamoleException("Unable to instantiate session provider", e);
}
catch (IllegalAccessException e) {
throw new GuacamoleException("Unable to access default constructor of session provider", e);
}
catch (InvocationTargetException e) {
throw new GuacamoleException("Internal error in constructor of session provider", e.getTargetException());
}
public GuacamoleSession createSession(HttpSession session) throws GuacamoleException {
return sessionProvider.createSession(session);
}
import javax.servlet.ServletConfig;
import javax.servlet.http.HttpSession;
private GuacamoleConfiguration config;
@Override
public void init(ServletConfig config) throws ServletException {
try {
this.config = new GuacamoleConfiguration(config.getServletContext());
}
catch (GuacamoleException e) {
throw new ServletException(e);
}
}
HttpSession httpSession = request.getSession(shouldCreateSession());
if (httpSession != null) {
GuacamoleSession session = config.createSession(httpSession);
handleRequest(session, request, response);
}
else
throw new GuacamoleException("No session");
private String protocol;
private String hostname;
private int port;
private String password;
public void setConnection(String protocol, String hostname, int port) {
this.protocol = protocol;
this.hostname = hostname;
this.port = port;
}
public String getProtocol() {
return protocol;
}
public String getHostname() {
return hostname;
}
public int getPort() {
return port;
}
public String getPassword() {
return password;
}
public void setPassword(String password) {
this.password = password;
}
public String getConnectMessage() throws GuacamoleException {
if (getProtocol() == null)
throw new GuacamoleException("Protocol not specified");
if (getHostname() == null)
throw new GuacamoleException("Hostname not specified");
if (getPassword() == null)
else
}
char[] connect = session.getConnectMessage().toCharArray();
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
public static class AuthInfo {
public static enum Encoding {
PLAIN_TEXT,
MD5
}
private Encoding auth_encoding;
public AuthInfo(String auth_username, String auth_password, Encoding auth_encoding) {
this.auth_encoding = auth_encoding;
private static final char HEX_CHARS[] = {
'0', '1', '2', '3', '4', '5', '6', '7',
'8', '9', 'A', 'B', 'C', 'D', 'E', 'F'
};
public static String getHexString(byte[] bytes) {
if (bytes == null)
return null;
StringBuilder hex = new StringBuilder(2 * bytes.length);
for (byte b : bytes) {
hex.append(HEX_CHARS[(b & 0xF0) >> 4])
.append(HEX_CHARS[(b & 0x0F)     ]);
}
return hex.toString();
}
public boolean validate(String username, String password) {
if (username != null && password != null && username.equals(auth_username)) {
switch (auth_encoding) {
case PLAIN_TEXT:
return password.equals(auth_password);
case MD5:
try {
MessageDigest digest = MessageDigest.getInstance("MD5");
String hashedPassword = getHexString(digest.digest(password.getBytes()));
return hashedPassword.equals(auth_password);
}
catch (NoSuchAlgorithmException e) {
throw new UnsupportedOperationException("Unexpected lack of MD5 support.", e);
}
}
}
return false;
}
AuthInfo.Encoding encoding;
String encodingString = attributes.getValue("encoding");
if (encodingString == null)
encoding = AuthInfo.Encoding.PLAIN_TEXT;
else if (encodingString.equals("plain"))
encoding = AuthInfo.Encoding.PLAIN_TEXT;
else if (encodingString.equals("md5"))
encoding = AuthInfo.Encoding.MD5;
else
throw new SAXException("Invalid encoding type");
attributes.getValue("password"),
encoding
if (info.validate(username, password)) {
return hashedPassword.equals(auth_password.toUpperCase());
current.auth_username,
import java.io.File;
private long mappingTime;
private File getUserMappingFile() {
return null;
return new File(filename);
}
@Override
public synchronized void init() throws ServletException {
File mapFile = getUserMappingFile();
if (mapFile == null)
parser.parse(mapFile.getAbsolutePath());
mappingTime = mapFile.lastModified();
File userMappingFile = getUserMappingFile();
if (userMappingFile.exists() && mappingTime < userMappingFile.lastModified()) {
synchronized (this) {
if (userMappingFile.exists() && mappingTime < userMappingFile.lastModified())
}
}
protected String readParameter(String name) throws GuacamoleException {
String value = GuacamoleProperties.getProperty(name);
return value;
}
String value = GuacamoleProperties.getProperty(name);
String value = GuacamoleProperties.getProperty(name);
String parmString = GuacamoleProperties.getProperty(name);
import net.sourceforge.guacamole.net.authentication.GuacamoleSessionProvider;
public GuacamoleConfiguration() throws GuacamoleException {
guacd_hostname       = readParameter("guacd-hostname");
String sessionProviderClassName = readParameter("session-provider");
public void init() throws ServletException {
this.config = new GuacamoleConfiguration();
config = new GuacamoleConfiguration();
package net.sourceforge.guacamole.net.authentication;
import net.sourceforge.guacamole.net.GuacamoleSession;
package net.sourceforge.guacamole.net.authentication;
import net.sourceforge.guacamole.net.GuacamoleSession;
package net.sourceforge.guacamole.net.authentication.basic;
import net.sourceforge.guacamole.net.authentication.GuacamoleSessionProvider;
import java.io.InputStream;
private static final Properties properties;
properties = new Properties();
InputStream stream = GuacamoleProperties.class.getResourceAsStream("/guacamole.properties");
if (stream == null)
throw new IOException("Resource /guacamole.properties not found.");
properties.load(stream);
import net.sourceforge.guacamole.net.GuacamoleProperties;
private File getUserMappingFile() throws GuacamoleException {
String filename = GuacamoleProperties.getProperty("basic-user-mapping");
import java.lang.reflect.InvocationTargetException;
import net.sourceforge.guacamole.net.Configuration;
private Config config;
@Override
public void init() throws ServletException {
try {
config = new Config();
}
catch (GuacamoleException e) {
throw new ServletException(e);
}
}
private class Config extends Configuration {
private AuthenticationProvider authProvider;
public Config() throws GuacamoleException {
try {
String authProviderClassName = readParameter("auth-provider");
Object obj = Class.forName(authProviderClassName).getConstructor().newInstance();
if (!(obj instanceof AuthenticationProvider))
throw new GuacamoleException("Specified session provider class is not a GuacamoleSessionProvider");
authProvider = (AuthenticationProvider) obj;
}
catch (ClassNotFoundException e) {
throw new GuacamoleException("Session provider class not found", e);
}
catch (NoSuchMethodException e) {
throw new GuacamoleException("Default constructor for session provider not present", e);
}
catch (SecurityException e) {
throw new GuacamoleException("Creation of session provider disallowed; check your security settings", e);
}
catch (InstantiationException e) {
throw new GuacamoleException("Unable to instantiate session provider", e);
}
catch (IllegalAccessException e) {
throw new GuacamoleException("Unable to access default constructor of session provider", e);
}
catch (InvocationTargetException e) {
throw new GuacamoleException("Internal error in constructor of session provider", e.getTargetException());
}
}
public AuthenticationProvider getAuthenticationProvider() {
return authProvider;
}
}
AuthorizedConfiguration info = config.getAuthenticationProvider().getAuthorizedConfiguration(username, password);
import java.util.HashMap;
private HashMap<String, String> parameters = new HashMap<String, String>();
public String getProtocol() {
return protocol;
}
public void setProtocol(String protocol) {
this.protocol = protocol;
}
public String getParameter(String name) {
return parameters.get(name);
}
public void setParameter(String name, String value) {
parameters.put(name, value);
}
public SessionClient getClient() throws GuacamoleException {
if (client == null)
throw new GuacamoleException("Client not yet connected.");
synchronized (session) {
if (client != null) {
client.disconnect();
session.removeAttribute("CLIENT");
client = null;
}
import java.util.HashMap;
public class Configuration {
private String protocol;
private HashMap<String, String> parameters = new HashMap<String, String>();
public String getProtocol() {
return protocol;
public void setProtocol(String protocol) {
this.protocol = protocol;
public String getParameter(String name) {
return parameters.get(name);
public void setParameter(String name, String value) {
parameters.put(name, value);
import java.lang.reflect.InvocationTargetException;
import net.sourceforge.guacamole.net.authentication.GuacamoleClientProvider;
public static String getProxyHostname() throws GuacamoleException {
return GuacamoleProperties.getProperty("guacd-hostname");
}
public static int getProxyPort() throws GuacamoleException {
return GuacamoleProperties.getIntProperty("guacd-port", null);
}
public static GuacamoleClientProvider getClientProvider() throws GuacamoleException {
try {
String sessionProviderClassName = GuacamoleProperties.getProperty("client-provider");
Object obj = Class.forName(sessionProviderClassName).getConstructor().newInstance();
if (!(obj instanceof GuacamoleClientProvider))
throw new GuacamoleException("Specified client provider class is not a GuacamoleClientProvider");
return (GuacamoleClientProvider) obj;
}
catch (ClassNotFoundException e) {
throw new GuacamoleException("Session provider class not found", e);
}
catch (NoSuchMethodException e) {
throw new GuacamoleException("Default constructor for client provider not present", e);
}
catch (SecurityException e) {
throw new GuacamoleException("Creation of client provider disallowed; check your security settings", e);
}
catch (InstantiationException e) {
throw new GuacamoleException("Unable to instantiate client provider", e);
}
catch (IllegalAccessException e) {
throw new GuacamoleException("Unable to access default constructor of client provider", e);
}
catch (InvocationTargetException e) {
throw new GuacamoleException("Internal error in constructor of client provider", e.getTargetException());
}
}
protected static String humanReadableList(Object... values) {
String list = "";
if (i >= 1)
if (i == values.length -1)
}
return list;
}
public static String getProperty(String name, String defaultValue, String... allowedValues) throws GuacamoleException {
String value = getProperty(name);
if (value == null) {
if (defaultValue == null)
return defaultValue;
}
if (allowedValues.length == 0)
return value;
for (String allowedValue : allowedValues)
if (value.equals(allowedValue))
return value;
}
public static boolean getBooleanProperty(String name, Boolean defaultValue) throws GuacamoleException {
String value = getProperty(name);
if (value == null) {
if (defaultValue == null)
return defaultValue;
}
value = value.trim();
if (value.equals("true"))
return true;
if (value.equals("false"))
return false;
}
public static int getIntProperty(String name, Integer defaultValue, Integer... allowedValues) throws GuacamoleException {
String parmString = getProperty(name);
if (parmString== null) {
if (defaultValue == null)
return defaultValue;
}
try {
int value = Integer.parseInt(parmString);
if (allowedValues.length == 0)
return value;
for (int allowedValue : allowedValues)
if (value == allowedValue)
return value;
}
catch (NumberFormatException e) {
}
}
synchronized (session) {
public void attachClient(GuacamoleClient client) throws GuacamoleException {
this.client = new SessionClient(client);
session.setAttribute("CLIENT", this.client);
throw new GuacamoleException("Client not yet attached.");
public void detachClient() throws GuacamoleException {
import net.sourceforge.guacamole.GuacamoleClient;
public interface GuacamoleClientProvider {
public GuacamoleClient createClient(HttpSession session) throws GuacamoleException;
import net.sourceforge.guacamole.GuacamoleClient;
public class NullGuacamoleClientProvider implements GuacamoleClientProvider {
public GuacamoleClient createClient(HttpSession session) throws GuacamoleException {
throw new GuacamoleException("Null provider will not create clients.");
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpSession;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.net.GuacamoleProperties;
public class Connect extends HttpServlet {
protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException {
HttpSession httpSession = request.getSession(false);
try {
GuacamoleSession session = new GuacamoleSession(httpSession);
session.attachClient(
GuacamoleProperties.getClientProvider().createClient(httpSession)
);
}
catch (GuacamoleException e) {
throw new ServletException(e);
}
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpSession;
public class Inbound extends HttpServlet {
protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException {
HttpSession httpSession = request.getSession(false);
GuacamoleSession session = new GuacamoleSession(httpSession);
try {
Reader input = request.getReader();
char[] buffer = new char[8192];
int length;
while ((length = input.read(buffer, 0, buffer.length)) != -1)
session.getClient().write(buffer, 0, length);
}
catch (IOException e) {
}
throw new ServletException(e);
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpSession;
public class Outbound extends HttpServlet {
protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException {
HttpSession httpSession = request.getSession(false);
GuacamoleSession session = new GuacamoleSession(httpSession);
ReentrantLock instructionStreamLock = session.getInstructionStreamLock();
instructionStreamLock.lock();
response.setContentType("text/plain");
Writer out = response.getWriter();
try {
Client client = session.getClient();
char[] message;
while ((message = client.read()) != null) {
out.write(message, 0, message.length);
out.flush();
response.flushBuffer();
if (instructionStreamLock.hasQueuedThreads())
break;
}
if (message == null) {
session.detachClient();
throw new GuacamoleException("Disconnected.");
}
}
catch (GuacamoleException e) {
out.write(';');
}
catch (UnsupportedEncodingException e) {
throw new ServletException("UTF-8 not supported by Java.", e);
}
catch (IOException e) {
throw new ServletException("I/O error writing to servlet output stream.", e);
}
finally {
instructionStreamLock.unlock();
catch (GuacamoleException e) {
throw new ServletException(e);
import net.sourceforge.guacamole.net.Configuration;
public Configuration getAuthorizedConfiguration(String username, String password) throws GuacamoleException {
if (info != null && info.validate(username, password)) {
Configuration config = new Configuration();
config.setProtocol(info.getProtocol());
config.setParameter("hostname", info.getHostname());
config.setParameter("port", Integer.toString(info.getPort()));
config.setParameter("password", info.getPassword());
return config;
}
import net.sourceforge.guacamole.GuacamoleClient;
import net.sourceforge.guacamole.net.Configuration;
import net.sourceforge.guacamole.net.authentication.GuacamoleClientProvider;
public class BasicGuacamoleClientProvider implements GuacamoleClientProvider {
public GuacamoleClient createClient(HttpSession session) throws GuacamoleException {
Configuration config = (Configuration) session.getAttribute("BASIC-LOGIN-AUTH");
GuacamoleClient client = new GuacamoleClient("localhost", 4822);
char[] initMessages = "select:vnc;connect:localhost,5901,potato;".toCharArray();
client.write(initMessages, 0, initMessages.length);
return client;
import net.sourceforge.guacamole.net.GuacamoleProperties;
private AuthenticationProvider authProvider;
String authProviderClassName = GuacamoleProperties.getProperty("auth-provider");
Object obj = Class.forName(authProviderClassName).getConstructor().newInstance();
if (!(obj instanceof AuthenticationProvider))
throw new ServletException("Specified authentication provider class is not a AuthenticationProvider.");
authProvider = (AuthenticationProvider) obj;
catch (ClassNotFoundException e) {
throw new ServletException("Authentication provider class not found", e);
catch (NoSuchMethodException e) {
throw new ServletException("Default constructor for authentication provider not present", e);
}
catch (SecurityException e) {
throw new ServletException("Creation of authentication provider disallowed; check your security settings", e);
}
catch (InstantiationException e) {
throw new ServletException("Unable to instantiate authentication provider", e);
}
catch (IllegalAccessException e) {
throw new ServletException("Unable to access default constructor of authentication provider", e);
}
catch (InvocationTargetException e) {
throw new ServletException("Internal error in constructor of authentication provider", e.getTargetException());
public Configuration getAuthorizedConfiguration(String username, String password) throws GuacamoleException;
Configuration config = authProvider.getAuthorizedConfiguration(username, password);
if (config != null) {
config
import net.sourceforge.guacamole.net.Configuration;
public abstract class GuacamoleClient {
public abstract void write(char[] chunk, int off, int len) throws GuacamoleException;
public abstract char[] read() throws GuacamoleException;
public abstract void disconnect() throws GuacamoleException;
public void connect(Configuration config) throws GuacamoleException {
char[] initMessages = "select:vnc;connect:localhost,5901,potato;".toCharArray();
write(initMessages, 0, initMessages.length);
import net.sourceforge.guacamole.GuacamoleTCPClient;
public class SessionClient extends GuacamoleClient implements HttpSessionBindingListener {
private GuacamoleClient client;
public SessionClient(GuacamoleClient client) {
public void attachClient(GuacamoleTCPClient client) throws GuacamoleException {
import net.sourceforge.guacamole.GuacamoleTCPClient;
public GuacamoleTCPClient createClient(HttpSession session) throws GuacamoleException;
import net.sourceforge.guacamole.GuacamoleTCPClient;
public GuacamoleTCPClient createClient(HttpSession session) throws GuacamoleException {
import net.sourceforge.guacamole.GuacamoleClient;
GuacamoleClient client = session.getClient();
import net.sourceforge.guacamole.GuacamoleTCPClient;
import net.sourceforge.guacamole.net.GuacamoleProperties;
public GuacamoleTCPClient createClient(HttpSession session) throws GuacamoleException {
String hostname = GuacamoleProperties.getProperty("guacd-hostname");
int port = GuacamoleProperties.getIntProperty("guacd-port", null);
GuacamoleTCPClient client = new GuacamoleTCPClient(hostname, port);
import net.sourceforge.guacamole.GuacamoleInstruction.Operation;
public void write(char[] chunk) throws GuacamoleException {
write(chunk, 0, chunk.length);
}
public void write(GuacamoleInstruction instruction) throws GuacamoleException {
write(instruction.toString().toCharArray());
}
write(new GuacamoleInstruction(Operation.CLIENT_SELECT, config.getProtocol()));
write(new GuacamoleInstruction(Operation.CLIENT_CONNECT, "localhost", "5901", "potato"));
import java.util.LinkedList;
private int instructionStart;
private char[] buffer;
public GuacamoleInstruction readInstruction() throws GuacamoleException {
if (buffer == null) {
buffer = read();
instructionStart = 0;
}
int opcodeEnd = -1;
int instructionEnd = -1;
char c = buffer[i];
if (c == ':')
opcodeEnd = i;
else if (c == ';') {
instructionEnd = i;
break;
}
}
if (instructionEnd == -1)
throw new GuacamoleException("Malformed instruction.");
if (opcodeEnd == -1)
opcodeEnd = instructionEnd;
String opcode = new String(buffer, instructionStart, opcodeEnd - instructionStart);
String[] args;
if (instructionEnd > opcodeEnd)
else
args = new String[0];
GuacamoleInstruction instruction = new GuacamoleInstruction(
Operation.fromOpcode(opcode),
args
);
if (instructionStart >= buffer.length)
buffer = null;
return instruction;
}
GuacamoleInstruction instruction;
do {
instruction = readInstruction();
} while (instruction.getOperation() != Operation.SERVER_ARGS);
String[] args = new String[instruction.getArgs().length];
String requiredArg = instruction.getArgs()[i];
String value = config.getParameter(requiredArg);
if (value != null)
args[i] = value;
else
args[i] = "";
}
write(new GuacamoleInstruction(Operation.CLIENT_CONNECT, args));
public static Operation fromOpcode(String opcode) {
buff.append(operation.getOpcode());
client.connect(config);
if (info != null && info.validate(username, password))
return info.getConfiguration();
private Configuration config;
config = new Configuration();
public Configuration getConfiguration() {
return config;
private enum State {
ROOT,
USER_MAPPING,
AUTH_INFO,
PARAMETER,
END;
}
private State state = State.ROOT;
private AuthInfo current = null;
private String currentParameter = null;
switch (state)  {
case USER_MAPPING:
if (localName.equals("user-mapping")) {
state = State.END;
return;
}
break;
case AUTH_INFO:
if (localName.equals("authorize")) {
authMapping.put(
current.auth_username,
current
);
state = State.USER_MAPPING;
return;
}
break;
case PROTOCOL:
if (localName.equals("protocol")) {
state = State.AUTH_INFO;
return;
}
break;
case PARAMETER:
if (localName.equals("param")) {
state = State.AUTH_INFO;
return;
}
break;
switch (state)  {
case ROOT:
if (localName.equals("user-mapping")) {
state = State.USER_MAPPING;
return;
}
break;
case USER_MAPPING:
if (localName.equals("authorize")) {
AuthInfo.Encoding encoding;
String encodingString = attributes.getValue("encoding");
if (encodingString == null)
encoding = AuthInfo.Encoding.PLAIN_TEXT;
else if (encodingString.equals("plain"))
encoding = AuthInfo.Encoding.PLAIN_TEXT;
else if (encodingString.equals("md5"))
encoding = AuthInfo.Encoding.MD5;
else
throw new SAXException("Invalid encoding type");
current = new AuthInfo(
attributes.getValue("username"),
attributes.getValue("password"),
encoding
);
state = State.AUTH_INFO;
return;
}
break;
case AUTH_INFO:
if (localName.equals("protocol")) {
state = State.PROTOCOL;
return;
}
if (localName.equals("param")) {
currentParameter = attributes.getValue("name");
if (currentParameter == null)
throw new SAXException("Attribute \"name\" required for param tag.");
state = State.PARAMETER;
return;
}
break;
switch (state) {
current.getConfiguration().setProtocol(str);
return;
case PARAMETER:
current.getConfiguration().setParameter(currentParameter, str);
return;
if (str.trim().length() != 0)
throw new SAXException("Unexpected character data.");
import net.sourceforge.guacamole.net.Configuration;
public Configuration getAuthorizedConfiguration(String username, String password) throws GuacamoleException {
return info.getConfiguration();
private Configuration config;
config = new Configuration();
public Configuration getConfiguration() {
return config;
private enum State {
ROOT,
USER_MAPPING,
AUTH_INFO,
PARAMETER,
END;
}
private State state = State.ROOT;
private AuthInfo current = null;
private String currentParameter = null;
switch (state)  {
case USER_MAPPING:
if (localName.equals("user-mapping")) {
state = State.END;
return;
}
break;
case AUTH_INFO:
if (localName.equals("authorize")) {
authMapping.put(
current.auth_username,
current
);
state = State.USER_MAPPING;
return;
}
break;
case PROTOCOL:
if (localName.equals("protocol")) {
state = State.AUTH_INFO;
return;
}
break;
case PARAMETER:
if (localName.equals("param")) {
state = State.AUTH_INFO;
return;
}
break;
switch (state)  {
case ROOT:
if (localName.equals("user-mapping")) {
state = State.USER_MAPPING;
return;
}
break;
case USER_MAPPING:
if (localName.equals("authorize")) {
AuthInfo.Encoding encoding;
String encodingString = attributes.getValue("encoding");
if (encodingString == null)
encoding = AuthInfo.Encoding.PLAIN_TEXT;
else if (encodingString.equals("plain"))
encoding = AuthInfo.Encoding.PLAIN_TEXT;
else if (encodingString.equals("md5"))
encoding = AuthInfo.Encoding.MD5;
else
throw new SAXException("Invalid encoding type");
current = new AuthInfo(
attributes.getValue("username"),
attributes.getValue("password"),
encoding
);
state = State.AUTH_INFO;
return;
}
break;
case AUTH_INFO:
if (localName.equals("protocol")) {
state = State.PROTOCOL;
return;
}
if (localName.equals("param")) {
currentParameter = attributes.getValue("name");
if (currentParameter == null)
throw new SAXException("Attribute \"name\" required for param tag.");
state = State.PARAMETER;
return;
}
break;
switch (state) {
current.getConfiguration().setProtocol(str);
return;
case PARAMETER:
current.getConfiguration().setParameter(currentParameter, str);
return;
if (str.trim().length() != 0)
throw new SAXException("Unexpected character data.");
import net.sourceforge.guacamole.net.GuacamoleProperties;
private AuthenticationProvider authProvider;
String authProviderClassName = GuacamoleProperties.getProperty("auth-provider");
Object obj = Class.forName(authProviderClassName).getConstructor().newInstance();
if (!(obj instanceof AuthenticationProvider))
throw new ServletException("Specified authentication provider class is not a AuthenticationProvider.");
authProvider = (AuthenticationProvider) obj;
catch (ClassNotFoundException e) {
throw new ServletException("Authentication provider class not found", e);
catch (NoSuchMethodException e) {
throw new ServletException("Default constructor for authentication provider not present", e);
}
catch (SecurityException e) {
throw new ServletException("Creation of authentication provider disallowed; check your security settings", e);
}
catch (InstantiationException e) {
throw new ServletException("Unable to instantiate authentication provider", e);
}
catch (IllegalAccessException e) {
throw new ServletException("Unable to access default constructor of authentication provider", e);
}
catch (InvocationTargetException e) {
throw new ServletException("Internal error in constructor of authentication provider", e.getTargetException());
public Configuration getAuthorizedConfiguration(String username, String password) throws GuacamoleException;
Configuration config = authProvider.getAuthorizedConfiguration(username, password);
if (config != null) {
config
package net.sourceforge.guacamole.net.basic;
package net.sourceforge.guacamole.net.basic;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.GuacamoleTCPClient;
import net.sourceforge.guacamole.net.Configuration;
import net.sourceforge.guacamole.net.GuacamoleProperties;
import net.sourceforge.guacamole.net.GuacamoleSession;
import net.sourceforge.guacamole.net.tunnel.GuacamoleTunnelServlet;
public class BasicGuacamoleTunnelServlet extends GuacamoleTunnelServlet {
@Override
protected void doConnect(HttpServletRequest request, HttpServletResponse response) throws GuacamoleException {
HttpSession httpSession = request.getSession(false);
Configuration config = (Configuration) httpSession.getAttribute("BASIC-LOGIN-AUTH");
GuacamoleSession session = new GuacamoleSession(httpSession);
session.attachClient(client);
package net.sourceforge.guacamole.net.basic;
package net.sourceforge.guacamole.net.basic;
package net.sourceforge.guacamole.net.basic;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.GuacamoleTCPClient;
import net.sourceforge.guacamole.net.Configuration;
import net.sourceforge.guacamole.net.GuacamoleProperties;
import net.sourceforge.guacamole.net.GuacamoleSession;
import net.sourceforge.guacamole.net.tunnel.GuacamoleTunnelServlet;
public class BasicGuacamoleTunnelServlet extends GuacamoleTunnelServlet {
@Override
protected void doConnect(HttpServletRequest request, HttpServletResponse response) throws GuacamoleException {
HttpSession httpSession = request.getSession(false);
Configuration config = (Configuration) httpSession.getAttribute("BASIC-LOGIN-AUTH");
GuacamoleSession session = new GuacamoleSession(httpSession);
session.attachClient(client);
package net.sourceforge.guacamole.net.basic;
response.setContentType("application/octet-stream");
response.setContentType("application/octet-stream");
response.setContentLength(0);
import java.net.InetSocketAddress;
import java.net.SocketAddress;
private static final int SOCKET_TIMEOUT = 5000;
SocketAddress address = new InetSocketAddress(
InetAddress.getByName(hostname),
port
);
sock = new Socket();
sock.connect(address, SOCKET_TIMEOUT);
private static final int SOCKET_TIMEOUT = 15000;
sock.setSoTimeout(SOCKET_TIMEOUT);
import net.sourceforge.guacamole.net.tunnel.GuacamoleTunnel;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
private ConcurrentMap<String, GuacamoleTunnel> tunnels;
tunnels = (ConcurrentMap<String, GuacamoleTunnel>) session.getAttribute("GUAC_TUNNELS");
if (tunnels == null) {
tunnels = new ConcurrentHashMap<String, GuacamoleTunnel>();
session.setAttribute("GUAC_TUNNELS", tunnels);
public void invalidate() {
session.invalidate();
}
public void attachTunnel(GuacamoleTunnel tunnel) throws GuacamoleException {
tunnels.put(tunnel.getUUID().toString(), tunnel);
}
public void detachTunnel(GuacamoleTunnel tunnel) throws GuacamoleException {
tunnels.remove(tunnel.getUUID().toString());
}
public GuacamoleTunnel getTunnel(String tunnelUUID) {
return tunnels.get(tunnelUUID);
if (query.equals("connect")) {
GuacamoleTunnel tunnel = doConnect(request);
if (tunnel != null) {
try {
response.getWriter().println(tunnel.getUUID().toString());
}
catch (IOException e) {
throw new GuacamoleException(e);
}
}
}
else if(query.startsWith("read:"))
doRead(request, response, query.substring(5));
else if(query.startsWith("write:"))
doWrite(request, response, query.substring(6));
protected abstract GuacamoleTunnel doConnect(HttpServletRequest request) throws GuacamoleException;
protected void doRead(HttpServletRequest request, HttpServletResponse response, String tunnelUUID) throws GuacamoleException {
GuacamoleTunnel tunnel = session.getTunnel(tunnelUUID);
if (tunnel == null)
throw new GuacamoleException("No such tunnel.");
ReentrantLock instructionStreamLock = tunnel.getInstructionStreamLock();
GuacamoleClient client = tunnel.getClient();
session.detachTunnel(tunnel);
protected void doWrite(HttpServletRequest request, HttpServletResponse response, String tunnelUUID) throws GuacamoleException {
GuacamoleTunnel tunnel = session.getTunnel(tunnelUUID);
if (tunnel == null)
throw new GuacamoleException("No such tunnel.");
GuacamoleClient client = tunnel.getClient();
client.write(buffer, 0, length);
try {
if (!response.isCommitted()) {
response.setHeader("X-Guacamole-Error-Message", e.getMessage());
response.sendError(
HttpServletResponse.SC_INTERNAL_SERVER_ERROR,
e.getMessage()
);
}
else
throw new ServletException(e);
}
catch (IOException ioe) {
throw new ServletException(ioe);
}
GuacamoleClient client = tunnel.getClient();
char[] message;
while ((message = client.read()) != null) {
out.write(message, 0, message.length);
if (instructionStreamLock.hasQueuedThreads())
break;
}
if (message == null) {
session.detachTunnel(tunnel);
throw new GuacamoleException("Disconnected.");
public class BasicFileAuthenticationProvider implements AuthenticationProvider {
import java.lang.reflect.InvocationTargetException;
import javax.servlet.ServletException;
import net.sourceforge.guacamole.net.tunnel.GuacamoleTunnel;
private AuthenticationProvider authProvider;
public void init() throws ServletException {
try {
String authProviderClassName = GuacamoleProperties.getProperty("auth-provider");
Object obj = Class.forName(authProviderClassName).getConstructor().newInstance();
if (!(obj instanceof AuthenticationProvider))
throw new ServletException("Specified authentication provider class is not a AuthenticationProvider.");
authProvider = (AuthenticationProvider) obj;
}
catch (GuacamoleException e) {
throw new ServletException(e);
}
catch (ClassNotFoundException e) {
throw new ServletException("Authentication provider class not found", e);
}
catch (NoSuchMethodException e) {
throw new ServletException("Default constructor for authentication provider not present", e);
}
catch (SecurityException e) {
throw new ServletException("Creation of authentication provider disallowed; check your security settings", e);
}
catch (InstantiationException e) {
throw new ServletException("Unable to instantiate authentication provider", e);
}
catch (IllegalAccessException e) {
throw new ServletException("Unable to access default constructor of authentication provider", e);
}
catch (InvocationTargetException e) {
throw new ServletException("Internal error in constructor of authentication provider", e.getTargetException());
}
}
@Override
protected GuacamoleTunnel doConnect(HttpServletRequest request) throws GuacamoleException {
HttpSession httpSession = request.getSession(true);
String username = request.getParameter("username");
String password = request.getParameter("password");
Configuration config = authProvider.getAuthorizedConfiguration(username, password);
throw new GuacamoleException("Invalid login");
GuacamoleTunnel tunnel = new GuacamoleTunnel(client);
session.attachTunnel(tunnel);
return tunnel;
package net.sourceforge.guacamole;
import net.sourceforge.guacamole.protocol.Configuration;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.io.GuacamoleReader;
import net.sourceforge.guacamole.io.GuacamoleWriter;
public interface GuacamoleSocket {
public GuacamoleReader getReader();
public GuacamoleWriter getWriter();
public void connect(Configuration config) throws GuacamoleException;
public void disconnect() throws GuacamoleException;
package net.sourceforge.guacamole.protocol;
package net.sourceforge.guacamole.protocol;
package net.sourceforge.guacamole.servlet;
import net.sourceforge.guacamole.net.GuacamoleTunnel;
package net.sourceforge.guacamole.servlet;
import net.sourceforge.guacamole.net.GuacamoleTunnel;
import net.sourceforge.guacamole.io.GuacamoleReader;
import net.sourceforge.guacamole.net.GuacamoleSocket;
import net.sourceforge.guacamole.io.GuacamoleWriter;
GuacamoleReader reader = tunnel.acquireReader();
while ((message = reader.read()) != null) {
if (tunnel.hasQueuedReaderThreads())
tunnel.releaseReader();
GuacamoleWriter writer = tunnel.acquireWriter();
writer.write(buffer, 0, length);
finally {
tunnel.releaseWriter();
}
public void close() throws GuacamoleException;
public class TCPGuacamoleSocket implements GuacamoleSocket {
public void close() throws GuacamoleException {
package net.sourceforge.guacamole.protocol;
import net.sourceforge.guacamole.net.GuacamoleSocket;
public class ConfiguredSocket implements GuacamoleSocket {
private GuacamoleSocket socket;
public ConfiguredSocket(GuacamoleSocket socket, Configuration config) throws GuacamoleException {
this.socket = socket;
GuacamoleReader reader = socket.getReader();
GuacamoleWriter writer = socket.getWriter();
@Override
public GuacamoleWriter getWriter() {
return socket.getWriter();
}
@Override
public GuacamoleReader getReader() {
return socket.getReader();
}
@Override
public void close() throws GuacamoleException {
socket.close();
}
@Override
public class ConfiguredGuacamoleSocket implements GuacamoleSocket {
public ConfiguredGuacamoleSocket(GuacamoleSocket socket, GuacamoleConfiguration config) throws GuacamoleException {
public class GuacamoleConfiguration {
public class InetGuacamoleSocket implements GuacamoleSocket {
public InetGuacamoleSocket(String hostname, int port) throws GuacamoleException {
private GuacamoleProperties() {}
import net.sourceforge.guacamole.protocol.GuacamoleConfiguration;
public GuacamoleConfiguration getAuthorizedConfiguration(String username, String password) throws GuacamoleException;
import net.sourceforge.guacamole.net.basic.properties.BasicGuacamoleProperties;
import net.sourceforge.guacamole.protocol.GuacamoleConfiguration;
import net.sourceforge.guacamole.properties.GuacamoleProperties;
return GuacamoleProperties.getProperty(BasicGuacamoleProperties.BASIC_USER_MAPPING);
public GuacamoleConfiguration getAuthorizedConfiguration(String username, String password) throws GuacamoleException {
private GuacamoleConfiguration config;
config = new GuacamoleConfiguration();
public GuacamoleConfiguration getConfiguration() {
import net.sourceforge.guacamole.net.InetGuacamoleSocket;
import net.sourceforge.guacamole.protocol.GuacamoleConfiguration;
import net.sourceforge.guacamole.properties.GuacamoleProperties;
import net.sourceforge.guacamole.net.GuacamoleSocket;
import net.sourceforge.guacamole.servlet.GuacamoleSession;
import net.sourceforge.guacamole.net.GuacamoleTunnel;
import net.sourceforge.guacamole.net.basic.properties.BasicGuacamoleProperties;
import net.sourceforge.guacamole.protocol.ConfiguredGuacamoleSocket;
import net.sourceforge.guacamole.servlet.GuacamoleTunnelServlet;
authProvider = GuacamoleProperties.getProperty(BasicGuacamoleProperties.AUTH_PROVIDER);
GuacamoleConfiguration config = authProvider.getAuthorizedConfiguration(username, password);
String hostname = GuacamoleProperties.getProperty(GuacamoleProperties.GUACD_HOSTNAME);
int port = GuacamoleProperties.getProperty(GuacamoleProperties.GUACD_PORT);
GuacamoleSocket socket = new ConfiguredGuacamoleSocket(
new InetGuacamoleSocket(hostname, port),
config
);
GuacamoleTunnel tunnel = new GuacamoleTunnel(socket);
public GuacamoleTunnel(GuacamoleSocket socket) {
private Operation(String opcode) {
this.opcode = opcode;
}
public void attachTunnel(GuacamoleTunnel tunnel) {
public void detachTunnel(GuacamoleTunnel tunnel) {
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.protocol.GuacamoleInstruction;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.protocol.GuacamoleInstruction;
import java.io.IOException;
import java.io.Reader;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.protocol.GuacamoleInstruction;
import net.sourceforge.guacamole.protocol.GuacamoleInstruction.Operation;
if (instructionBuffer != null) {
char[] chunk = new char[instructionBuffer.length - instructionStart];
System.arraycopy(instructionBuffer, instructionStart, chunk, 0, chunk.length);
instructionBuffer = null;
return chunk;
}
import java.io.IOException;
import java.io.Writer;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.protocol.GuacamoleInstruction;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.io.GuacamoleReader;
import net.sourceforge.guacamole.io.GuacamoleWriter;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.io.GuacamoleReader;
import net.sourceforge.guacamole.io.GuacamoleWriter;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.net.GuacamoleSocket;
import net.sourceforge.guacamole.protocol.GuacamoleInstruction.Operation;
import java.util.HashMap;
import java.util.HashMap;
handleTunnelRequest(request, response);
handleTunnelRequest(request, response);
protected void handleTunnelRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException {
@SuppressWarnings("unchecked")
char[] message = reader.read();
if (message == null) {
session.detachTunnel(tunnel);
throw new GuacamoleException("Disconnected.");
}
do {
} while ((message = reader.read()) != null);
import net.sourceforge.guacamole.GuacamoleException;
public void close() throws GuacamoleException {
socket.close();
}
if (message == null)
catch (GuacamoleException e) {
session.detachTunnel(tunnel);
tunnel.close();
throw e;
}
session.detachTunnel(tunnel);
tunnel.close();
session.detachTunnel(tunnel);
tunnel.close();
session.detachTunnel(tunnel);
tunnel.close();
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
private Logger logger = LoggerFactory.getLogger(BasicGuacamoleTunnelServlet.class);
if (config == null) {
logger.warn("Failed login from {} for user \"{}\".", request.getRemoteAddr(), username);
}
logger.debug("Successful login from {} for user \"{}\".", request.getRemoteAddr(), username);
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
private Logger logger = LoggerFactory.getLogger(InetGuacamoleSocket.class);
logger.debug("Connecting to guacd at {}:{}.", hostname, port);
logger.debug("Closing socket to guacd.");
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
private Logger logger = LoggerFactory.getLogger(GuacamoleSession.class);
logger.debug("Attached tunnel {}.", tunnel.getUUID());
logger.debug("Detached tunnel {}.", tunnel.getUUID());
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
private Logger logger = LoggerFactory.getLogger(GuacamoleTunnelServlet.class);
logger.info("Connection from {} succeeded.", request.getRemoteAddr());
else
logger.info("Connection from {} failed.", request.getRemoteAddr());
if (message == null)
tunnel.close();
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
private Logger logger = LoggerFactory.getLogger(BasicFileAuthenticationProvider.class);
logger.info("Reading user mapping file: {}", mapFile);
if (userMappingFile.exists() && mappingTime < userMappingFile.lastModified()) {
logger.info("User mapping file {} has been modified.", userMappingFile);
}
logger.error("Error getting authentication provider from properties.", e);
GuacamoleConfiguration config;
try {
config = authProvider.getAuthorizedConfiguration(username, password);
}
catch (GuacamoleException e) {
logger.error("Error retrieving authorized configuration for user {}.", username);
throw e;
}
logger.info("Successful login from {} for user \"{}\".", request.getRemoteAddr(), username);
if (mapping == null)
throw new GuacamoleException("User mapping could not be read.");
import java.util.Map;
import javax.servlet.http.HttpServletResponse;
String id = request.getParameter("id");
Map<String, GuacamoleConfiguration> configs =
(Map<String, GuacamoleConfiguration>)
httpSession.getAttribute("GUAC_AUTH_CONFIGS");
if (configs == null)
throw new GuacamoleException("No authorized configurations.");
GuacamoleConfiguration config = configs.get(id);
if (config == null) {
logger.error("Error retrieving authorized configuration id={}.", id);
throw new GuacamoleException("Unknown configuration ID.");
logger.info("Successful connection from {} to \"{}\".", request.getRemoteAddr(), id);
import java.util.HashMap;
import java.util.Map;
Map<String, GuacamoleConfiguration> configs = new HashMap<String, GuacamoleConfiguration>();
configs.put("TEST-UID", config);
httpSession.setAttribute("GUAC_AUTH_CONFIGS", configs);
import net.sourceforge.guacamole.net.auth.AuthenticationProvider;
import net.sourceforge.guacamole.net.auth.UserConfiguration;
import net.sourceforge.guacamole.protocol.GuacamoleConfiguration;
public UserConfiguration getUserConfiguration(String username, String password) throws GuacamoleException {
return info.getUserConfiguration();
protected static final String CONFIG_ID = "DEFAULT";
private BasicUserConfiguration userConfig;
userConfig = new BasicUserConfiguration();
userConfig.setConfiguration(CONFIG_ID, new GuacamoleConfiguration());
public BasicUserConfiguration getUserConfiguration() {
return userConfig;
current.getUserConfiguration().getConfiguration(AuthInfo.CONFIG_ID)
.setProtocol(str);
current.getUserConfiguration().getConfiguration(AuthInfo.CONFIG_ID)
.setParameter(currentParameter, str);
import net.sourceforge.guacamole.net.auth.AuthenticationProvider;
import net.sourceforge.guacamole.net.auth.UserConfiguration;
UserConfiguration userConfig = (UserConfiguration)
httpSession.getAttribute("GUAC_USER_CONFIG");
if (userConfig == null)
GuacamoleConfiguration config = userConfig.getConfiguration(id);
import net.sourceforge.guacamole.net.auth.UserConfiguration;
import net.sourceforge.guacamole.net.auth.AuthenticationProvider;
UserConfiguration config;
config = authProvider.getUserConfiguration(username, password);
logger.error("Error retrieving configuration for user {}.", username);
httpSession.setAttribute("GUAC_USER_CONFIG", config);
import net.sourceforge.guacamole.net.auth.UserConfiguration;
UserConfiguration userConfig = (UserConfiguration)
httpSession.getAttribute("GUAC_USER_CONFIG");
if (userConfig == null) {
for (String id : userConfig.listConfigurations()) {
GuacamoleConfiguration config = userConfig.getConfiguration(id);
out.print(id);
import net.sourceforge.guacamole.net.auth.AuthenticationProvider;
public interface AuthenticationProvider<CredentialType> {
public UserConfiguration getUserConfiguration(CredentialType credentials) throws GuacamoleException;
import net.sourceforge.guacamole.net.auth.UsernamePassword;
public class BasicFileAuthenticationProvider implements AuthenticationProvider<UsernamePassword> {
public UserConfiguration getUserConfiguration(UsernamePassword credentials) throws GuacamoleException {
AuthInfo info = mapping.get(credentials.getUsername());
if (info != null && info.validate(credentials.getUsername(), credentials.getPassword()))
import net.sourceforge.guacamole.net.auth.UsernamePassword;
UsernamePassword credentials = new UsernamePassword();
credentials.setUsername(username);
credentials.setPassword(password);
config = authProvider.getUserConfiguration(credentials);
public Map<String, GuacamoleConfiguration> getAuthorizedConfigurations(UsernamePassword credentials) throws GuacamoleException {
Map<String, GuacamoleConfiguration> configs = new HashMap<String, GuacamoleConfiguration>();
configs.put("DEFAULT", info.getConfiguration());
return configs;
private GuacamoleConfiguration config;
config = new GuacamoleConfiguration();
public GuacamoleConfiguration getConfiguration() {
return config;
current.getConfiguration()
current.getConfiguration()
import java.util.Map;
Map<String, GuacamoleConfiguration> configs = (Map<String, GuacamoleConfiguration>)
httpSession.getAttribute("GUAC_CONFIGS");
if (configs == null)
GuacamoleConfiguration config = configs.get(id);
import java.util.Map;
import net.sourceforge.guacamole.protocol.GuacamoleConfiguration;
Map<String, GuacamoleConfiguration> configs;
configs = authProvider.getAuthorizedConfigurations(credentials);
logger.error("Error retrieving configuration(s) for user {}.", username);
if (configs == null) {
httpSession.setAttribute("GUAC_CONFIGS", configs);
import java.util.Map;
Map<String, GuacamoleConfiguration> configs = (Map<String, GuacamoleConfiguration>)
httpSession.getAttribute("GUAC_CONFIGS");
if (configs == null) {
for (Entry<String, GuacamoleConfiguration> entry : configs.entrySet()) {
GuacamoleConfiguration config = entry.getValue();
out.print(entry.getKey());
configs.put("DEFAULT", info.getConfiguration());
if (instructionBuffer == null)
return null;
public static <Type> Type getRequiredProperty(GuacamoleProperty<Type> property)
throws GuacamoleException {
Type value = getProperty(property);
if (value == null)
return value;
}
import net.sourceforge.guacamole.net.basic.GuacamoleClassLoader;
Object obj = GuacamoleClassLoader.getInstance().loadClass(authProviderClassName)
.getConstructor().newInstance();
public static final FileGuacamoleProperty LIB_DIRECTORY = new FileGuacamoleProperty() {
@Override
public String getName() { return "lib-directory"; }
};
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import org.apache.commons.lang3.ArrayUtils;
LinkedList<String> elements = new LinkedList<String>();
while (instructionStart < instructionBuffer.length) {
int lengthEnd = ArrayUtils.indexOf(instructionBuffer, '.', instructionStart);
int length = Integer.parseInt(new String(
instructionBuffer,
instructionStart,
lengthEnd - instructionStart
));
String element = new String(
instructionBuffer,
instructionStart,
length
);
elements.addLast(element);
char terminator = instructionBuffer[instructionStart];
instructionStart;
if (terminator == ';')
String opcode = elements.removeFirst();
elements.toArray(new String[elements.size()])
out.write("0.;");
buff.append(operation.getOpcode().length());
buff.append('.');
buff.append(',');
buff.append(args[i].length());
buff.append('.');
response.getWriter().print(tunnel.getUUID().toString());
private int parseStart;
private char[] buffer = new char[20480];
private int usedLength = 0;
int elementLength = 0;
int i = parseStart;
while (i < usedLength) {
if (readChar >= '0' && readChar <= '9')
else if (readChar == '.') {
elementLength = 0;
parseStart = i;
if (terminator == ';') {
char[] instruction = new char[i];
System.arraycopy(buffer, 0, instruction, 0, i);
usedLength -= i;
parseStart = 0;
System.arraycopy(buffer, i, buffer, 0, usedLength);
return instruction;
}
else if (terminator != ',')
throw new GuacamoleException("Element terminator of instruction was not ';' nor ','");
}
else
break;
}
else
throw new GuacamoleException("Non-numeric character in element length.");
}
char[] instructionBuffer = read();
int elementStart = 0;
while (elementStart < instructionBuffer.length) {
int lengthEnd = ArrayUtils.indexOf(instructionBuffer, '.', elementStart);
elementStart,
lengthEnd - elementStart
elementStart,
char terminator = instructionBuffer[elementStart];
public boolean available() throws GuacamoleException;
public boolean available() throws GuacamoleException {
try {
return input.ready() || usedLength != 0;
}
catch (IOException e) {
throw new GuacamoleException(e);
}
}
@Override
if (!reader.available()) {
out.flush();
response.flushBuffer();
}
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.Reader;
import org.xml.sax.InputSource;
Reader reader = new BufferedReader(new FileReader(mapFile));
parser.parse(new InputSource(reader));
reader.close();
public abstract class GuacamoleHTTPTunnelServlet extends HttpServlet {
private Logger logger = LoggerFactory.getLogger(GuacamoleHTTPTunnelServlet.class);
import net.sourceforge.guacamole.servlet.GuacamoleHTTPTunnelServlet;
public class BasicGuacamoleTunnelServlet extends GuacamoleHTTPTunnelServlet {
public Map<String, GuacamoleConfiguration>
getAuthorizedConfigurations(CredentialType credentials)
throws GuacamoleException;
import net.sourceforge.guacamole.servlet.GuacamoleHTTPTunnelServlet;
public class ExampleTunnelServlet extends GuacamoleHTTPTunnelServlet {
import net.sourceforge.guacamole.properties.FileGuacamoleProperty;
public static final FileGuacamoleProperty BASIC_USER_MAPPING = new FileGuacamoleProperty() {
@Override
public String getName() { return "basic-user-mapping"; }
};
return GuacamoleProperties.getProperty(BASIC_USER_MAPPING);
import net.sourceforge.guacamole.properties.FileGuacamoleProperty;
throw new GuacamoleException("Cannot connect - user not logged in.");
if(value != null)
return new File(value);
else
return null;
import net.sourceforge.guacamole.servlet.GuacamoleHTTPTunnelServlet;
public class ExampleTunnelServlet extends GuacamoleHTTPTunnelServlet {
catch (NullPointerException e) {
e.printStackTrace(System.err);
}
return Class.forName(name);
import net.sourceforge.guacamole.properties.FileGuacamoleProperty;
public static final FileGuacamoleProperty BASIC_USER_MAPPING = new FileGuacamoleProperty() {
@Override
public String getName() { return "basic-user-mapping"; }
};
return GuacamoleProperties.getProperty(BASIC_USER_MAPPING);
throw new GuacamoleException("Cannot connect - user not logged in.");
import net.sourceforge.guacamole.properties.FileGuacamoleProperty;
if (value == null)
return new File(value);
if (value == null)
return null;
if (authProviderClassName == null)
return null;
authProvider = GuacamoleProperties.getRequiredProperty(BasicGuacamoleProperties.AUTH_PROVIDER);
if (info != null && info.validate(credentials.getUsername(), credentials.getPassword())) {
return configs;
}
return null;
Map<String, GuacamoleConfiguration> configs = new HashMap<String, GuacamoleConfiguration>();
response.setHeader("Cache-Control", "no-cache");
response.setHeader("Cache-Control", "no-cache");
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
private Logger logger = LoggerFactory.getLogger(WebSocketSupportLoader.class);
"net.sourceforge.guacamole.net.basic.BasicGuacamoleWebSocketTunnelServlet"
logger.info("WebSocket support found and loaded.");
logger.error("Servlet API 3.0 not found.", e);
logger.error("Servlet API 3.0 found, but incomplete.", e);
logger.error("Unable to load WebSocket tunnel servlet.", e);
logger.error("Internal error loading WebSocket tunnel servlet.", e);
catch (ClassNotFoundException e) {
logger.info("WebSocket support not found.");
logger.error("Unable to load/detect WebSocket support.", e);
import java.io.Serializable;
public class GuacamoleConfiguration implements Serializable {
private static final long serialVersionUID = 1L;
public interface AuthenticationProvider {
getAuthorizedConfigurations(Credentials credentials)
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpSession;
public class Credentials {
private HttpServletRequest request;
private HttpSession session;
public HttpServletRequest getRequest() {
return request;
}
public void setRequest(HttpServletRequest request) {
this.request = request;
}
public HttpSession getSession() {
return session;
}
public void setSession(HttpSession session) {
this.session = session;
}
import net.sourceforge.guacamole.net.auth.Credentials;
public class BasicFileAuthenticationProvider implements AuthenticationProvider {
public Map<String, GuacamoleConfiguration> getAuthorizedConfigurations(Credentials credentials) throws GuacamoleException {
import net.sourceforge.guacamole.net.auth.Credentials;
Credentials credentials = new Credentials ();
credentials.setSession(httpSession);
credentials.setRequest(request);
logger.warn("Authentication attempt from {} for user \"{}\" failed.",
import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletResponse;
public class BasicGuacamoleTunnelServlet extends AuthenticatingHttpServlet {
protected void authenticatedService(
Map<String, GuacamoleConfiguration> configs,
HttpServletRequest request, HttpServletResponse response)
throws IOException, ServletException {
tunnelServlet.service(request, response);
private GuacamoleHTTPTunnelServlet tunnelServlet = new GuacamoleHTTPTunnelServlet() {
@Override
protected GuacamoleTunnel doConnect(HttpServletRequest request) throws GuacamoleException {
HttpSession httpSession = request.getSession(true);
String id = request.getParameter("id");
Map<String, GuacamoleConfiguration> configs = (Map<String, GuacamoleConfiguration>)
httpSession.getAttribute("GUAC_CONFIGS");
if (configs == null)
throw new GuacamoleException("Cannot connect - user not logged in.");
GuacamoleConfiguration config = configs.get(id);
if (config == null) {
logger.error("Error retrieving authorized configuration id={}.", id);
throw new GuacamoleException("Unknown configuration ID.");
}
logger.info("Successful connection from {} to \"{}\".", request.getRemoteAddr(), id);
String hostname = GuacamoleProperties.getProperty(GuacamoleProperties.GUACD_HOSTNAME);
int port = GuacamoleProperties.getProperty(GuacamoleProperties.GUACD_PORT);
GuacamoleSocket socket = new ConfiguredGuacamoleSocket(
new InetGuacamoleSocket(hostname, port),
config
);
GuacamoleTunnel tunnel = new GuacamoleTunnel(socket);
GuacamoleSession session = new GuacamoleSession(httpSession);
session.attachTunnel(tunnel);
return tunnel;
}
};
public class BasicLogin extends AuthenticatingHttpServlet {
protected void authenticatedService(
Map<String, GuacamoleConfiguration> configs,
HttpServletRequest request, HttpServletResponse response)
logger.info("Login was successful.");
public class ConfigurationList extends AuthenticatingHttpServlet {
protected void authenticatedService(
Map<String, GuacamoleConfiguration> configs,
HttpServletRequest request, HttpServletResponse response)
private static final String AUTH_ERROR_MESSAGE =
"User not logged in or authentication failed.";
response.setHeader("X-Guacamole-Error-Message", AUTH_ERROR_MESSAGE);
response.setHeader("X-Guacamole-Error-Message", AUTH_ERROR_MESSAGE);
public void authenticationFailed(AuthenticationFailureEvent e);
import net.sourceforge.guacamole.GuacamoleException;
public void authenticationFailed(AuthenticationFailureEvent e)
throws GuacamoleException;
import net.sourceforge.guacamole.GuacamoleException;
public boolean authenticationSucceeded(AuthenticationSuccessEvent e)
throws GuacamoleException;
import net.sourceforge.guacamole.GuacamoleException;
public boolean tunnelAttached(TunnelAttachEvent e)
throws GuacamoleException;
import net.sourceforge.guacamole.GuacamoleException;
public boolean tunnelDetached(TunnelDetachEvent e)
throws GuacamoleException;
import java.util.Collection;
import net.sourceforge.guacamole.net.basic.event.SessionListenerCollection;
import net.sourceforge.guacamole.net.event.AuthenticationFailureEvent;
import net.sourceforge.guacamole.net.event.AuthenticationSuccessEvent;
import net.sourceforge.guacamole.net.event.listener.AuthenticationFailureListener;
import net.sourceforge.guacamole.net.event.listener.AuthenticationSuccessListener;
private void notifyFailed(Collection listeners, Credentials credentials) {
AuthenticationFailureEvent event = new AuthenticationFailureEvent(credentials);
for (Object listener : listeners) {
try {
if (listener instanceof AuthenticationFailureListener)
((AuthenticationFailureListener) listener).authenticationFailed(event);
}
catch (GuacamoleException e) {
logger.error("Error notifying AuthenticationFailureListener.", e);
}
}
}
private boolean notifySuccess(Collection listeners, Credentials credentials)
throws GuacamoleException {
AuthenticationSuccessEvent event = new AuthenticationSuccessEvent(credentials);
for (Object listener : listeners) {
if (listener instanceof AuthenticationSuccessListener) {
if (!((AuthenticationSuccessListener) listener).authenticationSucceeded(event))
return false;
}
}
return true;
}
private void failAuthentication(HttpServletResponse response) throws IOException {
response.setHeader("X-Guacamole-Error-Message", AUTH_ERROR_MESSAGE);
response.sendError(HttpServletResponse.SC_FORBIDDEN);
}
SessionListenerCollection listeners;
try {
listeners = new SessionListenerCollection(httpSession);
}
catch (GuacamoleException e) {
logger.error("Failed to retrieve listeners. Authentication canceled.", e);
failAuthentication(response);
return;
}
catch (GuacamoleException e) {
logger.error("Error retrieving configuration(s) for user \"{}\".", username);
notifyFailed(listeners, credentials);
failAuthentication(response);
notifyFailed(listeners, credentials);
failAuthentication(response);
try {
logger.info("User \"{}\" successfully authenticated from {}.",
username, request.getRemoteAddr());
if (!notifySuccess(listeners, credentials)) {
logger.info("Successful authentication canceled by hook.");
failAuthentication(response);
return;
}
}
catch (GuacamoleException e) {
logger.error("Successful authentication canceled by error in hook.");
failAuthentication(response);
return;
}
public TunnelAttachEvent(Credentials credentials, GuacamoleTunnel tunnel) {
this.credentials = credentials;
this.tunnel = tunnel;
}
public TunnelDetachEvent(Credentials credentials, GuacamoleTunnel tunnel) {
this.credentials = credentials;
this.tunnel = tunnel;
}
protected Credentials getCredentials(HttpSession session) {
return (Credentials) session.getAttribute("GUAC_CREDS");
}
protected Map<String, GuacamoleConfiguration> getConfigurations(HttpSession session) {
return (Map<String, GuacamoleConfiguration>) session.getAttribute("GUAC_CONFIGS");
}
Map<String, GuacamoleConfiguration> configs = getConfigurations(httpSession);
Credentials credentials = new Credentials();
logger.error("Error retrieving configuration(s) for user \"{}\".",
credentials.getUsername());
request.getRemoteAddr(), credentials.getUsername());
credentials.getUsername(), request.getRemoteAddr());
httpSession.setAttribute("GUAC_CREDS",   credentials);
private static final String CONFIGURATIONS_ATTRIBUTE = "GUAC_CONFIGS";
private static final String CREDENTIALS_ATTRIBUTE = "GUAC_CREDS";
return (Credentials) session.getAttribute(CREDENTIALS_ATTRIBUTE);
return (Map<String, GuacamoleConfiguration>) session.getAttribute(CONFIGURATIONS_ATTRIBUTE);
httpSession.setAttribute(CONFIGURATIONS_ATTRIBUTE, configs);
httpSession.setAttribute(CREDENTIALS_ATTRIBUTE,    credentials);
import net.sourceforge.guacamole.net.event.TunnelConnectEvent;
public boolean tunnelAttached(TunnelConnectEvent e)
import net.sourceforge.guacamole.net.event.TunnelCloseEvent;
public boolean tunnelDetached(TunnelCloseEvent e)
import net.sourceforge.guacamole.net.auth.Credentials;
Credentials credentials = getCredentials(httpSession);
Map<String, GuacamoleConfiguration> configs = getConfigurations(httpSession);
if (credentials == null || configs == null)
import java.util.Collection;
import net.sourceforge.guacamole.net.basic.event.SessionListenerCollection;
import net.sourceforge.guacamole.net.event.TunnelCloseEvent;
import net.sourceforge.guacamole.net.event.TunnelConnectEvent;
import net.sourceforge.guacamole.net.event.listener.TunnelCloseListener;
import net.sourceforge.guacamole.net.event.listener.TunnelConnectListener;
private boolean notifyConnect(Collection listeners,
Credentials credentials, GuacamoleTunnel tunnel)
throws GuacamoleException {
TunnelConnectEvent event = new TunnelConnectEvent(credentials, tunnel);
for (Object listener : listeners) {
if (listener instanceof TunnelConnectListener) {
if (!((TunnelConnectListener) listener).tunnelConnected(event))
return false;
}
}
return true;
}
private boolean notifyClose(Collection listeners,
Credentials credentials, GuacamoleTunnel tunnel)
throws GuacamoleException {
TunnelCloseEvent event = new TunnelCloseEvent(credentials, tunnel);
for (Object listener : listeners) {
if (listener instanceof TunnelCloseListener) {
if (!((TunnelCloseListener) listener).tunnelClosed(event))
return false;
}
}
return true;
}
final SessionListenerCollection listeners;
try {
listeners = new SessionListenerCollection(httpSession);
}
catch (GuacamoleException e) {
logger.error("Failed to retrieve listeners. Authentication canceled.", e);
throw e;
}
final Credentials credentials = getCredentials(httpSession);
GuacamoleTunnel tunnel = new GuacamoleTunnel(socket) {
@Override
public void close() throws GuacamoleException {
if (!notifyClose(listeners, credentials, this))
throw new GuacamoleException("Tunnel close canceled by listener.");
super.close();
}
};
if (!notifyConnect(listeners, credentials, tunnel)) {
logger.info("Connection canceled by listener.");
return null;
}
private static final String SESSION_ATTRIBUTE = "GUAC_LISTENERS";
HttpSession httpSession = request.getSession(true);
GuacamoleSession session = new GuacamoleSession(httpSession);
session.attachTunnel(tunnel);
import net.sourceforge.guacamole.net.basic.properties.BasicGuacamoleProperties;
import net.sourceforge.guacamole.properties.GuacamoleProperties;
Collection<Class> listenerClasses =
GuacamoleProperties.getProperty(BasicGuacamoleProperties.EVENT_LISTENERS);
if (listenerClasses != null) {
for (Class listenerClass : listenerClasses) {
Object listener = listenerClass.getConstructor().newInstance();
listeners.add(listener);
}
}
public static final EventListenersProperty EVENT_LISTENERS = new EventListenersProperty() {
@Override
public String getName() { return "event-listeners"; }
};
public class GuacamoleClientException extends GuacamoleException {
public GuacamoleClientException(String message, Throwable cause) {
public GuacamoleClientException(String message) {
public GuacamoleClientException(Throwable cause) {
public class GuacamoleResourceNotFoundException extends GuacamoleClientException {
public class GuacamoleSecurityException extends GuacamoleClientException {
public class GuacamoleServerException extends GuacamoleException {
public GuacamoleServerException(String message, Throwable cause) {
public GuacamoleServerException(String message) {
public GuacamoleServerException(Throwable cause) {
import net.sourceforge.guacamole.GuacamoleServerException;
throw new GuacamoleServerException(e);
throw new GuacamoleServerException("Element terminator of instruction was not ';' nor ','");
throw new GuacamoleServerException("Non-numeric character in element length.");
throw new GuacamoleServerException(e);
import net.sourceforge.guacamole.GuacamoleServerException;
throw new GuacamoleServerException(e);
import net.sourceforge.guacamole.GuacamoleServerException;
throw new GuacamoleServerException(e);
throw new GuacamoleServerException(e);
import net.sourceforge.guacamole.GuacamoleServerException;
exception = new GuacamoleServerException("Error reading guacamole.properties", e);
import net.sourceforge.guacamole.GuacamoleServerException;
import net.sourceforge.guacamole.*;
private void sendError(HttpServletResponse response, int code) throws ServletException {
try {
if (!response.isCommitted())
response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
}
catch (IOException ioe) {
throw new ServletException(ioe);
}
}
throw new GuacamoleClientException("No query string provided.");
throw new GuacamoleServerException(e);
else {
try {
response.sendError(HttpServletResponse.SC_NOT_FOUND);
}
catch (IOException e) {
throw new GuacamoleServerException(e);
}
}
catch (GuacamoleSecurityException e) {
logger.warn("Authorization failed.", e);
sendError(response, HttpServletResponse.SC_UNAUTHORIZED);
}
catch (GuacamoleResourceNotFoundException e) {
logger.debug("Resource not found.", e);
sendError(response, HttpServletResponse.SC_NOT_FOUND);
}
catch (GuacamoleClientException e) {
logger.warn("Error in client request.", e);
sendError(response, HttpServletResponse.SC_BAD_REQUEST);
}
logger.error("Server error in tunnel", e);
sendError(response, HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
throw new GuacamoleResourceNotFoundException("No such tunnel.");
throw new GuacamoleResourceNotFoundException("Tunnel reached end of stream.");
throw new GuacamoleServerException("I/O error writing to servlet output stream.", e);
throw new GuacamoleResourceNotFoundException("No such tunnel.");
import net.sourceforge.guacamole.GuacamoleSecurityException;
throw new GuacamoleSecurityException("User has no session.");
throw new GuacamoleResourceNotFoundException("No tunnel created.");
response.sendError(code);
logger.error("Configuration id={} not found.", id);
return null;
import net.sourceforge.guacamole.GuacamoleSecurityException;
throw new GuacamoleSecurityException("Requested configuration is not authorized.");
sendError(response, HttpServletResponse.SC_FORBIDDEN);
int lengthEnd = -1;
if (instructionBuffer[i] == '.') {
lengthEnd = i;
break;
}
}
if (lengthEnd == -1)
throw new GuacamoleServerException("Read returned incomplete instruction.");
public boolean isOpen();
private boolean open = true;
public GuacamoleSocket getSocket() {
return socket;
}
public boolean isOpen() {
return socket.isOpen();
}
@Override
public boolean isOpen() {
return !sock.isClosed();
}
@Override
public boolean isOpen() {
return socket.isOpen();
}
if (!tunnel.isOpen())
throw new GuacamoleResourceNotFoundException("Tunnel is closed.");
} while (tunnel.isOpen() && (message = reader.read()) != null);
while (tunnel.isOpen() &&
(length = input.read(buffer, 0, buffer.length)) != -1)
throw new GuacamoleSecurityException("Cannot connect - user not logged in.");
logger.warn("Configuration id={} not found.", id);
logger.info("Servlet API 3.0 not found.", e);
logger.warn("Servlet API 3.0 found, but incomplete.", e);
credentials.getUsername(), e);
logger.error("Successful authentication canceled by error in hook.", e);
try { properties.load(stream); }
finally { stream.close(); }
import java.security.AccessController;
import java.security.PrivilegedActionException;
import java.security.PrivilegedExceptionAction;
instance = AccessController.doPrivileged(new PrivilegedExceptionAction<GuacamoleClassLoader>() {
@Override
public GuacamoleClassLoader run() throws GuacamoleException {
return new GuacamoleClassLoader(
GuacamoleProperties.getProperty(BasicGuacamoleProperties.LIB_DIRECTORY)
);
}
});
catch (PrivilegedActionException e) {
exception = (GuacamoleException) e.getException();
import java.io.Serializable;
public class Credentials implements Serializable {
private static final long serialVersionUID = 1L;
private transient HttpServletRequest request;
private transient HttpSession session;
private GuacamoleConfiguration config;
public ConfiguredGuacamoleSocket(GuacamoleSocket socket,
GuacamoleConfiguration config) throws GuacamoleException {
public GuacamoleConfiguration getConfiguration() {
return config;
}
Map<String, GuacamoleConfiguration> configs = info.getConfigurations();
private Map<String, GuacamoleConfiguration> configs;
configs = new HashMap<String, GuacamoleConfiguration>();
public GuacamoleConfiguration getConfiguration(String name) {
return configs.get(name);
}
public Map<String, GuacamoleConfiguration> getConfigurations() {
return configs;
}
public void addConfiguration(String name) {
configs.put(name, new GuacamoleConfiguration());
REMOTE_SERVER,
private String currentRemoteServer = null;
case USER_MAPPING:
if (localName.equals("user-mapping")) {
state = State.END;
return;
}
break;
case AUTH_INFO:
if (localName.equals("authorize")) {
authMapping.put(
current.auth_username,
current
);
state = State.USER_MAPPING;
return;
}
break;
case REMOTE_SERVER:
if (localName.equals("remote-server")) {
state = State.AUTH_INFO;
return;
}
break;
case PROTOCOL:
if (localName.equals("protocol")) {
state = State.REMOTE_SERVER;
return;
}
break;
case PARAMETER:
if (localName.equals("param")) {
state = State.REMOTE_SERVER;
return;
}
break;
}
if (localName.equals("remote-server")) {
currentRemoteServer = attributes.getValue("servername");
if (currentRemoteServer == null)
throw new SAXException("Attribute \"servername\" required for param tag.");
current.addConfiguration(currentRemoteServer);
state = State.REMOTE_SERVER;
return;
}
break;
case REMOTE_SERVER:
break;
current.getConfiguration(currentRemoteServer)
.setProtocol(str);
current.getConfiguration(currentRemoteServer)
CONNECTION,
private String currentConnection = null;
case CONNECTION:
if (localName.equals("connection")) {
state = State.CONNECTION;
state = State.CONNECTION;
if (localName.equals("connection")) {
currentConnection = attributes.getValue("name");
if (currentConnection == null)
throw new SAXException("Attribute \"name\" required for param tag.");
current.addConfiguration(currentConnection);
state = State.CONNECTION;
case CONNECTION:
current.getConfiguration(currentConnection)
current.getConfiguration(currentConnection)
throw new SAXException("Attribute \"name\" required for connection tag.");
case USER_MAPPING:
if (localName.equals("user-mapping")) {
state = State.END;
return;
}
break;
case AUTH_INFO:
if (localName.equals("authorize")) {
authMapping.put(
current.auth_username,
current
);
state = State.USER_MAPPING;
return;
}
break;
case CONNECTION:
if (localName.equals("connection")) {
state = State.AUTH_INFO;
return;
}
break;
case PROTOCOL:
if (localName.equals("protocol")) {
state = State.CONNECTION;
return;
}
break;
case PARAMETER:
if (localName.equals("param")) {
state = State.CONNECTION;
return;
}
break;
}
if (info != null && info.validate(credentials.getUsername(), credentials.getPassword()))
return info.getConfigurations();
GuacamoleConfiguration config = configs.get(name);
if (config == null) {
config = new GuacamoleConfiguration();
configs.put(name, config);
}
return config;
CONNECTION,
DEFAULT_CONNECTION_PROTOCOL,
DEFAULT_CONNECTION_PARAMETER,
case DEFAULT_CONNECTION_PROTOCOL:
if (localName.equals("protocol")) {
state = State.AUTH_INFO;
return;
}
break;
case DEFAULT_CONNECTION_PARAMETER:
if (localName.equals("param")) {
state = State.AUTH_INFO;
return;
}
break;
if (localName.equals("protocol")) {
currentConnection = "DEFAULT";
state = State.DEFAULT_CONNECTION_PROTOCOL;
return;
}
if (localName.equals("param")) {
currentConnection = "DEFAULT";
currentParameter = attributes.getValue("name");
if (currentParameter == null)
throw new SAXException("Attribute \"name\" required for param tag.");
state = State.DEFAULT_CONNECTION_PARAMETER;
return;
}
case DEFAULT_CONNECTION_PROTOCOL:
case DEFAULT_CONNECTION_PARAMETER:
logger.debug("Error writing to servlet output stream", e);
reader = new ReaderGuacamoleReader(new InputStreamReader(sock.getInputStream(),   "UTF-8"));
writer = new WriterGuacamoleWriter(new OutputStreamWriter(sock.getOutputStream(), "UTF-8"));
import java.io.*;
Writer out = new BufferedWriter(new OutputStreamWriter(response.getOutputStream(), "UTF-8"));
Reader input = new BufferedReader(new InputStreamReader(request.getInputStream(), "UTF-8"));
import net.sourceforge.guacamole.net.GuacamoleTunnel;
Reader input = new InputStreamReader(request.getInputStream(), "UTF-8");
break;
break;
);
while (tunnel.isOpen() &&
Credentials getCredentials();
GuacamoleTunnel getTunnel();
void authenticationFailed(AuthenticationFailureEvent e)
boolean authenticationSucceeded(AuthenticationSuccessEvent e)
boolean tunnelClosed(TunnelCloseEvent e)
boolean tunnelConnected(TunnelConnectEvent e)
Map<String, GuacamoleConfiguration>
public void setPassword(final String password) {
public void setUsername(final String username) {
public void setRequest(final HttpServletRequest request) {
public void setSession(final HttpSession session) {
public AuthenticationFailureEvent(final Credentials credentials) {
public AuthenticationSuccessEvent(final Credentials credentials) {
public TunnelCloseEvent(final Credentials credentials,
final GuacamoleTunnel tunnel) {
public TunnelConnectEvent(final Credentials credentials,
final GuacamoleTunnel tunnel) {
public void setPassword(String password) {
public void setUsername(String username) {
public void setRequest(HttpServletRequest request) {
public void setSession(HttpSession session) {
public AuthenticationFailureEvent(Credentials credentials) {
public AuthenticationSuccessEvent(Credentials credentials) {
public TunnelCloseEvent(Credentials credentials, GuacamoleTunnel tunnel) {
public TunnelConnectEvent(Credentials credentials, GuacamoleTunnel tunnel) {
package org.glyptodon.guacamole.net.basic;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.AuthenticationProvider;
import org.glyptodon.guacamole.net.auth.Credentials;
import org.glyptodon.guacamole.net.basic.event.SessionListenerCollection;
import org.glyptodon.guacamole.net.basic.properties.BasicGuacamoleProperties;
import org.glyptodon.guacamole.net.event.AuthenticationFailureEvent;
import org.glyptodon.guacamole.net.event.AuthenticationSuccessEvent;
import org.glyptodon.guacamole.net.event.listener.AuthenticationFailureListener;
import org.glyptodon.guacamole.net.event.listener.AuthenticationSuccessListener;
import org.glyptodon.guacamole.properties.GuacamoleProperties;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
package org.glyptodon.guacamole.net.basic;
import org.glyptodon.guacamole.net.auth.AuthenticationProvider;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.Credentials;
import org.glyptodon.guacamole.properties.FileGuacamoleProperty;
import org.glyptodon.guacamole.properties.GuacamoleProperties;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
package org.glyptodon.guacamole.net.basic;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.GuacamoleSecurityException;
import org.glyptodon.guacamole.net.InetGuacamoleSocket;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
import org.glyptodon.guacamole.properties.GuacamoleProperties;
import org.glyptodon.guacamole.net.GuacamoleSocket;
import org.glyptodon.guacamole.net.GuacamoleTunnel;
import org.glyptodon.guacamole.net.auth.Credentials;
import org.glyptodon.guacamole.net.basic.event.SessionListenerCollection;
import org.glyptodon.guacamole.net.event.TunnelCloseEvent;
import org.glyptodon.guacamole.net.event.TunnelConnectEvent;
import org.glyptodon.guacamole.net.event.listener.TunnelCloseListener;
import org.glyptodon.guacamole.net.event.listener.TunnelConnectListener;
import org.glyptodon.guacamole.protocol.ConfiguredGuacamoleSocket;
import org.glyptodon.guacamole.servlet.GuacamoleHTTPTunnelServlet;
package org.glyptodon.guacamole.net.basic;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
package org.glyptodon.guacamole.net.basic;
package org.glyptodon.guacamole.net.basic;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
package org.glyptodon.guacamole.net.basic;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.basic.properties.BasicGuacamoleProperties;
import org.glyptodon.guacamole.properties.GuacamoleProperties;
package org.glyptodon.guacamole.net.basic;
import org.glyptodon.guacamole.GuacamoleException;
"org.glyptodon.guacamole.net.basic.BasicGuacamoleWebSocketTunnelServlet"
package org.glyptodon.guacamole.net.basic.event;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.basic.properties.BasicGuacamoleProperties;
import org.glyptodon.guacamole.properties.GuacamoleProperties;
package org.glyptodon.guacamole.net.basic.properties;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.AuthenticationProvider;
import org.glyptodon.guacamole.net.basic.GuacamoleClassLoader;
import org.glyptodon.guacamole.properties.GuacamoleProperty;
package org.glyptodon.guacamole.net.basic.properties;
import org.glyptodon.guacamole.properties.FileGuacamoleProperty;
package org.glyptodon.guacamole.net.basic.properties;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.basic.GuacamoleClassLoader;
import org.glyptodon.guacamole.properties.GuacamoleProperty;
import org.glyptodon.guacamole.io.GuacamoleWriter;
import org.glyptodon.guacamole.net.GuacamoleResourcePipe;
import org.glyptodon.guacamole.net.InetGuacamoleSocket;
import org.glyptodon.guacamole.properties.GuacamoleProperties;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
import org.glyptodon.guacamole.protocol.GuacamoleInstruction;
@Override
protected void handleClientInstruction(GuacamoleTunnel tunnel,
GuacamoleInstruction instruction, GuacamoleWriter writer)
throws GuacamoleException {
switch (instruction.getOperation()) {
case REJECT: {
GuacamoleResourcePipe resource = tunnel.getResourcePipe(
Integer.parseInt(instruction.getArgs()[0]));
tunnel.detachResourcePipe(resource);
break;
}
}
super.handleClientInstruction(tunnel, instruction, writer);
}
@Override
protected void handleServerInstruction(GuacamoleTunnel tunnel,
GuacamoleInstruction instruction, GuacamoleWriter writer)
throws GuacamoleException {
switch (instruction.getOperation()) {
case RESOURCE: {
GuacamoleResourcePipe resource = new GuacamoleResourcePipe(
Integer.parseInt(instruction.getArgs()[0]));
tunnel.attachResourcePipe(resource);
super.handleServerInstruction(tunnel, instruction, writer);
break;
}
case DATA: {
GuacamoleResourcePipe resource = tunnel.getResourcePipe(
Integer.parseInt(instruction.getArgs()[0]));
resource.write(instruction.getArgs()[1]);
break;
}
case END: {
GuacamoleResourcePipe resource = tunnel.getResourcePipe(
Integer.parseInt(instruction.getArgs()[0]));
resource.close();
break;
}
default:
super.handleServerInstruction(tunnel, instruction, writer);
}
}
String mimetype = request.getParameter("mimetype");
response.setContentType(mimetype);
import net.sourceforge.guacamole.GuacamoleServerException;
if (instruction == null)
throw new GuacamoleServerException("End of stream during initial handshake.");
private static final String READ_PREFIX  = "read:";
private static final String WRITE_PREFIX = "write:";
private static final int READ_PREFIX_LENGTH = READ_PREFIX.length();
private static final int WRITE_PREFIX_LENGTH = WRITE_PREFIX.length();
private static final int UUID_LENGTH = 36;
else if(query.startsWith(READ_PREFIX))
doRead(request, response, query.substring(
READ_PREFIX_LENGTH,
else if(query.startsWith(WRITE_PREFIX))
doWrite(request, response, query.substring(
WRITE_PREFIX_LENGTH,
CLIENT_SIZE("size"),
CLIENT_AUDIO("audio"),
CLIENT_VIDEO("video"),
this(socket, config, new GuacamoleClientInformation());
}
public ConfiguredGuacamoleSocket(GuacamoleSocket socket,
GuacamoleConfiguration config,
GuacamoleClientInformation info) throws GuacamoleException {
writer.writeInstruction(
new GuacamoleInstruction(
Operation.CLIENT_SIZE,
Integer.toString(info.getOptimalScreenWidth()),
Integer.toString(info.getOptimalScreenHeight())
)
);
writer.writeInstruction(new GuacamoleInstruction(Operation.CLIENT_AUDIO));
writer.writeInstruction(new GuacamoleInstruction(Operation.CLIENT_VIDEO));
import net.sourceforge.guacamole.net.InetGuacamoleSocket;
import net.sourceforge.guacamole.properties.GuacamoleProperties;
import net.sourceforge.guacamole.protocol.GuacamoleClientInformation;
import net.sourceforge.guacamole.protocol.GuacamoleConfiguration;
GuacamoleClientInformation info = new GuacamoleClientInformation();
String width  = request.getParameter("width");
if (width != null)
info.setOptimalScreenWidth(Integer.parseInt(width));
String height = request.getParameter("height");
if (height != null)
info.setOptimalScreenHeight(Integer.parseInt(height));
config, info
import java.util.ArrayList;
import java.util.List;
private List<String> audioMimetypes = new ArrayList<String>();
private List<String> videoMimetypes = new ArrayList<String>();
public List<String> getAudioMimetypes() {
public List<String> getVideoMimetypes() {
import net.sourceforge.guacamole.io.GuacamoleReader;
import net.sourceforge.guacamole.io.GuacamoleWriter;
writer.writeInstruction(
new GuacamoleInstruction(
Operation.CLIENT_AUDIO,
info.getAudioMimetypes().toArray(new String[0])
));
writer.writeInstruction(
new GuacamoleInstruction(
Operation.CLIENT_VIDEO,
info.getAudioMimetypes().toArray(new String[0])
));
import java.util.Arrays;
String[] audio_mimetypes = request.getParameterValues("audio");
if (audio_mimetypes != null)
info.getAudioMimetypes().addAll(Arrays.asList(audio_mimetypes));
String[] video_mimetypes = request.getParameterValues("video");
if (video_mimetypes != null)
info.getVideoMimetypes().addAll(Arrays.asList(video_mimetypes));
info.getVideoMimetypes().toArray(new String[0])
import net.sourceforge.guacamole.net.auth.AuthenticationProvider;
response.setHeader("Cache-Control", "no-cache");
response.setHeader("Cache-Control", "no-cache");
response.setHeader("Cache-Control", "no-cache");
import java.util.TreeMap;
configs = new TreeMap<String, GuacamoleConfiguration>();
if (stack.isEmpty())
return null;
if (handler == null)
private static class DocumentHandlerState {
import net.sourceforge.guacamole.net.basic.auth.Authorization;
import net.sourceforge.guacamole.net.basic.auth.UserMapping;
import net.sourceforge.guacamole.net.basic.xml.DocumentHandler;
import net.sourceforge.guacamole.net.basic.xml.user_mapping.UserMappingTagHandler;
private UserMapping mapping;
UserMappingTagHandler userMappingHandler =
new UserMappingTagHandler();
DocumentHandler contentHandler = new DocumentHandler(
"user-mapping", userMappingHandler);
mapping = userMappingHandler.asUserMapping();
Authorization auth = mapping.getAuthorization(credentials.getUsername());
if (auth != null && auth.validate(credentials.getUsername(), credentials.getPassword()))
return auth.getConfigurations();
}
private long mod_time;
private UserMapping user_mapping;
private UserMapping getUserMapping() throws GuacamoleException {
File user_mapping_file =
GuacamoleProperties.getRequiredProperty(BASIC_USER_MAPPING);
if (user_mapping == null ||
(user_mapping_file.exists()
&& mod_time < user_mapping_file.lastModified())) {
logger.info("Reading user mapping file: {}", user_mapping_file);
try {
UserMappingTagHandler userMappingHandler =
new UserMappingTagHandler();
DocumentHandler contentHandler = new DocumentHandler(
"user-mapping", userMappingHandler);
XMLReader parser = XMLReaderFactory.createXMLReader();
parser.setContentHandler(contentHandler);
Reader reader = new BufferedReader(new FileReader(user_mapping_file));
parser.parse(new InputSource(reader));
reader.close();
mod_time = user_mapping_file.lastModified();
user_mapping = userMappingHandler.asUserMapping();
}
catch (IOException e) {
throw new GuacamoleException("Error reading basic user mapping file.", e);
}
catch (SAXException e) {
throw new GuacamoleException("Error parsing basic user mapping XML.", e);
}
return user_mapping;
Authorization auth = getUserMapping().getAuthorization(credentials.getUsername());
import javax.xml.stream.XMLOutputFactory;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamWriter;
try {
XMLOutputFactory outputFactory = XMLOutputFactory.newInstance();
XMLStreamWriter xml = outputFactory.createXMLStreamWriter(response.getWriter());
xml.writeStartDocument();
xml.writeStartElement("configs");
for (Entry<String, GuacamoleConfiguration> entry : configs.entrySet()) {
GuacamoleConfiguration config = entry.getValue();
xml.writeEmptyElement("config");
xml.writeAttribute("id", entry.getKey());
xml.writeAttribute("protocol", config.getProtocol());
}
xml.writeEndElement();
xml.writeEndDocument();
catch (XMLStreamException e) {
throw new IOException("Unable to write configuration list XML.", e);
}
private String name;
this.config = config;
this.name = attributes.getValue("name");
config.setParameter(name, textContent);
getConfigurations(Credentials credentials)
void addConfiguration(Credentials credentials, String identifier,
GuacamoleConfiguration config) throws GuacamoleException;
void updateConfiguration(Credentials credentials, String identifier,
GuacamoleConfiguration config) throws GuacamoleException;
void removeConfiguration(Credentials credentials, String identifier)
throws GuacamoleException;
import net.sourceforge.guacamole.GuacamoleException;
import java.util.Set;
User toUser(Credentials ownCredentials, Credentials credentials)
throws GuacamoleException;
Set<User> getUsers(Credentials credentials) throws GuacamoleException;
void addUser(Credentials credentials, User user)
throws GuacamoleException;
void updateUser(Credentials credentials, User user)
throws GuacamoleException;
void removeUser(Credentials credentials, User user)
throws GuacamoleException;
Environment getAuthorizedEnvironment(Credentials credentials)
public abstract class AbstractUser implements User, Comparable<AbstractUser> {
Environment getEnvironment() throws GuacamoleException;
UserContext getUserContext(Credentials credentials)
public interface User {
private Role role;
public String getUsername() {
public void setUsername(String username) {
public String getPassword() {
public void setPassword(String password) {
@Override
public Role getRole() {
return role;
}
@Override
public void setRole(Role role) {
this.role = role;
}
public String getUsername();
public void setUsername(String username);
public String getPassword();
public void setPassword(String password);
public Role getRole();
public void setRole(Role role);
UserDirectory getUserDirectory() throws GuacamoleException;
GuacamoleConfigurationDirectory getGuacamoleConfigurationDirectory()
PermissionDirectory getPermissionDirectory() throws GuacamoleException;
import net.sourceforge.guacamole.net.auth.simple.SimpleAuthenticationProvider;
public class BasicFileAuthenticationProvider extends SimpleAuthenticationProvider {
public Map<String, GuacamoleConfiguration>
getAuthorizedConfigurations(Credentials credentials)
throws GuacamoleException {
import net.sourceforge.guacamole.net.auth.UserContext;
private static final String CONTEXT_ATTRIBUTE = "GUAC_CONTEXT";
protected UserContext getUserContext(HttpSession session) {
return (UserContext) session.getAttribute(CONTEXT_ATTRIBUTE);
UserContext context = getUserContext(httpSession);
if (context == null) {
context = authProvider.getUserContext(credentials);
logger.error("Error retrieving context for user \"{}\".",
if (context == null) {
httpSession.setAttribute(CONTEXT_ATTRIBUTE,     context);
httpSession.setAttribute(CREDENTIALS_ATTRIBUTE, credentials);
authenticatedService(context, request, response);
UserContext context,
import net.sourceforge.guacamole.net.auth.GuacamoleConfigurationDirectory;
import net.sourceforge.guacamole.net.auth.UserContext;
UserContext context,
UserContext context = getUserContext(httpSession);
GuacamoleConfigurationDirectory directory =
context.getGuacamoleConfigurationDirectory();
Map<String, GuacamoleConfiguration> configs =
directory.getConfigurations();
import net.sourceforge.guacamole.net.auth.UserContext;
UserContext context,
import javax.servlet.ServletException;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.net.auth.GuacamoleConfigurationDirectory;
import net.sourceforge.guacamole.net.auth.UserContext;
UserContext context,
throws IOException, ServletException {
Map<String, GuacamoleConfiguration> configs;
try {
GuacamoleConfigurationDirectory directory =
context.getGuacamoleConfigurationDirectory();
configs = directory.getConfigurations();
}
catch (GuacamoleException e) {
throw new ServletException("Unable to retrieve configurations.", e);
}
implements ObjectPermission<String> {
private String subject;
public GuacamoleConfigurationPermission(Type type, String subject) {
public String getSubject() {
public class UserPermission implements ObjectPermission<String> {
private String subject;
public UserPermission(String subject, Type type) {
public String getSubject() {
private String identifier;
public GuacamoleConfigurationPermission(Type type, String identifier) {
this.identifier = identifier;
public String getObjectIdentifier() {
return identifier;
public T getObjectIdentifier();
private String identifier;
public UserPermission(String identifier, Type type) {
this.identifier = identifier;
public String getObjectIdentifier() {
return identifier;
this.config = config;
private final PermissionDirectory permissionDirectory;
this.permissionDirectory =
new SimplePermissionDirectory(self, configs);
return permissionDirectory;
package net.sourceforge.guacamole.net.event.listener;
Map<String, GuacamoleConfigurationTemplate> getTemplates()
throws GuacamoleException;
import net.sourceforge.guacamole.net.auth.GuacamoleConfigurationTemplate;
public Map<String, GuacamoleConfigurationTemplate> getTemplates()
throws GuacamoleException {
throw new GuacamoleSecurityException("Permission denied.");
}
@Override
import java.io.UnsupportedEncodingException;
String hashedPassword = getHexString(digest.digest(password.getBytes("UTF-8")));
catch (UnsupportedEncodingException e) {
throw new UnsupportedOperationException("Unexpected lack of UTF-8 support.", e);
}
import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.InputStream;
InputStream input = new BufferedInputStream(new FileInputStream(user_mapping_file));
parser.parse(new InputSource(input));
input.close();
opcode,
writer.writeInstruction(new GuacamoleInstruction("select", config.getProtocol()));
} while (!instruction.getOpcode().equals("args"));
"size",
"audio",
"video",
writer.writeInstruction(new GuacamoleInstruction("connect", args));
private String opcode;
public GuacamoleInstruction(String opcode, String... args) {
this.opcode = opcode;
public String getOpcode() {
return opcode;
buff.append(opcode.length());
buff.append(opcode);
import java.util.List;
List<String> arg_names = instruction.getArgs();
String[] arg_values = new String[arg_names.size()];
String arg_name = arg_names.get(i);
String value = config.getParameter(arg_name);
if (value != null) arg_values[i] = value;
else arg_values[i] = "";
writer.writeInstruction(new GuacamoleInstruction("connect", arg_values));
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
private List<String> args;
this.args = Collections.unmodifiableList(Arrays.asList(args));
public List<String> getArgs() {
for (String value : args) {
buff.append(value.length());
buff.append(value);
Writer out = new BufferedWriter(new OutputStreamWriter(
response.getOutputStream(), "UTF-8"));
try {
char[] message = reader.read();
if (message == null)
throw new GuacamoleResourceNotFoundException("Tunnel reached end of stream.");
do {
out.write(message, 0, message.length);
if (!reader.available()) {
out.flush();
response.flushBuffer();
}
if (tunnel.hasQueuedReaderThreads())
break;
} while (tunnel.isOpen() && (message = reader.read()) != null);
if (message == null)
tunnel.close();
out.write("0.;");
out.flush();
response.flushBuffer();
}
finally {
out.close();
}
Reader input = new InputStreamReader(
request.getInputStream(), "UTF-8");
try {
int length;
char[] buffer = new char[8192];
while (tunnel.isOpen() &&
(length = input.read(buffer, 0, buffer.length)) != -1)
writer.write(buffer, 0, length);
}
finally {
input.close();
}
Collection<String> getPossibleValues();
import net.sourceforge.guacamole.GuacamoleSecurityException;
import net.sourceforge.guacamole.net.auth.PermissionDirectory;
import net.sourceforge.guacamole.net.auth.User;
import net.sourceforge.guacamole.net.auth.permission.GuacamoleConfigurationDirectoryPermission;
import net.sourceforge.guacamole.net.auth.permission.GuacamoleConfigurationPermission;
import net.sourceforge.guacamole.net.auth.permission.ObjectPermission;
import net.sourceforge.guacamole.net.auth.permission.Permission;
import net.sourceforge.guacamole.net.auth.permission.SystemPermission;
private boolean hasConfigPermission(PermissionDirectory permissions,
User user, SystemPermission.Type type)
throws GuacamoleException {
Permission permission =
new GuacamoleConfigurationDirectoryPermission(type);
try {
return permissions.hasPermission(user, permission);
}
catch (GuacamoleSecurityException e) {
return false;
}
}
private boolean hasConfigPermission(PermissionDirectory permissions,
User user, ObjectPermission.Type type, String identifier)
throws GuacamoleException {
Permission permission = new GuacamoleConfigurationPermission(
type,
identifier
);
try {
return permissions.hasPermission(user, permission);
}
catch (GuacamoleSecurityException e) {
return false;
}
}
PermissionDirectory permissions = null;
try {
permissions = context.getPermissionDirectory();
}
catch (GuacamoleSecurityException e) {
}
catch (GuacamoleException e) {
throw new ServletException("Unable to retrieve permissions.", e);
}
if (hasConfigPermission(permissions, context.self(),
SystemPermission.Type.CREATE))
xml.writeAttribute("create", "yes");
if (permissions != null) {
if (hasConfigPermission(permissions, context.self(),
ObjectPermission.Type.UPDATE, entry.getKey()))
xml.writeAttribute("update", "yes");
if (hasConfigPermission(permissions, context.self(),
ObjectPermission.Type.ADMINSTER, entry.getKey()))
xml.writeAttribute("admin", "yes");
if (hasConfigPermission(permissions, context.self(),
ObjectPermission.Type.DELETE, entry.getKey()))
xml.writeAttribute("delete", "yes");
}
catch (GuacamoleException e) {
throw new ServletException("Unable to read configurations.", e);
}
public UserPermission(Type type, String identifier) {
ADMINISTER
import java.util.Set;
Set<Permission> getPermissions(String user) throws GuacamoleException;
boolean hasPermission(String user, Permission permission)
void addPermission(String user, Permission permission)
void removePermission(String user, Permission permission)
import java.util.HashSet;
private String user;
this.user = user.getUsername();
public Set<Permission> getPermissions(String user) throws GuacamoleException {
if (!this.user.equals(user))
throw new GuacamoleSecurityException("Permission denied.");
Set<Permission> permissions = new HashSet<Permission>();
for (String identifier : configIdentifiers) {
permissions.add(
new GuacamoleConfigurationPermission(
ObjectPermission.Type.READ,
identifier
)
);
}
return permissions;
}
@Override
public boolean hasPermission(String user, Permission permission) throws GuacamoleException {
public void addPermission(String user, Permission permission) throws GuacamoleException {
public void removePermission(String user, Permission permission) throws GuacamoleException {
String user, SystemPermission.Type type)
String user, ObjectPermission.Type type, String identifier)
String username = context.self().getUsername();
if (hasConfigPermission(permissions, username,
SystemPermission.Type.CREATE))
xml.writeAttribute("create", "yes");
if (hasConfigPermission(permissions, username,
if (hasConfigPermission(permissions, username,
ObjectPermission.Type.ADMINISTER, entry.getKey()))
if (hasConfigPermission(permissions, username,
xml.writeEmptyElement("user");
if (permissions != null && hasConfigPermission(permissions, username,
if (permissions != null && hasUserPermission(permissions, username,
void removeUser(String username) throws GuacamoleException;
import java.util.Set;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.net.auth.permission.Permission;
Set<Permission> getPermissions() throws GuacamoleException;
boolean hasPermission(Permission permission) throws GuacamoleException;
void addPermission(Permission permission) throws GuacamoleException;
void removePermission(Permission permission) throws GuacamoleException;
User user = new SimpleUser(credentials.getUsername(), configs);
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.GuacamoleSecurityException;
import net.sourceforge.guacamole.net.auth.permission.GuacamoleConfigurationPermission;
import net.sourceforge.guacamole.net.auth.permission.ObjectPermission;
import net.sourceforge.guacamole.net.auth.permission.Permission;
import net.sourceforge.guacamole.protocol.GuacamoleConfiguration;
private Set<Permission> permissions = new HashSet<Permission>();
public SimpleUser(String username,
Map<String, GuacamoleConfiguration> configs) {
for (String identifier : configs.keySet()) {
Permission permission = new GuacamoleConfigurationPermission(
ObjectPermission.Type.READ,
identifier
);
permissions.add(permission);
}
}
@Override
public Set<Permission> getPermissions() throws GuacamoleException {
return permissions;
}
@Override
public boolean hasPermission(Permission permission) throws GuacamoleException {
throw new UnsupportedOperationException("Not supported yet.");
}
@Override
public void addPermission(Permission permission) throws GuacamoleException {
throw new GuacamoleSecurityException("Permission denied.");
}
@Override
public void removePermission(Permission permission) throws GuacamoleException {
throw new GuacamoleSecurityException("Permission denied.");
User getUser(String username) throws GuacamoleException;
GuacamoleConfiguration getConfiguration(String identifier)
throws GuacamoleException;
public GuacamoleConfiguration getConfiguration(String identifier)
throws GuacamoleException {
return configs.get(identifier);
}
@Override
public abstract class AbstractUser implements User {
@Override
public int hashCode() {
return type.hashCode();
}
@Override
public boolean equals(Object obj) {
if (obj == null) return false;
if (getClass() != obj.getClass()) return false;
final GuacamoleConfigurationDirectoryPermission other =
(GuacamoleConfigurationDirectoryPermission) obj;
if (type != other.type)
return false;
return true;
}
@Override
public int hashCode() {
int hash = 5;
return hash;
}
@Override
public boolean equals(Object obj) {
if (obj == null) return false;
if (getClass() != obj.getClass()) return false;
final GuacamoleConfigurationPermission other =
(GuacamoleConfigurationPermission) obj;
if (this.type != other.type)
return false;
if (identifier == null)
return other.identifier != null;
return identifier.equals(other.identifier);
}
@Override
public int hashCode() {
return type.hashCode();
}
@Override
public boolean equals(Object obj) {
if (obj == null) return false;
if (getClass() != obj.getClass()) return false;
final UserDirectoryPermission other = (UserDirectoryPermission) obj;
if (type != other.type)
return false;
return true;
}
@Override
public int hashCode() {
int hash = 5;
return hash;
}
@Override
public boolean equals(Object obj) {
if (obj == null) return false;
if (getClass() != obj.getClass()) return false;
final UserPermission other = (UserPermission) obj;
if (this.type != other.type)
return false;
if (identifier == null)
return other.identifier != null;
return identifier.equals(other.identifier);
}
return permissions.contains(permission);
import net.sourceforge.guacamole.net.auth.User;
private boolean hasConfigPermission(User user, SystemPermission.Type type)
return user.hasPermission(permission);
private boolean hasConfigPermission(User user, ObjectPermission.Type type,
String identifier)
return user.hasPermission(permission);
User self = context.self();
if (hasConfigPermission(self, SystemPermission.Type.CREATE))
if (hasConfigPermission(self, ObjectPermission.Type.UPDATE,
entry.getKey()))
xml.writeAttribute("update", "yes");
if (hasConfigPermission(self, ObjectPermission.Type.ADMINISTER,
entry.getKey()))
xml.writeAttribute("admin", "yes");
if (hasConfigPermission(self, ObjectPermission.Type.DELETE,
entry.getKey()))
xml.writeAttribute("delete", "yes");
import net.sourceforge.guacamole.net.auth.User;
import net.sourceforge.guacamole.net.auth.UserDirectory;
UserDirectory users = context.getUserDirectory();
User user = users.getUser(username);
for (Permission permission : user.getPermissions()) {
private boolean hasUserPermission(User user, SystemPermission.Type type)
return user.hasPermission(permission);
private boolean hasUserPermission(User user, ObjectPermission.Type type,
String identifier)
return user.hasPermission(permission);
User self = context.self();
if (hasUserPermission(self, SystemPermission.Type.CREATE))
if (hasUserPermission(self, ObjectPermission.Type.UPDATE,
user.getUsername()))
xml.writeAttribute("update", "yes");
if (hasUserPermission(self, ObjectPermission.Type.ADMINISTER,
user.getUsername()))
xml.writeAttribute("admin", "yes");
if (hasUserPermission(self, ObjectPermission.Type.DELETE,
user.getUsername()))
xml.writeAttribute("delete", "yes");
private final UserDirectory userDirectory;
this.userDirectory = new SimpleUserDirectory(self);
return userDirectory;
if (user == null)
throw new GuacamoleSecurityException("No such user.");
import java.io.File;
import java.io.FileInputStream;
File guacHome;
String desiredDir = System.getProperty("guacamole.home");
if (desiredDir != null)
guacHome = new File(desiredDir);
else
guacHome = new File(System.getProperty("user.home"), ".guacamole");
InputStream stream;
if (!guacHome.isDirectory()) {
stream = GuacamoleProperties.class.getResourceAsStream("/guacamole.properties");
if (stream == null)
throw new IOException(
" (not a directory), and guacamole.properties could"
" not be found as a resource in the classpath.");
}
else
stream = new FileInputStream(new File(guacHome, "guacamole.properties"));
import net.sourceforge.guacamole.protocol.GuacamoleConfiguration;
Directory<String, User> getUserDirectory() throws GuacamoleException;
Directory<String, GuacamoleConfiguration>
getGuacamoleConfigurationDirectory()
import java.util.Set;
import net.sourceforge.guacamole.net.auth.Directory;
implements Directory<String, GuacamoleConfiguration> {
public GuacamoleConfiguration get(String identifier)
public Set<String> getIdentifiers() throws GuacamoleException {
return configs.keySet();
public void add(String identifier, GuacamoleConfiguration config)
throws GuacamoleException {
public void update(String identifier, GuacamoleConfiguration config)
throws GuacamoleException {
public void remove(String identifier) throws GuacamoleException {
import net.sourceforge.guacamole.net.auth.Directory;
private final Directory<String, GuacamoleConfiguration> configDirectory;
private final Directory<String, User> userDirectory;
public Directory<String, GuacamoleConfiguration>
getGuacamoleConfigurationDirectory()
public Directory<String, User> getUserDirectory()
throws GuacamoleException {
import net.sourceforge.guacamole.net.auth.Directory;
public class SimpleUserDirectory implements Directory<String, User> {
public User get(String username) throws GuacamoleException {
public Set<String> getIdentifiers() throws GuacamoleException {
return Collections.singleton(user.getUsername());
public void add(String username, User user) throws GuacamoleException {
public void update(String username, User user) throws GuacamoleException {
public void remove(String username) throws GuacamoleException {
import net.sourceforge.guacamole.net.auth.Directory;
Directory<String, GuacamoleConfiguration> directory =
if (credentials == null)
GuacamoleConfiguration config = directory.get(id);
import net.sourceforge.guacamole.net.auth.Directory;
Directory<String, GuacamoleConfiguration> directory;
directory = context.getGuacamoleConfigurationDirectory();
for (String identifier : directory.getIdentifiers()) {
GuacamoleConfiguration config = directory.get(identifier);
xml.writeAttribute("id", identifier);
identifier))
identifier))
identifier))
import net.sourceforge.guacamole.net.auth.Directory;
Directory<String, User> users = context.getUserDirectory();
User user = users.get(username);
import net.sourceforge.guacamole.net.auth.Directory;
Directory<String, User> directory = context.getUserDirectory();
Set<String> users = directory.getIdentifiers();
for (String username : users) {
User user = directory.get(username);
void add(ObjectType object)
void update(ObjectType object)
Directory<String, Connection> getConnectionDirectory()
public class ConnectionDirectoryPermission
public ConnectionDirectoryPermission(Type type) {
final ConnectionDirectoryPermission other =
(ConnectionDirectoryPermission) obj;
public class ConnectionPermission
public ConnectionPermission(Type type, String identifier) {
final ConnectionPermission other =
(ConnectionPermission) obj;
import java.util.HashMap;
import java.util.Map.Entry;
import net.sourceforge.guacamole.net.auth.Connection;
public class SimpleConnectionDirectory
implements Directory<String, Connection> {
private Map<String, Connection> connections =
new HashMap<String, Connection>();
public SimpleConnectionDirectory(
for (Entry<String, GuacamoleConfiguration> entry : configs.entrySet())
connections.put(entry.getKey(),
new SimpleConnection(entry.getKey(), entry.getValue()));
public Connection get(String identifier)
return connections.get(identifier);
return connections.keySet();
public void add(Connection connection)
public void update(Connection connection)
import net.sourceforge.guacamole.net.auth.permission.ConnectionPermission;
Permission permission = new ConnectionPermission(
import net.sourceforge.guacamole.net.auth.Connection;
private final Directory<String, Connection> connectionDirectory;
this.connectionDirectory =
new SimpleConnectionDirectory(configs);
public Directory<String, Connection> getConnectionDirectory()
return connectionDirectory;
public void add(User user) throws GuacamoleException {
public void update(User user) throws GuacamoleException {
import net.sourceforge.guacamole.net.auth.Connection;
Directory<String, Connection> directory = context.getConnectionDirectory();
Connection connection = directory.get(id);
if (connection == null) {
logger.warn("Connection id={} not found.", id);
throw new GuacamoleSecurityException("Requested connection is not authorized.");
GuacamoleSocket socket = connection.connect(info);
import net.sourceforge.guacamole.net.auth.Connection;
import net.sourceforge.guacamole.net.auth.permission.ConnectionDirectoryPermission;
import net.sourceforge.guacamole.net.auth.permission.ConnectionPermission;
public class ConnectionList extends AuthenticatingHttpServlet {
new ConnectionDirectoryPermission(type);
Permission permission = new ConnectionPermission(
Directory<String, Connection> directory;
directory = context.getConnectionDirectory();
throw new ServletException("Unable to retrieve connections.", e);
xml.writeStartElement("connections");
Connection connection = directory.get(identifier);
xml.writeEmptyElement("connection");
xml.writeAttribute("protocol",
connection.getConfiguration().getProtocol());
import net.sourceforge.guacamole.net.auth.permission.ConnectionDirectoryPermission;
import net.sourceforge.guacamole.net.auth.permission.ConnectionPermission;
if (permission instanceof ConnectionDirectoryPermission) {
ConnectionDirectoryPermission cdp =
(ConnectionDirectoryPermission) permission;
xml.writeEmptyElement("connections");
xml.writeAttribute("type", toString(cdp.getType()));
else if (permission instanceof ConnectionPermission) {
ConnectionPermission cp =
(ConnectionPermission) permission;
xml.writeEmptyElement("connection");
xml.writeAttribute("type", toString(cp.getType()));
xml.writeAttribute("name", cp.getObjectIdentifier());
case CREATE: return "create";
package net.sourceforge.guacamole.net.basic.crud.connections;
import net.sourceforge.guacamole.net.basic.AuthenticatingHttpServlet;
public class List extends AuthenticatingHttpServlet {
package net.sourceforge.guacamole.net.basic.crud.permissions;
import net.sourceforge.guacamole.net.basic.AuthenticatingHttpServlet;
public class List extends AuthenticatingHttpServlet {
package net.sourceforge.guacamole.net.basic.crud.users;
import net.sourceforge.guacamole.net.basic.AuthenticatingHttpServlet;
public class List extends AuthenticatingHttpServlet {
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.net.auth.Directory;
import net.sourceforge.guacamole.net.auth.User;
String username = request.getParameter("name");
String password = request.getParameter("password");
try {
Directory<String, User> directory =
context.getUserDirectory();
User user = new DummyUser();
user.setUsername(username);
user.setPassword(password);
directory.add(user);
}
catch (GuacamoleException e) {
throw new ServletException("Unable to create connection.", e);
}
import java.util.Enumeration;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.net.auth.Connection;
import net.sourceforge.guacamole.net.auth.Directory;
import net.sourceforge.guacamole.protocol.GuacamoleConfiguration;
public static final String PARAMETER_PREFIX = "_";
String identifier = request.getParameter("id");
String protocol = request.getParameter("protocol");
try {
Directory<String, Connection> directory =
context.getConnectionDirectory();
GuacamoleConfiguration config = new GuacamoleConfiguration();
config.setProtocol(protocol);
Enumeration<String> params = request.getParameterNames();
while (params.hasMoreElements()) {
String param = params.nextElement();
if (param.startsWith(PARAMETER_PREFIX))
config.setParameter(
param.substring(PARAMETER_PREFIX.length()),
request.getParameter(param));
}
Connection connection = new DummyConnection();
connection.setIdentifier(identifier);
connection.setConfiguration(config);
directory.add(connection);
}
catch (GuacamoleException e) {
throw new ServletException("Unable to create connection.", e);
}
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.net.auth.Connection;
import net.sourceforge.guacamole.net.auth.Directory;
String identifier = request.getParameter("id");
try {
Directory<String, Connection> directory =
context.getConnectionDirectory();
directory.remove(identifier);
}
catch (GuacamoleException e) {
throw new ServletException("Unable to remove connection.", e);
}
import java.util.Enumeration;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.net.auth.Connection;
import net.sourceforge.guacamole.net.auth.Directory;
import net.sourceforge.guacamole.protocol.GuacamoleConfiguration;
public static final String PARAMETER_PREFIX = "_";
String identifier = request.getParameter("id");
String protocol = request.getParameter("protocol");
try {
Directory<String, Connection> directory =
context.getConnectionDirectory();
GuacamoleConfiguration config = new GuacamoleConfiguration();
config.setProtocol(protocol);
Enumeration<String> params = request.getParameterNames();
while (params.hasMoreElements()) {
String param = params.nextElement();
if (param.startsWith(PARAMETER_PREFIX))
config.setParameter(
param.substring(PARAMETER_PREFIX.length()),
request.getParameter(param));
}
Connection connection = new DummyConnection();
connection.setIdentifier(identifier);
connection.setConfiguration(config);
directory.update(connection);
}
catch (GuacamoleException e) {
throw new ServletException("Unable to update connection.", e);
}
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.net.auth.Directory;
import net.sourceforge.guacamole.net.auth.User;
String username = request.getParameter("name");
try {
Directory<String, User> directory = context.getUserDirectory();
directory.remove(username);
}
catch (GuacamoleException e) {
throw new ServletException("Unable to remove user.", e);
}
throw new ServletException("Unable to create user.", e);
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.net.auth.Directory;
import net.sourceforge.guacamole.net.auth.User;
import net.sourceforge.guacamole.net.auth.permission.ConnectionDirectoryPermission;
import net.sourceforge.guacamole.net.auth.permission.ConnectionPermission;
import net.sourceforge.guacamole.net.auth.permission.ObjectPermission;
import net.sourceforge.guacamole.net.auth.permission.Permission;
import net.sourceforge.guacamole.net.auth.permission.SystemPermission;
import net.sourceforge.guacamole.net.auth.permission.UserDirectoryPermission;
import net.sourceforge.guacamole.net.auth.permission.UserPermission;
private static final String CREATE_PERMISSION = "create";
private static final String READ_PREFIX   = "read:";
private static final String DELETE_PREFIX = "delete:";
private static final String UPDATE_PREFIX = "update:";
private static final String ADMIN_PREFIX  = "admin:";
private Permission parseUserPermission(String str)
throws GuacamoleException {
if (str.equals(CREATE_PERMISSION))
return new UserDirectoryPermission(SystemPermission.Type.CREATE);
if (str.startsWith(READ_PREFIX))
return new UserPermission(ObjectPermission.Type.READ,
str.substring(READ_PREFIX.length()));
if (str.startsWith(UPDATE_PREFIX))
return new UserPermission(ObjectPermission.Type.UPDATE,
str.substring(UPDATE_PREFIX.length()));
if (str.startsWith(DELETE_PREFIX))
return new UserPermission(ObjectPermission.Type.DELETE,
str.substring(DELETE_PREFIX.length()));
if (str.startsWith(ADMIN_PREFIX))
return new UserPermission(ObjectPermission.Type.ADMINISTER,
str.substring(ADMIN_PREFIX.length()));
throw new GuacamoleException("Invalid permission string.");
}
private Permission parseConnectionPermission(String str)
throws GuacamoleException {
if (str.equals(CREATE_PERMISSION))
return new ConnectionDirectoryPermission(SystemPermission.Type.CREATE);
if (str.startsWith(READ_PREFIX))
return new ConnectionPermission(ObjectPermission.Type.READ,
str.substring(READ_PREFIX.length()));
if (str.startsWith(UPDATE_PREFIX))
return new ConnectionPermission(ObjectPermission.Type.UPDATE,
str.substring(UPDATE_PREFIX.length()));
if (str.startsWith(DELETE_PREFIX))
return new ConnectionPermission(ObjectPermission.Type.DELETE,
str.substring(DELETE_PREFIX.length()));
if (str.startsWith(ADMIN_PREFIX))
return new ConnectionPermission(ObjectPermission.Type.ADMINISTER,
str.substring(ADMIN_PREFIX.length()));
throw new GuacamoleException("Invalid permission string.");
}
String username = request.getParameter("name");
String password = request.getParameter("password");
try {
Directory<String, User> directory =
context.getUserDirectory();
User user = new DummyUser();
user.setUsername(username);
user.setPassword(password);
String[] user_permission = request.getParameterValues("user");
if (user_permission != null) {
for (String str : user_permission)
user.addPermission(parseUserPermission(str));
}
String[] connection_permission = request.getParameterValues("connection");
if (connection_permission != null) {
for (String str : connection_permission)
user.addPermission(parseConnectionPermission(str));
}
directory.update(user);
}
catch (GuacamoleException e) {
throw new ServletException("Unable to update user.", e);
}
import java.util.Map;
private Map<String, String> parameters = new HashMap<String, String>();
xml.writeStartElement("connection");
if (hasConfigPermission(self, ObjectPermission.Type.UPDATE,
identifier)) {
xml.writeAttribute("update", "yes");
for (String name : new String[]{"hostname", "port"}) {
String value = connection.getConfiguration().getParameter(name);
xml.writeStartElement("param");
xml.writeAttribute("name", name);
xml.writeAttribute("title", name);
xml.writeAttribute("type", "text");
if (value != null)
xml.writeCharacters(value);
xml.writeEndElement();
}
}
xml.writeEndElement();
import java.util.UUID;
user.setPassword(UUID.randomUUID().toString());
User user;
if (username != null) {
Directory<String, User> users = context.getUserDirectory();
user = users.get(username);
if (user == null)
throw new GuacamoleSecurityException("No such user.");
}
else
user = context.self();
xml.writeAttribute("user", user.getUsername());
User user = directory.get(username);
if (password != null)
user.setPassword(password);
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
private Logger logger = LoggerFactory.getLogger(MySQLUserContext.class);
MySQLUserContext context = injector.getInstance(MySQLUserContext.class);
context.init(credentials);
bind(MySQLUserContext.class);
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
private Logger logger = LoggerFactory.getLogger(MySQLUserContext.class);
void init(Credentials credentials) {
File guacHome = GuacamoleHome.getDirectory();
import net.sourceforge.guacamole.net.auth.mysql.utility.PasswordEncryptionUtility;
import net.sourceforge.guacamole.net.auth.mysql.utility.SaltUtility;
import net.sourceforge.guacamole.net.auth.mysql.utility.SecureRandomSaltUtility;
import net.sourceforge.guacamole.net.auth.mysql.utility.Sha256PasswordEncryptionUtility;
bind(MySQLUser.class);
bind(SaltUtility.class).to(SecureRandomSaltUtility.class);
bind(PasswordEncryptionUtility.class).to(Sha256PasswordEncryptionUtility.class);
import com.google.inject.Inject;
import java.io.UnsupportedEncodingException;
import java.util.HashSet;
import java.util.List;
import net.sourceforge.guacamole.net.auth.mysql.dao.guacamole.UserMapper;
import net.sourceforge.guacamole.net.auth.mysql.model.guacamole.UserExample;
import net.sourceforge.guacamole.net.auth.mysql.utility.PasswordEncryptionUtility;
import net.sourceforge.guacamole.net.auth.mysql.utility.SaltUtility;
private net.sourceforge.guacamole.net.auth.mysql.model.guacamole.User user;
@Inject
UserMapper userDao;
@Inject
PasswordEncryptionUtility passwordUtility;
@Inject
SaltUtility saltUtility;
Set<Permission> permissions;
MySQLUser() {
user = new net.sourceforge.guacamole.net.auth.mysql.model.guacamole.User();
permissions = new HashSet<Permission>();
}
void init (Credentials credentials) throws GuacamoleException {
UserExample userExample = new UserExample();
userExample.createCriteria().andUsernameEqualTo(credentials.getUsername());
List<net.sourceforge.guacamole.net.auth.mysql.model.guacamole.User> users = userDao.selectByExample(userExample);
if(users.isEmpty())
throw new GuacamoleException("No user found with the supplied credentials");
user = users.get(0);
if(!passwordUtility.checkCredentials(credentials, user.getPassword_hash(), user.getUsername(), user.getPassword_salt()))
throw new GuacamoleException("No user found with the supplied credentials");
}
void init (User user) {
this.setPassword(user.getPassword());
this.setUsername(user.getUsername());
}
public net.sourceforge.guacamole.net.auth.mysql.model.guacamole.User getUser() {
return user;
return user.getUsername();
user.setUsername(username);
try {
return new String(user.getPassword_hash(), "UTF-8");
} catch (UnsupportedEncodingException ex) {
}
String salt = saltUtility.generateSalt();
user.setPassword_salt(salt);
byte[] hash = passwordUtility.createPasswordHash(password, salt);
user.setPassword_hash(hash);
return permissions;
return permissions.contains(permission);
permissions.add(permission);
permissions.remove(permission);
@Inject
private MySQLUser user;
void init(Credentials credentials) throws GuacamoleException {
user.init(credentials);
return user;
import net.sourceforge.guacamole.net.auth.mysql.dao.ConnectionMapper;
import net.sourceforge.guacamole.net.auth.mysql.dao.ConnectionParameterMapper;
import net.sourceforge.guacamole.net.auth.mysql.dao.ConnectionPermissionMapper;
import net.sourceforge.guacamole.net.auth.mysql.dao.SystemPermissionMapper;
import net.sourceforge.guacamole.net.auth.mysql.dao.UserMapper;
import net.sourceforge.guacamole.net.auth.mysql.dao.UserPermissionMapper;
import net.sourceforge.guacamole.net.auth.mysql.dao.UserMapper;
import net.sourceforge.guacamole.net.auth.mysql.model.UserExample;
import net.sourceforge.guacamole.net.auth.mysql.model.UserWithBLOBs;
private UserWithBLOBs user;
user = new UserWithBLOBs();
List<UserWithBLOBs> users = userDao.selectByExampleWithBLOBs(userExample);
public UserWithBLOBs getUser() {
byte[] salt = saltUtility.generateSalt();
import net.sourceforge.guacamole.net.auth.mysql.dao.UserMapper;
package net.sourceforge.guacamole.net.auth.mysql.dao;
import net.sourceforge.guacamole.net.auth.mysql.model.Connection;
import net.sourceforge.guacamole.net.auth.mysql.model.ConnectionExample;
package net.sourceforge.guacamole.net.auth.mysql.dao;
import net.sourceforge.guacamole.net.auth.mysql.model.ConnectionParameter;
import net.sourceforge.guacamole.net.auth.mysql.model.ConnectionParameterExample;
import net.sourceforge.guacamole.net.auth.mysql.model.ConnectionParameterKey;
package net.sourceforge.guacamole.net.auth.mysql.dao;
import net.sourceforge.guacamole.net.auth.mysql.model.ConnectionPermissionExample;
import net.sourceforge.guacamole.net.auth.mysql.model.ConnectionPermissionKey;
package net.sourceforge.guacamole.net.auth.mysql.dao;
import net.sourceforge.guacamole.net.auth.mysql.model.SystemPermissionExample;
import net.sourceforge.guacamole.net.auth.mysql.model.SystemPermissionKey;
package net.sourceforge.guacamole.net.auth.mysql.dao;
import net.sourceforge.guacamole.net.auth.mysql.model.User;
import net.sourceforge.guacamole.net.auth.mysql.model.UserExample;
import net.sourceforge.guacamole.net.auth.mysql.model.UserWithBLOBs;
int insert(UserWithBLOBs record);
int insertSelective(UserWithBLOBs record);
List<UserWithBLOBs> selectByExampleWithBLOBs(UserExample example);
UserWithBLOBs selectByPrimaryKey(Integer user_id);
int updateByExampleSelective(@Param("record") UserWithBLOBs record, @Param("example") UserExample example);
int updateByExampleWithBLOBs(@Param("record") UserWithBLOBs record, @Param("example") UserExample example);
int updateByPrimaryKeySelective(UserWithBLOBs record);
int updateByPrimaryKeyWithBLOBs(UserWithBLOBs record);
package net.sourceforge.guacamole.net.auth.mysql.dao;
import net.sourceforge.guacamole.net.auth.mysql.model.UserPermissionExample;
import net.sourceforge.guacamole.net.auth.mysql.model.UserPermissionKey;
package net.sourceforge.guacamole.net.auth.mysql.model;
this.connection_name = connection_name;
this.protocol = protocol;
package net.sourceforge.guacamole.net.auth.mysql.model;
package net.sourceforge.guacamole.net.auth.mysql.model;
this.parameter_value = parameter_value;
package net.sourceforge.guacamole.net.auth.mysql.model;
package net.sourceforge.guacamole.net.auth.mysql.model;
this.parameter_name = parameter_name;
package net.sourceforge.guacamole.net.auth.mysql.model;
package net.sourceforge.guacamole.net.auth.mysql.model;
this.permission = permission;
package net.sourceforge.guacamole.net.auth.mysql.model;
package net.sourceforge.guacamole.net.auth.mysql.model;
this.permission = permission;
package net.sourceforge.guacamole.net.auth.mysql.model;
package net.sourceforge.guacamole.net.auth.mysql.model;
package net.sourceforge.guacamole.net.auth.mysql.model;
this.permission = permission;
public boolean checkCredentials(Credentials credentials, byte[] dbPasswordHash, String dbUsername, byte[] dbSalt);
public byte[] createPasswordHash(String password, byte[] salt);
public byte[] generateSalt();
public byte[] generateSalt() {
return salt;
import javax.xml.bind.DatatypeConverter;
public boolean checkCredentials(Credentials credentials, byte[] dbPasswordHash, String dbUsername, byte[] dbSalt) {
public byte[] createPasswordHash(String password, byte[] salt) {
builder.append(DatatypeConverter.printHexBinary(salt));
return other.identifier == null;
return other.identifier == null;
import net.sourceforge.guacamole.net.auth.mysql.utility.PermissionCheckUtility;
bind(PermissionCheckUtility.class);
import net.sourceforge.guacamole.net.auth.mysql.utility.PermissionCheckUtility;
UserMapper userDAO;
@Inject
PermissionCheckUtility permissionCheckUtility;
List<UserWithBLOBs> users = userDAO.selectByExampleWithBLOBs(userExample);
this.permissions = permissionCheckUtility.getAllPermissions(user.getUser_id());
public void initNew (User user) throws GuacamoleException {
this.permissions = user.getPermissions();
public void initExisting (String username) throws GuacamoleException {
UserExample example = new UserExample();
example.createCriteria().andUsernameEqualTo(username);
List<UserWithBLOBs> userList = userDAO.selectByExampleWithBLOBs(example);
if(userList.size() == 0)
this.user = userList.get(0);
this.permissions = permissionCheckUtility.getAllPermissions(user.getUser_id());
}
public void init(UserWithBLOBs user) {
this.user = user;
this.permissions = permissionCheckUtility.getAllPermissions(user.getUser_id());
}
public int getUserID() {
return user.getUser_id();
}
@Inject UserDirectory userDirectory;
userDirectory.init(user);
return userDirectory;
import com.google.common.base.Preconditions;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import net.sourceforge.guacamole.net.auth.mysql.dao.ConnectionMapper;
import net.sourceforge.guacamole.net.auth.mysql.dao.ConnectionPermissionMapper;
import net.sourceforge.guacamole.net.auth.mysql.dao.SystemPermissionMapper;
import net.sourceforge.guacamole.net.auth.mysql.dao.UserPermissionMapper;
import net.sourceforge.guacamole.net.auth.mysql.model.ConnectionExample;
import net.sourceforge.guacamole.net.auth.mysql.model.ConnectionPermissionExample;
import net.sourceforge.guacamole.net.auth.mysql.model.ConnectionPermissionKey;
import net.sourceforge.guacamole.net.auth.mysql.model.SystemPermissionExample;
import net.sourceforge.guacamole.net.auth.mysql.model.SystemPermissionKey;
import net.sourceforge.guacamole.net.auth.mysql.model.UserExample;
import net.sourceforge.guacamole.net.auth.mysql.model.UserPermissionExample;
import net.sourceforge.guacamole.net.auth.mysql.model.UserPermissionKey;
import net.sourceforge.guacamole.net.auth.mysql.utility.PermissionCheckUtility;
import net.sourceforge.guacamole.net.auth.permission.ConnectionDirectoryPermission;
import net.sourceforge.guacamole.net.auth.permission.ConnectionPermission;
import net.sourceforge.guacamole.net.auth.permission.Permission;
import net.sourceforge.guacamole.net.auth.permission.SystemPermission;
import net.sourceforge.guacamole.net.auth.permission.UserDirectoryPermission;
import net.sourceforge.guacamole.net.auth.permission.UserPermission;
import org.mybatis.guice.transactional.Transactional;
private MySQLUser user;
ConnectionMapper connectionDAO;
@Inject
UserPermissionMapper userPermissionDAO;
@Inject
ConnectionPermissionMapper connectionPermissionDAO;
@Inject
SystemPermissionMapper systemPermissionDAO;
@Inject
PermissionCheckUtility permissionCheckUtility;
@Inject
void init(MySQLUser user) {
this.user = user;
}
private MySQLUser getNewMySQLUser(User user) throws GuacamoleException {
mySQLUser.initNew(user);
private MySQLUser getExistingMySQLUser(User user) throws GuacamoleException {
return getExistingMySQLUser(user.getUsername());
}
private MySQLUser getExistingMySQLUser(String name) throws GuacamoleException {
MySQLUser mySQLUser = mySQLUserProvider.get();
mySQLUser.initExisting(name);
return mySQLUser;
}
@Transactional
return getExistingMySQLUser(identifier);
@Transactional
Set<String> userNameSet = new HashSet<String>();
List<MySQLUser> users = permissionCheckUtility.getReadableUsers(user.getUserID());
for(MySQLUser mySQLUser : users) {
userNameSet.add(mySQLUser.getUsername());
}
return userNameSet;
@Transactional
Preconditions.checkNotNull(object);
MySQLUser mySQLUser = getNewMySQLUser(object);
updatePermissions(mySQLUser);
}
private void updatePermissions(MySQLUser user) throws GuacamoleException {
List<UserPermission> userPermissions = new ArrayList<UserPermission>();
List<ConnectionPermission> connectionPermissions = new ArrayList<ConnectionPermission>();
List<SystemPermission> systemPermissions = new ArrayList<SystemPermission>();
for(Permission permission : user.getPermissions()) {
if(permission instanceof UserPermission)
userPermissions.add((UserPermission)permission);
else if(permission instanceof ConnectionPermission)
connectionPermissions.add((ConnectionPermission)permission);
else if(permission instanceof SystemPermission)
systemPermissions.add((SystemPermission)permission);
}
updateUserPermissions(userPermissions, user);
updateConnectionPermissions(connectionPermissions, user);
updateSystemPermissions(systemPermissions, user);
}
private void updateUserPermissions(Iterable<UserPermission> permissions, MySQLUser user) throws GuacamoleException {
List<String> usernames = new ArrayList<String>();
for(UserPermission permission : permissions) {
usernames.add(permission.getObjectIdentifier());
}
UserExample userExample = new UserExample();
userExample.createCriteria().andUsernameIn(usernames);
List<net.sourceforge.guacamole.net.auth.mysql.model.User> dbUsers = userDAO.selectByExample(userExample);
List<Integer> userIDs = new ArrayList<Integer>();
Map<String, net.sourceforge.guacamole.net.auth.mysql.model.User> dbUserMap = new HashMap<String, net.sourceforge.guacamole.net.auth.mysql.model.User>();
for(net.sourceforge.guacamole.net.auth.mysql.model.User dbUser : dbUsers) {
dbUserMap.put(dbUser.getUsername(), dbUser);
userIDs.add(dbUser.getUser_id());
}
UserPermissionExample userPermissionExample = new UserPermissionExample();
userPermissionExample.createCriteria().andAffected_user_idIn(userIDs);
List<UserPermissionKey> existingPermissions = userPermissionDAO.selectByExample(userPermissionExample);
Set<Integer> existingUserIDs = new HashSet<Integer>();
for(UserPermissionKey userPermission : existingPermissions) {
existingUserIDs.add(userPermission.getAffected_user_id());
}
userPermissionExample.clear();
userPermissionExample.createCriteria().andAffected_user_idNotIn(userIDs);
userPermissionDAO.deleteByExample(userPermissionExample);
for(UserPermission permission : permissions) {
net.sourceforge.guacamole.net.auth.mysql.model.User dbAffectedUser = dbUserMap.get(permission.getObjectIdentifier());
if(dbAffectedUser == null)
if(existingUserIDs.contains(dbAffectedUser.getUser_id()))
continue;
UserPermissionKey newPermission = new UserPermissionKey();
newPermission.setAffected_user_id(dbAffectedUser.getUser_id());
newPermission.setPermission(permission.getType().name());
newPermission.setUser_id(user.getUserID());
userPermissionDAO.insert(newPermission);
}
}
private void updateConnectionPermissions(Iterable<ConnectionPermission> permissions, MySQLUser user) throws GuacamoleException {
List<String> connectionnames = new ArrayList<String>();
for(ConnectionPermission permission : permissions) {
connectionnames.add(permission.getObjectIdentifier());
}
ConnectionExample connectionExample = new ConnectionExample();
connectionExample.createCriteria().andConnection_nameIn(connectionnames);
List<net.sourceforge.guacamole.net.auth.mysql.model.Connection> dbConnections = connectionDAO.selectByExample(connectionExample);
List<Integer> connectionIDs = new ArrayList<Integer>();
Map<String, net.sourceforge.guacamole.net.auth.mysql.model.Connection> dbConnectionMap = new HashMap<String, net.sourceforge.guacamole.net.auth.mysql.model.Connection>();
for(net.sourceforge.guacamole.net.auth.mysql.model.Connection dbConnection : dbConnections) {
dbConnectionMap.put(dbConnection.getConnection_name(), dbConnection);
connectionIDs.add(dbConnection.getConnection_id());
}
ConnectionPermissionExample connectionPermissionExample = new ConnectionPermissionExample();
connectionPermissionExample.createCriteria().andConnection_idIn(connectionIDs);
List<ConnectionPermissionKey> existingPermissions = connectionPermissionDAO.selectByExample(connectionPermissionExample);
Set<Integer> existingConnectionIDs = new HashSet<Integer>();
for(ConnectionPermissionKey connectionPermission : existingPermissions) {
existingConnectionIDs.add(connectionPermission.getConnection_id());
}
connectionPermissionExample.clear();
connectionPermissionExample.createCriteria().andConnection_idNotIn(connectionIDs);
connectionPermissionDAO.deleteByExample(connectionPermissionExample);
for(ConnectionPermission permission : permissions) {
net.sourceforge.guacamole.net.auth.mysql.model.Connection dbConnection = dbConnectionMap.get(permission.getObjectIdentifier());
if(dbConnection == null)
if(existingConnectionIDs.contains(dbConnection.getConnection_id()))
continue;
ConnectionPermissionKey newPermission = new ConnectionPermissionKey();
newPermission.setConnection_id(dbConnection.getConnection_id());
newPermission.setPermission(permission.getType().name());
newPermission.setConnection_id(user.getUserID());
connectionPermissionDAO.insert(newPermission);
}
}
private void updateSystemPermissions(Iterable<SystemPermission> permissions, MySQLUser user) {
List<String> systemPermissionTypes = new ArrayList<String>();
for(SystemPermission permission : permissions) {
String operation = permission.getType().name();
if(permission instanceof ConnectionDirectoryPermission)
else if(permission instanceof UserDirectoryPermission)
}
SystemPermissionExample systemPermissionExample = new SystemPermissionExample();
systemPermissionExample.createCriteria().andUser_idEqualTo(user.getUserID()).andPermissionNotIn(systemPermissionTypes);
systemPermissionDAO.deleteByExample(systemPermissionExample);
systemPermissionExample.clear();
systemPermissionExample.createCriteria().andUser_idEqualTo(user.getUserID()).andPermissionIn(systemPermissionTypes);
List<SystemPermissionKey> existingPermissions = systemPermissionDAO.selectByExample(systemPermissionExample);
Set<String> existingPermissionTypes = new HashSet<String>();
for(SystemPermissionKey existingPermission : existingPermissions) {
existingPermissionTypes.add(existingPermission.getPermission());
}
for(String systemPermissionType : systemPermissionTypes) {
if(existingPermissionTypes.contains(systemPermissionType))
continue;
SystemPermissionKey newSystemPermission = new SystemPermissionKey();
newSystemPermission.setUser_id(user.getUserID());
newSystemPermission.setPermission(systemPermissionType);
systemPermissionDAO.insert(newSystemPermission);
}
@Transactional
MySQLUser mySQLUser = getExistingMySQLUser(object);
updatePermissions(mySQLUser);
@Transactional
MySQLUser mySQLUser = getExistingMySQLUser(identifier);
deleteAllPermissions(mySQLUser);
userDAO.deleteByPrimaryKey(mySQLUser.getUserID());
}
private void deleteAllPermissions(MySQLUser user) {
UserPermissionExample userPermissionExample = new UserPermissionExample();
userPermissionExample.createCriteria().andUser_idEqualTo(user.getUserID());
userPermissionDAO.deleteByExample(userPermissionExample);
ConnectionPermissionExample connectionPermissionExample = new ConnectionPermissionExample();
connectionPermissionExample.createCriteria().andUser_idEqualTo(user.getUserID());
connectionPermissionDAO.deleteByExample(connectionPermissionExample);
SystemPermissionExample systemPermissionExample = new SystemPermissionExample();
systemPermissionExample.createCriteria().andUser_idEqualTo(user.getUserID());
systemPermissionDAO.deleteByExample(systemPermissionExample);
return other.identifier == null;
return other.identifier == null;
import net.sourceforge.guacamole.net.auth.permission.ConnectionDirectoryPermission;
import net.sourceforge.guacamole.net.auth.permission.ConnectionPermission;
import net.sourceforge.guacamole.net.auth.permission.UserDirectoryPermission;
import net.sourceforge.guacamole.net.auth.permission.UserPermission;
public final class MySQLConstants {
private MySQLConstants() {}
public static final String USER_READ = UserPermission.Type.READ.name();
public static final String USER_UPDATE = UserPermission.Type.UPDATE.name();
public static final String USER_DELETE = UserPermission.Type.DELETE.name();
public static final String USER_ADMINISTER = UserPermission.Type.ADMINISTER.name();
public static final String USER_CREATE = UserDirectoryPermission.Type.CREATE.name();
public static final String CONNECTION_READ = ConnectionPermission.Type.READ.name();
public static final String CONNECTION_UPDATE = ConnectionPermission.Type.UPDATE.name();
public static final String CONNECTION_DELETE = ConnectionPermission.Type.DELETE.name();
public static final String CONNECTION_ADMINISTER = ConnectionPermission.Type.ADMINISTER.name();
public static final String CONNECTION_CREATE = ConnectionDirectoryPermission.Type.CREATE.name();
public static final String SYSTEM_USER_CREATE = "USER_CREATE";
public static final String SYSTEM_CONNECTION_CREATE = "CONNECTION_CREATE";
return checkUserAccess(userID, affectedUserID, MySQLConstants.USER_READ);
public boolean checkUserUpdateAccess(int userID, int affectedUserID) {
return checkUserAccess(userID, affectedUserID, MySQLConstants.USER_UPDATE);
return checkUserAccess(userID, affectedUserID, MySQLConstants.USER_DELETE);
return checkUserAccess(userID, affectedUserID, MySQLConstants.USER_ADMINISTER);
return checkUserAccess(userID, affectedUsername, MySQLConstants.USER_READ);
public boolean checkUserUpdateAccess(int userID, String affectedUsername) {
return checkUserAccess(userID, affectedUsername, MySQLConstants.USER_UPDATE);
return checkUserAccess(userID, affectedUsername, MySQLConstants.USER_DELETE);
return checkUserAccess(userID, affectedUsername, MySQLConstants.USER_ADMINISTER);
return getUsers(userID, MySQLConstants.USER_ADMINISTER);
return getUsers(userID, MySQLConstants.USER_DELETE);
public List<MySQLUser> getUpdateableUsers(int userID) {
return getUsers(userID, MySQLConstants.USER_UPDATE);
return getUsers(userID, MySQLConstants.USER_READ);
return checkConnectionAccess(userID, affectedConnectionID, MySQLConstants.CONNECTION_READ);
public boolean checkConnectionUpdateAccess(int userID, int affectedConnectionID) {
return checkConnectionAccess(userID, affectedConnectionID, MySQLConstants.CONNECTION_UPDATE);
return checkConnectionAccess(userID, affectedConnectionID, MySQLConstants.CONNECTION_DELETE);
return checkConnectionAccess(userID, affectedConnectionID, MySQLConstants.CONNECTION_ADMINISTER);
return checkConnectionAccess(userID, affectedConnectionname, MySQLConstants.CONNECTION_READ);
public boolean checkConnectionUpdateAccess(int userID, String affectedConnectionname) {
return checkConnectionAccess(userID, affectedConnectionname, MySQLConstants.CONNECTION_UPDATE);
return checkConnectionAccess(userID, affectedConnectionname, MySQLConstants.CONNECTION_DELETE);
return checkConnectionAccess(userID, affectedConnectionname, MySQLConstants.CONNECTION_ADMINISTER);
return getConnections(userID, MySQLConstants.CONNECTION_ADMINISTER);
return getConnections(userID, MySQLConstants.CONNECTION_DELETE);
public List<MySQLConnection> getUpdateableConnections(int userID) {
return getConnections(userID, MySQLConstants.CONNECTION_UPDATE);
return getConnections(userID, MySQLConstants.CONNECTION_READ);
return checkSystemPermission(userID, MySQLConstants.SYSTEM_USER_CREATE);
return checkSystemPermission(userID, MySQLConstants.SYSTEM_CONNECTION_CREATE);
if(systemPermission.getPermission().equals(MySQLConstants.SYSTEM_USER_CREATE))
else if(systemPermission.getPermission().equals(MySQLConstants.SYSTEM_CONNECTION_CREATE))
User user = new DummyUser();
user.setUsername(username);
permissionCheckUtility.verifyUserReadAccess(this.user.getUserID(), identifier);
permissionCheckUtility.verifyCreateUserPermission(this.user.getUserID());
permissionCheckUtility.verifyUserUpdateAccess(user.getUserID(), object.getUsername());
permissionCheckUtility.verifyUserUpdateAccess(this.user.getUserID(), object.getUsername());
permissionCheckUtility.verifyUserDeleteAccess(this.user.getUserID(), identifier);
import net.sourceforge.guacamole.net.auth.mysql.GuacamolePermissionException;
public void verifyUserReadAccess(int userID, int affectedUserID) throws GuacamolePermissionException {
if(!checkUserReadAccess(userID, affectedUserID))
}
public void verifyUserUpdateAccess(int userID, int affectedUserID) throws GuacamolePermissionException {
if(!checkUserUpdateAccess(userID, affectedUserID))
}
public void verifyUserDeleteAccess(int userID, int affectedUserID) throws GuacamolePermissionException {
if(!checkUserDeleteAccess(userID, affectedUserID))
}
public void verifyUserAdministerAccess(int userID, int affectedUserID) throws GuacamolePermissionException {
if(!checkUserAdministerAccess(userID, affectedUserID))
}
public void verifyUserReadAccess(int userID, String affectedUsername) throws GuacamolePermissionException {
if(!checkUserReadAccess(userID, affectedUsername))
}
public void verifyUserUpdateAccess(int userID, String affectedUsername) throws GuacamolePermissionException {
if(!checkUserUpdateAccess(userID, affectedUsername))
}
public void verifyUserDeleteAccess(int userID, String affectedUsername) throws GuacamolePermissionException {
if(!checkUserDeleteAccess(userID, affectedUsername))
}
public void verifyUserAdministerAccess(int userID, String affectedUsername) throws GuacamolePermissionException {
if(!checkUserAdministerAccess(userID, affectedUsername))
}
public void verifyConnectionReadAccess(int userID, int affectedConnectionID) throws GuacamolePermissionException {
if(!checkConnectionReadAccess(userID, affectedConnectionID))
}
public void verifyConnectionUpdateAccess(int userID, int affectedConnectionID) throws GuacamolePermissionException {
if(!checkConnectionUpdateAccess(userID, affectedConnectionID))
}
public void verifyConnectionDeleteAccess(int userID, int affectedConnectionID) throws GuacamolePermissionException {
if(!checkConnectionDeleteAccess(userID, affectedConnectionID))
}
public void verifyConnectionAdministerAccess(int userID, int affectedConnectionID) throws GuacamolePermissionException {
if(!checkConnectionAdministerAccess(userID, affectedConnectionID))
}
public void verifyConnectionReadAccess(int userID, String affectedConnectionName) throws GuacamolePermissionException {
if(!checkConnectionReadAccess(userID, affectedConnectionName))
}
public void verifyConnectionUpdateAccess(int userID, String affectedConnectionName) throws GuacamolePermissionException {
if(!checkConnectionUpdateAccess(userID, affectedConnectionName))
}
public void verifyConnectionDeleteAccess(int userID, String affectedConnectionName) throws GuacamolePermissionException {
if(!checkConnectionDeleteAccess(userID, affectedConnectionName))
}
public void verifyConnectionAdministerAccess(int userID, String affectedConnectionName) throws GuacamolePermissionException {
if(!checkConnectionAdministerAccess(userID, affectedConnectionName))
}
public boolean checkConnectionReadAccess(int userID, String affectedConnectionName) {
return checkConnectionAccess(userID, affectedConnectionName, MySQLConstants.CONNECTION_READ);
public boolean checkConnectionUpdateAccess(int userID, String affectedConnectionName) {
return checkConnectionAccess(userID, affectedConnectionName, MySQLConstants.CONNECTION_UPDATE);
public boolean checkConnectionAdministerAccess(int userID, String affectedConnectionName) {
return checkConnectionAccess(userID, affectedConnectionName, MySQLConstants.CONNECTION_ADMINISTER);
public void verifyCreateUserPermission(int userID) throws GuacamolePermissionException {
if(!checkCreateUserPermission(userID))
}
public void verifyCreateConnectionPermission(int userID) throws GuacamolePermissionException {
if(!checkCreateConnectionPermission(userID))
}
import java.util.Collections;
import java.util.Set;
public void unsetParameter(String name) {
parameters.remove(name);
}
public Set<String> getParameterNames() {
return Collections.unmodifiableSet(parameters.keySet());
}
import net.sourceforge.guacamole.protocol.GuacamoleConfiguration;
GuacamoleConfiguration config = connection.getConfiguration();
for (String name : config.getParameterNames()) {
}
public int getConnectionID() {
return connection.getConnection_id();
}
public net.sourceforge.guacamole.net.auth.mysql.model.Connection getConnection() {
return connection;
}
@Override
public boolean equals(Object other) {
if(!(other instanceof MySQLConnection))
return false;
return ((MySQLConnection)other).getConnectionID() == this.getConnectionID();
}
@Override
public boolean equals(Object other) {
if(!(other instanceof MySQLUser))
return false;
return ((MySQLUser)other).getUserID() == this.getUserID();
}
Set<MySQLUser> users = permissionCheckUtility.getReadableUsers(user.getUserID());
Set<Integer> administerableUsers = permissionCheckUtility.getAdministerableUserIDs(this.user.getUserID());
Set<Integer> administerableConnections = permissionCheckUtility.getAdministerableConnectionIDs(this.user.getUserID());
updateUserPermissions(userPermissions, user, administerableUsers);
updateConnectionPermissions(connectionPermissions, user, administerableConnections);
private void updateUserPermissions(Iterable<UserPermission> permissions, MySQLUser user, Set<Integer> administerableUsers) throws GuacamoleException {
List<UserPermissionKey> permissionsToDelete = userPermissionDAO.selectByExample(userPermissionExample);
for(UserPermissionKey permissionToDelete : permissionsToDelete) {
if(!administerableUsers.contains(permissionToDelete.getAffected_user_id()))
}
if(!administerableUsers.contains(dbAffectedUser.getUser_id()))
private void updateConnectionPermissions(Iterable<ConnectionPermission> permissions, MySQLUser user, Set<Integer> administerableConnections) throws GuacamoleException {
List<ConnectionPermissionKey> connectionPermissionsToDelete = connectionPermissionDAO.selectByExample(connectionPermissionExample);
for(ConnectionPermissionKey connectionPermissionToDelete : connectionPermissionsToDelete) {
if(!administerableConnections.contains(connectionPermissionToDelete.getConnection_id()))
}
if(!administerableConnections.contains(dbConnection.getConnection_id()))
import com.google.common.collect.Lists;
public Set<Integer> getAdministerableUserIDs(int userID) {
return getUserIDs(userID, MySQLConstants.USER_ADMINISTER);
}
public Set<Integer> getDeletableUserIDs(int userID) {
return getUserIDs(userID, MySQLConstants.USER_DELETE);
}
public Set<Integer> getUpdateableUserIDs(int userID) {
return getUserIDs(userID, MySQLConstants.USER_UPDATE);
}
public Set<Integer> getReadableUserIDs(int userID) {
return getUserIDs(userID, MySQLConstants.USER_READ);
}
public Set<MySQLUser> getAdministerableUsers(int userID) {
public Set<MySQLUser> getDeletableUsers(int userID) {
public Set<MySQLUser> getUpdateableUsers(int userID) {
public Set<MySQLUser> getReadableUsers(int userID) {
private Set<MySQLUser> getUsers(int userID, String permissionType) {
Set<Integer> affectedUserIDs = getUserIDs(userID, permissionType);
example.createCriteria().andUser_idIn(Lists.newArrayList(affectedUserIDs));
Set<MySQLUser> affectedUsers = new HashSet<MySQLUser>();
private Set<Integer> getUserIDs(int userID, String permissionType) {
Set<Integer> userIDs = new HashSet<Integer>();
public Set<Integer> getAdministerableConnectionIDs(int userID) {
return getConnectionIDs(userID, MySQLConstants.CONNECTION_ADMINISTER);
}
public Set<Integer> getDeletableConnectionIDs(int userID) {
return getConnectionIDs(userID, MySQLConstants.CONNECTION_DELETE);
}
public Set<Integer> getUpdateableConnectionIDs(int userID) {
return getConnectionIDs(userID, MySQLConstants.CONNECTION_UPDATE);
}
public Set<Integer> getReadableConnectionIDs(int userID) {
return getConnectionIDs(userID, MySQLConstants.CONNECTION_READ);
}
public Set<MySQLConnection> getAdministerableConnections(int userID) {
public Set<MySQLConnection> getDeletableConnections(int userID) {
public Set<MySQLConnection> getUpdateableConnections(int userID) {
public Set<MySQLConnection> getReadableConnections(int userID) {
private Set<MySQLConnection> getConnections(int userID, String permissionType) {
Set<Integer> affectedConnectionIDs = getConnectionIDs(userID, permissionType);
example.createCriteria().andConnection_idIn(Lists.newArrayList(affectedConnectionIDs));
Set<MySQLConnection> affectedConnections = new HashSet<MySQLConnection>();
private Set<Integer> getConnectionIDs(int userID, String permissionType) {
Set<Integer> connectionIDs = new HashSet<Integer>();
UserPermissionKey newUserPermission = new UserPermissionKey();
newUserPermission.setUser_id(this.user.getUserID());
newUserPermission.setAffected_user_id(mySQLUser.getUserID());
newUserPermission.setPermission(MySQLConstants.USER_READ);
userPermissionDAO.insert(newUserPermission);
newUserPermission.setPermission(MySQLConstants.USER_UPDATE);
userPermissionDAO.insert(newUserPermission);
newUserPermission.setPermission(MySQLConstants.USER_DELETE);
userPermissionDAO.insert(newUserPermission);
newUserPermission.setPermission(MySQLConstants.USER_ADMINISTER);
userPermissionDAO.insert(newUserPermission);
private void deleteAllPermissions(MySQLUser user) throws GuacamolePermissionException {
Set<Integer> administerableUsers = permissionCheckUtility.getAdministerableUserIDs(this.user.getUserID());
Set<Integer> administerableConnections = permissionCheckUtility.getAdministerableConnectionIDs(this.user.getUserID());
List<UserPermissionKey> permissionsToDelete = userPermissionDAO.selectByExample(userPermissionExample);
for(UserPermissionKey permissionToDelete : permissionsToDelete) {
if(!administerableUsers.contains(permissionToDelete.getAffected_user_id()))
}
List<ConnectionPermissionKey> connectionPermissionsToDelete = connectionPermissionDAO.selectByExample(connectionPermissionExample);
for(ConnectionPermissionKey connectionPermissionToDelete : connectionPermissionsToDelete) {
if(!administerableConnections.contains(connectionPermissionToDelete.getConnection_id()))
}
import java.util.List;
public List<ConnectionRecord> getHistory() throws GuacamoleException;
import java.util.Collections;
import java.util.List;
import net.sourceforge.guacamole.net.auth.ConnectionRecord;
@Override
public List<ConnectionRecord> getHistory() throws GuacamoleException {
return Collections.EMPTY_LIST;
}
import java.util.List;
import net.sourceforge.guacamole.net.auth.ConnectionRecord;
@Override
public List<ConnectionRecord> getHistory() throws GuacamoleException {
throw new UnsupportedOperationException("History unsuppported in DummyConnection.");
}
import net.sourceforge.guacamole.net.auth.ConnectionRecord;
xml.writeStartElement("history");
for (ConnectionRecord record : connection.getHistory()) {
xml.writeStartElement("record");
xml.writeAttribute("start",
Long.toString(record.getStartDate().getTime()));
if (record.getEndDate() != null)
xml.writeAttribute("end",
Long.toString(record.getEndDate().getTime()));
xml.writeCharacters(record.getUser().getUsername());
xml.writeEndElement();
}
xml.writeEndElement();
public List<? extends ConnectionRecord> getHistory() throws GuacamoleException;
import net.sourceforge.guacamole.net.auth.mysql.utility.PermissionCheckUtility;
import net.sourceforge.guacamole.net.auth.mysql.utility.ProviderUtility;
bind(UserDirectory.class);
bind(ProviderUtility.class);
import net.sourceforge.guacamole.net.auth.ConnectionRecord;
import net.sourceforge.guacamole.net.auth.mysql.utility.ProviderUtility;
@Inject
ProviderUtility providerUtility;
private GuacamoleConfiguration configuration;
public void initNew(Connection connection) {
configuration = connection.getConfiguration();
this.connection.setConnection_name(connection.getIdentifier());
this.configuration = connection.getConfiguration();
}
public void initExisting(String connectionName) throws GuacamoleException {
return configuration;
this.configuration = config;
@Override
public List<? extends ConnectionRecord> getHistory() throws GuacamoleException {
return providerUtility.getExistingMySQLConnectionRecords(connection.getConnection_id());
}
if(userList.isEmpty())
@Inject
private UserDirectory userDirectory;
@Inject
private ConnectionDirectory connectionDirectory;
connectionDirectory.init(user);
return connectionDirectory;
import net.sourceforge.guacamole.net.auth.mysql.utility.ProviderUtility;
ProviderUtility providerUtility;
return providerUtility.getExistingMySQLUser(identifier);
MySQLUser mySQLUser = providerUtility.getNewMySQLUser(object);
MySQLUser mySQLUser = providerUtility.getExistingMySQLUser(object);
MySQLUser mySQLUser = providerUtility.getExistingMySQLUser(identifier);
boolean idsAreEqual = ((MySQLConnection)other).getConnectionID() == this.getConnectionID();
if(idsAreEqual && this.getConnectionID() == 0)
return this.getIdentifier().equals(((MySQLConnection)other).getIdentifier());
return idsAreEqual;
}
@Override
public int hashCode() {
int hash = 7;
return hash;
boolean idsAreEqual = ((MySQLUser)other).getUserID() == this.getUserID();
if(idsAreEqual && this.getUserID() == 0)
return this.getUsername().equals(((MySQLUser)other).getUsername());
return idsAreEqual;
}
@Override
public int hashCode() {
int hash = 7;
return hash;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
public void setConfiguration(GuacamoleConfiguration config);
public void setConfiguration(GuacamoleConfiguration config) {
public abstract class SimpleAuthenticationProvider
public class SimpleConnectionDirectory
private String toString(SystemPermission.Type type)
private String toString(ObjectPermission.Type type)
}
import java.io.UnsupportedEncodingException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Map;
import java.util.TreeMap;
import net.sourceforge.guacamole.protocol.GuacamoleConfiguration;
.append(HEX_CHARS[ b & 0x0F      ]);
import java.util.Deque;
private Deque<DocumentHandlerState> stack =
import java.util.Deque;
Deque<String> elements = new LinkedList<String>();
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.Reader;
import java.io.Writer;
import net.sourceforge.guacamole.GuacamoleClientException;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.GuacamoleResourceNotFoundException;
import net.sourceforge.guacamole.GuacamoleSecurityException;
import net.sourceforge.guacamole.GuacamoleServerException;
public static <Type> Type getProperty(GuacamoleProperty<Type> property,
Type defaultValue) throws GuacamoleException {
Type value = getProperty(property);
if (value == null)
return defaultValue;
return value;
}
import com.google.common.collect.Lists;
import net.sourceforge.guacamole.net.auth.mysql.model.ConnectionPermissionExample;
example.createCriteria().andConnection_idEqualTo(mySQLConnection.getConnectionID());
String parameterValue = configuration.getParameter(parameterName);
if(existingConfiguration.containsKey(parameterName)) {
String existingValue = existingConfiguration.get(parameterName);
if(!parameterValue.equals(existingValue)) {
ConnectionParameter parameterToUpdate = new ConnectionParameter();
parameterToUpdate.setConnection_id(mySQLConnection.getConnectionID());
parameterToUpdate.setParameter_name(parameterName);
parameterToUpdate.setParameter_value(parameterValue);
parametersToUpdate.add(parameterToUpdate);
}
} else {
ConnectionParameter parameterToInsert = new ConnectionParameter();
parameterToInsert.setConnection_id(mySQLConnection.getConnectionID());
parameterToInsert.setParameter_name(parameterName);
parameterToInsert.setParameter_value(parameterValue);
parametersToInsert.add(parameterToInsert);
}
}
example.clear();
example.createCriteria().
andConnection_idEqualTo(mySQLConnection.getConnectionID()).
andParameter_nameNotIn(Lists.newArrayList(existingConfiguration.keySet()));
for(ConnectionParameter parameter : parametersToUpdate) {
example.clear();
example.createCriteria().
andConnection_idEqualTo(mySQLConnection.getConnectionID()).
andParameter_nameEqualTo(parameter.getParameter_name());
connectionParameterDAO.updateByExample(parameter, example);
}
for(ConnectionParameter parameter : parametersToInsert) {
example.clear();
example.createCriteria().
andConnection_idEqualTo(mySQLConnection.getConnectionID()).
andParameter_nameEqualTo(parameter.getParameter_name());
connectionParameterDAO.insert(parameter);
permissionCheckUtility.verifyConnectionUpdateAccess(this.user.getUserID(), object.getIdentifier());
MySQLConnection mySQLConnection = providerUtility.getExistingMySQLConnection(object);
connectionDAO.updateByPrimaryKey(mySQLConnection.getConnection());
updateConfigurationValues(mySQLConnection);
permissionCheckUtility.verifyConnectionDeleteAccess(this.user.getUserID(), identifier);
MySQLConnection mySQLConnection = providerUtility.getExistingMySQLConnection(identifier);
ConnectionParameterExample connectionParameterExample = new ConnectionParameterExample();
connectionParameterExample.createCriteria().andConnection_idEqualTo(mySQLConnection.getConnectionID());
connectionParameterDAO.deleteByExample(connectionParameterExample);
ConnectionPermissionExample connectionPermissionExample = new ConnectionPermissionExample();
connectionPermissionExample.createCriteria().andConnection_idEqualTo(mySQLConnection.getConnectionID());
connectionPermissionDAO.deleteByExample(connectionPermissionExample);
connectionDAO.deleteByPrimaryKey(mySQLConnection.getConnectionID());
import net.sourceforge.guacamole.net.auth.mysql.utility.ConfigurationTranslationUtility;
private ActiveConnectionSet activeConnectionSet = new ActiveConnectionSet();
bind(ConfigurationTranslationUtility.class);
bind(ActiveConnectionSet.class).toInstance(activeConnectionSet);
import net.sourceforge.guacamole.net.InetGuacamoleSocket;
import net.sourceforge.guacamole.net.auth.mysql.dao.ConnectionParameterMapper;
import net.sourceforge.guacamole.net.auth.mysql.model.ConnectionParameter;
import net.sourceforge.guacamole.net.auth.mysql.model.ConnectionParameterExample;
import net.sourceforge.guacamole.net.auth.mysql.properties.MySQLGuacamoleProperties;
import net.sourceforge.guacamole.net.auth.mysql.utility.ConfigurationTranslationUtility;
import net.sourceforge.guacamole.properties.GuacamoleProperties;
import net.sourceforge.guacamole.protocol.ConfiguredGuacamoleSocket;
@Inject
ConnectionParameterMapper connectionParameterDAO;
@Inject
ActiveConnectionSet activeConnectionSet;
@Inject
ConfigurationTranslationUtility configurationTranslationUtility;
configuration = new GuacamoleConfiguration();
private void initConfiguration() {
ConnectionParameterExample connectionParameterExample = new ConnectionParameterExample();
connectionParameterExample.createCriteria().andConnection_idEqualTo(connection.getConnection_id());
List<ConnectionParameter> connectionParameters = connectionParameterDAO.selectByExample(connectionParameterExample);
configuration = configurationTranslationUtility.getConfiguration(connection.getProtocol(), connectionParameters);
}
initConfiguration();
initConfiguration();
if(GuacamoleProperties.getProperty(MySQLGuacamoleProperties.MYSQL_DISALLOW_SIMULTANEOUS_CONNECTIONS, false)
&& activeConnectionSet.contains(getConnectionID()))
throw new GuacamoleException("Cannot connect. This connection is in use.");
String host = GuacamoleProperties.getProperty(GuacamoleProperties.GUACD_HOSTNAME);
int port = GuacamoleProperties.getProperty(GuacamoleProperties.GUACD_PORT);
InetGuacamoleSocket inetSocket = new InetGuacamoleSocket(host, port);
ConfiguredGuacamoleSocket configuredSocket = new ConfiguredGuacamoleSocket(inetSocket, configuration);
MySQLGuacamoleSocket mySQLSocket = providerUtility.getMySQLGuacamoleSocket(configuredSocket, getConnectionID());
activeConnectionSet.add(getConnectionID());
return mySQLSocket;
userPermissionExample.createCriteria();
userPermissionExample.createCriteria().andAffected_user_idEqualTo(user.getUserID());
userPermissionDAO.deleteByExample(userPermissionExample);
import net.sourceforge.guacamole.properties.BooleanGuacamoleProperty;
public static final BooleanGuacamoleProperty MYSQL_DISALLOW_SIMULTANEOUS_CONNECTIONS = new BooleanGuacamoleProperty() {
@Override
public String getName() { return "mysql-disallow-simultaneous-connections"; }
};
import net.sourceforge.guacamole.net.auth.mysql.MySQLGuacamoleSocket;
import net.sourceforge.guacamole.protocol.ConfiguredGuacamoleSocket;
@Inject
Provider<MySQLGuacamoleSocket> mySQLGuacamoleSocketProvider;
example.setOrderByClause("start_date DESC");
public MySQLGuacamoleSocket getMySQLGuacamoleSocket(ConfiguredGuacamoleSocket socket, int connectionID) {
MySQLGuacamoleSocket mySQLGuacamoleSocket = mySQLGuacamoleSocketProvider.get();
mySQLGuacamoleSocket.init(socket, connectionID);
return mySQLGuacamoleSocket;
}
package net.sourceforge.guacamole.net.auth.mysql;
import net.sourceforge.guacamole.net.auth.mysql.model.Connection;
import net.sourceforge.guacamole.net.auth.mysql.model.User;
public class UserDirectory implements Directory<String, net.sourceforge.guacamole.net.auth.User> {
public net.sourceforge.guacamole.net.auth.User get(String identifier)
throws GuacamoleException {
Set<String> userNameSet = new HashSet<String>();
for (MySQLUser mySQLUser : users)
public void add(net.sourceforge.guacamole.net.auth.User object)
throws GuacamoleException {
for (Permission permission : user.getPermissions()) {
if (permission instanceof UserPermission)
userPermissions.add((UserPermission) permission);
else if (permission instanceof ConnectionPermission)
connectionPermissions.add((ConnectionPermission) permission);
else if (permission instanceof SystemPermission)
systemPermissions.add((SystemPermission) permission);
updateUserPermissions(userPermissions, user);
updateConnectionPermissions(connectionPermissions, user);
private void updateUserPermissions(Iterable<UserPermission> permissions,
MySQLUser user)
throws GuacamoleException {
Set<Integer> administerableUsers =
permissionCheckUtility.getAdministerableUserIDs(this.user.getUserID());
for (UserPermission permission : permissions)
List<User> dbUsers = userDAO.selectByExample(userExample);
Map<String, User> dbUserMap = new HashMap<String, User>();
for (User dbUser : dbUsers) {
List<UserPermissionKey> existingPermissions =
userPermissionDAO.selectByExample(userPermissionExample);
Set<Integer> existingUserIDs = new HashSet<Integer>();
for (UserPermissionKey userPermission : existingPermissions)
existingUserIDs.add(userPermission.getAffected_user_id());
List<UserPermissionKey> permissionsToDelete =
userPermissionDAO.selectByExample(userPermissionExample);
for (UserPermissionKey permissionToDelete : permissionsToDelete) {
if (!administerableUsers.contains(permissionToDelete.getAffected_user_id()))
throw new GuacamolePermissionException(
"' does not have permission to administrate user "
permissionToDelete.getAffected_user_id());
for (UserPermission permission : permissions) {
User dbAffectedUser = dbUserMap.get(permission.getObjectIdentifier());
if (dbAffectedUser == null)
throw new GuacamoleException(
"' not found.");
if (existingUserIDs.contains(dbAffectedUser.getUser_id()))
if (!administerableUsers.contains(dbAffectedUser.getUser_id()))
throw new GuacamolePermissionException(
"' does not have permission to administrate user "
dbAffectedUser.getUser_id());
private void updateConnectionPermissions(
Iterable<ConnectionPermission> permissions, MySQLUser user)
throws GuacamoleException {
Set<Integer> administerableConnections =
permissionCheckUtility.getAdministerableConnectionIDs(this.user.getUserID());
List<String> connectionNames = new ArrayList<String>();
for (ConnectionPermission permission : permissions)
connectionNames.add(permission.getObjectIdentifier());
connectionExample.createCriteria().andConnection_nameIn(connectionNames);
List<Connection> dbConnections = connectionDAO.selectByExample(connectionExample);
Map<String, Connection> dbConnectionMap = new HashMap<String, Connection>();
for (Connection dbConnection : dbConnections) {
List<ConnectionPermissionKey> existingPermissions =
connectionPermissionDAO.selectByExample(connectionPermissionExample);
for (ConnectionPermissionKey connectionPermission : existingPermissions)
List<ConnectionPermissionKey> connectionPermissionsToDelete =
connectionPermissionDAO.selectByExample(connectionPermissionExample);
for (ConnectionPermissionKey connectionPermissionToDelete : connectionPermissionsToDelete) {
if (!administerableConnections.contains(connectionPermissionToDelete.getConnection_id()))
throw new GuacamolePermissionException(
"' does not have permission to administrate connection "
connectionPermissionToDelete.getConnection_id());
for (ConnectionPermission permission : permissions) {
Connection dbConnection = dbConnectionMap.get(permission.getObjectIdentifier());
if (dbConnection == null)
throw new GuacamoleException(
"' not found.");
if (existingConnectionIDs.contains(dbConnection.getConnection_id()))
if (!administerableConnections.contains(dbConnection.getConnection_id()))
throw new GuacamolePermissionException(
"' does not have permission to administrate connection "
dbConnection.getConnection_id());
private void updateSystemPermissions(Iterable<SystemPermission> permissions,
MySQLUser user) {
for (SystemPermission permission : permissions) {
if (permission instanceof ConnectionDirectoryPermission)
else if (permission instanceof UserDirectoryPermission)
for (SystemPermissionKey existingPermission : existingPermissions) {
for (String systemPermissionType : systemPermissionTypes) {
if (existingPermissionTypes.contains(systemPermissionType))
public void update(net.sourceforge.guacamole.net.auth.User object)
throws GuacamoleException {
permissionCheckUtility.verifyUserUpdateAccess(this.user.getUserID(),
object.getUsername());
permissionCheckUtility.verifyUserDeleteAccess(this.user.getUserID(),
identifier);
private void deleteAllPermissions(MySQLUser user) {
import net.sourceforge.guacamole.GuacamoleSecurityException;
throw new GuacamoleSecurityException(
throw new GuacamoleSecurityException(
throw new GuacamoleSecurityException(
throw new GuacamoleSecurityException(
import net.sourceforge.guacamole.GuacamoleSecurityException;
public void verifyUserReadAccess(int userID, int affectedUserID) throws GuacamoleSecurityException {
public void verifyUserUpdateAccess(int userID, int affectedUserID) throws GuacamoleSecurityException {
public void verifyUserDeleteAccess(int userID, int affectedUserID) throws GuacamoleSecurityException {
public void verifyUserAdministerAccess(int userID, int affectedUserID) throws GuacamoleSecurityException {
public void verifyUserReadAccess(int userID, String affectedUsername) throws GuacamoleSecurityException {
public void verifyUserUpdateAccess(int userID, String affectedUsername) throws GuacamoleSecurityException {
public void verifyUserDeleteAccess(int userID, String affectedUsername) throws GuacamoleSecurityException {
public void verifyUserAdministerAccess(int userID, String affectedUsername) throws GuacamoleSecurityException {
public void verifyConnectionReadAccess(int userID, int affectedConnectionID) throws GuacamoleSecurityException {
public void verifyConnectionUpdateAccess(int userID, int affectedConnectionID) throws GuacamoleSecurityException {
public void verifyConnectionDeleteAccess(int userID, int affectedConnectionID) throws GuacamoleSecurityException {
public void verifyConnectionAdministerAccess(int userID, int affectedConnectionID) throws GuacamoleSecurityException {
public void verifyConnectionReadAccess(int userID, String affectedConnectionName) throws GuacamoleSecurityException {
public void verifyConnectionUpdateAccess(int userID, String affectedConnectionName) throws GuacamoleSecurityException {
public void verifyConnectionDeleteAccess(int userID, String affectedConnectionName) throws GuacamoleSecurityException {
public void verifyConnectionAdministerAccess(int userID, String affectedConnectionName) throws GuacamoleSecurityException {
public void verifyCreateUserPermission(int userID) throws GuacamoleSecurityException {
public void verifyCreateConnectionPermission(int userID) throws GuacamoleSecurityException {
package net.sourceforge.guacamole.net.auth.mysql.utility;
public boolean checkCredentials(Credentials credentials,
byte[] dbPasswordHash, String dbUsername, byte[] dbSalt) {
if (!dbUsername.equals(credentials.getUsername()))
return false;
try {
MessageDigest md = MessageDigest.getInstance("SHA-256");
}
catch (UnsupportedEncodingException ex) {
catch (NoSuchAlgorithmException ex) {
throw new RuntimeException(ex);
}
package net.sourceforge.guacamole.net.auth.mysql.utility;
private SecureRandom secureRandom = new SecureRandom();
package net.sourceforge.guacamole.net.auth.mysql;
public class ActiveConnectionSet extends HashSet<Integer> {}
package net.sourceforge.guacamole.net.auth.mysql;
},
new MyBatisModule() {
package net.sourceforge.guacamole.net.auth.mysql;
package net.sourceforge.guacamole.net.auth.mysql.utility;
public GuacamoleConfiguration getConfiguration(String protocol,
Iterable<ConnectionParameter> parameters) {
for(ConnectionParameter parameter : parameters)
public List<ConnectionParameter> getConnectionParameters(int connectionID,
GuacamoleConfiguration configuration) {
List<ConnectionParameter> connectionParameters =
new ArrayList<ConnectionParameter>();
for (String parameterName : configuration.getParameterNames()) {
ConnectionParameter connectionParameter = new ConnectionParameter();
package net.sourceforge.guacamole.net.auth.mysql;
private GuacamoleSocket socket;
public void init(GuacamoleSocket socket, int connectionID) {
package net.sourceforge.guacamole.net.auth.mysql;
import net.sourceforge.guacamole.net.auth.mysql.dao.ConnectionHistoryMapper;
import org.apache.ibatis.transaction.jdbc.JdbcTransactionFactory;
bindTransactionFactoryType(JdbcTransactionFactory.class);
addMapperClass(ConnectionHistoryMapper.class);
if (credentials.getUsername() == null)
return null;
void init(Credentials credentials) throws GuacamoleException {
if (users.size() > 1)
throw new GuacamoleException(
"Multiple users found with the same username: "
credentials.getUsername());
if (users.isEmpty())
user = users.get(0);
if (!passwordUtility.checkCredentials(credentials,
user.getPassword_hash(), user.getUsername(), user.getPassword_salt()))
throw new GuacamoleException("No user found with the supplied credentials");
import java.util.Collections;
if (!affectedConnectionIDs.isEmpty()) {
ConnectionExample example = new ConnectionExample();
example.createCriteria().andConnection_idIn(Lists.newArrayList(affectedConnectionIDs));
List<Connection> connectionDBOjects = connectionDAO.selectByExample(example);
Set<MySQLConnection> affectedConnections = new HashSet<MySQLConnection>();
for(Connection affectedConnection : connectionDBOjects) {
MySQLConnection mySQLConnection = mySQLConnectionProvider.get();
mySQLConnection.init(affectedConnection);
affectedConnections.add(mySQLConnection);
}
return affectedConnections;
return Collections.EMPTY_SET;
List<UserPermissionKey> userPermissions =
userPermissionDAO.selectByExample(userPermissionExample);
if (!userPermissions.isEmpty()) {
List<Integer> affectedUserIDs = new ArrayList<Integer>();
for(UserPermissionKey userPermission : userPermissions)
affectedUserIDs.add(userPermission.getAffected_user_id());
UserExample userExample = new UserExample();
userExample.createCriteria().andUser_idIn(affectedUserIDs);
List<User> users = userDAO.selectByExample(userExample);
Map<Integer, User> userMap = new HashMap<Integer, User>();
for(User user : users)
userMap.put(user.getUser_id(), user);
for(UserPermissionKey userPermission : userPermissions) {
User affectedUser = userMap.get(userPermission.getAffected_user_id());
UserPermission newPermission = new UserPermission(
UserPermission.Type.valueOf(userPermission.getPermission()),
affectedUser.getUsername()
);
allPermissions.add(newPermission);
}
List<ConnectionPermissionKey> connectionPermissions =
connectionPermissionDAO.selectByExample(connectionPermissionExample);
if (!connectionPermissions.isEmpty()) {
List<Integer> affectedConnectionIDs = new ArrayList<Integer>();
for(ConnectionPermissionKey connectionPermission : connectionPermissions)
affectedConnectionIDs.add(connectionPermission.getConnection_id());
ConnectionExample connectionExample = new ConnectionExample();
connectionExample.createCriteria().andConnection_idIn(affectedConnectionIDs);
List<Connection> connections = connectionDAO.selectByExample(connectionExample);
Map<Integer, Connection> connectionMap = new HashMap<Integer, Connection>();
for(Connection connection : connections)
connectionMap.put(connection.getConnection_id(), connection);
for(ConnectionPermissionKey connectionPermission : connectionPermissions) {
Connection affectedConnection = connectionMap.get(connectionPermission.getConnection_id());
ConnectionPermission newPermission = new ConnectionPermission(
ConnectionPermission.Type.valueOf(connectionPermission.getPermission()),
affectedConnection.getConnection_name()
);
allPermissions.add(newPermission);
}
List<SystemPermissionKey> systemPermissions =
systemPermissionDAO.selectByExample(systemPermissionExample);
public static final String USER_READ = "READ";
public static final String USER_UPDATE = "UPDATE";
public static final String USER_DELETE = "DELETE";
public static final String USER_ADMINISTER = "ADMINISTER";
public static final String CONNECTION_READ = "READ";
public static final String CONNECTION_UPDATE = "UPDATE";
public static final String CONNECTION_DELETE = "DELETE";
public static final String CONNECTION_ADMINISTER = "ADMINISTER";
public static final String SYSTEM_USER_CREATE = "CREATE_USER";
public static final String SYSTEM_CONNECTION_CREATE = "CREATE_CONNECTION";
if (permission instanceof ConnectionDirectoryPermission) {
switch (permission.getType()) {
case CREATE:
systemPermissionTypes.add(MySQLConstants.SYSTEM_CONNECTION_CREATE);
break;
default:
}
}
else if (permission instanceof UserDirectoryPermission) {
switch (permission.getType()) {
case CREATE:
systemPermissionTypes.add(MySQLConstants.SYSTEM_USER_CREATE);
break;
default:
}
}
for (SystemPermissionKey existingPermission : existingPermissions)
if(systemPermission.getPermission().equals(MySQLConstants.SYSTEM_USER_CREATE))
allPermissions.add(new UserDirectoryPermission(UserDirectoryPermission.Type.CREATE));
else if(systemPermission.getPermission().equals(MySQLConstants.SYSTEM_CONNECTION_CREATE))
allPermissions.add(new ConnectionDirectoryPermission(ConnectionDirectoryPermission.Type.CREATE));
import net.sourceforge.guacamole.net.auth.mysql.service.PermissionCheckService;
import net.sourceforge.guacamole.net.auth.mysql.service.ProviderService;
PermissionCheckService permissionCheckUtility;
ProviderService providerUtility;
import net.sourceforge.guacamole.net.auth.mysql.service.ConfigurationTranslationService;
import net.sourceforge.guacamole.net.auth.mysql.service.PasswordEncryptionService;
import net.sourceforge.guacamole.net.auth.mysql.service.PermissionCheckService;
import net.sourceforge.guacamole.net.auth.mysql.service.ProviderService;
import net.sourceforge.guacamole.net.auth.mysql.service.SaltService;
import net.sourceforge.guacamole.net.auth.mysql.service.SecureRandomSaltService;
import net.sourceforge.guacamole.net.auth.mysql.service.Sha256PasswordEncryptionService;
bind(SaltService.class).to(SecureRandomSaltService.class);
bind(PasswordEncryptionService.class).to(Sha256PasswordEncryptionService.class);
bind(PermissionCheckService.class);
bind(ProviderService.class);
bind(ConfigurationTranslationService.class);
import net.sourceforge.guacamole.net.auth.mysql.service.ConfigurationTranslationService;
import net.sourceforge.guacamole.net.auth.mysql.service.ProviderService;
ProviderService providerUtility;
ConfigurationTranslationService configurationTranslationUtility;
import net.sourceforge.guacamole.net.auth.mysql.service.ProviderService;
ProviderService providerUtility;
import net.sourceforge.guacamole.net.auth.mysql.service.PasswordEncryptionService;
import net.sourceforge.guacamole.net.auth.mysql.service.PermissionCheckService;
import net.sourceforge.guacamole.net.auth.mysql.service.SaltService;
PasswordEncryptionService passwordUtility;
SaltService saltUtility;
PermissionCheckService permissionCheckUtility;
import net.sourceforge.guacamole.net.auth.mysql.service.PermissionCheckService;
import net.sourceforge.guacamole.net.auth.mysql.service.ProviderService;
PermissionCheckService permissionCheckUtility;
ProviderService providerUtility;
package net.sourceforge.guacamole.net.auth.mysql.service;
public class ConfigurationTranslationService {
package net.sourceforge.guacamole.net.auth.mysql.service;
public interface PasswordEncryptionService {
package net.sourceforge.guacamole.net.auth.mysql.service;
public class PermissionCheckService {
package net.sourceforge.guacamole.net.auth.mysql.service;
public class ProviderService {
package net.sourceforge.guacamole.net.auth.mysql.service;
public interface SaltService {
package net.sourceforge.guacamole.net.auth.mysql.service;
public class SecureRandomSaltService implements SaltService {
package net.sourceforge.guacamole.net.auth.mysql.service;
public class Sha256PasswordEncryptionService implements PasswordEncryptionService {
package net.sourceforge.guacamole.net.auth.mysql.service;
User user = directory.get(username);
if (add_user_permission != null) {
for (String str : add_user_permission)
if (add_connection_permission != null) {
for (String str : add_connection_permission)
String[] remove_user_permission = request.getParameterValues("-user");
if (remove_user_permission != null) {
for (String str : remove_user_permission)
user.removePermission(parseUserPermission(str));
}
String[] remove_connection_permission = request.getParameterValues("-connection");
if (remove_connection_permission != null) {
for (String str : remove_connection_permission)
user.removePermission(parseConnectionPermission(str));
}
import java.util.Collections;
Set<Permission> newPermissions;
Set<Permission> removedPermissions;
Set<Permission> getCurrentPermissions() {
return permissions;
}
Set<Permission> getNewPermissions() {
return newPermissions;
}
Set<Permission> getRemovedPermissions() {
return removedPermissions;
}
void resetPermissions() {
newPermissions.clear();
removedPermissions.clear();
}
return Collections.unmodifiableSet(permissions);
newPermissions.add(permission);
removedPermissions.remove(permission);
import java.util.Collection;
List<UserPermission> newUserPermissions = new ArrayList<UserPermission>();
List<ConnectionPermission> newConnectionPermissions = new ArrayList<ConnectionPermission>();
List<SystemPermission> newSystemPermissions = new ArrayList<SystemPermission>();
for (Permission permission : user.getNewPermissions()) {
newUserPermissions.add((UserPermission) permission);
newConnectionPermissions.add((ConnectionPermission) permission);
newSystemPermissions.add((SystemPermission) permission);
List<UserPermission> removedUserPermissions = new ArrayList<UserPermission>();
List<ConnectionPermission> removedConnectionPermissions = new ArrayList<ConnectionPermission>();
List<SystemPermission> removedSystemPermissions = new ArrayList<SystemPermission>();
for (Permission permission : user.getRemovedPermissions()) {
if (permission instanceof UserPermission)
removedUserPermissions.add((UserPermission) permission);
else if (permission instanceof ConnectionPermission)
removedConnectionPermissions.add((ConnectionPermission) permission);
else if (permission instanceof SystemPermission)
removedSystemPermissions.add((SystemPermission) permission);
}
createUserPermissions(newUserPermissions, user);
createConnectionPermissions(newConnectionPermissions, user);
createSystemPermissions(newSystemPermissions, user);
deleteUserPermissions(removedUserPermissions, user);
deleteConnectionPermissions(removedConnectionPermissions, user);
deleteSystemPermissions(removedSystemPermissions, user);
user.resetPermissions();
private void createUserPermissions(Collection<UserPermission> permissions,
if(permissions.isEmpty())
return;
Set<Integer> administerableUsers =
permissionCheckUtility.getAdministerableUserIDs(this.user.getUserID());
List<String> usernames = new ArrayList<String>();
for (UserPermission permission : permissions)
usernames.add(permission.getObjectIdentifier());
UserExample userExample = new UserExample();
userExample.createCriteria().andUsernameIn(usernames);
List<User> dbUsers = userDAO.selectByExample(userExample);
Map<String, User> dbUserMap = new HashMap<String, User>();
for (User dbUser : dbUsers) {
dbUserMap.put(dbUser.getUsername(), dbUser);
}
for (UserPermission permission : permissions) {
User dbAffectedUser = dbUserMap.get(permission.getObjectIdentifier());
if (dbAffectedUser == null)
throw new GuacamoleException(
"' not found.");
if (!administerableUsers.contains(dbAffectedUser.getUser_id()))
throw new GuacamoleSecurityException(
"' does not have permission to administrate user "
dbAffectedUser.getUser_id());
UserPermissionKey newPermission = new UserPermissionKey();
newPermission.setAffected_user_id(dbAffectedUser.getUser_id());
newPermission.setPermission(permission.getType().name());
newPermission.setUser_id(user.getUserID());
userPermissionDAO.insert(newPermission);
}
}
private void deleteUserPermissions(Collection<UserPermission> permissions,
MySQLUser user)
throws GuacamoleException {
if(permissions.isEmpty())
return;
}
if(!userIDs.isEmpty()) {
UserPermissionExample userPermissionExample = new UserPermissionExample();
userPermissionExample.createCriteria().andUser_idEqualTo(user.getUserID())
.andAffected_user_idIn(userIDs);
userPermissionDAO.deleteByExample(userPermissionExample);
private void createConnectionPermissions(
Collection<ConnectionPermission> permissions, MySQLUser user)
if(permissions.isEmpty())
return;
private void deleteConnectionPermissions(Collection<ConnectionPermission> permissions,
MySQLUser user)
throws GuacamoleException {
if(permissions.isEmpty())
return;
Set<Integer> administerableConnections =
permissionCheckUtility.getAdministerableConnectionIDs(this.user.getUserID());
List<String> identifiers = new ArrayList<String>();
for (ConnectionPermission permission : permissions)
identifiers.add(permission.getObjectIdentifier());
ConnectionExample connectionExample = new ConnectionExample();
connectionExample.createCriteria().andConnection_nameIn(identifiers);
List<Connection> dbConnections = connectionDAO.selectByExample(connectionExample);
List<Integer> connectionIDs = new ArrayList<Integer>();
Map<String, Connection> dbConnectionMap = new HashMap<String, Connection>();
for (Connection dbConnection : dbConnections) {
dbConnectionMap.put(dbConnection.getConnection_name(), dbConnection);
connectionIDs.add(dbConnection.getConnection_id());
}
for (ConnectionPermission permission : permissions) {
Connection dbConnection = dbConnectionMap.get(permission.getObjectIdentifier());
if (dbConnection == null)
throw new GuacamoleException(
"' not found.");
if (!administerableConnections.contains(dbConnection.getConnection_id()))
throw new GuacamoleSecurityException(
"' does not have permission to administrate connection "
dbConnection.getConnection_id());
}
if(!connectionIDs.isEmpty()) {
ConnectionPermissionExample connectionPermissionExample = new ConnectionPermissionExample();
connectionPermissionExample.createCriteria().andUser_idEqualTo(user.getUserID())
.andConnection_idIn(connectionIDs);
connectionPermissionDAO.deleteByExample(connectionPermissionExample);
}
}
private void createSystemPermissions(Collection<SystemPermission> permissions,
if(permissions.isEmpty())
return;
List<String> systemPermissionTypes = new ArrayList<String>();
for (SystemPermission permission : permissions) {
if (permission instanceof ConnectionDirectoryPermission) {
switch (permission.getType()) {
case CREATE:
systemPermissionTypes.add(MySQLConstants.SYSTEM_CONNECTION_CREATE);
break;
default:
}
}
else if (permission instanceof UserDirectoryPermission) {
switch (permission.getType()) {
case CREATE:
systemPermissionTypes.add(MySQLConstants.SYSTEM_USER_CREATE);
break;
default:
}
}
for (String systemPermissionType : systemPermissionTypes) {
SystemPermissionKey newSystemPermission = new SystemPermissionKey();
newSystemPermission.setUser_id(user.getUserID());
newSystemPermission.setPermission(systemPermissionType);
systemPermissionDAO.insert(newSystemPermission);
}
private void deleteSystemPermissions(Collection<SystemPermission> permissions,
MySQLUser user) {
if(permissions.isEmpty())
return;
if(!systemPermissionTypes.isEmpty()) {
SystemPermissionExample systemPermissionExample = new SystemPermissionExample();
systemPermissionExample.createCriteria().andUser_idEqualTo(user.getUserID())
.andPermissionIn(systemPermissionTypes);
systemPermissionDAO.deleteByExample(systemPermissionExample);
private Set<Permission> permissions;
private Set<Permission> newPermissions = new HashSet<Permission>();
private Set<Permission> removedPermissions = new HashSet<Permission>();
public Set<Permission> getCurrentPermissions() {
public Set<Permission> getNewPermissions() {
public Set<Permission> getRemovedPermissions() {
public void resetPermissions() {
removedPermissions.remove(permission);
newPermissions.remove(permission);
removedPermissions.add(permission);
userPermissionExample.clear();
private int user_id;
void init(int user_id) {
this.user_id = user_id;
permissionCheckUtility.verifyConnectionReadAccess(this.user_id, identifier);
Set<MySQLConnection> connections = permissionCheckUtility.getReadableConnections(this.user_id);
permissionCheckUtility.verifyCreateConnectionPermission(this.user_id);
newConnectionPermission.setUser_id(this.user_id);
permissionCheckUtility.verifyConnectionUpdateAccess(this.user_id, object.getIdentifier());
permissionCheckUtility.verifyConnectionDeleteAccess(this.user_id, identifier);
import java.util.List;
import net.sourceforge.guacamole.net.auth.mysql.model.UserExample;
import net.sourceforge.guacamole.net.auth.mysql.model.UserWithBLOBs;
UserMapper userDAO = injector.getInstance(UserMapper.class);
UserExample userExample = new UserExample();
userExample.createCriteria().andUsernameEqualTo(credentials.getUsername());
List<UserWithBLOBs> users = userDAO.selectByExampleWithBLOBs(userExample);
if (users.size() > 1)
throw new GuacamoleException(
"Multiple users found with the same username: "
credentials.getUsername());
if (users.isEmpty())
throw new GuacamoleException("No user found with the supplied credentials");
UserWithBLOBs user = users.get(0);
PasswordEncryptionService passwordService = injector.getInstance(PasswordEncryptionService.class);
if (!passwordService.checkCredentials(credentials,
user.getPassword_hash(), user.getUsername(), user.getPassword_salt()))
return null;
context.init(user.getUser_id());
import net.sourceforge.guacamole.net.auth.AbstractUser;
public class MySQLUser extends AbstractUser {
private Integer userID;
private Set<Permission> permissions = new HashSet<Permission>();
public MySQLUser() {
}
public void init(String name) {
setUsername(name);
}
public void init(User user) throws GuacamoleException {
setUsername(user.getUsername());
setPassword(user.getPassword());
permissions.addAll(user.getPermissions());
}
public void init(UserWithBLOBs user) {
this.userID = user.getUser_id();
setUsername(user.getUsername());
permissions.addAll(
permissionCheckUtility.getAllPermissions(user.getUser_id()));
}
public Integer getUserID() {
return userID;
public void setUserID(Integer userID) {
this.userID = userID;
public UserWithBLOBs toUserWithBLOBs() {
UserWithBLOBs user = new UserWithBLOBs();
user.setUser_id(userID);
user.setUsername(getUsername());
if (getPassword() != null) {
byte[] salt = saltUtility.generateSalt();
user.setPassword_salt(salt);
user.setPassword_hash(
passwordUtility.createPasswordHash(getPassword(), salt));
}
return user;
import net.sourceforge.guacamole.net.auth.mysql.service.ProviderService;
private int user_id;
@Inject
private ProviderService providerService;
void init(int user_id) {
this.user_id = user_id;
userDirectory.init(user_id);
connectionDirectory.init(user_id);
return providerService.getExistingMySQLUser(user_id);
import net.sourceforge.guacamole.net.auth.mysql.model.UserWithBLOBs;
import net.sourceforge.guacamole.net.auth.mysql.service.PasswordEncryptionService;
import net.sourceforge.guacamole.net.auth.mysql.service.SaltService;
private int user_id;
@Inject
PasswordEncryptionService passwordUtility;
@Inject
SaltService saltUtility;
void init(int user_id) {
this.user_id = user_id;
permissionCheckUtility.verifyUserReadAccess(this.user_id, identifier);
Set<MySQLUser> users = permissionCheckUtility.getReadableUsers(this.user_id);
permissionCheckUtility.verifyCreateUserPermission(this.user_id);
UserWithBLOBs user = new UserWithBLOBs();
user.setUsername(object.getUsername());
if (object.getPassword() != null) {
byte[] salt = saltUtility.generateSalt();
user.setPassword_salt(salt);
user.setPassword_hash(
passwordUtility.createPasswordHash(object.getPassword(), salt));
}
userDAO.insert(user);
createPermissions(user.getUser_id(), object.getPermissions());
newUserPermission.setUser_id(this.user_id);
newUserPermission.setAffected_user_id(user.getUser_id());
private void createPermissions(int user_id, Set<Permission> permissions) throws GuacamoleException {
for (Permission permission : permissions) {
createUserPermissions(newUserPermissions, user_id);
createConnectionPermissions(newConnectionPermissions, user_id);
createSystemPermissions(newSystemPermissions, user_id);
}
private void removePermissions(int user_id, Set<Permission> permissions) throws GuacamoleException {
for (Permission permission : permissions) {
deleteUserPermissions(removedUserPermissions, user_id);
deleteConnectionPermissions(removedConnectionPermissions, user_id);
deleteSystemPermissions(removedSystemPermissions, user_id);
int user_id)
permissionCheckUtility.getAdministerableUserIDs(this.user_id);
" does not have permission to administrate user "
newPermission.setUser_id(user_id);
int user_id)
permissionCheckUtility.getAdministerableUserIDs(this.user_id);
" does not have permission to administrate user "
userPermissionExample.createCriteria().andUser_idEqualTo(user_id)
Collection<ConnectionPermission> permissions, int user_id)
permissionCheckUtility.getAdministerableConnectionIDs(this.user_id);
" does not have permission to administrate connection "
newPermission.setConnection_id(user_id);
int user_id)
permissionCheckUtility.getAdministerableConnectionIDs(this.user_id);
" does not have permission to administrate connection "
connectionPermissionExample.createCriteria().andUser_idEqualTo(user_id)
int user_id) {
newSystemPermission.setUser_id(user_id);
}
int user_id) {
systemPermissionExample.createCriteria().andUser_idEqualTo(user_id)
if (!(object instanceof MySQLUser))
throw new GuacamoleException("User not from database.");
permissionCheckUtility.verifyUserUpdateAccess(this.user_id,
MySQLUser mySQLUser = (MySQLUser) object;
userDAO.updateByPrimaryKeySelective(mySQLUser.toUserWithBLOBs());
mySQLUser.resetPermissions();
permissionCheckUtility.verifyUserDeleteAccess(this.user_id,
deleteAllPermissions(mySQLUser.getUserID());
private void deleteAllPermissions(int user_id) {
userPermissionExample.createCriteria().andUser_idEqualTo(user_id);
connectionPermissionExample.createCriteria().andUser_idEqualTo(user_id);
systemPermissionExample.createCriteria().andUser_idEqualTo(user_id);
userPermissionExample.createCriteria().andAffected_user_idEqualTo(user_id);
if (affectedUserIDs.isEmpty())
return Collections.EMPTY_SET;
import java.util.Collections;
mySQLUser.init(user);
UserExample example = new UserExample();
example.createCriteria().andUsernameEqualTo(name);
List<UserWithBLOBs> users = userDAO.selectByExampleWithBLOBs(example);
if(users.isEmpty())
return null;
return getExistingMySQLUser(users.get(0));
newPermission.setUser_id(user_id);
createPermissions(mySQLUser.getUserID(), mySQLUser.getNewPermissions());
removePermissions(mySQLUser.getUserID(), mySQLUser.getRemovedPermissions());
private PermissionCheckService permissionCheckUtility;
private ProviderService providerUtility;
private ConnectionMapper connectionDAO;
private ConnectionPermissionMapper connectionPermissionDAO;
private ConnectionParameterMapper connectionParameterDAO;
public void init(int user_id) {
private ConnectionMapper connectionDAO;
private ConnectionParameterMapper connectionParameterDAO;
private ProviderService providerUtility;
private ActiveConnectionSet activeConnectionSet;
private ConfigurationTranslationService configurationTranslationUtility;
public MySQLConnection() {
private UserMapper userDAO;
private ConnectionMapper connectionDAO;
private ProviderService providerUtility;
private ActiveConnectionSet activeConnectionSet;
private PasswordEncryptionService passwordUtility;
private SaltService saltUtility;
private PermissionCheckService permissionCheckUtility;
public void init(int user_id) {
private UserMapper userDAO;
private ConnectionMapper connectionDAO;
private UserPermissionMapper userPermissionDAO;
private ConnectionPermissionMapper connectionPermissionDAO;
private SystemPermissionMapper systemPermissionDAO;
private PermissionCheckService permissionCheckUtility;
private ProviderService providerUtility;
private PasswordEncryptionService passwordUtility;
private SaltService saltUtility;
public void init(int user_id) {
private UserMapper userDAO;
private ConnectionMapper connectionDAO;
private UserPermissionMapper userPermissionDAO;
private ConnectionPermissionMapper connectionPermissionDAO;
private SystemPermissionMapper systemPermissionDAO;
private Provider<MySQLUser> mySQLUserProvider;
private Provider<MySQLConnection> mySQLConnectionProvider;
createUserPermissions(user_id, newUserPermissions);
createConnectionPermissions(user_id, newConnectionPermissions);
createSystemPermissions(user_id, newSystemPermissions);
private void removePermissions(int user_id, Set<Permission> permissions)
throws GuacamoleException {
deleteUserPermissions(user_id, removedUserPermissions);
deleteConnectionPermissions(user_id, removedConnectionPermissions);
deleteSystemPermissions(user_id, removedSystemPermissions);
private void createUserPermissions(int user_id,
Collection<UserPermission> permissions)
private void deleteUserPermissions(int user_id,
Collection<UserPermission> permissions)
private void createConnectionPermissions(int user_id,
Collection<ConnectionPermission> permissions)
private void deleteConnectionPermissions(int user_id,
Collection<ConnectionPermission> permissions)
private void createSystemPermissions(int user_id,
Collection<SystemPermission> permissions) {
private void deleteSystemPermissions(int user_id,
Collection<SystemPermission> permissions) {
package net.sourceforge.guacamole.net.auth.mysql;
PasswordEncryptionService passwordService =
injector.getInstance(PasswordEncryptionService.class);
if (!passwordService.checkPassword(credentials.getPassword(),
user.getPassword_hash(), user.getPassword_salt()))
package net.sourceforge.guacamole.net.auth.mysql.service;
public boolean checkPassword(String password, byte[] hashedPassword,
byte[] salt);
public boolean checkPassword(String password, byte[] hashedPassword,
byte[] salt) {
byte[] passwordBytes = createPasswordHash(password, salt);
return Arrays.equals(passwordBytes, hashedPassword);
private PermissionCheckService permissionCheckService;
private ProviderService providerService;
permissionCheckService.verifyConnectionReadAccess(this.user_id, identifier);
return providerService.getExistingMySQLConnection(identifier);
Set<MySQLConnection> connections = permissionCheckService.getReadableConnections(this.user_id);
permissionCheckService.verifyCreateConnectionPermission(this.user_id);
MySQLConnection mySQLConnection = providerService.getNewMySQLConnection(object);
permissionCheckService.verifyConnectionUpdateAccess(this.user_id, object.getIdentifier());
MySQLConnection mySQLConnection = providerService.getExistingMySQLConnection(object);
permissionCheckService.verifyConnectionDeleteAccess(this.user_id, identifier);
MySQLConnection mySQLConnection = providerService.getExistingMySQLConnection(identifier);
private ProviderService providerService;
private ConfigurationTranslationService configurationTranslationService;
configuration = configurationTranslationService.getConfiguration(connection.getProtocol(), connectionParameters);
MySQLGuacamoleSocket mySQLSocket = providerService.getMySQLGuacamoleSocket(configuredSocket, getConnectionID());
return providerService.getExistingMySQLConnectionRecords(connection.getConnection_id());
private ProviderService providerService;
return providerService.getExistingMySQLUser(connectionHistory.getUser_id());
return providerService.getExistingMySQLConnection(connectionHistory.getConnection_id());
private PasswordEncryptionService passwordService;
private SaltService saltService;
private PermissionCheckService permissionCheckService;
permissionCheckService.getAllPermissions(user.getUser_id()));
byte[] salt = saltService.generateSalt();
passwordService.createPasswordHash(getPassword(), salt));
private PermissionCheckService permissionCheckService;
private ProviderService providerService;
private PasswordEncryptionService passwordService;
private SaltService saltService;
permissionCheckService.verifyUserReadAccess(this.user_id, identifier);
return providerService.getExistingMySQLUser(identifier);
Set<MySQLUser> users = permissionCheckService.getReadableUsers(this.user_id);
permissionCheckService.verifyCreateUserPermission(this.user_id);
byte[] salt = saltService.generateSalt();
passwordService.createPasswordHash(object.getPassword(), salt));
permissionCheckService.getAdministerableUserIDs(this.user_id);
permissionCheckService.getAdministerableUserIDs(this.user_id);
permissionCheckService.getAdministerableConnectionIDs(this.user_id);
permissionCheckService.getAdministerableConnectionIDs(this.user_id);
permissionCheckService.verifyUserUpdateAccess(this.user_id,
permissionCheckService.verifyUserDeleteAccess(this.user_id,
MySQLUser mySQLUser = providerService.getExistingMySQLUser(identifier);
init(null, name, null, Collections.EMPTY_SET);
init(null, user.getUsername(), user.getPassword(), user.getPermissions());
public void init(Integer userID, String username, String password,
Set<Permission> permissions) {
this.userID = userID;
setUsername(username);
setPassword(password);
permissions.addAll(permissions);
UserWithBLOBs user = new UserWithBLOBs();
user.setUser_id(mySQLUser.getUserID());
user.setUsername(mySQLUser.getUsername());
if (mySQLUser.getPassword() != null) {
byte[] salt = saltService.generateSalt();
user.setPassword_salt(salt);
user.setPassword_hash(
passwordService.createPasswordHash(mySQLUser.getPassword(), salt));
}
userDAO.updateByPrimaryKeySelective(user);
mySQLUser.init(affectedUser.getUsername());
@Inject
private PermissionCheckService permissionCheckService;
mySQLUser.init(
user.getUser_id(),
user.getUsername(),
permissionCheckService.getAllPermissions(user.getUser_id())
);
null,
package net.sourceforge.guacamole.net.auth.mysql;
net.sourceforge.guacamole.net.auth.mysql.model.Connection connection =
new net.sourceforge.guacamole.net.auth.mysql.model.Connection();
connection.setConnection_name(object.getIdentifier());
connection.setProtocol(object.getConfiguration().getProtocol());
connectionDAO.insert(connection);
createConfigurationValues(connection.getConnection_id(),
object.getConfiguration());
newConnectionPermission.setConnection_id(connection.getConnection_id());
newConnectionPermission.setPermission(MySQLConstants.CONNECTION_READ);
newConnectionPermission.setPermission(MySQLConstants.CONNECTION_UPDATE);
newConnectionPermission.setPermission(MySQLConstants.CONNECTION_DELETE);
newConnectionPermission.setPermission(MySQLConstants.CONNECTION_ADMINISTER);
private void createConfigurationValues(int connection_id,
GuacamoleConfiguration config) {
for (String name : config.getParameterNames()) {
ConnectionParameter parameter = new ConnectionParameter();
parameter.setConnection_id(connection_id);
parameter.setParameter_name(name);
parameter.setParameter_value(config.getParameter(name));
MySQLConnection mySQLConnection =
providerService.getExistingMySQLConnection(object);
net.sourceforge.guacamole.net.auth.mysql.model.Connection connection =
new net.sourceforge.guacamole.net.auth.mysql.model.Connection();
connection.setConnection_id(mySQLConnection.getConnectionID());
connection.setConnection_name(object.getIdentifier());
connection.setProtocol(object.getConfiguration().getProtocol());
connectionDAO.updateByPrimaryKey(connection);
ConnectionParameterExample parameterExample = new ConnectionParameterExample();
parameterExample.createCriteria().andConnection_idEqualTo(connection.getConnection_id());
connectionParameterDAO.deleteByExample(parameterExample);
createConfigurationValues(connection.getConnection_id(),
object.getConfiguration());
import java.util.ArrayList;
import java.util.Collections;
import net.sourceforge.guacamole.net.auth.AbstractConnection;
public class MySQLConnection extends AbstractConnection {
private Integer connectionID;
private List<ConnectionRecord> history = new ArrayList<ConnectionRecord>();
public Integer getConnectionID() {
return connectionID;
public void setConnectionID(Integer connectionID) {
this.connectionID = connectionID;
public void init(Connection connection) throws GuacamoleException {
init(null, connection.getIdentifier(), connection.getConfiguration(), connection.getHistory());
public void init(Integer connectionID, String identifier,
GuacamoleConfiguration config,
List<? extends ConnectionRecord> history) {
this.connectionID = connectionID;
setIdentifier(identifier);
setConfiguration(config);
this.history.addAll(history);
GuacamoleSocket socket = providerService.getMySQLGuacamoleSocket(
new ConfiguredGuacamoleSocket(
new InetGuacamoleSocket(host, port),
getConfiguration()
),
getConnectionID()
);
return socket;
return Collections.unmodifiableList(history);
this.permissions.addAll(permissions);
import net.sourceforge.guacamole.protocol.GuacamoleConfiguration;
mySQLConnection.init(
affectedConnection.getConnection_id(),
affectedConnection.getConnection_name(),
new GuacamoleConfiguration(),
Collections.EMPTY_LIST
);
import java.util.Collections;
import net.sourceforge.guacamole.net.auth.mysql.dao.ConnectionParameterMapper;
import net.sourceforge.guacamole.net.auth.mysql.model.ConnectionParameter;
import net.sourceforge.guacamole.net.auth.mysql.model.ConnectionParameterExample;
import net.sourceforge.guacamole.protocol.GuacamoleConfiguration;
private UserMapper userDAO;
private ConnectionMapper connectionDAO;
private ConnectionParameterMapper connectionParameterDAO;
private ConnectionHistoryMapper connectionHistoryDAO;
private Provider<MySQLUser> mySQLUserProvider;
private Provider<MySQLConnection> mySQLConnectionProvider;
@Inject
private Provider<MySQLConnectionRecord> mySQLConnectionRecordProvider;
@Inject
private Provider<MySQLGuacamoleSocket> mySQLGuacamoleSocketProvider;
UserWithBLOBs user = userDAO.selectByPrimaryKey(id);
if(user == null)
return getExistingMySQLUser(user);
ConnectionExample example = new ConnectionExample();
example.createCriteria().andConnection_nameEqualTo(name);
List<net.sourceforge.guacamole.net.auth.mysql.model.Connection> connections =
connectionDAO.selectByExample(example);
if(connections.isEmpty())
return null;
return getExistingMySQLConnection(connections.get(0));
GuacamoleConfiguration config = new GuacamoleConfiguration();
ConnectionParameterExample connectionParameterExample = new ConnectionParameterExample();
connectionParameterExample.createCriteria().andConnection_idEqualTo(connection.getConnection_id());
List<ConnectionParameter> connectionParameters =
connectionParameterDAO.selectByExample(connectionParameterExample);
config.setProtocol(connection.getProtocol());
for (ConnectionParameter parameter : connectionParameters)
config.setParameter(parameter.getParameter_name(),
parameter.getParameter_value());
mySQLConnection.init(
connection.getConnection_id(),
connection.getConnection_name(),
config,
);
net.sourceforge.guacamole.net.auth.mysql.model.Connection connection =
connectionDAO.selectByPrimaryKey(id);
if(connection == null)
return getExistingMySQLConnection(connection);
@Override
public int hashCode() {
if (identifier == null) return 0;
return identifier.hashCode();
}
@Override
public boolean equals(Object obj) {
if (obj == null) return false;
if (!(obj instanceof AbstractConnection)) return false;
String objIdentifier = ((AbstractConnection) obj).identifier;
if (objIdentifier == null) return identifier == null;
return objIdentifier.equals(identifier);
}
Connection connection = directory.get(identifier);
if (!(object instanceof MySQLConnection))
throw new GuacamoleException("Connection not from database.");
MySQLConnection mySQLConnection = (MySQLConnection) object;
public class SystemPermission implements Permission<SystemPermission.Type> {
CREATE_USER,
CREATE_CONNECTION,
ADMINISTER
private Type type;
public SystemPermission(Type type) {
this.type = type;
}
@Override
public Type getType() {
return type;
}
@Override
public int hashCode() {
return type.hashCode();
}
@Override
public boolean equals(Object obj) {
if (obj == null) return false;
if (getClass() != obj.getClass()) return false;
final SystemPermission other = (SystemPermission) obj;
if (type != other.type)
return false;
return true;
}
switch (permission.getType()) {
case CREATE_CONNECTION:
systemPermissionTypes.add(MySQLConstants.SYSTEM_CONNECTION_CREATE);
break;
case CREATE_USER:
systemPermissionTypes.add(MySQLConstants.SYSTEM_USER_CREATE);
break;
default:
if (permissions.isEmpty())
switch (permission.getType()) {
case CREATE_CONNECTION:
systemPermissionTypes.add(MySQLConstants.SYSTEM_CONNECTION_CREATE);
break;
case CREATE_USER:
systemPermissionTypes.add(MySQLConstants.SYSTEM_USER_CREATE);
break;
default:
SystemPermissionExample systemPermissionExample = new SystemPermissionExample();
systemPermissionExample.createCriteria().andUser_idEqualTo(user_id)
.andPermissionIn(systemPermissionTypes);
systemPermissionDAO.deleteByExample(systemPermissionExample);
import net.sourceforge.guacamole.net.auth.permission.SystemPermission;
allPermissions.add(new SystemPermission(SystemPermission.Type.CREATE_USER));
allPermissions.add(new SystemPermission(SystemPermission.Type.CREATE_CONNECTION));
case CREATE_USER:       return "create-user";
case CREATE_CONNECTION: return "create-connection";
case ADMINISTER:        return "admin";
if (permission instanceof SystemPermission) {
SystemPermission sp = (SystemPermission) permission;
xml.writeEmptyElement("system");
xml.writeAttribute("type", toString(sp.getType()));
private static final String CREATE_USER_PERMISSION = "create-user";
private static final String CREATE_CONNECTION_PERMISSION = "create-connection";
private static final String ADMIN_PERMISSION = "admin";
private Permission parseSystemPermission(String str)
throws GuacamoleException {
if (str.startsWith(CREATE_USER_PERMISSION))
return new SystemPermission(SystemPermission.Type.CREATE_USER);
if (str.startsWith(CREATE_CONNECTION_PERMISSION))
return new SystemPermission(SystemPermission.Type.CREATE_CONNECTION);
if (str.startsWith(ADMIN_PERMISSION))
return new SystemPermission(SystemPermission.Type.ADMINISTER);
throw new GuacamoleException("Invalid permission string.");
}
if (add_sys_permission != null) {
for (String str : add_sys_permission)
user.addPermission(parseSystemPermission(str));
}
String[] remove_sys_permission = request.getParameterValues("-sys");
if (remove_sys_permission != null) {
for (String str : remove_sys_permission)
user.removePermission(parseSystemPermission(str));
}
import net.sourceforge.guacamole.net.auth.mysql.service.UserService;
UserService userService = injector.getInstance(UserService.class);
MySQLUser authenticatedUser = userService.retrieveUser(credentials);
if (authenticatedUser != null) {
MySQLUserContext context = injector.getInstance(MySQLUserContext.class);
context.init(authenticatedUser.getUserID());
return context;
}
return null;
bind(UserService.class);
import net.sourceforge.guacamole.net.auth.mysql.service.UserService;
private UserService userService;
return userService.retrieveUser(connectionHistory.getUser_id());
import net.sourceforge.guacamole.net.auth.mysql.service.UserService;
private UserService userService;
return userService.retrieveUser(user_id);
import net.sourceforge.guacamole.net.auth.mysql.service.UserService;
private UserService userService;
return userService.retrieveUser(identifier);
MySQLUser user = userService.createUser(object.getUsername(),
object.getPassword());
createPermissions(user.getUserID(), object.getPermissions());
newUserPermission.setAffected_user_id(user.getUserID());
List<MySQLUser> users = userService.retrieveUsersByUsername(usernames);
Map<String, MySQLUser> userMap = new HashMap<String, MySQLUser>();
for (MySQLUser user : users)
userMap.put(user.getUsername(), user);
MySQLUser affectedUser =
userMap.get(permission.getObjectIdentifier());
if (affectedUser == null)
if (!administerableUsers.contains(affectedUser.getUserID()))
affectedUser.getUsername());
newPermission.setAffected_user_id(affectedUser.getUserID());
List<MySQLUser> users = userService.retrieveUsersByUsername(usernames);
Map<String, MySQLUser> userMap = new HashMap<String, MySQLUser>();
for (MySQLUser user : users) {
userMap.put(user.getUsername(), user);
userIDs.add(user.getUserID());
MySQLUser affectedUser = userMap.get(permission.getObjectIdentifier());
if (affectedUser == null)
if (!administerableUsers.contains(affectedUser.getUserID()))
affectedUser.getUsername());
MySQLUser mySQLUser = (MySQLUser) object;
userService.updateUser(mySQLUser);
userService.deleteUser(identifier);
private UserService userService;
MySQLUser affectedUser = userService.retrieveUser(affectedUsername);
return checkUserAccess(userID, affectedUser.getUserID(), permissionType);
return new HashSet<MySQLUser>(userService.retrieveUsersByID(
Lists.newArrayList(affectedUserIDs)));
List<MySQLUser> users = userService.retrieveUsersByID(affectedUserIDs);
Map<Integer, MySQLUser> userMap = new HashMap<Integer, MySQLUser>();
for (MySQLUser user : users)
userMap.put(user.getUserID(), user);
MySQLUser affectedUser = userMap.get(userPermission.getAffected_user_id());
public static final String SYSTEM_ADMINISTER = "ADMINISTER";
else if(systemPermission.getPermission().equals(MySQLConstants.SYSTEM_ADMINISTER))
allPermissions.add(new SystemPermission(SystemPermission.Type.ADMINISTER));
public MySQLUser retrieveUser(int id) {
import net.sourceforge.guacamole.net.auth.mysql.service.ConnectionService;
private ConnectionService connectionService;
return connectionService.retrieveConnection(identifier);
MySQLConnection mySQLConnection =
connectionService.retrieveConnection(identifier);
import net.sourceforge.guacamole.net.auth.mysql.service.ConnectionService;
bind(ConnectionService.class);
package net.sourceforge.guacamole.net.auth.mysql;
import net.sourceforge.guacamole.net.auth.mysql.service.ConnectionService;
private ConnectionService connectionService;
return connectionService.connect(this, info);
import net.sourceforge.guacamole.net.auth.mysql.service.ConnectionService;
private ConnectionService connectionService;
return connectionService.retrieveConnection(connectionHistory.getConnection_id());
public class SHA256PasswordEncryptionService implements PasswordEncryptionService {
MySQLConnection connection = connectionService.createConnection(
object.getIdentifier(), object.getConfiguration().getProtocol());
createConfigurationValues(connection.getConnectionID(),
newConnectionPermission.setConnection_id(connection.getConnectionID());
connectionService.updateConnection(mySQLConnection);
parameterExample.createCriteria().andConnection_idEqualTo(mySQLConnection.getConnectionID());
createConfigurationValues(mySQLConnection.getConnectionID(),
connectionService.deleteConnection(mySQLConnection.getConnectionID());
import net.sourceforge.guacamole.net.auth.mysql.service.SHA256PasswordEncryptionService;
bind(PasswordEncryptionService.class).to(SHA256PasswordEncryptionService.class);
import net.sourceforge.guacamole.net.auth.mysql.service.ConnectionService;
private ConnectionService connectionService;
List<MySQLConnection> connections = connectionService.retrieveConnectionsByName(connectionNames);
Map<String, MySQLConnection> connectionMap = new HashMap<String, MySQLConnection>();
for (MySQLConnection connection : connections)
connectionMap.put(connection.getIdentifier(), connection);
MySQLConnection connection = connectionMap.get(permission.getObjectIdentifier());
if (connection == null)
if (!administerableConnections.contains(connection.getConnectionID()))
connection.getIdentifier());
newPermission.setConnection_id(connection.getConnectionID());
List<MySQLConnection> connections = connectionService.retrieveConnectionsByName(identifiers);
Map<String, MySQLConnection> connectionMap = new HashMap<String, MySQLConnection>();
for (MySQLConnection connection : connections) {
connectionMap.put(connection.getIdentifier(), connection);
connectionIDs.add(connection.getConnectionID());
MySQLConnection connection = connectionMap.get(permission.getObjectIdentifier());
if (connection == null)
if (!administerableConnections.contains(connection.getConnectionID()))
connection.getIdentifier());
public List<MySQLConnection> retrieveConnectionsByID(List<Integer> ids) {
if (ids.isEmpty())
return Collections.EMPTY_LIST;
ConnectionExample example = new ConnectionExample();
example.createCriteria().andConnection_idIn(ids);
List<Connection> connections = connectionDAO.selectByExample(example);
List<MySQLConnection> mySQLConnections = new ArrayList<MySQLConnection>(connections.size());
for (Connection connection : connections)
mySQLConnections.add(toMySQLConnection(connection));
return mySQLConnections;
}
public List<MySQLConnection> retrieveConnectionsByName(List<String> names) {
if (names.isEmpty())
return Collections.EMPTY_LIST;
ConnectionExample example = new ConnectionExample();
example.createCriteria().andConnection_nameIn(names);
List<Connection> connections = connectionDAO.selectByExample(example);
List<MySQLConnection> mySQLConnections = new ArrayList<MySQLConnection>(connections.size());
for (Connection connection : connections)
mySQLConnections.add(toMySQLConnection(connection));
return mySQLConnections;
}
public MySQLConnection createConnection(String name, String protocol) {
Connection connection = new Connection();
connection.setConnection_name(name);
connection.setProtocol(protocol);
connectionDAO.insert(connection);
return toMySQLConnection(connection);
}
public void deleteConnection(String name) {
MySQLConnection mySQLConnection = retrieveConnection(name);
int connection_id = mySQLConnection.getConnectionID();
deleteConnection(connection_id);
}
public void deleteConnection(int id) {
connectionDAO.deleteByPrimaryKey(id);
}
public void updateConnection(MySQLConnection mySQLConnection) {
Connection connection = new Connection();
connection.setConnection_id(mySQLConnection.getConnectionID());
connection.setConnection_name(mySQLConnection.getIdentifier());
connection.setProtocol(mySQLConnection.getConfiguration().getProtocol());
connectionDAO.updateByPrimaryKeySelective(connection);
}
private ConnectionService connectionService;
MySQLConnection connection = connectionService.retrieveConnection(affectedConnectionName);
return checkConnectionAccess(userID, connection.getConnectionID(), permissionType);
return new HashSet<MySQLConnection>(
connectionService.retrieveConnectionsByID(Lists.newArrayList(affectedConnectionIDs)));
List<MySQLConnection> connections =
connectionService.retrieveConnectionsByID(affectedConnectionIDs);
Map<Integer, MySQLConnection> connectionMap = new HashMap<Integer, MySQLConnection>();
for(MySQLConnection connection : connections)
connectionMap.put(connection.getConnectionID(), connection);
MySQLConnection affectedConnection =
connectionMap.get(connectionPermission.getConnection_id());
affectedConnection.getIdentifier()
import net.sourceforge.guacamole.net.auth.permission.ObjectPermission;
import net.sourceforge.guacamole.net.auth.permission.SystemPermission;
public static String getUserConstant(ObjectPermission.Type type) {
switch (type) {
case READ:       return USER_READ;
case UPDATE:     return USER_UPDATE;
case ADMINISTER: return USER_ADMINISTER;
case DELETE:     return USER_DELETE;
}
throw new UnsupportedOperationException(
}
public static String getConnectionConstant(ObjectPermission.Type type) {
switch (type) {
case READ:       return CONNECTION_READ;
case UPDATE:     return CONNECTION_UPDATE;
case ADMINISTER: return CONNECTION_ADMINISTER;
case DELETE:     return CONNECTION_DELETE;
}
throw new UnsupportedOperationException(
}
public static String getSystemConstant(SystemPermission.Type type) {
switch (type) {
case CREATE_USER:       return SYSTEM_USER_CREATE;
case CREATE_CONNECTION: return SYSTEM_CONNECTION_CREATE;
case ADMINISTER:        return SYSTEM_ADMINISTER;
}
throw new UnsupportedOperationException(
}
import java.util.List;
MySQLConnection connection =
connectionService.retrieveConnection(identifier);
permissionCheckService.verifyConnectionAccess(
this.user_id,
connection.getConnectionID(),
MySQLConstants.CONNECTION_READ);
return connection;
List<Integer> connectionIDs =
permissionCheckService.retrieveConnectionIDs(this.user_id,
MySQLConstants.CONNECTION_READ);
return connectionService.translateNames(connectionIDs).keySet();
permissionCheckService.verifySystemAccess(this.user_id,
MySQLConstants.SYSTEM_CONNECTION_CREATE);
permissionCheckService.verifyConnectionAccess(this.user_id,
mySQLConnection.getConnectionID(),
MySQLConstants.CONNECTION_UPDATE);
permissionCheckService.verifyConnectionAccess(this.user_id,
mySQLConnection.getConnectionID(),
MySQLConstants.CONNECTION_DELETE);
MySQLUser user = userService.retrieveUser(identifier);
permissionCheckService.verifyUserAccess(this.user_id,
user.getUserID(),
MySQLConstants.USER_READ);
List<Integer> userIDs =
permissionCheckService.retrieveConnectionIDs(this.user_id,
MySQLConstants.USER_READ);
return userService.translateUsernames(userIDs).keySet();
permissionCheckService.verifySystemAccess(this.user_id,
MySQLConstants.SYSTEM_USER_CREATE);
List<Integer> administerableUserIDs =
permissionCheckService.retrieveUserIDs(this.user_id,
MySQLConstants.USER_ADMINISTER);
Map<String, Integer> administerableUsers =
userService.translateUsernames(administerableUserIDs);
Integer affected_id =
administerableUsers.get(permission.getObjectIdentifier());
if (affected_id == null)
permission.getObjectIdentifier());
newPermission.setPermission(MySQLConstants.getUserConstant(permission.getType()));
newPermission.setAffected_user_id(affected_id);
List<Integer> administerableUserIDs =
permissionCheckService.retrieveUserIDs(this.user_id,
MySQLConstants.USER_ADMINISTER);
Map<String, Integer> administerableUsers =
userService.translateUsernames(administerableUserIDs);
Integer affected_id =
administerableUsers.get(permission.getObjectIdentifier());
if (affected_id == null)
permission.getObjectIdentifier());
UserPermissionExample userPermissionExample = new UserPermissionExample();
userPermissionExample.createCriteria()
.andUser_idEqualTo(user_id)
.andPermissionEqualTo(MySQLConstants.getUserConstant(permission.getType()))
.andAffected_user_idEqualTo(affected_id);
userPermissionDAO.deleteByExample(userPermissionExample);
List<Integer> administerableConnectionIDs =
permissionCheckService.retrieveUserIDs(this.user_id,
MySQLConstants.CONNECTION_ADMINISTER);
Map<String, Integer> administerableConnections =
userService.translateUsernames(administerableConnectionIDs);
Integer connection_id =
administerableConnections.get(permission.getObjectIdentifier());
if (connection_id == null)
permission.getObjectIdentifier());
newPermission.setPermission(MySQLConstants.getConnectionConstant(permission.getType()));
newPermission.setConnection_id(connection_id);
List<Integer> administerableConnectionIDs =
permissionCheckService.retrieveUserIDs(this.user_id,
MySQLConstants.CONNECTION_ADMINISTER);
Map<String, Integer> administerableConnections =
userService.translateUsernames(administerableConnectionIDs);
Integer connection_id =
administerableConnections.get(permission.getObjectIdentifier());
if (connection_id == null)
permission.getObjectIdentifier());
ConnectionPermissionExample connectionPermissionExample = new ConnectionPermissionExample();
connectionPermissionExample.createCriteria()
.andUser_idEqualTo(user_id)
.andPermissionEqualTo(MySQLConstants.getConnectionConstant(permission.getType()))
.andConnection_idEqualTo(connection_id);
connectionPermissionDAO.deleteByExample(connectionPermissionExample);
MySQLUser mySQLUser = (MySQLUser) object;
permissionCheckService.verifyUserAccess(this.user_id,
mySQLUser.getUserID(),
MySQLConstants.USER_UPDATE);
MySQLUser user = userService.retrieveUser(identifier);
permissionCheckService.verifyUserAccess(this.user_id,
user.getUserID(),
MySQLConstants.USER_DELETE);
userService.deleteUser(user.getUserID());
import java.util.HashMap;
import java.util.Map;
public Map<String, Integer> translateNames(List<Integer> ids) {
return Collections.EMPTY_MAP;
Map<String, Integer> names = new HashMap<String, Integer>();
names.put(connection.getConnection_name(),
connection.getConnection_id());
return names;
public Map<Integer, String> retrieveNames(List<Integer> ids) {
if (ids.isEmpty())
return Collections.EMPTY_MAP;
Map<Integer, String> names = new HashMap<Integer, String>();
example.createCriteria().andConnection_idIn(ids);
names.put(connection.getConnection_id(),
connection.getConnection_name());
return names;
public void verifyUserAccess(int userID, int affectedUserID,
String permissionType) throws GuacamoleSecurityException {
if(!checkUserAccess(userID, affectedUserID, permissionType))
throw new GuacamoleSecurityException("Permission denied.");
public void verifyConnectionAccess(int userID, int affectedConnectionID, String permissionType) throws GuacamoleSecurityException {
if(!checkConnectionAccess(userID, affectedConnectionID, permissionType))
throw new GuacamoleSecurityException("Permission denied.");
}
public void verifySystemAccess(int userID, String systemPermissionType)
throws GuacamoleSecurityException {
if(!checkSystemAccess(userID, systemPermissionType))
throw new GuacamoleSecurityException("Permission denied.");
public boolean checkUserAccess(int userID, Integer affectedUserID, String permissionType) {
return userPermissionDAO.countByExample(example) > 0;
public boolean checkConnectionAccess(int userID, Integer affectedConnectionID, String permissionType) {
ConnectionPermissionExample example = new ConnectionPermissionExample();
example.createCriteria().andUser_idEqualTo(userID).andConnection_idEqualTo(affectedConnectionID).andPermissionEqualTo(permissionType);
return connectionPermissionDAO.countByExample(example) > 0;
private boolean checkSystemAccess(int userID, String systemPermissionType) {
SystemPermissionExample example = new SystemPermissionExample();
example.createCriteria().andUser_idEqualTo(userID).andPermissionEqualTo(systemPermissionType);
return systemPermissionDAO.countByExample(example) > 0;
public List<Integer> retrieveUserIDs(int userID, String permissionType) {
example.setDistinct(true);
List<UserPermissionKey> userPermissions =
userPermissionDAO.selectByExample(example);
List<Integer> userIDs = new ArrayList<Integer>(userPermissions.size());
public List<Integer> retrieveConnectionIDs(int userID,
String permissionType) {
example.setDistinct(true);
List<ConnectionPermissionKey> connectionPermissions =
connectionPermissionDAO.selectByExample(example);
List<Integer> connectionIDs = new ArrayList<Integer>(connectionPermissions.size());
public Set<UserPermission> retrieveUserPermissions(int userID) {
Set<UserPermission> permissions = new HashSet<UserPermission>();
List<Integer> affectedUserIDs = new ArrayList<Integer>();
for(UserPermissionKey userPermission : userPermissions)
affectedUserIDs.add(userPermission.getAffected_user_id());
Map<Integer, String> affectedUsers =
userService.retrieveUsernames(affectedUserIDs);
for(UserPermissionKey userPermission : userPermissions) {
UserPermission permission = new UserPermission(
UserPermission.Type.valueOf(userPermission.getPermission()),
affectedUsers.get(userPermission.getUser_id())
);
permissions.add(permission);
return permissions;
}
public Set<ConnectionPermission> retrieveConnectionPermissions(int userID) {
Set<ConnectionPermission> permissions = new HashSet<ConnectionPermission>();
List<Integer> connectionIDs = new ArrayList<Integer>();
for(ConnectionPermissionKey connectionPermission : connectionPermissions)
connectionIDs.add(connectionPermission.getConnection_id());
Map<Integer, String> affectedUsers =
connectionService.retrieveNames(connectionIDs);
for(ConnectionPermissionKey connectionPermission : connectionPermissions) {
ConnectionPermission permission = new ConnectionPermission(
ConnectionPermission.Type.valueOf(connectionPermission.getPermission()),
affectedUsers.get(connectionPermission.getUser_id())
);
permissions.add(permission);
return permissions;
}
public Set<Permission> retrieveAllPermissions(int userID) {
Set<Permission> allPermissions = new HashSet<Permission>();
allPermissions.addAll(retrieveUserPermissions(userID));
allPermissions.addAll(retrieveConnectionPermissions(userID));
import java.util.HashMap;
import java.util.Map;
permissionCheckService.retrieveAllPermissions(user.getUser_id())
public Map<String, Integer> translateUsernames(List<Integer> ids) {
if (ids.isEmpty())
return Collections.EMPTY_MAP;
Map<String, Integer> names = new HashMap<String, Integer>();
UserExample example = new UserExample();
example.createCriteria().andUser_idIn(ids);
List<net.sourceforge.guacamole.net.auth.mysql.model.User> users =
userDAO.selectByExample(example);
for (net.sourceforge.guacamole.net.auth.mysql.model.User user : users)
names.put(user.getUsername(), user.getUser_id());
return names;
}
public Map<Integer, String> retrieveUsernames(List<Integer> ids) {
if (ids.isEmpty())
return Collections.EMPTY_MAP;
Map<Integer, String> names = new HashMap<Integer, String>();
UserExample example = new UserExample();
example.createCriteria().andUser_idIn(ids);
List<net.sourceforge.guacamole.net.auth.mysql.model.User> users =
userDAO.selectByExample(example);
for (net.sourceforge.guacamole.net.auth.mysql.model.User user : users)
names.put(user.getUser_id(), user.getUsername());
return names;
}
public void deleteUser(int user_id) {
permissionCheckService.retrieveConnectionIDs(this.user_id,
connectionService.translateNames(administerableConnectionIDs);
affectedUsers.get(userPermission.getAffected_user_id())
Map<Integer, String> affectedConnections =
affectedConnections.get(connectionPermission.getConnection_id())
newSystemPermission.setPermission(MySQLConstants.getSystemConstant(permission.getType()));
for (SystemPermission permission : permissions)
systemPermissionTypes.add(MySQLConstants.getSystemConstant(permission.getType()));
retrieveHistory(connection.getConnection_id())
public Set<SystemPermission> retrieveSystemPermissions(int userID) {
Set<SystemPermission> permissions = new HashSet<SystemPermission>();
SystemPermissionExample systemPermissionExample = new SystemPermissionExample();
systemPermissionExample.createCriteria().andUser_idEqualTo(userID);
List<SystemPermissionKey> systemPermissions =
systemPermissionDAO.selectByExample(systemPermissionExample);
for(SystemPermissionKey systemPermission : systemPermissions) {
if(systemPermission.getPermission().equals(MySQLConstants.SYSTEM_USER_CREATE))
permissions.add(new SystemPermission(SystemPermission.Type.CREATE_USER));
else if(systemPermission.getPermission().equals(MySQLConstants.SYSTEM_CONNECTION_CREATE))
permissions.add(new SystemPermission(SystemPermission.Type.CREATE_CONNECTION));
else if(systemPermission.getPermission().equals(MySQLConstants.SYSTEM_ADMINISTER))
permissions.add(new SystemPermission(SystemPermission.Type.ADMINISTER));
}
return permissions;
}
allPermissions.addAll(retrieveSystemPermissions(userID));
import net.sourceforge.guacamole.GuacamoleClientException;
import net.sourceforge.guacamole.GuacamoleResourceNotFoundException;
import net.sourceforge.guacamole.GuacamoleSecurityException;
private void sendError(HttpServletResponse response, int code,
String message) throws ServletException {
try {
if (!response.isCommitted()) {
response.sendError(code);
response.addHeader("Guacamole-Error-Message", message);
}
}
catch (IOException ioe) {
throw new ServletException(ioe);
}
}
try {
authenticatedService(context, request, response);
}
catch (GuacamoleSecurityException e) {
logger.warn("Permission denied: {}", e.getMessage());
sendError(response, HttpServletResponse.SC_FORBIDDEN,
"Permission denied.");
}
catch (GuacamoleResourceNotFoundException e) {
logger.debug("Resource not found: {}", e.getMessage());
sendError(response, HttpServletResponse.SC_NOT_FOUND,
e.getMessage());
}
catch (GuacamoleClientException e) {
logger.warn("Error in client request: {}", e.getMessage());
sendError(response, HttpServletResponse.SC_BAD_REQUEST,
e.getMessage());
}
catch (GuacamoleException e) {
logger.error("Internal server error.", e);
sendError(response, HttpServletResponse.SC_INTERNAL_SERVER_ERROR,
"Internal server error.");
}
throws GuacamoleException;
throws GuacamoleException {
try {
tunnelServlet.service(request, response);
}
catch (ServletException e) {
logger.info("Error from tunnel (see previous log messages): {}",
e.getMessage());
}
catch (IOException e) {
logger.info("I/O error from tunnel (see previous log messages): {}",
e.getMessage());
}
HttpServletRequest request, HttpServletResponse response) {
throws GuacamoleException {
Directory<String, Connection> directory =
context.getConnectionDirectory();
GuacamoleConfiguration config = new GuacamoleConfiguration();
config.setProtocol(protocol);
Enumeration<String> params = request.getParameterNames();
while (params.hasMoreElements()) {
String param = params.nextElement();
if (param.startsWith(PARAMETER_PREFIX))
config.setParameter(
param.substring(PARAMETER_PREFIX.length()),
request.getParameter(param));
Connection connection = new DummyConnection();
connection.setIdentifier(identifier);
connection.setConfiguration(config);
directory.add(connection);
throws GuacamoleException {
Directory<String, Connection> directory =
context.getConnectionDirectory();
directory.remove(identifier);
import net.sourceforge.guacamole.GuacamoleServerException;
throws GuacamoleException {
Directory<String, Connection> directory = context.getConnectionDirectory();
throw new GuacamoleServerException(
"Unable to write configuration list XML.", e);
catch (IOException e) {
throw new GuacamoleServerException(
"I/O error writing configuration list XML.", e);
throws GuacamoleException {
Directory<String, Connection> directory =
context.getConnectionDirectory();
GuacamoleConfiguration config = new GuacamoleConfiguration();
config.setProtocol(protocol);
Enumeration<String> params = request.getParameterNames();
while (params.hasMoreElements()) {
String param = params.nextElement();
if (param.startsWith(PARAMETER_PREFIX))
config.setParameter(
param.substring(PARAMETER_PREFIX.length()),
request.getParameter(param));
Connection connection = directory.get(identifier);
connection.setConfiguration(config);
directory.update(connection);
import net.sourceforge.guacamole.GuacamoleClientException;
import net.sourceforge.guacamole.GuacamoleServerException;
throws GuacamoleException {
throw new GuacamoleClientException(
"Unsupported permission type.");
throw new GuacamoleServerException(
"Unable to write permission list XML.", e);
catch (IOException e) {
throw new GuacamoleServerException(
"I/O error writing permission list XML.", e);
throws GuacamoleException {
Directory<String, User> directory =
context.getUserDirectory();
User user = new DummyUser();
user.setUsername(username);
user.setPassword(UUID.randomUUID().toString());
directory.add(user);
throws GuacamoleException {
Directory<String, User> directory = context.getUserDirectory();
directory.remove(username);
import net.sourceforge.guacamole.GuacamoleServerException;
throws GuacamoleException {
throw new GuacamoleServerException(
"Unable to write configuration list XML.", e);
catch (IOException e) {
throw new GuacamoleServerException(
"I/O error writing configuration list XML.", e);
import net.sourceforge.guacamole.GuacamoleClientException;
throw new GuacamoleClientException("Invalid permission string.");
throws GuacamoleException {
Directory<String, User> directory =
context.getUserDirectory();
User user = directory.get(username);
user.setUsername(username);
if (password != null)
user.setPassword(password);
if (add_sys_permission != null) {
for (String str : add_sys_permission)
user.addPermission(parseSystemPermission(str));
if (add_user_permission != null) {
for (String str : add_user_permission)
user.addPermission(parseUserPermission(str));
if (add_connection_permission != null) {
for (String str : add_connection_permission)
user.addPermission(parseConnectionPermission(str));
}
String[] remove_sys_permission = request.getParameterValues("-sys");
if (remove_sys_permission != null) {
for (String str : remove_sys_permission)
user.removePermission(parseSystemPermission(str));
}
String[] remove_user_permission = request.getParameterValues("-user");
if (remove_user_permission != null) {
for (String str : remove_user_permission)
user.removePermission(parseUserPermission(str));
}
String[] remove_connection_permission = request.getParameterValues("-connection");
if (remove_connection_permission != null) {
for (String str : remove_connection_permission)
user.removePermission(parseConnectionPermission(str));
}
directory.update(user);
public String getUsername();
xml.writeCharacters(record.getUsername());
import com.google.inject.Inject;
import java.util.Date;
import java.util.Set;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.net.auth.mysql.dao.ConnectionHistoryMapper;
import net.sourceforge.guacamole.net.auth.mysql.model.ConnectionHistory;
public class ActiveConnectionSet {
@Inject
private ConnectionHistoryMapper connectionHistoryDAO;
private Set<Integer> activeConnectionSet = new HashSet<Integer>();
public boolean isActive(int connectionID) {
return activeConnectionSet.contains(connectionID);
}
public int openConnection(int connectionID, int userID) {
ConnectionHistory connectionHistory = new ConnectionHistory();
connectionHistory.setConnection_id(connectionID);
connectionHistory.setUser_id(userID);
connectionHistory.setStart_date(new Date());
connectionHistoryDAO.insert(connectionHistory);
activeConnectionSet.add(connectionID);
return connectionHistory.getHistory_id();
}
public void closeConnection(int connectionID, int historyID)
throws GuacamoleException {
ConnectionHistory connectionHistory =
connectionHistoryDAO.selectByPrimaryKey(historyID);
if(connectionHistory == null)
throw new GuacamoleException("History record not found.");
connectionHistory.setEnd_date(new Date());
connectionHistoryDAO.updateByPrimaryKey(connectionHistory);
activeConnectionSet.remove(connectionID);
}
}
connectionService.retrieveConnection(identifier, user_id);
object.getIdentifier(), object.getConfiguration().getProtocol(),
user_id);
connectionService.retrieveConnection(identifier, user_id);
private int userID;
List<? extends ConnectionRecord> history, int userID) {
this.userID = userID;
return connectionService.connect(this, info, userID);
private Date startDate;
private Date endDate;
private String username;
public MySQLConnectionRecord(Date startDate, Date endDate,
String username) {
this.startDate = startDate;
this.endDate = endDate;
this.username = username;
return startDate;
return endDate;
public String getUsername() {
return username;
return endDate == null;
private int historyID;
public void init(GuacamoleSocket socket, int connectionID, int historyID) {
this.historyID = historyID;
activeConnectionSet.closeConnection(connectionID, historyID);
import com.google.common.collect.Lists;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Set;
@Inject
private UserService userService;
public MySQLConnection retrieveConnection(String name, int userID) {
return toMySQLConnection(connections.get(0), userID);
public MySQLConnection retrieveConnection(int id, int userID) {
return toMySQLConnection(connection, userID);
public Map<Integer, String> retrieveNames(Collection<Integer> ids) {
example.createCriteria().andConnection_idIn(Lists.newArrayList(ids));
private MySQLConnection toMySQLConnection(Connection connection, int userID) {
retrieveHistory(connection.getConnection_id()),
userID
Set<Integer> userIDSet = new HashSet<Integer>();
userIDSet.add(history.getUser_id());
}
Map<Integer, String> usernameMap = userService.retrieveUsernames(userIDSet);
for(ConnectionHistory history : connectionHistories) {
Date startDate = history.getStart_date();
Date endDate = history.getEnd_date();
String username = usernameMap.get(history.getUser_id());
MySQLConnectionRecord connectionRecord = new MySQLConnectionRecord(startDate, endDate, username);
connectionRecords.add(connectionRecord);
GuacamoleClientInformation info, int userID)
&& activeConnectionSet.isActive(connection.getConnectionID()))
int historyID = activeConnectionSet.openConnection(connection.getConnectionID(), userID);
mySQLGuacamoleSocket.init(socket, connection.getConnectionID(), historyID);
public MySQLConnection createConnection(String name, String protocol, int userID) {
return toMySQLConnection(connection, userID);
import com.google.common.collect.Lists;
import java.util.Collection;
public Map<Integer, String> retrieveUsernames(Collection<Integer> ids) {
example.createCriteria().andUser_idIn(Lists.newArrayList(ids));
ConnectionHistory connectionHistory =
this.startDate = new Date(startDate.getTime());
this.endDate = new Date(endDate.getTime());
return new Date(startDate.getTime());
return new Date(endDate.getTime());
if (startDate != null) this.startDate = new Date(startDate.getTime());
if (endDate != null) this.endDate = new Date(endDate.getTime());
if (startDate == null) return null;
if (endDate == null) return null;
if (record.isActive())
xml.writeAttribute("active", "yes");
import org.apache.ibatis.session.RowBounds;
RowBounds rowBounds = new RowBounds(0, 100);
List<ConnectionHistory> connectionHistories =
connectionHistoryDAO.selectByExampleWithRowbounds(example, rowBounds);
import net.sourceforge.guacamole.GuacamoleClientException;
if(object.getIdentifier().isEmpty())
throw new GuacamoleClientException("The connection identifier cannot be blank.");
MySQLConnection previousConnection =
connectionService.retrieveConnection(object.getIdentifier(), user_id);
if(previousConnection != null)
throw new GuacamoleClientException("That connection identifier is already in use.");
import net.sourceforge.guacamole.GuacamoleClientException;
if(object.getUsername().isEmpty())
throw new GuacamoleClientException("The username cannot be blank.");
MySQLUser previousUser =
userService.retrieveUser(object.getUsername());
if(previousUser != null)
throw new GuacamoleClientException("That username is already in use.");
import net.sourceforge.guacamole.GuacamoleClientException;
throw new GuacamoleClientException("Cannot connect. This connection is in use.");
public List<MySQLConnection> getAllConnections(int userID) {
List<Connection> allConnections = connectionDAO.selectByExample(new ConnectionExample());
List<MySQLConnection> allMySQLConnections = new ArrayList<MySQLConnection>();
for(Connection connection : allConnections) {
allMySQLConnections.add(toMySQLConnection(connection, userID));
}
return allMySQLConnections;
}
public List<Integer> getAllConnectionIDs(int userID) {
List<Integer> connectionIDs = new ArrayList<Integer>();
for(MySQLConnection connection : getAllConnections(userID)) {
connectionIDs.add(connection.getConnectionID());
}
return connectionIDs;
}
if(checkSystemAdministratorAccess(userID))
return true;
if(checkSystemAdministratorAccess(userID))
return true;
if(checkSystemAdministratorAccess(userID))
return true;
private boolean checkSystemAdministratorAccess(int userID) {
SystemPermissionExample example = new SystemPermissionExample();
example.createCriteria().andUser_idEqualTo(userID).
andPermissionEqualTo(MySQLConstants.SYSTEM_ADMINISTER);
return systemPermissionDAO.countByExample(example) > 0;
}
if(checkSystemAdministratorAccess(userID)) {
return userService.getAllUserIDs();
}
if(checkSystemAdministratorAccess(userID)) {
return connectionService.getAllConnectionIDs(userID);
}
import java.util.ArrayList;
public List<MySQLUser> getAllUsers() {
List<UserWithBLOBs> allUsers = userDAO.selectByExampleWithBLOBs(new UserExample());
List<MySQLUser> allMySQLUsers = new ArrayList<MySQLUser>();
for(UserWithBLOBs user : allUsers) {
allMySQLUsers.add(toMySQLUser(user));
}
return allMySQLUsers;
}
public List<Integer> getAllUserIDs() {
List<Integer> userIDs = new ArrayList<Integer>();
for(MySQLUser user : getAllUsers()) {
userIDs.add(user.getUserID());
}
return userIDs;
}
Collection<SystemPermission> permissions) throws GuacamoleException {
permissionCheckService.verifySystemAccess(
this.user_id, SystemPermission.Type.ADMINISTER.name());
return permissionCheckService.retrieveConnectionNames(user_id,
return permissionCheckService.retrieveUsernames(user_id,
permissionCheckService.retrieveConnectionIDs(this.user_id,
connectionService.translateNames(administerableConnectionIDs);
public Set<String> getAllConnectionNames() {
Set<String> names = new HashSet<String>();
List<Connection> connections =
connectionDAO.selectByExample(new ConnectionExample());
for (Connection connection : connections)
names.add(connection.getConnection_name());
return names;
public List<Integer> getAllConnectionIDs() {
List<Integer> connectionIDs = new ArrayList<Integer>();
List<Connection> connections =
connectionDAO.selectByExample(new ConnectionExample());
for (Connection connection : connections)
connectionIDs.add(connection.getConnection_id());
return connectionIDs;
}
if(checkSystemAdministratorAccess(userID))
if(checkSystemAdministratorAccess(userID))
return connectionService.getAllConnectionIDs();
public Set<String> retrieveUsernames(int userID, String permissionType) {
if(checkSystemAdministratorAccess(userID))
return userService.getAllUsernames();
List<Integer> userIDs =
retrieveUserIDs(userID, MySQLConstants.USER_READ);
return userService.translateUsernames(userIDs).keySet();
}
public Set<String> retrieveConnectionNames(int userID, String permissionType) {
if(checkSystemAdministratorAccess(userID))
return connectionService.getAllConnectionNames();
List<Integer> connectionIDs =
retrieveUserIDs(userID, MySQLConstants.CONNECTION_READ);
return connectionService.translateNames(connectionIDs).keySet();
}
import java.util.HashSet;
import java.util.Set;
import net.sourceforge.guacamole.net.auth.mysql.model.User;
public MySQLUser toMySQLUser(net.sourceforge.guacamole.net.auth.User user) throws GuacamoleException {
List<User> users =
for (User user : users)
List<User> users =
for (User user : users)
public Set<String> getAllUsernames() {
Set<String> usernames = new HashSet<String>();
List<User> users =
userDAO.selectByExample(new UserExample());
for (User user : users)
usernames.add(user.getUsername());
return usernames;
public List<Integer> getAllUserIDs() {
List<Integer> userIDs = new ArrayList<Integer>();
List<User> users =
userDAO.selectByExample(new UserExample());
for (User user : users)
userIDs.add(user.getUser_id());
return userIDs;
}
String identifier = object.getIdentifier().trim();
if(identifier.isEmpty())
connectionService.retrieveConnection(identifier, user_id);
identifier, object.getConfiguration().getProtocol(),
String username = object.getUsername().trim();
if(username.isEmpty())
MySQLUser previousUser = userService.retrieveUser(username);
MySQLUser user = userService.createUser(username, object.getPassword());
response.sendError(code);
Collection<SystemPermission> permissions)
throws GuacamoleException {
if (user_id == this.user_id)
throw new GuacamoleClientException("Removing your own administrative permissions is not allowed.");
if (user.getUserID() == this.user_id)
throw new GuacamoleClientException("Deleting your own user is not allowed.");
import net.sourceforge.guacamole.net.auth.permission.SystemPermission;
Permission systemPermission =
new SystemPermission(SystemPermission.Type.ADMINISTER);
if (self.hasPermission(systemPermission) ||
hasConfigPermission(self, ObjectPermission.Type.UPDATE,
MySQLConnection previousConnection =
List<ConnectionHistory> connectionHistories =
retrieveConnectionIDs(userID, MySQLConstants.CONNECTION_READ);
retrieveConnectionIDs(userID, MySQLConstants.CONNECTION_READ);
handler = parent_handler.childElement(localName);
handler.init(attributes);
public TagHandler childElement(String localName)
public void init(Attributes attributes) throws SAXException;
@Override
public void init(Attributes attributes) throws SAXException {
public TagHandler childElement(String localName) throws SAXException {
ConnectionTagHandler tagHandler = new ConnectionTagHandler();
return new ParamTagHandler(default_config);
@Override
public void init(Attributes attributes) throws SAXException {
public TagHandler childElement(String localName) throws SAXException {
return new ParamTagHandler(config);
public ParamTagHandler(GuacamoleConfiguration config) {
public void init(Attributes attributes) throws SAXException {
this.name = attributes.getValue("name");
}
@Override
public TagHandler childElement(String localName) throws SAXException {
public void init(Attributes attributes) throws SAXException {
}
@Override
public TagHandler childElement(String localName) throws SAXException {
public void init(Attributes attributes) throws SAXException {
}
@Override
public TagHandler childElement(String localName) throws SAXException {
AuthorizeTagHandler tagHandler = new AuthorizeTagHandler();
import java.util.HashMap;
import java.util.Map;
private static final String[] KNOWN_PROTOCOLS = new String[]{
"vnc", "rdp", "ssh"};
Map<String, ProtocolInfo> protocols = new HashMap<String, ProtocolInfo>();
for (String protocol : KNOWN_PROTOCOLS) {
if (!protocols.containsKey(protocol)) {
InputStream stream = List.class.getResourceAsStream(
"/net/sourceforge/guacamole/net/protocols/"
if (stream != null)
protocols.put(protocol, getProtocol(stream));
}
}
for (ProtocolInfo protocol : protocols.values())
writeProtocol(xml, protocol);
import java.io.File;
import java.io.FileInputStream;
import java.io.FilenameFilter;
import net.sourceforge.guacamole.properties.GuacamoleHome;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
private Logger logger = LoggerFactory.getLogger(List.class);
File protocol_directory = new File(GuacamoleHome.getDirectory(),
"protocols");
if (protocol_directory.isDirectory()) {
File[] files = protocol_directory.listFiles(
new FilenameFilter() {
@Override
public boolean accept(File file, String string) {
return string.endsWith(".xml");
}
}
);
for (File file : files) {
try {
FileInputStream stream = new FileInputStream(file);
ProtocolInfo protocol = getProtocol(stream);
stream.close();
protocols.put(protocol.getName(), protocol);
}
catch (IOException e) {
logger.error("Unable to read protocol XML.", e);
}
}
}
import net.sourceforge.guacamole.net.basic.auth.UserMapping;
private UserMapping parent;
public AuthorizeTagHandler(UserMapping parent) {
this.parent = parent;
}
parent.addAuthorization(this.asAuthorization());
if (localName.equals("connection"))
return new ConnectionTagHandler(authorization);
import net.sourceforge.guacamole.net.basic.auth.Authorization;
private Authorization parent;
public ConnectionTagHandler(Authorization parent) {
this.parent = parent;
}
parent.addConfiguration(name, this.asGuacamoleConfiguration());
if (localName.equals("authorize"))
return new AuthorizeTagHandler(user_mapping);
private String value;
public String getValue() {
return value;
}
public void setValue(String value) {
this.value = value;
}
xml.writeAttribute("value", param.getValue());
protocolParameter.setValue(attributes.getValue("value"));
import net.sourceforge.guacamole.net.basic.auth.UserMapping;
private UserMapping parent;
public AuthorizeTagHandler(UserMapping parent) {
this.parent = parent;
}
parent.addAuthorization(this.asAuthorization());
if (localName.equals("connection"))
return new ConnectionTagHandler(authorization);
import net.sourceforge.guacamole.net.basic.auth.Authorization;
private Authorization parent;
public ConnectionTagHandler(Authorization parent) {
this.parent = parent;
}
parent.addConfiguration(name, this.asGuacamoleConfiguration());
if (localName.equals("authorize"))
return new AuthorizeTagHandler(user_mapping);
else if ("boolean".equals(type)) {
if(protocolParameter.getValue() == null)
throw new SAXException
("A value is required for the boolean parameter type.");
}
if (user == null)
throw new GuacamoleSecurityException("No such user.");
final Properties driverProperties = new Properties();
driverProperties.setProperty("characterEncoding","UTF-8");
binder.bind(Properties.class)
.annotatedWith(Names.named("JDBC.driverProperties"))
.toInstance(driverProperties);
response.setCharacterEncoding("UTF-8");
response.setCharacterEncoding("UTF-8");
response.setCharacterEncoding("UTF-8");
response.setCharacterEncoding("UTF-8");
final Properties driverProperties = new Properties();
driverProperties.setProperty("characterEncoding","UTF-8");
binder.bind(Properties.class)
.annotatedWith(Names.named("JDBC.driverProperties"))
.toInstance(driverProperties);
import java.io.UnsupportedEncodingException;
if(request.getCharacterEncoding() == null) {
try {
request.setCharacterEncoding("UTF-8");
} catch (UnsupportedEncodingException exception) {
throw new ServletException(exception);
}
}
response.setCharacterEncoding("UTF-8");
response.setCharacterEncoding("UTF-8");
response.setCharacterEncoding("UTF-8");
response.setCharacterEncoding("UTF-8");
import java.io.UnsupportedEncodingException;
if(request.getCharacterEncoding() == null) {
try {
request.setCharacterEncoding("UTF-8");
} catch (UnsupportedEncodingException exception) {
throw new ServletException(exception);
}
}
import java.io.UnsupportedEncodingException;
if(request.getCharacterEncoding() == null) {
try {
request.setCharacterEncoding("UTF-8");
} catch (UnsupportedEncodingException exception) {
throw new ServletException(exception);
}
}
import net.sourceforge.guacamole.net.SSLGuacamoleSocket;
GuacamoleSocket socket;
if (GuacamoleProperties.getProperty(GuacamoleProperties.GUACD_SSL, false))
socket = new ConfiguredGuacamoleSocket(
new SSLGuacamoleSocket(host, port),
connection.getConfiguration(), info
);
else
socket = new ConfiguredGuacamoleSocket(
new InetGuacamoleSocket(host, port),
connection.getConfiguration(), info
);
import net.sourceforge.guacamole.net.SSLGuacamoleSocket;
if (GuacamoleProperties.getProperty(GuacamoleProperties.GUACD_SSL, false))
return new ConfiguredGuacamoleSocket(
new SSLGuacamoleSocket(hostname, port),
config, info
);
new InetGuacamoleSocket(hostname, port),
config, info
public static final BooleanGuacamoleProperty GUACD_SSL = new BooleanGuacamoleProperty() {
@Override
public String getName() { return "guacd-ssl"; }
};
@Override
public UserContext updateUserContext(UserContext context,
Credentials credentials) throws GuacamoleException {
return context;
}
UserContext updateUserContext(UserContext context, Credentials credentials)
throws GuacamoleException;
@Override
public UserContext updateUserContext(UserContext context,
Credentials credentials) throws GuacamoleException {
return context;
}
import java.util.HashMap;
import java.util.Map;
private static final long serialVersionUID = 2L;
private Map<String, String> queryParameters = null;
String get_password = getQueryParameter("password");
if (get_password != null)
return get_password;
return request.getParameter("password");
String get_password = getQueryParameter("username");
if (get_password != null)
return get_password;
return request.getParameter("username");
public String getQueryParameter(String parameter) {
if (queryParameters == null) {
if (request == null)
return null;
String query_string = request.getQueryString();
if (query_string == null)
return null;
String[] nv_pairs = query_string.split("&");
queryParameters = new HashMap<String, String>();
for (String nv_pair : nv_pairs) {
String name;
String value;
int eq = nv_pair.indexOf('=');
if (eq == -1) {
name  = nv_pair;
value = "";
}
else {
name  = nv_pair.substring(0, eq);
}
queryParameters.put(name, value);
}
return queryParameters.get(parameter);
}
import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.nio.charset.UnsupportedCharsetException;
try {
for (String nv_pair : nv_pairs) {
String name;
String value;
int eq = nv_pair.indexOf('=');
if (eq == -1) {
name  = nv_pair;
value = "";
}
else {
name  = nv_pair.substring(0, eq);
}
queryParameters.put(
URLDecoder.decode(name,  "UTF-8"),
URLDecoder.decode(value, "UTF-8")
);
}
catch (UnsupportedEncodingException e) {
throw new UnsupportedOperationException("Unexpected lack of support for UTF-8", e);
import net.sourceforge.guacamole.net.auth.UserContext;
public class AuthenticationSuccessEvent implements UserEvent, CredentialEvent {
private UserContext context;
public AuthenticationSuccessEvent(UserContext context, Credentials credentials) {
this.context = context;
public UserContext getUserContext() {
return context;
}
@Override
import net.sourceforge.guacamole.net.auth.UserContext;
public class TunnelCloseEvent implements UserEvent, TunnelEvent {
private UserContext context;
public TunnelCloseEvent(UserContext context, GuacamoleTunnel tunnel) {
this.context = context;
public UserContext getUserContext() {
return context;
import net.sourceforge.guacamole.net.auth.UserContext;
public class TunnelConnectEvent implements UserEvent, TunnelEvent {
private UserContext context;
public TunnelConnectEvent(UserContext context, GuacamoleTunnel tunnel) {
this.context = context;
public UserContext getUserContext() {
return context;
private boolean notifySuccess(Collection listeners, UserContext context,
Credentials credentials) throws GuacamoleException {
AuthenticationSuccessEvent event =
new AuthenticationSuccessEvent(context, credentials);
SessionListenerCollection listeners;
try {
listeners = new SessionListenerCollection(httpSession);
}
catch (GuacamoleException e) {
logger.error("Failed to retrieve listeners. Authentication canceled.", e);
failAuthentication(response);
return;
}
Credentials credentials = new Credentials();
credentials.setSession(httpSession);
credentials.setRequest(request);
if (context != null) {
context.self().getUsername(), request.getRemoteAddr());
try {
if (!notifySuccess(listeners, context, credentials)) {
logger.info("Successful authentication canceled by hook.");
context = null;
}
catch (GuacamoleException e) {
logger.error("Successful authentication canceled by error in hook.", e);
context = null;
}
else {
try {
context = authProvider.updateUserContext(context, credentials);
catch (GuacamoleException e) {
logger.error("Error updating context for user \"{}\".",
context.self().getUsername(), e);
}
if (context == null) {
logger.warn("Authentication attempt from {} for user \"{}\" failed.",
request.getRemoteAddr(), credentials.getUsername());
notifyFailed(listeners, credentials);
failAuthentication(response);
return;
httpSession.setAttribute(CONTEXT_ATTRIBUTE, context);
UserContext context, GuacamoleTunnel tunnel)
TunnelConnectEvent event = new TunnelConnectEvent(context, tunnel);
UserContext context, GuacamoleTunnel tunnel)
TunnelCloseEvent event = new TunnelCloseEvent(context, tunnel);
final UserContext context = getUserContext(httpSession);
if (context == null)
throw new GuacamoleSecurityException("Cannot connect - user not logged in.");
if (!notifyClose(listeners, context, this))
if (!notifyConnect(listeners, context, tunnel)) {
try {
SessionListenerCollection listeners = new SessionListenerCollection(httpSession);
UserContext context = getUserContext(httpSession);
if (context == null) {
if (context != null) {
logger.info("User \"{}\" successfully authenticated from {}.",
context.self().getUsername(), request.getRemoteAddr());
}
else
if (context == null) {
logger.warn("Authentication attempt from {} for user \"{}\" failed.",
request.getRemoteAddr(), credentials.getUsername());
notifyFailed(listeners, credentials);
sendError(response, HttpServletResponse.SC_FORBIDDEN,
"Permission denied.");
return;
httpSession.setAttribute(CONTEXT_ATTRIBUTE, context);
import java.util.Collections;
public Map<String, String> getQueryParameters() {
return Collections.unmodifiableMap(queryParameters);
}
public String getQueryParameter(String parameter) {
return getQueryParameters().get(parameter);
protected boolean hasNewCredentials(HttpServletRequest request) {
return true;
}
else if (hasNewCredentials(request))
@Override
protected boolean hasNewCredentials(HttpServletRequest request) {
String query = request.getQueryString();
if (query == null)
return false;
return query.equals("connect");
}
private static final long serialVersionUID = 1L;
private String username;
private String password;
return password;
public void setPassword(String password) {
this.password = password;
}
return username;
public void setUsername(String username) {
this.username = username;
String username = request.getParameter("username");
String password = request.getParameter("password");
credentials.setUsername(username);
credentials.setPassword(password);
HttpSession httpSession = request.getSession(true);
if (hasNewCredentials(request)) {
String username = request.getParameter("username");
String password = request.getParameter("password");
Credentials credentials = new Credentials();
credentials.setSession(httpSession);
credentials.setRequest(request);
credentials.setUsername(username);
credentials.setPassword(password);
SessionListenerCollection listeners = new SessionListenerCollection(httpSession);
if (context == null)
context = authProvider.getUserContext(credentials);
else
context = authProvider.updateUserContext(context, credentials);
if (context == null) {
logger.warn("Authentication attempt from {} for user \"{}\" failed.",
request.getRemoteAddr(), credentials.getUsername());
notifyFailed(listeners, credentials);
}
else {
httpSession.setAttribute(CONTEXT_ATTRIBUTE, context);
}
if (context == null)
throw new GuacamoleSecurityException("Not authenticated");
if (context == null) {
if (context != null)
logger.info("User \"{}\" successfully authenticated from {}.",
context.self().getUsername(), request.getRemoteAddr());
}
else if (!notifySuccess(listeners, context, credentials)) {
logger.info("Successful authentication canceled by hook.");
context = null;
else
httpSession.setAttribute(CONTEXT_ATTRIBUTE, context);
import net.sourceforge.guacamole.net.auth.Credentials;
public class TunnelCloseEvent implements UserEvent, CredentialEvent, TunnelEvent {
private Credentials credentials;
public TunnelCloseEvent(UserContext context, Credentials credentials,
GuacamoleTunnel tunnel) {
this.credentials = credentials;
public Credentials getCredentials() {
return credentials;
}
@Override
import net.sourceforge.guacamole.net.auth.Credentials;
public class TunnelConnectEvent implements UserEvent, CredentialEvent, TunnelEvent {
private Credentials credentials;
public TunnelConnectEvent(UserContext context, Credentials credentials,
GuacamoleTunnel tunnel) {
this.credentials = credentials;
public Credentials getCredentials() {
return credentials;
}
@Override
private static final String CREDENTIALS_ATTRIBUTE = "GUAC_CREDS";
protected Credentials getCredentials(HttpSession session) {
return (Credentials) session.getAttribute(CREDENTIALS_ATTRIBUTE);
}
else {
httpSession.setAttribute(CONTEXT_ATTRIBUTE,     context);
httpSession.setAttribute(CREDENTIALS_ATTRIBUTE, credentials);
}
import net.sourceforge.guacamole.net.auth.Credentials;
private boolean notifyConnect(Collection listeners, UserContext context,
Credentials credentials, GuacamoleTunnel tunnel)
TunnelConnectEvent event = new TunnelConnectEvent(context,
credentials, tunnel);
private boolean notifyClose(Collection listeners, UserContext context,
Credentials credentials, GuacamoleTunnel tunnel)
TunnelCloseEvent event = new TunnelCloseEvent(context,
credentials, tunnel);
final Credentials credentials = getCredentials(httpSession);
if (context == null || credentials == null)
if (!notifyClose(listeners, context, credentials, this))
if (!notifyConnect(listeners, context, credentials, tunnel)) {
public interface Connection extends ConnectionGroupMember {
Directory<String, ConnectionGroup> getConnectionGroupDirectory()
throws GuacamoleException;
public interface Connection {
public interface ConnectionGroup {
Directory<String, Connection> getConnectionDirectory()
throws GuacamoleException;
Directory<String, ConnectionGroup> getConnectionGroupDirectory()
throws GuacamoleException;
ConnectionGroup getConnectionGroup() throws GuacamoleException;
import net.sourceforge.guacamole.net.auth.ConnectionGroup;
private final Directory<String, ConnectionGroup> connectionGroupDirectory;
private final ConnectionGroup connectionGroup;
this.connectionGroupDirectory = new SimpleConnectionGroupDirectory();
this.connectionGroup = new SimpleConnectionGroup(this.connectionDirectory,
this.connectionGroupDirectory);
@Override
public ConnectionGroup getConnectionGroup() throws GuacamoleException {
return connectionGroup;
}
import net.sourceforge.guacamole.net.auth.mysql.dao.ConnectionGroupMapper;
addMapperClass(ConnectionGroupMapper.class);
import net.sourceforge.guacamole.net.auth.ConnectionGroup;
public ConnectionGroup getConnectionGroup() throws GuacamoleException {
throw new UnsupportedOperationException("Not supported yet.");
import net.sourceforge.guacamole.net.auth.mysql.service.ConnectionGroupService;
import net.sourceforge.guacamole.net.auth.mysql.service.SHA256PasswordEncryptionService;
bind(ConnectionGroupService.class);
import net.sourceforge.guacamole.net.auth.mysql.service.ConnectionGroupService;
@Inject
private ConnectionGroupService connectionGroupService;
import net.sourceforge.guacamole.net.auth.mysql.MySQLConnectionGroup;
import net.sourceforge.guacamole.net.auth.mysql.dao.ConnectionGroupMapper;
@Inject
private ConnectionService connectionService;
@Inject
private ConnectionGroupMapper connectionGroupDAO;
@Inject
private Provider<MySQLConnectionGroup> mysqlConnectionGroupProvider;
public GuacamoleSocket connect(MySQLConnectionGroup aThis,
GuacamoleClientInformation info, int userID) {
throw new UnsupportedOperationException("Not yet implemented");
private Directory<String, Connection> connectionDirectory = null;
private Directory<String, ConnectionGroup> connectionGroupDirectory = null;
public void init(Integer connectionGroupID, String identifier, int userID) {
private void loadConnectionDirectory() {
}
if(connectionDirectory == null)
loadConnectionDirectory();
private void loadConnectionGroupDirectory() {
}
if(connectionGroupDirectory == null)
loadConnectionGroupDirectory();
import com.google.common.collect.Lists;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import net.sourceforge.guacamole.net.auth.mysql.model.Connection;
import net.sourceforge.guacamole.net.auth.mysql.model.ConnectionExample;
import net.sourceforge.guacamole.net.auth.mysql.model.ConnectionGroup;
import net.sourceforge.guacamole.net.auth.mysql.model.ConnectionGroupExample;
public GuacamoleSocket connect(MySQLConnectionGroup group,
public Map<Integer, String> retrieveNames(Collection<Integer> ids) {
if (ids.isEmpty())
return Collections.EMPTY_MAP;
Map<Integer, String> names = new HashMap<Integer, String>();
ConnectionGroupExample example = new ConnectionGroupExample();
example.createCriteria().andConnection_group_idIn(Lists.newArrayList(ids));
List<ConnectionGroup> connectionGroups = connectionGroupDAO.selectByExample(example);
for (ConnectionGroup connectionGroup : connectionGroups)
names.put(connectionGroup.getConnection_group_id(),
connectionGroup.getConnection_group_name());
return names;
}
public Set<String> getAllConnectionGroupNames() {
Set<String> names = new HashSet<String>();
List<ConnectionGroup> connectionGroups =
connectionGroupDAO.selectByExample(new ConnectionGroupExample());
for (ConnectionGroup connectionGroup : connectionGroups)
names.add(connectionGroup.getConnection_group_name());
return names;
}
public List<Integer> getAllConnectionGroupIDs() {
List<Integer> connectionGroupIDs = new ArrayList<Integer>();
List<ConnectionGroup> connections =
connectionGroupDAO.selectByExample(new ConnectionGroupExample());
for (ConnectionGroup connection : connections)
connectionGroupIDs.add(connection.getConnection_group_id());
return connectionGroupIDs;
}
import net.sourceforge.guacamole.net.auth.mysql.dao.ConnectionGroupPermissionMapper;
import net.sourceforge.guacamole.net.auth.mysql.model.ConnectionGroupPermissionExample;
import net.sourceforge.guacamole.net.auth.mysql.model.ConnectionGroupPermissionKey;
import net.sourceforge.guacamole.net.auth.permission.ConnectionGroupPermission;
@Inject
private ConnectionGroupService connectionGroupService;
@Inject
private ConnectionGroupPermissionMapper connectionGroupPermissionDAO;
public void verifyConnectionGroupAccess(int userID, int affectedConnectionGroupID, String permissionType) throws GuacamoleSecurityException {
if(!checkConnectionGroupAccess(userID, affectedConnectionGroupID, permissionType))
throw new GuacamoleSecurityException("Permission denied.");
}
public boolean checkConnectionGroupAccess(int userID, Integer affectedConnectionGroupID, String permissionType) {
if(checkSystemAdministratorAccess(userID))
return true;
ConnectionGroupPermissionExample example = new ConnectionGroupPermissionExample();
example.createCriteria().andUser_idEqualTo(userID).andConnection_group_idEqualTo(affectedConnectionGroupID).andPermissionEqualTo(permissionType);
return connectionGroupPermissionDAO.countByExample(example) > 0;
}
public List<Integer> retrieveConnectionGroupIDs(int userID,
String permissionType) {
if(checkSystemAdministratorAccess(userID))
return connectionGroupService.getAllConnectionGroupIDs();
ConnectionGroupPermissionExample example = new ConnectionGroupPermissionExample();
example.createCriteria().andUser_idEqualTo(userID).andPermissionEqualTo(permissionType);
example.setDistinct(true);
List<ConnectionGroupPermissionKey> connectionGroupPermissions =
connectionGroupPermissionDAO.selectByExample(example);
List<Integer> connectionGroupIDs = new ArrayList<Integer>(connectionGroupPermissions.size());
for(ConnectionGroupPermissionKey permission : connectionGroupPermissions)
connectionGroupIDs.add(permission.getConnection_group_id());
return connectionGroupIDs;
}
public Set<ConnectionGroupPermission> retrieveConnectionGroupPermissions(int userID) {
Set<ConnectionGroupPermission> permissions = new HashSet<ConnectionGroupPermission>();
ConnectionGroupPermissionExample connectionGroupPermissionExample = new ConnectionGroupPermissionExample();
connectionGroupPermissionExample.createCriteria().andUser_idEqualTo(userID);
List<ConnectionGroupPermissionKey> connectionGroupPermissions =
connectionGroupPermissionDAO.selectByExample(connectionGroupPermissionExample);
List<Integer> connectionGroupIDs = new ArrayList<Integer>();
for(ConnectionGroupPermissionKey connectionGroupPermission : connectionGroupPermissions)
connectionGroupIDs.add(connectionGroupPermission.getConnection_group_id());
Map<Integer, String> affectedConnectionGroups =
connectionGroupService.retrieveNames(connectionGroupIDs);
for(ConnectionGroupPermissionKey connectionGroupPermission : connectionGroupPermissions) {
ConnectionGroupPermission permission = new ConnectionGroupPermission(
ConnectionGroupPermission.Type.valueOf(connectionGroupPermission.getPermission()),
affectedConnectionGroups.get(connectionGroupPermission.getConnection_group_id())
);
permissions.add(permission);
}
return permissions;
}
allPermissions.addAll(retrieveConnectionGroupPermissions(userID));
private Integer parentID;
public Integer getParentID() {
return parentID;
}
public void setParentID(Integer parentID) {
this.parentID = parentID;
}
public void init(Integer connectionID, Integer parentID, String identifier,
this.parentID = parentID;
import net.sourceforge.guacamole.net.auth.mysql.service.ConnectionService;
import net.sourceforge.guacamole.net.auth.mysql.service.PermissionCheckService;
private Integer parentID;
@Inject
private ConnectionService connectionService;
@Inject
private PermissionCheckService permissionCheckService;
public Integer getParentID() {
return parentID;
}
public void setParentID(Integer parentID) {
this.parentID = parentID;
}
public void init(Integer connectionGroupID, Integer parentID, String identifier, int userID) {
this.parentID = parentID;
public Collection<MySQLConnectionGroup> getConnectionGroupsByParentConnectionGroup(Integer parentID, int userID) {
ConnectionGroupExample example = new ConnectionGroupExample();
if(parentID != null)
example.createCriteria().andParent_group_idEqualTo(parentID);
else
example.createCriteria().andParent_group_idIsNull();
List<ConnectionGroup> connectionGroups = connectionGroupDAO.selectByExample(example);
List<MySQLConnectionGroup> mySQLConnectionGroups = new ArrayList<MySQLConnectionGroup>();
for(ConnectionGroup connectionGroup : connectionGroups) {
mySQLConnectionGroups.add(toMySQLConnectionGroup(connectionGroup, userID));
}
return mySQLConnectionGroups;
}
private MySQLConnectionGroup toMySQLConnectionGroup(ConnectionGroup connectionGroup, int userID) {
MySQLConnectionGroup mySQLConnectionGroup = mysqlConnectionGroupProvider.get();
mySQLConnectionGroup.init(
connectionGroup.getConnection_group_id(),
connectionGroup.getParent_group_id(),
connectionGroup.getConnection_group_name(),
userID
);
return mySQLConnectionGroup;
}
public Collection<MySQLConnection> getConnectionsByParentConnectionGroup(Integer parentID, int userID) {
ConnectionExample example = new ConnectionExample();
if(parentID != null)
example.createCriteria().andConnection_group_idEqualTo(parentID);
else
example.createCriteria().andConnection_group_idIsNull();
List<Connection> connections = connectionDAO.selectByExample(example);
List<MySQLConnection> mySQLConnections = new ArrayList<MySQLConnection>();
for(Connection connection : connections) {
mySQLConnections.add(toMySQLConnection(connection, userID));
}
return mySQLConnections;
}
connection.getConnection_group_id(),
private Integer parentID;
public void init(int user_id, Integer parentID) {
this.parentID = parentID;
public Connection get(String name) throws GuacamoleException {
connectionService.retrieveConnection(name, parentID, user_id);
permissionCheckService.verifyConnectionGroupUsageAccess
(parentID, user_id, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
return permissionCheckService.retrieveConnectionNames(user_id,
parentID, MySQLConstants.CONNECTION_READ);
permissionCheckService.verifyConnectionGroupAccess(this.user_id,
this.parentID, MySQLConstants.CONNECTION_GROUP_UPDATE);
permissionCheckService.verifyConnectionGroupUsageAccess
(parentID, user_id, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
connectionService.retrieveConnection(identifier, user_id, parentID);
connectionService.retrieveConnection(identifier, parentID, user_id);
public void init(Integer connectionID, Integer parentID, String name,
String identifier, GuacamoleConfiguration config,
setName(name);
import com.google.inject.Provider;
private String type;
private ConnectionDirectory connectionDirectory = null;
private ConnectionGroupDirectory connectionGroupDirectory = null;
@Inject Provider<ConnectionDirectory> connectionDirectoryProvider;
@Inject Provider<ConnectionGroupDirectory> connectionGroupDirectoryProvider;
public void init(Integer connectionGroupID, Integer parentID, String name,
String identifier, String type, int userID) {
setName(name);
this.type = type;
connectionDirectory = connectionDirectoryProvider.get();
connectionDirectory.init(userID, parentID);
connectionGroupDirectory = connectionGroupDirectoryProvider.get();
permissionCheckService.verifyConnectionGroupUsageAccess
(this.connectionGroupID, this.userID, MySQLConstants.CONNECTION_GROUP_BALANCING);
return connectionGroupService.connect(this, info, userID);
public String getType() {
return type;
}
public void setType(String type) {
this.type = type;
}
@Override
public void setBalancing(boolean balancing) {
if(balancing)
this.type = MySQLConstants.CONNECTION_GROUP_BALANCING;
else
this.type = MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL;
}
@Override
public boolean isBalancing() {
return MySQLConstants.CONNECTION_GROUP_BALANCING.equals(this.type);
}
public static final String CONNECTION_GROUP_READ = "READ";
public static final String CONNECTION_GROUP_UPDATE = "UPDATE";
public static final String CONNECTION_GROUP_DELETE = "DELETE";
public static final String CONNECTION_GROUP_ADMINISTER = "ADMINISTER";
public static final String CONNECTION_GROUP_BALANCING = "BALANCING";
public static final String CONNECTION_GROUP_ORGANIZATIONAL =
"ORGANIZATIONAL";
public static String getConnectionGroupConstant(ObjectPermission.Type type) {
switch (type) {
case READ:       return CONNECTION_GROUP_READ;
case UPDATE:     return CONNECTION_GROUP_UPDATE;
case ADMINISTER: return CONNECTION_GROUP_ADMINISTER;
case DELETE:     return CONNECTION_GROUP_DELETE;
}
throw new UnsupportedOperationException(
}
import net.sourceforge.guacamole.net.auth.mysql.MySQLConnection;
import net.sourceforge.guacamole.net.auth.mysql.model.Connection;
import net.sourceforge.guacamole.net.auth.mysql.model.ConnectionGroupExample.Criteria;
public MySQLConnectionGroup retrieveConnectionGroup(String name, Integer parentID,
int userID) {
Criteria criteria = example.createCriteria().andConnection_group_nameEqualTo(name);
criteria.andParent_idEqualTo(parentID);
criteria.andParent_idIsNull();
List<ConnectionGroup> connectionGroups =
connectionGroupDAO.selectByExample(example);
if(connectionGroups.isEmpty())
return null;
return toMySQLConnectionGroup(connectionGroups.get(0), userID);
}
public MySQLConnectionGroup retrieveConnectionGroup(int id, int userID) {
ConnectionGroup connectionGroup = connectionGroupDAO.selectByPrimaryKey(id);
if(connectionGroup == null)
return null;
return toMySQLConnectionGroup(connectionGroup, userID);
public Map<String, Integer> translateNames(List<Integer> ids) {
if (ids.isEmpty())
return Collections.EMPTY_MAP;
Map<String, Integer> names = new HashMap<String, Integer>();
ConnectionGroupExample example = new ConnectionGroupExample();
example.createCriteria().andConnection_group_idIn(ids);
List<ConnectionGroup> connectionGroups = connectionGroupDAO.selectByExample(example);
for (ConnectionGroup connectionGroup : connectionGroups)
names.put(connectionGroup.getConnection_group_name(),
connectionGroup.getConnection_group_id());
return names;
}
public List<Integer> getAllConnectionGroupIDs(Integer parentID) {
ConnectionGroupExample example = new ConnectionGroupExample();
Criteria criteria = example.createCriteria();
if(parentID != null)
criteria.andConnection_group_idEqualTo(parentID);
else
criteria.andConnection_group_idIsNull();
List<ConnectionGroup> connectionGroups = connectionGroupDAO.selectByExample(example);
List<Integer> connectionGroupIDs = new ArrayList<Integer>();
for(ConnectionGroup connectionGroup : connectionGroups) {
connectionGroupIDs.add(connectionGroup.getConnection_group_id());
}
return connectionGroupIDs;
}
connectionGroup.getParent_id(),
Integer.toString(connectionGroup.getConnection_group_id()),
connectionGroup.getType(),
import net.sourceforge.guacamole.net.auth.mysql.model.ConnectionExample.Criteria;
public MySQLConnection retrieveConnection(String name, Integer parentID,
int userID) {
Criteria criteria = example.createCriteria().andConnection_nameEqualTo(name);
if(parentID != null)
criteria.andParent_idEqualTo(parentID);
else
criteria.andParent_idIsNull();
public List<Integer> getAllConnectionIDs(Integer parentID) {
ConnectionExample example = new ConnectionExample();
Criteria criteria = example.createCriteria();
if(parentID != null)
criteria.andConnection_idEqualTo(parentID);
else
criteria.andConnection_idIsNull();
List<Connection> connections = connectionDAO.selectByExample(example);
List<Integer> connectionIDs = new ArrayList<Integer>();
for(Connection connection : connections) {
connectionIDs.add(connection.getConnection_id());
}
return connectionIDs;
}
connection.getParent_id(),
Integer.toString(connection.getConnection_id()),
public Set<String> getAllConnectionNames(Integer parentID) {
ConnectionExample example = new ConnectionExample();
Criteria criteria = example.createCriteria();
if(parentID != null)
criteria.andParent_idEqualTo(parentID);
else
criteria.andParent_idIsNull();
connectionDAO.selectByExample(example);
ConnectionExample example = new ConnectionExample();
if(parentID != null)
criteria.andParent_idEqualTo(parentID);
else
connectionDAO.selectByExample(example);
import net.sourceforge.guacamole.net.auth.mysql.MySQLConnectionGroup;
import net.sourceforge.guacamole.net.auth.mysql.model.ConnectionPermissionExample.Criteria;
public void verifyConnectionGroupUsageAccess(Integer connectionGroupID,
int userID, String type) throws GuacamoleSecurityException {
if(!checkConnectionGroupUsageAccess(connectionGroupID, userID, type))
throw new GuacamoleSecurityException("Permission denied.");
}
private boolean checkConnectionGroupUsageAccess(
Integer connectionGroupID, int userID, String usage) {
if(connectionGroupID == null)
return MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL.equals(usage);
if(checkSystemAdministratorAccess(userID))
return true;
MySQLConnectionGroup connectionGroup = connectionGroupService.
retrieveConnectionGroup(connectionGroupID, userID);
if(connectionGroup == null)
return false;
return connectionGroup.getType().equals(usage);
}
private void verifySystemAdministratorAccess(int userID)
throws GuacamoleSecurityException {
if(!checkSystemAdministratorAccess(userID))
throw new GuacamoleSecurityException("Permission denied.");
}
return retrieveConnectionIDs(userID, null, permissionType, false);
}
public List<Integer> retrieveConnectionIDs(int userID, Integer parentID,
String permissionType) {
return retrieveConnectionIDs(userID, parentID, permissionType, true);
}
private List<Integer> retrieveConnectionIDs(int userID, Integer parentID,
String permissionType, boolean checkParentID) {
if(checkSystemAdministratorAccess(userID)) {
if(checkParentID)
return connectionService.getAllConnectionIDs(parentID);
else
return connectionService.getAllConnectionIDs();
}
Criteria criteria = example.createCriteria().andUser_idEqualTo(userID)
.andPermissionEqualTo(permissionType);
if(checkParentID) {
List<Integer> allConnectionIDs = connectionService.getAllConnectionIDs(parentID);
criteria.andConnection_idIn(allConnectionIDs);
}
return retrieveConnectionGroupIDs(userID, null, permissionType, false);
}
public List<Integer> retrieveConnectionGroupIDs(int userID, Integer parentID,
String permissionType) {
return retrieveConnectionGroupIDs(userID, parentID, permissionType, true);
}
private List<Integer> retrieveConnectionGroupIDs(int userID, Integer parentID,
String permissionType, boolean checkParentID) {
if(checkSystemAdministratorAccess(userID)) {
if(checkParentID)
return connectionGroupService.getAllConnectionGroupIDs(parentID);
else
return connectionGroupService.getAllConnectionGroupIDs();
}
ConnectionGroupPermissionExample.Criteria criteria =
example.createCriteria().andUser_idEqualTo(userID)
.andPermissionEqualTo(permissionType);
if(checkParentID) {
List<Integer> allConnectionGroupIDs = connectionGroupService
.getAllConnectionGroupIDs(parentID);
criteria.andConnection_group_idIn(allConnectionGroupIDs);
}
public Set<String> retrieveConnectionNames(int userID, Integer parentID,
String permissionType) {
return connectionService.getAllConnectionNames(parentID);
retrieveConnectionIDs(userID, parentID, permissionType);
public Set<String> retrieveConnectionGroupNames(int userID, Integer parentID,
String permissionType) {
if(checkSystemAdministratorAccess(userID))
return connectionService.getAllConnectionNames(parentID);
List<Integer> connectionGroupIDs =
retrieveConnectionGroupIDs(userID, parentID, permissionType);
return connectionGroupService.translateNames(connectionGroupIDs).keySet();
}
private String name;
public String getName() {
return name;
}
@Override
public void setName(String name) {
this.name = name;
}
@Override
private String name;
@Override
public String getName() {
return name;
}
@Override
public void setName(String name) {
this.name = name;
}
public String getName();
public void setName(String name);
public String getName();
public void setName(String name);
public void setBalancing(boolean balancing);
public boolean isBalancing();
public SimpleConnection(String name, String identifier,
setName(name);
new SimpleConnection(entry.getKey(), entry.getKey(),
entry.getValue()));
@Override
public void setBalancing(boolean balancing) {
}
@Override
public boolean isBalancing() {
return false;
}
import net.sourceforge.guacamole.net.auth.mysql.dao.ConnectionGroupPermissionMapper;
import net.sourceforge.guacamole.net.auth.mysql.model.ConnectionGroupPermissionExample;
import net.sourceforge.guacamole.net.auth.mysql.model.ConnectionGroupPermissionKey;
import net.sourceforge.guacamole.net.auth.mysql.service.ConnectionGroupService;
import net.sourceforge.guacamole.net.auth.permission.ConnectionGroupPermission;
@Inject
private ConnectionGroupService connectionGroupService;
@Inject
private ConnectionGroupPermissionMapper connectionGroupPermissionDAO;
List<ConnectionGroupPermission> newConnectionGroupPermissions = new ArrayList<ConnectionGroupPermission>();
else if (permission instanceof ConnectionGroupPermission)
newConnectionGroupPermissions.add((ConnectionGroupPermission) permission);
createConnectionGroupPermissions(user_id, newConnectionGroupPermissions);
List<ConnectionGroupPermission> removedConnectionGroupPermissions = new ArrayList<ConnectionGroupPermission>();
else if (permission instanceof ConnectionGroupPermission)
removedConnectionGroupPermissions.add((ConnectionGroupPermission) permission);
deleteConnectionGroupPermissions(user_id, removedConnectionGroupPermissions);
private void createConnectionGroupPermissions(int user_id,
Collection<ConnectionGroupPermission> permissions)
throws GuacamoleException {
if(permissions.isEmpty())
return;
List<Integer> administerableConnectionGroupIDs =
permissionCheckService.retrieveConnectionGroupIDs(this.user_id,
MySQLConstants.CONNECTION_GROUP_ADMINISTER);
Map<String, Integer> administerableConnectionGroups =
connectionGroupService.translateNames(administerableConnectionGroupIDs);
for (ConnectionGroupPermission permission : permissions) {
Integer connection_group_id =
administerableConnectionGroups.get(permission.getObjectIdentifier());
if (connection_group_id == null)
throw new GuacamoleSecurityException(
" does not have permission to administrate connection group"
permission.getObjectIdentifier());
ConnectionGroupPermissionKey newPermission = new ConnectionGroupPermissionKey();
newPermission.setUser_id(user_id);
newPermission.setPermission(MySQLConstants.getConnectionConstant(permission.getType()));
newPermission.setConnection_group_id(connection_group_id);
connectionGroupPermissionDAO.insert(newPermission);
}
}
private void deleteConnectionGroupPermissions(int user_id,
Collection<ConnectionGroupPermission> permissions)
throws GuacamoleException {
if(permissions.isEmpty())
return;
List<Integer> administerableConnectionGroupIDs =
permissionCheckService.retrieveConnectionGroupIDs(this.user_id,
MySQLConstants.CONNECTION_GROUP_ADMINISTER);
Map<String, Integer> administerableConnectionGroups =
connectionGroupService.translateNames(administerableConnectionGroupIDs);
for (ConnectionGroupPermission permission : permissions) {
Integer connection_group_id =
administerableConnectionGroups.get(permission.getObjectIdentifier());
if (connection_group_id == null)
throw new GuacamoleSecurityException(
" does not have permission to administrate connection group"
permission.getObjectIdentifier());
ConnectionGroupPermissionExample connectionGroupPermissionExample = new ConnectionGroupPermissionExample();
connectionGroupPermissionExample.createCriteria()
.andUser_idEqualTo(user_id)
.andPermissionEqualTo(MySQLConstants.getConnectionGroupConstant(permission.getType()))
.andConnection_group_idEqualTo(connection_group_id);
connectionGroupPermissionDAO.deleteByExample(connectionGroupPermissionExample);
}
}
import net.sourceforge.guacamole.net.auth.mysql.service.ConnectionGroupService;
@Inject
private ConnectionGroupService connectionGroupService;
public Connection get(String identifier) throws GuacamoleException {
connectionService.retrieveConnection(identifier, user_id);
if(connection == null)
return null;
permissionCheckService.verifyConnectionGroupUsageAccess
(connection.getParentID(), user_id, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
return permissionCheckService.retrieveConnectionIdentifiers(user_id,
String name = object.getName().trim();
if(name.isEmpty())
throw new GuacamoleClientException("The connection name cannot be blank.");
connectionService.retrieveConnection(name, user_id, parentID);
throw new GuacamoleClientException("That connection name is already in use.");
name, object.getConfiguration().getProtocol(), user_id);
connectionService.retrieveConnection(identifier, user_id);
if(mySQLConnection == null)
throw new GuacamoleException("Connection not found.");
permissionCheckService.verifyConnectionGroupUsageAccess
(mySQLConnection.getParentID(), user_id, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
@Override
public void move(String identifier, String groupIdentifier)
throws GuacamoleException {
MySQLConnection mySQLConnection =
connectionService.retrieveConnection(identifier, user_id);
if(mySQLConnection == null)
throw new GuacamoleException("Connection not found.");
permissionCheckService.verifyConnectionAccess(this.user_id,
mySQLConnection.getConnectionID(),
MySQLConstants.CONNECTION_UPDATE);
permissionCheckService.verifyConnectionGroupUsageAccess
(mySQLConnection.getParentID(), user_id, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
permissionCheckService.verifyConnectionGroupAccess(this.user_id,
mySQLConnection.getParentID(), MySQLConstants.CONNECTION_GROUP_UPDATE);
Integer toConnectionGroupID;
if(groupIdentifier.equals(MySQLConstants.CONNECTION_GROUP_ROOT_IDENTIFIER))
toConnectionGroupID = null;
try {
toConnectionGroupID = Integer.valueOf(groupIdentifier);
} catch(NumberFormatException e) {
throw new GuacamoleException("Invalid connection group identifier.");
}
permissionCheckService.verifyConnectionGroupUsageAccess
(toConnectionGroupID, user_id, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
permissionCheckService.verifyConnectionGroupAccess(this.user_id,
toConnectionGroupID, MySQLConstants.CONNECTION_GROUP_UPDATE);
mySQLConnection.setParentID(toConnectionGroupID);
connectionService.updateConnection(mySQLConnection);
}
import net.sourceforge.guacamole.net.auth.mysql.dao.ConnectionGroupPermissionMapper;
import net.sourceforge.guacamole.net.auth.mysql.model.ConnectionGroupPermissionKey;
private ConnectionGroupPermissionMapper connectionGroupPermissionDAO;
public void init(int user_id, Integer parentID) {
this.parentID = parentID;
this.user_id = user_id;
}
public ConnectionGroup get(String identifier) throws GuacamoleException {
connectionGroupService.retrieveConnectionGroup(identifier, user_id);
if(connectionGroup == null)
return null;
permissionCheckService.verifyConnectionGroupUsageAccess
(connectionGroup.getParentID(), user_id, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
return permissionCheckService.retrieveConnectionGroupIdentifiers(user_id,
@Transactional
String name = object.getName().trim();
if(name.isEmpty())
throw new GuacamoleClientException("The connection group name cannot be blank.");
permissionCheckService.verifySystemAccess(this.user_id,
MySQLConstants.SYSTEM_CONNECTION_GROUP_CREATE);
permissionCheckService.verifyConnectionGroupAccess(this.user_id,
this.parentID, MySQLConstants.CONNECTION_GROUP_UPDATE);
permissionCheckService.verifyConnectionGroupUsageAccess
(parentID, user_id, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
MySQLConnectionGroup previousConnectionGroup =
connectionGroupService.retrieveConnectionGroup(name, user_id, parentID);
if(previousConnectionGroup != null)
throw new GuacamoleClientException("That connection group name is already in use.");
MySQLConnectionGroup connectionGroup = connectionGroupService
.createConnectionGroup(name, user_id);
ConnectionGroupPermissionKey newConnectionGroupPermission = new ConnectionGroupPermissionKey();
newConnectionGroupPermission.setUser_id(this.user_id);
newConnectionGroupPermission.setConnection_group_id(connectionGroup.getConnectionGroupID());
newConnectionGroupPermission.setPermission(MySQLConstants.CONNECTION_GROUP_READ);
connectionGroupPermissionDAO.insert(newConnectionGroupPermission);
newConnectionGroupPermission.setPermission(MySQLConstants.CONNECTION_GROUP_UPDATE);
connectionGroupPermissionDAO.insert(newConnectionGroupPermission);
newConnectionGroupPermission.setPermission(MySQLConstants.CONNECTION_GROUP_DELETE);
connectionGroupPermissionDAO.insert(newConnectionGroupPermission);
newConnectionGroupPermission.setPermission(MySQLConstants.CONNECTION_GROUP_ADMINISTER);
connectionGroupPermissionDAO.insert(newConnectionGroupPermission);
@Transactional
if (!(object instanceof MySQLConnectionGroup))
throw new GuacamoleException("Connection not from database.");
MySQLConnectionGroup mySQLConnectionGroup = (MySQLConnectionGroup) object;
permissionCheckService.verifyConnectionAccess(this.user_id,
mySQLConnectionGroup.getConnectionGroupID(),
MySQLConstants.CONNECTION_UPDATE);
connectionGroupService.updateConnectionGroup(mySQLConnectionGroup);
}
@Transactional
@Override
public void remove(String identifier) throws GuacamoleException {
MySQLConnectionGroup mySQLConnectionGroup =
connectionGroupService.retrieveConnectionGroup(identifier, user_id);
if(mySQLConnectionGroup == null)
throw new GuacamoleException("Connection group not found.");
permissionCheckService.verifyConnectionGroupUsageAccess
(mySQLConnectionGroup.getParentID(), user_id, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
permissionCheckService.verifyConnectionGroupAccess(this.user_id,
mySQLConnectionGroup.getConnectionGroupID(),
MySQLConstants.CONNECTION_GROUP_DELETE);
connectionGroupService.deleteConnectionGroup
(mySQLConnectionGroup.getConnectionGroupID());
public void move(String identifier, String groupIdentifier)
throws GuacamoleException {
MySQLConnectionGroup mySQLConnectionGroup =
connectionGroupService.retrieveConnectionGroup(identifier, user_id);
if(mySQLConnectionGroup == null)
throw new GuacamoleException("Connection not found.");
permissionCheckService.verifyConnectionAccess(this.user_id,
mySQLConnectionGroup.getConnectionGroupID(),
MySQLConstants.CONNECTION_GROUP_UPDATE);
permissionCheckService.verifyConnectionGroupUsageAccess
(mySQLConnectionGroup.getParentID(), user_id, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
permissionCheckService.verifyConnectionGroupAccess(this.user_id,
mySQLConnectionGroup.getParentID(), MySQLConstants.CONNECTION_GROUP_UPDATE);
Integer toConnectionGroupID;
if(groupIdentifier.equals(MySQLConstants.CONNECTION_GROUP_ROOT_IDENTIFIER))
toConnectionGroupID = null;
try {
toConnectionGroupID = Integer.valueOf(groupIdentifier);
} catch(NumberFormatException e) {
throw new GuacamoleException("Invalid connection group identifier.");
}
permissionCheckService.verifyConnectionGroupUsageAccess
(toConnectionGroupID, user_id, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
permissionCheckService.verifyConnectionGroupAccess(this.user_id,
toConnectionGroupID, MySQLConstants.CONNECTION_GROUP_UPDATE);
mySQLConnectionGroup.setParentID(toConnectionGroupID);
connectionGroupService.updateConnectionGroup(mySQLConnectionGroup);
connectionGroupDirectory.init(userID, parentID);
public static final String CONNECTION_GROUP_ROOT_IDENTIFIER = "ROOT";
public static final String SYSTEM_CONNECTION_GROUP_CREATE = "CREATE_CONNECTION_GROUP";
@Inject
private MySQLConnectionGroup mySQLConnectionGroup;
mySQLConnectionGroup.init(null, null, MySQLConstants.CONNECTION_GROUP_ROOT_IDENTIFIER,
MySQLConstants.CONNECTION_GROUP_ROOT_IDENTIFIER,
MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL, user_id);
return mySQLConnectionGroup;
@Override
public void move(String identifier, String groupIdentifier)
throws GuacamoleException {
throw new GuacamoleSecurityException("Permission denied.");
}
public MySQLConnectionGroup retrieveConnectionGroup(String uniqueIdentifier, int userID) {
int connectionGroupID;
try {
connectionGroupID = Integer.parseInt(uniqueIdentifier);
} catch(NumberFormatException e) {
return null;
}
return retrieveConnectionGroup(connectionGroupID, userID);
}
public MySQLConnectionGroup createConnectionGroup(String name, int userID) {
ConnectionGroup connectionGroup = new ConnectionGroup();
connectionGroup.setConnection_group_name(name);
connectionGroupDAO.insert(connectionGroup);
return toMySQLConnectionGroup(connectionGroup, userID);
}
public void updateConnectionGroup(MySQLConnectionGroup mySQLConnectionGroup) {
ConnectionGroup connectionGroup = new ConnectionGroup();
connectionGroup.setConnection_group_id(mySQLConnectionGroup.getConnectionGroupID());
connectionGroup.setParent_id(mySQLConnectionGroup.getParentID());
connectionGroup.setConnection_group_name(mySQLConnectionGroup.getName());
connectionGroup.setType(mySQLConnectionGroup.getType());
connectionGroupDAO.updateByPrimaryKeySelective(connectionGroup);
}
public void deleteConnectionGroup(int id) {
connectionGroupDAO.deleteByPrimaryKey(id);
}
public MySQLConnection retrieveConnection(String uniqueIdentifier, int userID) {
int connectionID;
try {
connectionID = Integer.parseInt(uniqueIdentifier);
} catch(NumberFormatException e) {
return null;
}
return retrieveConnection(connectionID, userID);
}
connection.setParent_id(mySQLConnection.getParentID());
connection.setConnection_name(mySQLConnection.getName());
if(affectedConnectionGroupID == null)
return true;
public Set<String> retrieveConnectionIdentifiers(int userID, Integer parentID,
Set<String> connectionIdentifiers = new HashSet<String>();
for(Integer connectionID : connectionIDs)
connectionIdentifiers.add(Integer.toString(connectionID));
return connectionIdentifiers;
public Set<String> retrieveConnectionGroupIdentifiers(int userID, Integer parentID,
Set<String> connectionGroupIdentifiers = new HashSet<String>();
for(Integer connectionGroupID : connectionGroupIDs)
connectionGroupIdentifiers.add(Integer.toString(connectionGroupID));
return connectionGroupIdentifiers;
void move(IdentifierType identifier, IdentifierType groupIdentifier)
throws GuacamoleException;
@Override
public void move(String identifier, String groupIdentifier)
throws GuacamoleException {
throw new GuacamoleSecurityException("Permission denied.");
}
@Override
public void move(String identifier, String groupIdentifier)
throws GuacamoleException {
throw new GuacamoleSecurityException("Permission denied.");
}
@Override
public void move(String identifier, String groupIdentifier)
throws GuacamoleException {
throw new GuacamoleSecurityException("Permission denied.");
}
permissionCheckService.verifyConnectionGroupAccess(this.userID,
this.connectionGroupID,
MySQLConstants.CONNECTION_GROUP_READ);
import net.sourceforge.guacamole.net.auth.mysql.MySQLConstants;
switch(mySQLConnectionGroup.getType()) {
case BALANCING :
connectionGroup.setType(MySQLConstants.CONNECTION_GROUP_BALANCING);
break;
case ORGANIZATIONAL:
connectionGroup.setType(MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
break;
}
private ConnectionGroup.Type type;
@Override
public ConnectionGroup.Type getType() {
return type;
}
@Override
public void setType(ConnectionGroup.Type type) {
this.type = type;
}
public enum Type {
ORGANIZATIONAL, BALANCING
};
public void setType(Type type);
public Type getType();
this.setType(ConnectionGroup.Type.ORGANIZATIONAL);
MySQLConnection previousConnection =
connectionService.retrieveConnection(mySQLConnection.getName(), user_id, parentID);
if(previousConnection != null)
throw new GuacamoleClientException("That connection name is already in use.");
MySQLConnectionGroup previousConnectionGroup =
connectionGroupService.retrieveConnectionGroup(mySQLConnectionGroup.getName(), user_id, parentID);
if(previousConnectionGroup != null)
throw new GuacamoleClientException("That connection group name is already in use.");
import com.google.common.collect.Sets;
Set<Integer> administerableConnectionIDs = Sets.<Integer>newHashSet(
MySQLConstants.CONNECTION_ADMINISTER));
Integer connection_id = Integer.valueOf(permission.getObjectIdentifier());
if (!administerableConnectionIDs.contains(connection_id))
Set<Integer> administerableConnectionGroupIDs = Sets.<Integer>newHashSet(
MySQLConstants.CONNECTION_GROUP_ADMINISTER));
Integer connection_group_id = Integer.valueOf(permission.getObjectIdentifier());
if (!administerableConnectionGroupIDs.contains(connection_group_id))
Set<Integer> administerableConnectionIDs = Sets.<Integer>newHashSet(
MySQLConstants.CONNECTION_ADMINISTER));
Integer connection_id = Integer.valueOf(permission.getObjectIdentifier());
if (!administerableConnectionIDs.contains(connection_id))
Set<Integer> administerableConnectionGroupIDs = Sets.<Integer>newHashSet(
MySQLConstants.CONNECTION_GROUP_ADMINISTER));
Integer connection_group_id = Integer.valueOf(permission.getObjectIdentifier());
if (!administerableConnectionGroupIDs.contains(connection_group_id))
public Set<String> getAllConnectionGroupIdentifiers(Integer parentID) {
Set<String> identifiers = new HashSet<String>();
ConnectionGroupExample example = new ConnectionGroupExample();
Criteria criteria = example.createCriteria();
if(parentID != null)
criteria.andParent_idEqualTo(parentID);
else
criteria.andParent_idIsNull();
List<ConnectionGroup> connectionGroups =
connectionGroupDAO.selectByExample(example);
for (ConnectionGroup connectionGroup : connectionGroups)
identifiers.add(String.valueOf(connectionGroup.getConnection_group_id()));
return identifiers;
}
public Set<String> getAllConnectionIdentifiers(Integer parentID) {
Set<String> identifiers = new HashSet<String>();
identifiers.add(String.valueOf(connection.getConnection_id()));
return identifiers;
return connectionService.getAllConnectionIdentifiers(parentID);
return connectionGroupService.getAllConnectionGroupIdentifiers(parentID);
String.valueOf(connectionPermission.getConnection_id())
String.valueOf(connectionGroupPermission.getConnection_group_id())
name, object.getConfiguration().getProtocol(), user_id, parentID);
.createConnectionGroup(name, user_id, parentID);
public MySQLConnectionGroup createConnectionGroup(String name, int userID,
Integer parentID) {
connectionGroup.setParent_id(parentID);
public MySQLConnection createConnection(String name, String protocol,
int userID, Integer parentID) {
connection.setParent_id(parentID);
private ActiveConnectionMap activeConnectionSet = new ActiveConnectionMap();
bind(ActiveConnectionMap.class).toInstance(activeConnectionSet);
private ActiveConnectionMap activeConnectionSet;
import net.sourceforge.guacamole.GuacamoleClientException;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.net.auth.mysql.ActiveConnectionMap;
import net.sourceforge.guacamole.net.auth.mysql.MySQLConnection;
import net.sourceforge.guacamole.net.auth.mysql.properties.MySQLGuacamoleProperties;
import net.sourceforge.guacamole.properties.GuacamoleProperties;
@Inject
private ConnectionService connectionService;
@Inject
private ActiveConnectionMap activeConnectionMap;
GuacamoleClientInformation info, int userID) throws GuacamoleException {
List<Integer> connectionIDs = connectionService.getAllConnectionIDs
(group.getConnectionGroupID());
Integer leastUsedConnectionID =
activeConnectionMap.getLeastUsedConnection(connectionIDs);
if(leastUsedConnectionID == null)
throw new GuacamoleException("No connections found in group.");
if(GuacamoleProperties.getProperty(
MySQLGuacamoleProperties.MYSQL_DISALLOW_SIMULTANEOUS_CONNECTIONS, false)
&& activeConnectionMap.isActive(leastUsedConnectionID))
throw new GuacamoleClientException
("Cannot connect. All connections are in use.");
MySQLConnection connection = connectionService
.retrieveConnection(leastUsedConnectionID, userID);
return connectionService.connect(connection, info, userID);
import net.sourceforge.guacamole.net.auth.mysql.ActiveConnectionMap;
private ActiveConnectionMap activeConnectionMap;
&& activeConnectionMap.isActive(connection.getConnectionID()))
int historyID = activeConnectionMap.openConnection(connection.getConnectionID(), userID);
private ActiveConnectionMap activeConnectionMap = new ActiveConnectionMap();
bind(ActiveConnectionMap.class).toInstance(activeConnectionMap);
import net.sourceforge.guacamole.net.auth.mysql.dao.ConnectionGroupPermissionMapper;
addMapperClass(ConnectionGroupPermissionMapper.class);
String identifier, ConnectionGroup.Type type, int userID) {
setType(type);
private MySQLConnectionGroup rootConnectionGroup;
rootConnectionGroup.init(null, null,
MySQLConstants.CONNECTION_GROUP_ROOT_IDENTIFIER,
ConnectionGroup.Type.ORGANIZATIONAL, user_id);
return rootConnectionGroup;
String mySqlType = connectionGroup.getType();
net.sourceforge.guacamole.net.auth.ConnectionGroup.Type authType;
if(mySqlType.equals(MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL))
authType = net.sourceforge.guacamole.net.auth.ConnectionGroup.Type.ORGANIZATIONAL;
else
authType = net.sourceforge.guacamole.net.auth.ConnectionGroup.Type.BALANCING;
authType,
int minUserCount = Integer.MAX_VALUE;
Integer minConnectionID = null;
minUserCount = 0;
minConnectionID = connectionID;
else if(connection.getCurrentUserCount() < minUserCount) {
minUserCount = connection.getCurrentUserCount();
minConnectionID = connection.getConnectionID();
}
return minConnectionID;
public void move(String identifier, Directory<String, Connection> directory)
if(!(directory instanceof ConnectionDirectory))
throw new GuacamoleException("Directory not from database");
int toConnectionGroupID = ((ConnectionDirectory)directory).parentID;
public void move(String identifier, Directory<String, ConnectionGroup> directory)
if(!(directory instanceof ConnectionGroupDirectory))
throw new GuacamoleException("Directory not from database");
int toConnectionGroupID = ((ConnectionGroupDirectory)directory).parentID;
public ConnectionGroup getRootConnectionGroup() throws GuacamoleException {
import net.sourceforge.guacamole.net.auth.User;
public class UserDirectory implements Directory<String, User> {
public void move(String identifier, Directory<String, User> groupIdentifier)
void move(IdentifierType identifier, Directory<IdentifierType, ObjectType> directory)
ConnectionGroup getRootConnectionGroup() throws GuacamoleException;
public void move(String identifier, Directory<String, Connection> directory)
public void move(String identifier, Directory<String, ConnectionGroup> directory)
public ConnectionGroup getRootConnectionGroup() throws GuacamoleException {
public void move(String identifier, Directory<String, User> directory)
public class Connection {
Directory<String, Connection> directory =
context.getRootConnectionGroup().getConnectionDirectory();
context.getRootConnectionGroup().getConnectionDirectory();
context.getRootConnectionGroup().getConnectionDirectory();
Directory<String, Connection> directory =
context.getRootConnectionGroup().getConnectionDirectory();
context.getRootConnectionGroup().getConnectionDirectory();
String name     = request.getParameter("name");
connection.setName(name);
xml.writeAttribute("name", connection.getName());
String name       = request.getParameter("name");
String protocol   = request.getParameter("protocol");
connection.setName(name);
import java.util.Set;
import net.sourceforge.guacamole.net.auth.ConnectionGroup;
private static final Permission SYSTEM_PERMISSION =
new SystemPermission(SystemPermission.Type.ADMINISTER);
private void writeConnectionGroup(User self, XMLStreamWriter xml,
ConnectionGroup group) throws GuacamoleException, XMLStreamException {
xml.writeStartElement("group");
xml.writeAttribute("id", group.getIdentifier());
xml.writeAttribute("name", group.getName());
switch (group.getType()) {
case ORGANIZATIONAL:
xml.writeAttribute("type", "organizational");
break;
case BALANCING:
xml.writeAttribute("type", "balancing");
break;
}
writeConnections(self, xml, group.getConnectionDirectory());
writeConnectionGroups(self, xml, group.getConnectionGroupDirectory());
xml.writeEndElement();
}
private void writeConnection(User self, XMLStreamWriter xml,
Connection connection) throws GuacamoleException, XMLStreamException {
xml.writeStartElement("connection");
xml.writeAttribute("id", connection.getIdentifier());
xml.writeAttribute("name", connection.getName());
xml.writeAttribute("protocol",
connection.getConfiguration().getProtocol());
if (self.hasPermission(SYSTEM_PERMISSION) ||
hasConfigPermission(self, ObjectPermission.Type.UPDATE,
connection.getIdentifier())) {
GuacamoleConfiguration config = connection.getConfiguration();
for (String name : config.getParameterNames()) {
String value = connection.getConfiguration().getParameter(name);
xml.writeStartElement("param");
xml.writeAttribute("name", name);
if (value != null)
xml.writeCharacters(value);
xml.writeEndElement();
}
}
xml.writeStartElement("history");
for (ConnectionRecord record : connection.getHistory()) {
xml.writeStartElement("record");
xml.writeAttribute("start",
Long.toString(record.getStartDate().getTime()));
if (record.getEndDate() != null)
xml.writeAttribute("end",
Long.toString(record.getEndDate().getTime()));
if (record.isActive())
xml.writeAttribute("active", "yes");
xml.writeCharacters(record.getUsername());
xml.writeEndElement();
}
xml.writeEndElement();
xml.writeEndElement();
}
private void writeConnectionGroups(User self, XMLStreamWriter xml,
Directory<String, ConnectionGroup> directory)
throws GuacamoleException, XMLStreamException {
Set<String> identifiers = directory.getIdentifiers();
if (identifiers.isEmpty())
return;
xml.writeStartElement("groups");
for (String identifier : identifiers) {
ConnectionGroup group = directory.get(identifier);
writeConnectionGroup(self, xml, group);
}
xml.writeEndElement();
}
private void writeConnections(User self, XMLStreamWriter xml,
Directory<String, Connection> directory)
throws GuacamoleException, XMLStreamException {
Set<String> identifiers = directory.getIdentifiers();
if (identifiers.isEmpty())
return;
xml.writeStartElement("connections");
for (String identifier : identifiers) {
Connection connection = directory.get(identifier);
writeConnection(self, xml, connection);
}
xml.writeEndElement();
}
ConnectionGroup root = context.getRootConnectionGroup();
writeConnectionGroup(self, xml, root);
connectionDirectory.init(userID, connectionGroupID);
connectionGroupDirectory.init(userID, connectionGroupID);
connectionService.retrieveConnection(name, parentID, user_id);
connectionService.retrieveConnection(mySQLConnection.getName(), parentID, user_id);
connectionGroupService.retrieveConnectionGroup(name, parentID, user_id);
connectionGroupService.retrieveConnectionGroup(mySQLConnectionGroup.getName(), parentID, user_id);
import java.util.Collections;
public void verifyConnectionGroupAccess(int userID, Integer affectedConnectionGroupID, String permissionType) throws GuacamoleSecurityException {
if(allConnectionIDs.isEmpty())
return Collections.EMPTY_LIST;
if(allConnectionGroupIDs.isEmpty())
return Collections.EMPTY_LIST;
criteria.andParent_idEqualTo(parentID);
criteria.andParent_idIsNull();
criteria.andParent_idEqualTo(parentID);
criteria.andParent_idIsNull();
case CREATE_USER:             return SYSTEM_USER_CREATE;
case CREATE_CONNECTION:       return SYSTEM_CONNECTION_CREATE;
case CREATE_CONNECTION_GROUP: return SYSTEM_CONNECTION_GROUP_CREATE;
case ADMINISTER:              return SYSTEM_ADMINISTER;
else if(systemPermission.getPermission().equals(MySQLConstants.SYSTEM_CONNECTION_GROUP_CREATE))
permissions.add(new SystemPermission(SystemPermission.Type.CREATE_CONNECTION_GROUP));
CREATE_CONNECTION_GROUP,
newPermission.setPermission(MySQLConstants.getConnectionGroupConstant(permission.getType()));
String parentID = request.getParameter("parentID");
Directory<String, Connection> directory =
ConnectionUtility.findConnectionDirectory(context, parentID);
if(directory == null)
throw new GuacamoleException("Connection directory not found.");
throw new UnsupportedOperationException("Connection unsupported in DummyConnection.");
throw new UnsupportedOperationException("History unsupported in DummyConnection.");
import net.sourceforge.guacamole.net.auth.permission.ConnectionGroupPermission;
case CREATE_USER:             return "create-user";
case CREATE_CONNECTION:       return "create-connection";
case CREATE_CONNECTION_GROUP: return "create-connection-group";
case ADMINISTER:              return "admin";
else if (permission instanceof ConnectionGroupPermission) {
ConnectionGroupPermission cgp =
(ConnectionGroupPermission) permission;
xml.writeEmptyElement("connection-group");
xml.writeAttribute("type", toString(cgp.getType()));
xml.writeAttribute("name", cgp.getObjectIdentifier());
}
String type     = request.getParameter("type");
if("balancing".equals(type))
connectionGroup.setType(ConnectionGroup.Type.BALANCING);
else if("organizational".equals(type))
connectionGroup.setType(ConnectionGroup.Type.ORGANIZATIONAL);
String type       = request.getParameter("type");
if("balancing".equals(type))
connectionGroup.setType(ConnectionGroup.Type.BALANCING);
else if("organizational".equals(type))
connectionGroup.setType(ConnectionGroup.Type.ORGANIZATIONAL);
import net.sourceforge.guacamole.net.auth.ConnectionGroup.Type;
import net.sourceforge.guacamole.net.auth.permission.ObjectPermission;
Type type = object.getType();
String mySQLType = MySQLConstants.getConnectionGroupTypeConstant(type);
.createConnectionGroup(name, user_id, parentID, mySQLType);
import net.sourceforge.guacamole.net.auth.ConnectionGroup;
public static String getConnectionGroupTypeConstant(ConnectionGroup.Type type) {
switch (type) {
case ORGANIZATIONAL: return CONNECTION_GROUP_ORGANIZATIONAL;
case BALANCING:      return CONNECTION_GROUP_BALANCING;
}
throw new UnsupportedOperationException(
}
public MySQLConnectionGroup retrieveConnectionGroup(String uniqueIdentifier,
int userID) throws GuacamoleException {
Integer connectionGroupID = null;
if(!MySQLConstants.CONNECTION_GROUP_ROOT_IDENTIFIER.equals(uniqueIdentifier)) {
try {
connectionGroupID = Integer.parseInt(uniqueIdentifier);
} catch(NumberFormatException e) {
throw new GuacamoleException("Invalid connection group ID.");
}
public MySQLConnectionGroup retrieveConnectionGroup(Integer id, int userID) {
if(id == null) {
MySQLConnectionGroup connectionGroup = mysqlConnectionGroupProvider.get();
connectionGroup.init(null, null,
MySQLConstants.CONNECTION_GROUP_ROOT_IDENTIFIER,
MySQLConstants.CONNECTION_GROUP_ROOT_IDENTIFIER,
net.sourceforge.guacamole.net.auth.ConnectionGroup.Type.BALANCING,
userID);
return connectionGroup;
}
Integer parentID, String type) {
connectionGroup.setType(type);
net.sourceforge.guacamole.net.auth.ConnectionGroup.Type.ORGANIZATIONAL,
connectionService.retrieveConnection(mySQLConnection.getName(),
toConnectionGroupID, user_id);
connectionGroupService.retrieveConnectionGroup(mySQLConnectionGroup.getName(),
toConnectionGroupID, user_id);
if (str.equals(CREATE_USER_PERMISSION))
if (str.equals(CREATE_CONNECTION_PERMISSION))
if (str.equals(ADMIN_PERMISSION))
import net.sourceforge.guacamole.net.auth.permission.ConnectionGroupPermission;
private static final String CREATE_CONNECTION_GROUP_PERMISSION = "create-connection-group";
private Permission parseConnectionGroupPermission(String str)
throws GuacamoleException {
if (str.startsWith(READ_PREFIX))
return new ConnectionGroupPermission(ObjectPermission.Type.READ,
str.substring(READ_PREFIX.length()));
if (str.startsWith(UPDATE_PREFIX))
return new ConnectionGroupPermission(ObjectPermission.Type.UPDATE,
str.substring(UPDATE_PREFIX.length()));
if (str.startsWith(DELETE_PREFIX))
return new ConnectionGroupPermission(ObjectPermission.Type.DELETE,
str.substring(DELETE_PREFIX.length()));
if (str.startsWith(ADMIN_PREFIX))
return new ConnectionGroupPermission(ObjectPermission.Type.ADMINISTER,
str.substring(ADMIN_PREFIX.length()));
throw new GuacamoleClientException("Invalid permission string.");
}
if (add_connection_group_permission != null) {
for (String str : add_connection_group_permission)
user.addPermission(parseConnectionGroupPermission(str));
}
String[] remove_connection_group_permission = request.getParameterValues("-connection-group");
if (remove_connection_group_permission != null) {
for (String str : remove_connection_group_permission)
user.removePermission(parseConnectionGroupPermission(str));
}
if (str.equals(CREATE_CONNECTION_GROUP_PERMISSION))
return new SystemPermission(SystemPermission.Type.CREATE_CONNECTION_GROUP);
import net.sourceforge.guacamole.GuacamoleClientException;
import net.sourceforge.guacamole.net.auth.ConnectionGroup;
private static enum IdentifierType {
CONNECTION("c/"),
CONNECTION_GROUP("g/");
final String PREFIX;
IdentifierType(String prefix) {
PREFIX = prefix;
}
static IdentifierType getType(String identifier) {
if (identifier == null)
return null;
if (identifier.startsWith(CONNECTION.PREFIX))
return CONNECTION;
if (identifier.startsWith(CONNECTION_GROUP.PREFIX))
return CONNECTION_GROUP;
return null;
}
};
IdentifierType id_type = IdentifierType.getType(id);
if (id_type == null)
throw new GuacamoleClientException("Illegal identifier - unknown type.");
id = id.substring(id_type.PREFIX.length());
GuacamoleSocket socket;
switch (id_type) {
case CONNECTION: {
Directory<String, Connection> directory =
context.getRootConnectionGroup().getConnectionDirectory();
Connection connection = directory.get(id);
if (connection == null) {
logger.warn("Connection id={} not found.", id);
throw new GuacamoleSecurityException("Requested connection is not authorized.");
}
socket = connection.connect(info);
logger.info("Successful connection from {} to \"{}\".", request.getRemoteAddr(), id);
break;
}
case CONNECTION_GROUP: {
Directory<String, ConnectionGroup> directory =
context.getRootConnectionGroup().getConnectionGroupDirectory();
ConnectionGroup group = directory.get(id);
if (group == null) {
logger.warn("Connection group id={} not found.", id);
throw new GuacamoleSecurityException("Requested connection group is not authorized.");
}
socket = group.connect(info);
logger.info("Successful connection from {} to group \"{}\".", request.getRemoteAddr(), id);
break;
}
default:
throw new GuacamoleClientException("Connection not supported for provided identifier type.");
}
if(checkConnectionGroupAccess(userID, connectionGroupID,
MySQLConstants.CONNECTION_GROUP_ADMINISTER))
return true;
import net.sourceforge.guacamole.GuacamoleClientException;
import net.sourceforge.guacamole.net.auth.ConnectionGroup;
private static enum IdentifierType {
CONNECTION("c/"),
CONNECTION_GROUP("g/");
final String PREFIX;
IdentifierType(String prefix) {
PREFIX = prefix;
}
static IdentifierType getType(String identifier) {
if (identifier == null)
return null;
if (identifier.startsWith(CONNECTION.PREFIX))
return CONNECTION;
if (identifier.startsWith(CONNECTION_GROUP.PREFIX))
return CONNECTION_GROUP;
return null;
}
};
IdentifierType id_type = IdentifierType.getType(id);
if (id_type == null)
throw new GuacamoleClientException("Illegal identifier - unknown type.");
id = id.substring(id_type.PREFIX.length());
GuacamoleSocket socket;
switch (id_type) {
case CONNECTION: {
Directory<String, Connection> directory =
context.getRootConnectionGroup().getConnectionDirectory();
Connection connection = directory.get(id);
if (connection == null) {
logger.warn("Connection id={} not found.", id);
throw new GuacamoleSecurityException("Requested connection is not authorized.");
}
socket = connection.connect(info);
logger.info("Successful connection from {} to \"{}\".", request.getRemoteAddr(), id);
break;
}
case CONNECTION_GROUP: {
Directory<String, ConnectionGroup> directory =
context.getRootConnectionGroup().getConnectionGroupDirectory();
ConnectionGroup group = directory.get(id);
if (group == null) {
logger.warn("Connection group id={} not found.", id);
throw new GuacamoleSecurityException("Requested connection group is not authorized.");
}
socket = group.connect(info);
logger.info("Successful connection from {} to group \"{}\".", request.getRemoteAddr(), id);
break;
}
default:
throw new GuacamoleClientException("Connection not supported for provided identifier type.");
}
return MySQLConstants.getConnectionGroupTypeConstant(
connectionGroup.getType()).equals(usage);
import net.sourceforge.guacamole.net.auth.permission.ConnectionGroupPermission;
Permission group_admin_permission = new ConnectionGroupPermission(
ObjectPermission.Type.ADMINISTER, group.getIdentifier());
if (group.getType() == ConnectionGroup.Type.ORGANIZATIONAL
|| self.hasPermission(SYSTEM_PERMISSION)
|| self.hasPermission(group_admin_permission)) {
writeConnections(self, xml, group.getConnectionDirectory());
writeConnectionGroups(self, xml, group.getConnectionGroupDirectory());
}
if(MySQLConstants.CONNECTION_GROUP_ROOT_IDENTIFIER.equals(identifier))
throw new GuacamoleException("The root connection group cannot be moved.");
throw new GuacamoleException("Connection group not found.");
Integer relativeParentID = toConnectionGroupID;
while(relativeParentID != null) {
if(relativeParentID == mySQLConnectionGroup.getConnectionGroupID())
throw new GuacamoleException("Connection group cycle detected.");
MySQLConnectionGroup relativeParentGroup = connectionGroupService.
retrieveConnectionGroup(relativeParentID, user_id);
relativeParentID = relativeParentGroup.getParentID();
}
throw new GuacamoleClientException("Directory not from database");
Integer toConnectionGroupID = ((ConnectionDirectory)directory).parentID;
throw new GuacamoleClientException("Connection not found.");
throw new GuacamoleClientException("The root connection group cannot be moved.");
throw new GuacamoleClientException("Directory not from database");
Integer toConnectionGroupID = ((ConnectionGroupDirectory)directory).parentID;
throw new GuacamoleClientException("Connection group not found.");
throw new GuacamoleClientException("Connection group cycle detected.");
connectionGroupDAO.updateByPrimaryKey(connectionGroup);
connectionDAO.updateByPrimaryKey(connection);
if(MySQLConstants.CONNECTION_GROUP_READ.equals(permissionType)
&& MySQLConstants.CONNECTION_GROUP_UPDATE.equals(permissionType)
&& !checkParentID)
connectionGroupIDs.add(null);
permissions.add(new ConnectionGroupPermission(
ConnectionGroupPermission.Type.READ,
MySQLConstants.CONNECTION_GROUP_ROOT_IDENTIFIER
));
permissions.add(new ConnectionGroupPermission(
ConnectionGroupPermission.Type.UPDATE,
MySQLConstants.CONNECTION_GROUP_ROOT_IDENTIFIER
));
if(affectedConnectionGroupID == null &&
MySQLConstants.CONNECTION_GROUP_READ.equals(permissionType) ||
MySQLConstants.CONNECTION_GROUP_UPDATE.equals(permissionType))
public class ConnectionUser {
private int connectionID;
private int userID;
public int getConnectionGroupID() {
return connectionID;
}
public int getUserID() {
return userID;
}
public ConnectionUser(int connectionID, int userID) {
this.connectionID = connectionID;
this.userID = userID;
}
@Override
public boolean equals(Object other) {
if(!(other instanceof ConnectionUser))
return false;
ConnectionUser otherConnectionGroupUser =
(ConnectionUser)other;
return this.connectionID == otherConnectionGroupUser.connectionID
&& this.userID == otherConnectionGroupUser.userID;
}
@Override
public int hashCode() {
int hash = 3;
return hash;
}
}
private Map<ConnectionUser, Integer> activeConnectionGroupUserMap =
new HashMap<ConnectionUser, Integer>();
private Map<ConnectionUser, Integer> activeConnectionUserMap =
new HashMap<ConnectionUser, Integer>();
public int getConnectionGroupUserCount(int connectionGroupID, int userID) {
Integer count = activeConnectionGroupUserMap.get
(new ConnectionUser(connectionGroupID, userID));
if(count == null)
return 0;
return count;
}
public boolean isConnectionGroupUserActive(int connectionGroupID, int userID) {
Integer count = activeConnectionGroupUserMap.get
(new ConnectionUser(connectionGroupID, userID));
return count != null && count > 0;
}
private void incrementConnectionGroupUserCount(int connectionGroupID, int userID) {
int currentCount = getConnectionGroupUserCount(connectionGroupID, userID);
activeConnectionGroupUserMap.put
}
private void decrementConnectionGroupUserCount(int connectionGroupID, int userID) {
int currentCount = getConnectionGroupUserCount(connectionGroupID, userID);
activeConnectionGroupUserMap.put
(new ConnectionUser(connectionGroupID, userID), currentCount - 1);
}
public int getConnectionUserCount(int connectionID, int userID) {
Integer count = activeConnectionUserMap.get
(new ConnectionUser(connectionID, userID));
if(count == null)
return 0;
return count;
}
public boolean isConnectionUserActive(int connectionID, int userID) {
Integer count = activeConnectionUserMap.get
(new ConnectionUser(connectionID, userID));
return count != null && count > 0;
}
private void incrementConnectionUserCount(int connectionID, int userID) {
int currentCount = getConnectionGroupUserCount(connectionID, userID);
activeConnectionUserMap.put
}
private void decrementConnectionUserCount(int connectionID, int userID) {
int currentCount = getConnectionGroupUserCount(connectionID, userID);
activeConnectionUserMap.put
(new ConnectionUser(connectionID, userID), currentCount - 1);
}
public int openConnection(int connectionID, int userID, Integer connectionGroupID) {
incrementConnectionUserCount(connectionID, userID);
if(connectionGroupID != null)
incrementConnectionGroupUserCount(connectionGroupID, userID);
public void closeConnection(int connectionID, int userID, int historyID,
Integer connectionGroupID) throws GuacamoleException {
decrementConnectionUserCount(connectionID, userID);
if(connectionGroupID != null)
decrementConnectionGroupUserCount(connectionGroupID, userID);
return connectionService.connect(this, info, userID, null);
private int userID;
private Integer connectionGroupID;
public void init(GuacamoleSocket socket, int connectionID, int userID,
int historyID, Integer connectionGroupID) {
this.userID = userID;
this.connectionGroupID = connectionGroupID;
activeConnectionSet.closeConnection(connectionID, userID,
historyID, connectionGroupID);
public static final BooleanGuacamoleProperty MYSQL_DISALLOW_DUPLICATE_CONNECTIONS = new BooleanGuacamoleProperty() {
@Override
public String getName() { return "mysql-disallow-duplicate-connections"; }
};
if(GuacamoleProperties.getProperty(
MySQLGuacamoleProperties.MYSQL_DISALLOW_DUPLICATE_CONNECTIONS, true)
&& activeConnectionMap.isConnectionGroupUserActive(group.getConnectionGroupID(), userID))
throw new GuacamoleClientException
("Cannot connect. Connection group already in use by this user.");
return connectionService.connect(connection, info, userID, group.getConnectionGroupID());
GuacamoleClientInformation info, int userID, Integer connectionGroupID)
if(GuacamoleProperties.getProperty(
MySQLGuacamoleProperties.MYSQL_DISALLOW_DUPLICATE_CONNECTIONS, true)
&& activeConnectionMap.isConnectionUserActive(connection.getConnectionID(), userID))
throw new GuacamoleClientException
("Cannot connect. Connection already in use by this user.");
int historyID = activeConnectionMap.openConnection(connection.getConnectionID(),
userID, connectionGroupID);
mySQLGuacamoleSocket.init(socket, connection.getConnectionID(), userID,
historyID, connectionGroupID);
private int identifier;
public int getIdentifier() {
return identifier;
public ConnectionUser(int identifier, int userID) {
this.identifier = identifier;
return this.identifier == otherConnectionGroupUser.identifier
public void closeConnection(int historyID, Integer connectionGroupID)
throws GuacamoleException {
int connectionID = connectionHistory.getConnection_id();
int userID = connectionHistory.getUser_id();
activeConnectionSet.closeConnection(historyID, connectionGroupID);
String host = GuacamoleProperties.getRequiredProperty(GuacamoleProperties.GUACD_HOSTNAME);
int port = GuacamoleProperties.getRequiredProperty(GuacamoleProperties.GUACD_PORT);
if(connections.containsKey(connection.getIdentifier()))
throw new GuacamoleException("Connection identifier already present.");
connections.put(connection.getIdentifier(), connection);
if(!connections.containsKey(connection.getIdentifier()))
throw new GuacamoleException("Connection not found.");
connections.put(connection.getIdentifier(), connection);
if(!connections.containsKey(identifier))
throw new GuacamoleException("Connection not found.");
connections.remove(identifier);
throw new GuacamoleSecurityException("Permission denied.");
throw new GuacamoleSecurityException("Permission denied.");
throw new GuacamoleSecurityException("Permission denied.");
public Connection putConnection(Connection connection) {
return connections.put(connection.getIdentifier(), connection);
}
public Connection removeConnection(String identifier) {
return connections.remove(identifier);
}
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
private Logger logger = LoggerFactory.getLogger(LDAPAuthenticationProvider.class);
logger.info("Anonymous bind is not currently allowed by the LDAP authentication provider.");
logger.info("Anonymous bind is not currently allowed by the LDAP authentication provider.");
String user_dn =
credentials.getPassword().getBytes("UTF-8")
public SimpleConnectionGroup(String name, String identifier,
Directory<String, Connection> connectionDirectory,
setName(name);
setIdentifier(identifier);
setType(ConnectionGroup.Type.ORGANIZATIONAL);
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
private Map<String, ConnectionGroup> connectionGroups =
new HashMap<String, ConnectionGroup>();
public SimpleConnectionGroupDirectory(Collection<ConnectionGroup> groups) {
for (ConnectionGroup group : groups)
connectionGroups.put(group.getIdentifier(), group);
}
return connectionGroups.get(identifier);
return connectionGroups.keySet();
public ConnectionGroup putConnectionGroup(ConnectionGroup connectionGroup) {
return connectionGroups.put(connectionGroup.getIdentifier(), connectionGroup);
}
public ConnectionGroup removeConnectionGroup(String identifier) {
return connectionGroups.remove(identifier);
}
import java.util.Collections;
this.connectionGroup = new SimpleConnectionGroup("ROOT", "ROOT",
new SimpleConnectionDirectory(configs),
new SimpleConnectionGroupDirectory(Collections.EMPTY_LIST));
return new SimpleUserContext(configs);
import java.util.Collection;
import net.sourceforge.guacamole.net.auth.ConnectionGroup;
import net.sourceforge.guacamole.net.auth.permission.ConnectionGroupPermission;
Map<String, GuacamoleConfiguration> configs,
Collection<ConnectionGroup> groups) {
for (ConnectionGroup group : groups) {
Permission permission = new ConnectionGroupPermission(
ObjectPermission.Type.READ,
group.getIdentifier()
);
permissions.add(permission);
}
public SimpleUserContext(Map<String, GuacamoleConfiguration> configs) {
this.self = new SimpleUser("user",
configs, Collections.singleton(connectionGroup));
this.userDirectory = new SimpleUserDirectory(self);
import net.sourceforge.guacamole.GuacamoleServerException;
return GuacamoleProperties.getRequiredProperty(NOAUTH_CONFIG);
if (configs == null)
throw new GuacamoleServerException("Configuration could not be read.");
currentConfig = null;
current = null;
if (current != null)
throw new SAXException("Configurations cannot be nested.");
String name = attributes.getValue("name");
if (name == null)
throw new SAXException("Each configuration must have a name.");
String protocol = attributes.getValue("protocol");
if (protocol == null)
throw new SAXException("Each configuration must have a protocol.");
current = name;
currentConfig.setProtocol(protocol);
if (currentConfig == null)
throw new SAXException("Parameter without corresponding configuration.");
else
package org.glyptodon.guacamole.net.example;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.GuacamoleSocket;
import org.glyptodon.guacamole.net.GuacamoleTunnel;
import org.glyptodon.guacamole.net.InetGuacamoleSocket;
import org.glyptodon.guacamole.protocol.ConfiguredGuacamoleSocket;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
import org.glyptodon.guacamole.servlet.GuacamoleHTTPTunnelServlet;
import org.glyptodon.guacamole.servlet.GuacamoleSession;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.Credentials;
import org.glyptodon.guacamole.net.auth.simple.SimpleAuthenticationProvider;
import org.glyptodon.guacamole.properties.GuacamoleProperties;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
import org.glyptodon.guacamole.properties.IntegerGuacamoleProperty;
import org.glyptodon.guacamole.properties.StringGuacamoleProperty;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.GuacamoleClientException;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.Connection;
import org.glyptodon.guacamole.net.auth.Directory;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
import org.glyptodon.guacamole.GuacamoleClientException;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.ConnectionGroup;
import org.glyptodon.guacamole.net.auth.ConnectionGroup.Type;
import org.glyptodon.guacamole.net.auth.Directory;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.AuthenticationProvider;
import org.glyptodon.guacamole.net.auth.Credentials;
import org.glyptodon.guacamole.net.auth.UserContext;
import org.glyptodon.guacamole.properties.GuacamoleProperties;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.GuacamoleSocket;
import org.glyptodon.guacamole.net.auth.AbstractConnection;
import org.glyptodon.guacamole.net.auth.ConnectionRecord;
import org.glyptodon.guacamole.protocol.GuacamoleClientInformation;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.GuacamoleSocket;
import org.glyptodon.guacamole.net.auth.AbstractConnectionGroup;
import org.glyptodon.guacamole.net.auth.Connection;
import org.glyptodon.guacamole.net.auth.ConnectionGroup;
import org.glyptodon.guacamole.net.auth.Directory;
import org.glyptodon.guacamole.protocol.GuacamoleClientInformation;
import org.glyptodon.guacamole.net.auth.ConnectionRecord;
import org.glyptodon.guacamole.net.auth.ConnectionGroup;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermission;
import org.glyptodon.guacamole.net.auth.permission.SystemPermission;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.io.GuacamoleReader;
import org.glyptodon.guacamole.io.GuacamoleWriter;
import org.glyptodon.guacamole.net.GuacamoleSocket;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.AbstractUser;
import org.glyptodon.guacamole.net.auth.User;
import org.glyptodon.guacamole.net.auth.permission.Permission;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.ConnectionGroup;
import org.glyptodon.guacamole.net.auth.Directory;
import org.glyptodon.guacamole.net.auth.User;
import org.glyptodon.guacamole.net.auth.UserContext;
import org.glyptodon.guacamole.GuacamoleClientException;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.GuacamoleSecurityException;
import org.glyptodon.guacamole.net.auth.Directory;
import org.glyptodon.guacamole.net.auth.User;
import org.glyptodon.guacamole.net.auth.permission.ConnectionGroupPermission;
import org.glyptodon.guacamole.net.auth.permission.ConnectionPermission;
import org.glyptodon.guacamole.net.auth.permission.Permission;
import org.glyptodon.guacamole.net.auth.permission.SystemPermission;
import org.glyptodon.guacamole.net.auth.permission.UserPermission;
public org.glyptodon.guacamole.net.auth.User get(String identifier)
public void add(org.glyptodon.guacamole.net.auth.User object)
public void update(org.glyptodon.guacamole.net.auth.User object)
import org.glyptodon.guacamole.properties.BooleanGuacamoleProperty;
import org.glyptodon.guacamole.properties.IntegerGuacamoleProperty;
import org.glyptodon.guacamole.properties.StringGuacamoleProperty;
import org.glyptodon.guacamole.GuacamoleClientException;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.GuacamoleSocket;
import org.glyptodon.guacamole.properties.GuacamoleProperties;
import org.glyptodon.guacamole.protocol.GuacamoleClientInformation;
org.glyptodon.guacamole.net.auth.ConnectionGroup.Type.ORGANIZATIONAL,
org.glyptodon.guacamole.net.auth.ConnectionGroup.Type authType;
authType = org.glyptodon.guacamole.net.auth.ConnectionGroup.Type.ORGANIZATIONAL;
authType = org.glyptodon.guacamole.net.auth.ConnectionGroup.Type.BALANCING;
import org.glyptodon.guacamole.GuacamoleClientException;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.GuacamoleSocket;
import org.glyptodon.guacamole.net.InetGuacamoleSocket;
import org.glyptodon.guacamole.net.SSLGuacamoleSocket;
import org.glyptodon.guacamole.properties.GuacamoleProperties;
import org.glyptodon.guacamole.protocol.ConfiguredGuacamoleSocket;
import org.glyptodon.guacamole.protocol.GuacamoleClientInformation;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
import org.glyptodon.guacamole.GuacamoleSecurityException;
import org.glyptodon.guacamole.net.auth.permission.ConnectionGroupPermission;
import org.glyptodon.guacamole.net.auth.permission.ConnectionPermission;
import org.glyptodon.guacamole.net.auth.permission.Permission;
import org.glyptodon.guacamole.net.auth.permission.SystemPermission;
import org.glyptodon.guacamole.net.auth.permission.UserPermission;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.Credentials;
public MySQLUser toMySQLUser(org.glyptodon.guacamole.net.auth.User user) throws GuacamoleException {
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.GuacamoleServerException;
import org.glyptodon.guacamole.net.auth.simple.SimpleAuthenticationProvider;
import org.glyptodon.guacamole.net.auth.Credentials;
import org.glyptodon.guacamole.properties.FileGuacamoleProperty;
import org.glyptodon.guacamole.properties.GuacamoleProperties;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
package org.glyptodon.guacamole;
package org.glyptodon.guacamole;
package org.glyptodon.guacamole;
package org.glyptodon.guacamole;
package org.glyptodon.guacamole;
package org.glyptodon.guacamole.io;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.protocol.GuacamoleInstruction;
package org.glyptodon.guacamole.io;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.protocol.GuacamoleInstruction;
package org.glyptodon.guacamole.io;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.GuacamoleServerException;
import org.glyptodon.guacamole.protocol.GuacamoleInstruction;
package org.glyptodon.guacamole.io;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.GuacamoleServerException;
import org.glyptodon.guacamole.protocol.GuacamoleInstruction;
package org.glyptodon.guacamole.io;
package org.glyptodon.guacamole.net;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.io.GuacamoleReader;
import org.glyptodon.guacamole.io.GuacamoleWriter;
package org.glyptodon.guacamole.net;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.io.GuacamoleReader;
import org.glyptodon.guacamole.io.GuacamoleWriter;
package org.glyptodon.guacamole.net;
import org.glyptodon.guacamole.io.GuacamoleReader;
import org.glyptodon.guacamole.io.ReaderGuacamoleReader;
import org.glyptodon.guacamole.io.WriterGuacamoleWriter;
import org.glyptodon.guacamole.io.GuacamoleWriter;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.GuacamoleServerException;
package org.glyptodon.guacamole.net;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.GuacamoleServerException;
import org.glyptodon.guacamole.io.GuacamoleReader;
import org.glyptodon.guacamole.io.GuacamoleWriter;
import org.glyptodon.guacamole.io.ReaderGuacamoleReader;
import org.glyptodon.guacamole.io.WriterGuacamoleWriter;
package org.glyptodon.guacamole.net;
package org.glyptodon.guacamole;
package org.glyptodon.guacamole.protocol;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.GuacamoleServerException;
import org.glyptodon.guacamole.io.GuacamoleReader;
import org.glyptodon.guacamole.io.GuacamoleWriter;
import org.glyptodon.guacamole.net.GuacamoleSocket;
package org.glyptodon.guacamole.protocol;
package org.glyptodon.guacamole.protocol;
package org.glyptodon.guacamole.protocol;
package org.glyptodon.guacamole.protocol;
package org.glyptodon.guacamole.servlet;
import org.glyptodon.guacamole.GuacamoleClientException;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.GuacamoleResourceNotFoundException;
import org.glyptodon.guacamole.GuacamoleSecurityException;
import org.glyptodon.guacamole.GuacamoleServerException;
import org.glyptodon.guacamole.io.GuacamoleReader;
import org.glyptodon.guacamole.io.GuacamoleWriter;
import org.glyptodon.guacamole.net.GuacamoleTunnel;
package org.glyptodon.guacamole.servlet;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.GuacamoleSecurityException;
import org.glyptodon.guacamole.net.GuacamoleTunnel;
package org.glyptodon.guacamole.servlet;
package org.glyptodon.guacamole.net.auth;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
package org.glyptodon.guacamole.net.auth;
package org.glyptodon.guacamole.net.auth;
package org.glyptodon.guacamole.net.auth;
import org.glyptodon.guacamole.GuacamoleException;
package org.glyptodon.guacamole.net.auth;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.GuacamoleSocket;
import org.glyptodon.guacamole.protocol.GuacamoleClientInformation;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
package org.glyptodon.guacamole.net.auth;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.GuacamoleSocket;
import org.glyptodon.guacamole.protocol.GuacamoleClientInformation;
package org.glyptodon.guacamole.net.auth;
package org.glyptodon.guacamole.net.auth;
package org.glyptodon.guacamole.net.auth;
import org.glyptodon.guacamole.GuacamoleException;
package org.glyptodon.guacamole.net.auth;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.permission.Permission;
package org.glyptodon.guacamole.net.auth;
import org.glyptodon.guacamole.GuacamoleException;
package org.glyptodon.guacamole.net.auth;
package org.glyptodon.guacamole.net.auth.permission;
package org.glyptodon.guacamole.net.auth.permission;
package org.glyptodon.guacamole.net.auth.permission;
package org.glyptodon.guacamole.net.auth.permission;
package org.glyptodon.guacamole.net.auth.permission;
package org.glyptodon.guacamole.net.auth.permission;
package org.glyptodon.guacamole.net.auth.permission;
package org.glyptodon.guacamole.net.auth.simple;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.AuthenticationProvider;
import org.glyptodon.guacamole.net.auth.Credentials;
import org.glyptodon.guacamole.net.auth.UserContext;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
package org.glyptodon.guacamole.net.auth.simple;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.GuacamoleSocket;
import org.glyptodon.guacamole.net.InetGuacamoleSocket;
import org.glyptodon.guacamole.net.SSLGuacamoleSocket;
import org.glyptodon.guacamole.net.auth.AbstractConnection;
import org.glyptodon.guacamole.net.auth.ConnectionRecord;
import org.glyptodon.guacamole.properties.GuacamoleProperties;
import org.glyptodon.guacamole.protocol.ConfiguredGuacamoleSocket;
import org.glyptodon.guacamole.protocol.GuacamoleClientInformation;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
package org.glyptodon.guacamole.net.auth.simple;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.GuacamoleSecurityException;
import org.glyptodon.guacamole.net.auth.Connection;
import org.glyptodon.guacamole.net.auth.Directory;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
package org.glyptodon.guacamole.net.auth.simple;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.GuacamoleSecurityException;
import org.glyptodon.guacamole.net.GuacamoleSocket;
import org.glyptodon.guacamole.net.auth.AbstractConnectionGroup;
import org.glyptodon.guacamole.net.auth.Connection;
import org.glyptodon.guacamole.net.auth.ConnectionGroup;
import org.glyptodon.guacamole.net.auth.Directory;
import org.glyptodon.guacamole.protocol.GuacamoleClientInformation;
package org.glyptodon.guacamole.net.auth.simple;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.GuacamoleSecurityException;
import org.glyptodon.guacamole.net.auth.ConnectionGroup;
import org.glyptodon.guacamole.net.auth.Directory;
package org.glyptodon.guacamole.net.auth.simple;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.GuacamoleSecurityException;
import org.glyptodon.guacamole.net.auth.AbstractUser;
import org.glyptodon.guacamole.net.auth.ConnectionGroup;
import org.glyptodon.guacamole.net.auth.permission.ConnectionGroupPermission;
import org.glyptodon.guacamole.net.auth.permission.ConnectionPermission;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermission;
import org.glyptodon.guacamole.net.auth.permission.Permission;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
package org.glyptodon.guacamole.net.auth.simple;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.ConnectionGroup;
import org.glyptodon.guacamole.net.auth.Directory;
import org.glyptodon.guacamole.net.auth.User;
import org.glyptodon.guacamole.net.auth.UserContext;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
package org.glyptodon.guacamole.net.auth.simple;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.GuacamoleSecurityException;
import org.glyptodon.guacamole.net.auth.Directory;
import org.glyptodon.guacamole.net.auth.User;
package org.glyptodon.guacamole.net.auth.simple;
package org.glyptodon.guacamole.net.event;
import org.glyptodon.guacamole.net.auth.Credentials;
package org.glyptodon.guacamole.net.event;
import org.glyptodon.guacamole.net.auth.Credentials;
import org.glyptodon.guacamole.net.auth.UserContext;
package org.glyptodon.guacamole.net.event;
import org.glyptodon.guacamole.net.auth.Credentials;
package org.glyptodon.guacamole.net.event;
import org.glyptodon.guacamole.net.GuacamoleTunnel;
import org.glyptodon.guacamole.net.auth.Credentials;
import org.glyptodon.guacamole.net.auth.UserContext;
package org.glyptodon.guacamole.net.event;
import org.glyptodon.guacamole.net.GuacamoleTunnel;
import org.glyptodon.guacamole.net.auth.Credentials;
import org.glyptodon.guacamole.net.auth.UserContext;
package org.glyptodon.guacamole.net.event;
import org.glyptodon.guacamole.net.GuacamoleTunnel;
package org.glyptodon.guacamole.net.event;
import org.glyptodon.guacamole.net.auth.UserContext;
package org.glyptodon.guacamole.net.event.listener;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.event.AuthenticationFailureEvent;
package org.glyptodon.guacamole.net.event.listener;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.event.AuthenticationSuccessEvent;
package org.glyptodon.guacamole.net.event.listener;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.event.TunnelCloseEvent;
package org.glyptodon.guacamole.net.event.listener;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.event.TunnelConnectEvent;
package org.glyptodon.guacamole.net.event.listener;
package org.glyptodon.guacamole.net.event;
package org.glyptodon.guacamole.properties;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.GuacamoleServerException;
package org.glyptodon.guacamole.properties;
import org.glyptodon.guacamole.GuacamoleException;
package org.glyptodon.guacamole.properties;
package org.glyptodon.guacamole.properties;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.GuacamoleServerException;
package org.glyptodon.guacamole.properties;
import org.glyptodon.guacamole.GuacamoleException;
package org.glyptodon.guacamole.properties;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.GuacamoleServerException;
package org.glyptodon.guacamole.properties;
import org.glyptodon.guacamole.GuacamoleException;
package org.glyptodon.guacamole.properties;
package org.glyptodon.guacamole.net.basic;
import org.glyptodon.guacamole.GuacamoleClientException;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.GuacamoleResourceNotFoundException;
import org.glyptodon.guacamole.GuacamoleSecurityException;
import org.glyptodon.guacamole.net.auth.AuthenticationProvider;
import org.glyptodon.guacamole.net.auth.Credentials;
import org.glyptodon.guacamole.net.auth.UserContext;
import org.glyptodon.guacamole.net.basic.event.SessionListenerCollection;
import org.glyptodon.guacamole.net.basic.properties.BasicGuacamoleProperties;
import org.glyptodon.guacamole.net.event.AuthenticationFailureEvent;
import org.glyptodon.guacamole.net.event.AuthenticationSuccessEvent;
import org.glyptodon.guacamole.net.event.listener.AuthenticationFailureListener;
import org.glyptodon.guacamole.net.event.listener.AuthenticationSuccessListener;
import org.glyptodon.guacamole.properties.GuacamoleProperties;
package org.glyptodon.guacamole.net.basic;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.Credentials;
import org.glyptodon.guacamole.net.auth.simple.SimpleAuthenticationProvider;
import org.glyptodon.guacamole.net.basic.auth.Authorization;
import org.glyptodon.guacamole.net.basic.auth.UserMapping;
import org.glyptodon.guacamole.net.basic.xml.DocumentHandler;
import org.glyptodon.guacamole.net.basic.xml.user_mapping.UserMappingTagHandler;
import org.glyptodon.guacamole.properties.FileGuacamoleProperty;
import org.glyptodon.guacamole.properties.GuacamoleProperties;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
package org.glyptodon.guacamole.net.basic;
import org.glyptodon.guacamole.GuacamoleClientException;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.GuacamoleSecurityException;
import org.glyptodon.guacamole.net.GuacamoleSocket;
import org.glyptodon.guacamole.net.GuacamoleTunnel;
import org.glyptodon.guacamole.net.auth.Connection;
import org.glyptodon.guacamole.net.auth.ConnectionGroup;
import org.glyptodon.guacamole.net.auth.Credentials;
import org.glyptodon.guacamole.net.auth.Directory;
import org.glyptodon.guacamole.net.auth.UserContext;
import org.glyptodon.guacamole.net.basic.event.SessionListenerCollection;
import org.glyptodon.guacamole.net.event.TunnelCloseEvent;
import org.glyptodon.guacamole.net.event.TunnelConnectEvent;
import org.glyptodon.guacamole.net.event.listener.TunnelCloseListener;
import org.glyptodon.guacamole.net.event.listener.TunnelConnectListener;
import org.glyptodon.guacamole.protocol.GuacamoleClientInformation;
import org.glyptodon.guacamole.servlet.GuacamoleHTTPTunnelServlet;
package org.glyptodon.guacamole.net.basic;
import org.glyptodon.guacamole.net.auth.UserContext;
package org.glyptodon.guacamole.net.basic;
package org.glyptodon.guacamole.net.basic;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.basic.properties.BasicGuacamoleProperties;
import org.glyptodon.guacamole.properties.GuacamoleProperties;
package org.glyptodon.guacamole.net.basic;
package org.glyptodon.guacamole.net.basic;
package org.glyptodon.guacamole.net.basic;
package org.glyptodon.guacamole.net.basic;
import org.glyptodon.guacamole.GuacamoleException;
"org.glyptodon.guacamole.net.basic.BasicGuacamoleWebSocketTunnelServlet"
package org.glyptodon.guacamole.net.basic.auth;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
package org.glyptodon.guacamole.net.basic.auth;
package org.glyptodon.guacamole.net.basic.auth;
package org.glyptodon.guacamole.net.basic.crud.connectiongroups;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.ConnectionGroup;
import org.glyptodon.guacamole.net.auth.Directory;
import org.glyptodon.guacamole.net.auth.UserContext;
package org.glyptodon.guacamole.net.basic.crud.connectiongroups;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.ConnectionGroup;
import org.glyptodon.guacamole.net.auth.Directory;
import org.glyptodon.guacamole.net.auth.UserContext;
import org.glyptodon.guacamole.net.basic.AuthenticatingHttpServlet;
package org.glyptodon.guacamole.net.basic.crud.connectiongroups;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.ConnectionGroup;
import org.glyptodon.guacamole.net.auth.Directory;
import org.glyptodon.guacamole.net.auth.UserContext;
import org.glyptodon.guacamole.net.basic.AuthenticatingHttpServlet;
package org.glyptodon.guacamole.net.basic.crud.connectiongroups;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.GuacamoleSocket;
import org.glyptodon.guacamole.net.auth.AbstractConnectionGroup;
import org.glyptodon.guacamole.net.auth.Connection;
import org.glyptodon.guacamole.net.auth.ConnectionGroup;
import org.glyptodon.guacamole.net.auth.Directory;
import org.glyptodon.guacamole.protocol.GuacamoleClientInformation;
package org.glyptodon.guacamole.net.basic.crud.connectiongroups;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.GuacamoleSecurityException;
import org.glyptodon.guacamole.GuacamoleServerException;
import org.glyptodon.guacamole.net.auth.ConnectionGroup;
import org.glyptodon.guacamole.net.auth.Directory;
import org.glyptodon.guacamole.net.auth.User;
import org.glyptodon.guacamole.net.auth.UserContext;
import org.glyptodon.guacamole.net.auth.permission.ConnectionPermission;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermission;
import org.glyptodon.guacamole.net.auth.permission.Permission;
import org.glyptodon.guacamole.net.auth.permission.SystemPermission;
import org.glyptodon.guacamole.net.basic.AuthenticatingHttpServlet;
package org.glyptodon.guacamole.net.basic.crud.connectiongroups;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.ConnectionGroup;
import org.glyptodon.guacamole.net.auth.Directory;
import org.glyptodon.guacamole.net.auth.UserContext;
import org.glyptodon.guacamole.net.basic.AuthenticatingHttpServlet;
package org.glyptodon.guacamole.net.basic.crud.connectiongroups;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.ConnectionGroup;
import org.glyptodon.guacamole.net.auth.Directory;
import org.glyptodon.guacamole.net.auth.UserContext;
import org.glyptodon.guacamole.net.basic.AuthenticatingHttpServlet;
package org.glyptodon.guacamole.net.basic.crud.connections;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.Connection;
import org.glyptodon.guacamole.net.auth.ConnectionGroup;
import org.glyptodon.guacamole.net.auth.Directory;
import org.glyptodon.guacamole.net.auth.UserContext;
package org.glyptodon.guacamole.net.basic.crud.connections;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.Connection;
import org.glyptodon.guacamole.net.auth.Directory;
import org.glyptodon.guacamole.net.auth.UserContext;
import org.glyptodon.guacamole.net.basic.AuthenticatingHttpServlet;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
package org.glyptodon.guacamole.net.basic.crud.connections;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.Connection;
import org.glyptodon.guacamole.net.auth.Directory;
import org.glyptodon.guacamole.net.auth.UserContext;
import org.glyptodon.guacamole.net.basic.AuthenticatingHttpServlet;
package org.glyptodon.guacamole.net.basic.crud.connections;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.GuacamoleSocket;
import org.glyptodon.guacamole.net.auth.AbstractConnection;
import org.glyptodon.guacamole.net.auth.ConnectionRecord;
import org.glyptodon.guacamole.protocol.GuacamoleClientInformation;
package org.glyptodon.guacamole.net.basic.crud.connections;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.GuacamoleSecurityException;
import org.glyptodon.guacamole.GuacamoleServerException;
import org.glyptodon.guacamole.net.auth.Connection;
import org.glyptodon.guacamole.net.auth.ConnectionGroup;
import org.glyptodon.guacamole.net.auth.ConnectionRecord;
import org.glyptodon.guacamole.net.auth.Directory;
import org.glyptodon.guacamole.net.auth.User;
import org.glyptodon.guacamole.net.auth.UserContext;
import org.glyptodon.guacamole.net.auth.permission.ConnectionGroupPermission;
import org.glyptodon.guacamole.net.auth.permission.ConnectionPermission;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermission;
import org.glyptodon.guacamole.net.auth.permission.Permission;
import org.glyptodon.guacamole.net.auth.permission.SystemPermission;
import org.glyptodon.guacamole.net.basic.AuthenticatingHttpServlet;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
package org.glyptodon.guacamole.net.basic.crud.connections;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.Connection;
import org.glyptodon.guacamole.net.auth.Directory;
import org.glyptodon.guacamole.net.auth.UserContext;
import org.glyptodon.guacamole.net.basic.AuthenticatingHttpServlet;
package org.glyptodon.guacamole.net.basic.crud.connections;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.Connection;
import org.glyptodon.guacamole.net.auth.Directory;
import org.glyptodon.guacamole.net.auth.UserContext;
import org.glyptodon.guacamole.net.basic.AuthenticatingHttpServlet;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
package org.glyptodon.guacamole.net.basic.crud.permissions;
import org.glyptodon.guacamole.GuacamoleClientException;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.GuacamoleSecurityException;
import org.glyptodon.guacamole.GuacamoleServerException;
import org.glyptodon.guacamole.net.auth.Directory;
import org.glyptodon.guacamole.net.auth.User;
import org.glyptodon.guacamole.net.auth.UserContext;
import org.glyptodon.guacamole.net.auth.permission.ConnectionGroupPermission;
import org.glyptodon.guacamole.net.auth.permission.ConnectionPermission;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermission;
import org.glyptodon.guacamole.net.auth.permission.Permission;
import org.glyptodon.guacamole.net.auth.permission.SystemPermission;
import org.glyptodon.guacamole.net.auth.permission.UserPermission;
import org.glyptodon.guacamole.net.basic.AuthenticatingHttpServlet;
package org.glyptodon.guacamole.net.basic.crud.protocols;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.GuacamoleServerException;
import org.glyptodon.guacamole.net.auth.UserContext;
import org.glyptodon.guacamole.net.basic.AuthenticatingHttpServlet;
import org.glyptodon.guacamole.net.basic.ProtocolInfo;
import org.glyptodon.guacamole.net.basic.ProtocolParameter;
import org.glyptodon.guacamole.net.basic.ProtocolParameterOption;
import org.glyptodon.guacamole.net.basic.xml.DocumentHandler;
import org.glyptodon.guacamole.net.basic.xml.protocol.ProtocolTagHandler;
import org.glyptodon.guacamole.properties.GuacamoleHome;
package org.glyptodon.guacamole.net.basic.crud.users;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.Directory;
import org.glyptodon.guacamole.net.auth.User;
import org.glyptodon.guacamole.net.auth.UserContext;
import org.glyptodon.guacamole.net.basic.AuthenticatingHttpServlet;
package org.glyptodon.guacamole.net.basic.crud.users;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.Directory;
import org.glyptodon.guacamole.net.auth.User;
import org.glyptodon.guacamole.net.auth.UserContext;
import org.glyptodon.guacamole.net.basic.AuthenticatingHttpServlet;
package org.glyptodon.guacamole.net.basic.crud.users;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.AbstractUser;
import org.glyptodon.guacamole.net.auth.permission.Permission;
package org.glyptodon.guacamole.net.basic.crud.users;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.GuacamoleServerException;
import org.glyptodon.guacamole.net.auth.Directory;
import org.glyptodon.guacamole.net.auth.User;
import org.glyptodon.guacamole.net.auth.UserContext;
import org.glyptodon.guacamole.net.basic.AuthenticatingHttpServlet;
package org.glyptodon.guacamole.net.basic.crud.users;
import org.glyptodon.guacamole.GuacamoleClientException;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.Directory;
import org.glyptodon.guacamole.net.auth.User;
import org.glyptodon.guacamole.net.auth.UserContext;
import org.glyptodon.guacamole.net.auth.permission.ConnectionGroupPermission;
import org.glyptodon.guacamole.net.auth.permission.ConnectionPermission;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermission;
import org.glyptodon.guacamole.net.auth.permission.Permission;
import org.glyptodon.guacamole.net.auth.permission.SystemPermission;
import org.glyptodon.guacamole.net.auth.permission.UserPermission;
import org.glyptodon.guacamole.net.basic.AuthenticatingHttpServlet;
package org.glyptodon.guacamole.net.basic.event;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.basic.properties.BasicGuacamoleProperties;
import org.glyptodon.guacamole.properties.GuacamoleProperties;
package org.glyptodon.guacamole.net.basic.event;
package org.glyptodon.guacamole.net.basic;
package org.glyptodon.guacamole.net.basic.properties;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.AuthenticationProvider;
import org.glyptodon.guacamole.net.basic.GuacamoleClassLoader;
import org.glyptodon.guacamole.properties.GuacamoleProperty;
package org.glyptodon.guacamole.net.basic.properties;
import org.glyptodon.guacamole.properties.FileGuacamoleProperty;
package org.glyptodon.guacamole.net.basic.properties;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.basic.GuacamoleClassLoader;
import org.glyptodon.guacamole.properties.GuacamoleProperty;
package org.glyptodon.guacamole.net.basic.properties;
package org.glyptodon.guacamole.net.basic.xml;
package org.glyptodon.guacamole.net.basic.xml;
package org.glyptodon.guacamole.net.basic.xml;
package org.glyptodon.guacamole.net.basic.xml.protocol;
import org.glyptodon.guacamole.net.basic.ProtocolParameterOption;
import org.glyptodon.guacamole.net.basic.xml.TagHandler;
package org.glyptodon.guacamole.net.basic.xml.protocol;
import org.glyptodon.guacamole.net.basic.ProtocolParameter;
import org.glyptodon.guacamole.net.basic.xml.TagHandler;
package org.glyptodon.guacamole.net.basic.xml.protocol;
import org.glyptodon.guacamole.net.basic.ProtocolInfo;
import org.glyptodon.guacamole.net.basic.xml.TagHandler;
package org.glyptodon.guacamole.net.basic.xml.protocol;
package org.glyptodon.guacamole.net.basic.xml.user_mapping;
import org.glyptodon.guacamole.net.basic.auth.Authorization;
import org.glyptodon.guacamole.net.basic.auth.UserMapping;
import org.glyptodon.guacamole.net.basic.xml.TagHandler;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
package org.glyptodon.guacamole.net.basic.xml.user_mapping;
import org.glyptodon.guacamole.net.basic.auth.Authorization;
import org.glyptodon.guacamole.net.basic.xml.TagHandler;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
package org.glyptodon.guacamole.net.basic.xml.user_mapping;
import org.glyptodon.guacamole.net.basic.xml.TagHandler;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
package org.glyptodon.guacamole.net.basic.xml.user_mapping;
import org.glyptodon.guacamole.net.basic.xml.TagHandler;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
package org.glyptodon.guacamole.net.basic.xml.user_mapping;
import org.glyptodon.guacamole.net.basic.auth.UserMapping;
import org.glyptodon.guacamole.net.basic.xml.TagHandler;
package net.sourceforge.guacamole.net.basic;
package net.sourceforge.guacamole.net.basic;
public static final String CONTEXT_ATTRIBUTE = "GUAC_CONTEXT";
public static final String CREDENTIALS_ATTRIBUTE = "GUAC_CREDS";
private static final String JETTY_WEBSOCKET =
"net.sourceforge.guacamole.net.basic.websocket.jetty.BasicGuacamoleWebSocketTunnelServlet";
private static final String TOMCAT_WEBSOCKET =
"net.sourceforge.guacamole.net.basic.websocket.tomcat.BasicGuacamoleWebSocketTunnelServlet";
private boolean loadWebSocketTunnel(ServletContext context, String classname) {
Class<Servlet> servlet = (Class<Servlet>)
GuacamoleClassLoader.getInstance().findClass(classname);
Method addServlet = ServletContext.class.getMethod("addServlet",
String.class, Class.class);
Object reg = addServlet.invoke(context, "WebSocketTunnel", servlet);
return true;
logger.info("WebSocket support not found.", e);
}
catch (NoClassDefFoundError e) {
logger.info("WebSocket support not found.", e);
return false;
}
@Override
public void contextDestroyed(ServletContextEvent sce) {
}
@Override
public void contextInitialized(ServletContextEvent sce) {
logger.info("Attempting to load Jetty-specific WebSocket support...");
if (loadWebSocketTunnel(sce.getServletContext(), JETTY_WEBSOCKET))
return;
logger.info("Attempting to load Tomcat-specific WebSocket support...");
if (loadWebSocketTunnel(sce.getServletContext(), TOMCAT_WEBSOCKET))
return;
logger.info("No WebSocket support could be loaded. Only HTTP will be used.");
import org.glyptodon.guacamole.properties.BooleanGuacamoleProperty;
import org.glyptodon.guacamole.properties.GuacamoleProperties;
private static final BooleanGuacamoleProperty ENABLE_WEBSOCKET =
new BooleanGuacamoleProperty() {
@Override
public String getName() {
return "enable-websocket";
}
};
logger.info("WebSocket support not found.");
logger.info("WebSocket support not found.");
try {
if (!GuacamoleProperties.getProperty(ENABLE_WEBSOCKET, false)) {
logger.info("WebSocket support not enabled.");
return;
}
}
catch (GuacamoleException e) {
logger.error("Error parsing enable-websocket property.", e);
}
public static final String CONTEXT_ATTRIBUTE = "GUAC_CONTEXT";
public static final String CREDENTIALS_ATTRIBUTE = "GUAC_CREDS";
public static Credentials getCredentials(HttpSession session) {
public static UserContext getUserContext(HttpSession session) {
private static Logger logger = LoggerFactory.getLogger(BasicGuacamoleTunnelServlet.class);
public static enum IdentifierType {
public static boolean notifyConnect(Collection listeners, UserContext context,
public static boolean notifyClose(Collection listeners, UserContext context,
public static GuacamoleTunnel createTunnel(HttpServletRequest request)
throws GuacamoleException {
HttpSession httpSession = request.getSession(true);
final SessionListenerCollection listeners;
try {
listeners = new SessionListenerCollection(httpSession);
}
catch (GuacamoleException e) {
logger.error("Failed to retrieve listeners. Authentication canceled.", e);
throw e;
}
String id = request.getParameter("id");
IdentifierType id_type = IdentifierType.getType(id);
if (id_type == null)
throw new GuacamoleClientException("Illegal identifier - unknown type.");
id = id.substring(id_type.PREFIX.length());
final Credentials credentials = getCredentials(httpSession);
final UserContext context = getUserContext(httpSession);
if (context == null || credentials == null)
throw new GuacamoleSecurityException("Cannot connect - user not logged in.");
GuacamoleClientInformation info = new GuacamoleClientInformation();
String width  = request.getParameter("width");
if (width != null)
info.setOptimalScreenWidth(Integer.parseInt(width));
String height = request.getParameter("height");
if (height != null)
info.setOptimalScreenHeight(Integer.parseInt(height));
String[] audio_mimetypes = request.getParameterValues("audio");
if (audio_mimetypes != null)
info.getAudioMimetypes().addAll(Arrays.asList(audio_mimetypes));
String[] video_mimetypes = request.getParameterValues("video");
if (video_mimetypes != null)
info.getVideoMimetypes().addAll(Arrays.asList(video_mimetypes));
GuacamoleSocket socket;
switch (id_type) {
case CONNECTION: {
Directory<String, Connection> directory =
context.getRootConnectionGroup().getConnectionDirectory();
Connection connection = directory.get(id);
if (connection == null) {
logger.warn("Connection id={} not found.", id);
throw new GuacamoleSecurityException("Requested connection is not authorized.");
}
socket = connection.connect(info);
logger.info("Successful connection from {} to \"{}\".", request.getRemoteAddr(), id);
break;
}
case CONNECTION_GROUP: {
Directory<String, ConnectionGroup> directory =
context.getRootConnectionGroup().getConnectionGroupDirectory();
ConnectionGroup group = directory.get(id);
if (group == null) {
logger.warn("Connection group id={} not found.", id);
throw new GuacamoleSecurityException("Requested connection group is not authorized.");
}
socket = group.connect(info);
logger.info("Successful connection from {} to group \"{}\".", request.getRemoteAddr(), id);
break;
}
default:
throw new GuacamoleClientException("Connection not supported for provided identifier type.");
}
GuacamoleTunnel tunnel = new GuacamoleTunnel(socket) {
@Override
public void close() throws GuacamoleException {
if (!notifyClose(listeners, context, credentials, this))
throw new GuacamoleException("Tunnel close canceled by listener.");
super.close();
}
};
if (!notifyConnect(listeners, context, credentials, tunnel)) {
logger.info("Connection canceled by listener.");
return null;
}
return tunnel;
}
return createTunnel(request);
import org.glyptodon.guacamole.properties.BooleanGuacamoleProperty;
import org.glyptodon.guacamole.properties.GuacamoleProperties;
private static final BooleanGuacamoleProperty ENABLE_WEBSOCKET =
new BooleanGuacamoleProperty() {
@Override
public String getName() {
return "enable-websocket";
}
};
private static final String JETTY_WEBSOCKET =
"org.glyptodon.guacamole.net.basic.websocket.jetty.BasicGuacamoleWebSocketTunnelServlet";
private static final String TOMCAT_WEBSOCKET =
"org.glyptodon.guacamole.net.basic.websocket.tomcat.BasicGuacamoleWebSocketTunnelServlet";
private boolean loadWebSocketTunnel(ServletContext context, String classname) {
Class<Servlet> servlet = (Class<Servlet>)
GuacamoleClassLoader.getInstance().findClass(classname);
Method addServlet = ServletContext.class.getMethod("addServlet",
String.class, Class.class);
Object reg = addServlet.invoke(context, "WebSocketTunnel", servlet);
return true;
catch (NoClassDefFoundError e) {
logger.info("WebSocket support not found.");
}
return false;
}
@Override
public void contextDestroyed(ServletContextEvent sce) {
}
@Override
public void contextInitialized(ServletContextEvent sce) {
try {
if (!GuacamoleProperties.getProperty(ENABLE_WEBSOCKET, false)) {
logger.info("WebSocket support not enabled.");
return;
}
}
catch (GuacamoleException e) {
logger.error("Error parsing enable-websocket property.", e);
}
logger.info("Attempting to load Jetty-specific WebSocket support...");
if (loadWebSocketTunnel(sce.getServletContext(), JETTY_WEBSOCKET))
return;
logger.info("Attempting to load Tomcat-specific WebSocket support...");
if (loadWebSocketTunnel(sce.getServletContext(), TOMCAT_WEBSOCKET))
return;
logger.info("No WebSocket support could be loaded. Only HTTP will be used.");
return BasicTunnelRequestUtility.createTunnel(request);
public void init() throws ServletException {
auth_servlet.init();
}
@Override
import org.glyptodon.guacamole.net.basic.BasicTunnelRequestUtility;
return BasicTunnelRequestUtility.createTunnel(request);
public void init() throws ServletException {
auth_servlet.init();
}
@Override
import org.glyptodon.guacamole.net.basic.BasicTunnelRequestUtility;
return BasicTunnelRequestUtility.createTunnel(request);
import java.util.List;
protected String selectSubProtocol(List<String> subProtocols) {
for (String protocol : subProtocols)
if ("guacamole".equals(protocol))
return "guacamole";
return null;
}
@Override
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
private static Logger logger = LoggerFactory.getLogger(GuacamoleWebSocketTunnelServlet.class);
logger.error("Error connecting WebSocket tunnel.", e);
return null;
logger.debug("Tunnel write failed.", e);
logger.debug("Tunnel read failed due to I/O error.", e);
logger.debug("Tunnel read failed.", e);
logger.debug("Unable to close WebSocket tunnel.", e);
logger.debug("Tunnel write failed.", e);
logger.debug("Tunnel read failed due to I/O error.", e);
logger.debug("Tunnel read failed.", e);
logger.debug("Unable to close WebSocket tunnel.", e);
ENUM,
MULTILINE
case MULTILINE:
xml.writeAttribute("type", "multiline");
break;
else if ("multiline".equals(type))
protocolParameter.setType(ProtocolParameter.Type.MULTILINE);
Guice.createInjector(
new RESTServletModule(),
new RESTModule()
);
import com.google.inject.Inject;
import javax.ws.rs.QueryParam;
import javax.ws.rs.WebApplicationException;
import javax.ws.rs.core.Response;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.GuacamoleSecurityException;
import org.glyptodon.guacamole.net.auth.UserContext;
import org.glyptodon.guacamole.net.basic.rest.auth.TokenUserContextMap;
@Inject
private TokenUserContextMap tokenUserMap;
public String getConnections(@QueryParam("token") String authToken) {
UserContext userContext = tokenUserMap.get(authToken);
if(userContext == null)
throw new WebApplicationException(Response.Status.UNAUTHORIZED);
try {
return userContext.getRootConnectionGroup().getConnectionDirectory().getIdentifiers().toString();
} catch(GuacamoleSecurityException e) {
throw new WebApplicationException(e, Response.Status.UNAUTHORIZED);
} catch(GuacamoleException e) {
throw new WebApplicationException(e, Response.Status.INTERNAL_SERVER_ERROR);
}
import org.glyptodon.guacamole.net.basic.rest.connection.ConnectionService;
bind(ConnectionService.class);
import com.google.inject.Scopes;
import org.codehaus.jackson.jaxrs.JacksonJsonProvider;
import org.glyptodon.guacamole.net.basic.rest.auth.LoginRESTService;
import org.glyptodon.guacamole.net.basic.rest.connection.ConnectionRESTService;
bind(ConnectionRESTService.class);
bind(LoginRESTService.class);
bind(GuiceContainer.class);
bind(JacksonJsonProvider.class).in(Scopes.SINGLETON);
serve("/*").with(GuiceContainer.class);
public class LoginRESTService {
private static final Logger logger = LoggerFactory.getLogger(LoginRESTService.class);
import java.util.ArrayList;
import java.util.List;
import org.glyptodon.guacamole.GuacamoleException;
public List<Connection> convertConnectionList(List<? extends org.glyptodon.guacamole.net.auth.Connection> connections)
throws GuacamoleException {
List<Connection> restConnections = new ArrayList<Connection>();
for(org.glyptodon.guacamole.net.auth.Connection connection : connections) {
restConnections.add(new Connection(connection));
return restConnections;
}
import java.util.HashMap;
import java.util.Map;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
import org.glyptodon.guacamole.net.basic.rest.APIError;
@Produces(MediaType.APPLICATION_JSON)
public APIAuthToken login(@QueryParam("username") String username,
throw new WebApplicationException(
Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(e).build());
throw new WebApplicationException(
Response.status(Response.Status.UNAUTHORIZED)
.entity(new APIError("Permission Denied.")).build());
return new APIAuthToken(authToken);
@Produces(MediaType.APPLICATION_JSON)
throw new WebApplicationException(
Response.status(Response.Status.UNAUTHORIZED)
.entity(new APIError("Permission Denied.")).build());
throw new WebApplicationException(
Response.status(Response.Status.UNAUTHORIZED)
.entity(new APIError("Permission Denied.")).build());
throw new WebApplicationException(
Response.status(Response.Status.INTERNAL_SERVER_ERROR)
.entity(e).build());
import org.glyptodon.guacamole.net.basic.rest.auth.AuthenticationService;
bind(AuthenticationService.class);
import org.glyptodon.guacamole.net.basic.rest.auth.AuthenticationService;
private AuthenticationService authenticationService;
UserContext userContext = authenticationService.getUserContextFromAuthToken(authToken);
}
import org.glyptodon.guacamole.net.auth.Connection;
public class APIConnection {
public APIConnection() {}
public APIConnection(Connection connection)
import javax.ws.rs.PathParam;
import org.glyptodon.guacamole.net.auth.Connection;
public List<APIConnection> getConnections(@QueryParam("token") String authToken, @QueryParam("parentID") String parentID) {
Directory<String, Connection> connectionDirectory =
List<Connection> connections = new ArrayList<Connection>();
@GET
@Path("/{connectionID}")
public APIConnection getConnection(@QueryParam("token") String authToken, @PathParam("connectionID") String connectionID) {
UserContext userContext = authenticationService.getUserContextFromAuthToken(authToken);
try {
ConnectionGroup rootGroup = userContext.getRootConnectionGroup();
Directory<String, Connection> connectionDirectory =
rootGroup.getConnectionDirectory();
Connection connection = connectionDirectory.get(connectionID);
if(connection == null)
throw new WebApplicationException(
Response.status(Response.Status.BAD_REQUEST)
.entity(new APIError("No Connection found with the provided ID."))
.build());
return new APIConnection(connection);
} catch(GuacamoleSecurityException e) {
throw new WebApplicationException(
Response.status(Response.Status.UNAUTHORIZED)
.entity(new APIError("Permission Denied.")).build());
} catch(GuacamoleException e) {
throw new WebApplicationException(
Response.status(Response.Status.INTERNAL_SERVER_ERROR)
.entity(e).build());
}
}
public List<APIConnection> convertConnectionList(List<? extends org.glyptodon.guacamole.net.auth.Connection> connections)
List<APIConnection> restConnections = new ArrayList<APIConnection>();
restConnections.add(new APIConnection(connection));
import javax.ws.rs.core.Response.Status;
import org.glyptodon.guacamole.net.basic.rest.HTTPException;
throw new HTTPException(Status.UNAUTHORIZED, "Permission Denied.");
import javax.ws.rs.core.Response.Status;
import org.glyptodon.guacamole.net.basic.rest.HTTPException;
throw new HTTPException(Status.INTERNAL_SERVER_ERROR,
"Unexpected server error.");
throw new HTTPException(Status.UNAUTHORIZED, "Permission Denied.");
import javax.ws.rs.core.Response.Status;
import org.glyptodon.guacamole.net.basic.rest.HTTPException;
throw new HTTPException(Status.BAD_REQUEST,
"No ConnectionGroup found with the provided parentID.");
throw new HTTPException(Status.UNAUTHORIZED, "Permission Denied.");
throw new HTTPException(Status.INTERNAL_SERVER_ERROR,
"Unexpected server error.");
throw new HTTPException(Status.BAD_REQUEST,
"No Connection found with the provided ID.");
throw new HTTPException(Status.UNAUTHORIZED, "Permission Denied.");
throw new HTTPException(Status.INTERNAL_SERVER_ERROR,
"Unexpected server error.");
import org.glyptodon.guacamole.net.auth.Connection;
public List<APIConnection> convertConnectionList(List<? extends Connection> connections)
for(Connection connection : connections) {
import javax.ws.rs.DELETE;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
private static final Logger logger = LoggerFactory.getLogger(ConnectionRESTService.class);
logger.error("Unexpected GuacamoleException caught while listing connections.", e);
logger.error("Unexpected GuacamoleException caught while getting a connection.", e);
throw new HTTPException(Status.INTERNAL_SERVER_ERROR,
}
}
@DELETE
@Path("/{connectionID}")
public void deleteConnection(@QueryParam("token") String authToken, @PathParam("connectionID") String connectionID) {
UserContext userContext = authenticationService.getUserContextFromAuthToken(authToken);
try {
ConnectionGroup rootGroup = userContext.getRootConnectionGroup();
Directory<String, Connection> connectionDirectory =
rootGroup.getConnectionDirectory();
if(connectionDirectory.get(connectionID) == null)
throw new HTTPException(Status.BAD_REQUEST,
"No Connection found with the provided ID.");
connectionDirectory.remove(connectionID);
} catch(GuacamoleSecurityException e) {
throw new HTTPException(Status.UNAUTHORIZED, "Permission Denied.");
} catch(GuacamoleException e) {
logger.error("Unexpected GuacamoleException caught while deleting a connection.", e);
throw new HTTPException(Status.INTERNAL_SERVER_ERROR,
import org.glyptodon.guacamole.properties.LongGuacamoleProperty;
public static final LongGuacamoleProperty API_SESSION_TIMEOUT = new LongGuacamoleProperty() {
@Override
public String getName() { return "api-session-timeout"; }
};
import java.util.Date;
import java.util.Map;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.basic.properties.BasicGuacamoleProperties;
import org.glyptodon.guacamole.properties.GuacamoleProperties;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class BasicTokenUserContextMap implements TokenUserContextMap {
private static Logger logger = LoggerFactory.getLogger(BasicTokenUserContextMap.class);
private Map<String, Long> lastAccessTimeMap = new HashMap<String, Long>();
private Map<String, UserContext> userContextMap = new HashMap<String, UserContext>();
private final long SESSION_TIMEOUT;
public BasicTokenUserContextMap() {
super();
long sessionTimeoutValue = 3600000l;
try {
sessionTimeoutValue = GuacamoleProperties.getProperty(BasicGuacamoleProperties.API_SESSION_TIMEOUT, 3600000l);
} catch (GuacamoleException e) {
logger.error("Unexpected GuacamoleException caught while reading API_SESSION_TIMEOUT property.", e);
}
SESSION_TIMEOUT = sessionTimeoutValue;
}
private void evict(String authToken) {
userContextMap.remove(authToken);
lastAccessTimeMap.remove(authToken);
}
private void logAccessTime(String authToken) {
lastAccessTimeMap.put(authToken, new Date().getTime());
}
private boolean sessionHasTimedOut(String authToken) {
if(!lastAccessTimeMap.containsKey(authToken))
return true;
long lastAccessTime = lastAccessTimeMap.get(authToken);
long currentTime = new Date().getTime();
return currentTime - lastAccessTime > SESSION_TIMEOUT;
}
@Override
public UserContext get(String authToken) {
if(sessionHasTimedOut(authToken)) {
evict(authToken);
return null;
}
logAccessTime(authToken);
return userContextMap.get(authToken);
}
@Override
public void put(String authToken, UserContext userContext) {
logAccessTime(authToken);
userContextMap.put(authToken, userContext);
}
}
public interface TokenUserContextMap {
public void put(String authToken, UserContext userContext);
public UserContext get(String authToken);
}
long sessionTimeoutValue;
}
catch (GuacamoleException e) {
logger.error("Unexpected GuacamoleException caught while reading API_SESSION_TIMEOUT property. Defaulting to 1 hour.", e);
sessionTimeoutValue = 3600000l;
import org.glyptodon.guacamole.net.GuacamoleSocket;
import org.glyptodon.guacamole.protocol.GuacamoleClientInformation;
public class APIConnection implements Connection {
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
public GuacamoleSocket connect(GuacamoleClientInformation info) throws GuacamoleException {
throw new UnsupportedOperationException("Not supported.");
}
import javax.ws.rs.POST;
import javax.ws.rs.PUT;
public APIConnection getConnection(@QueryParam("token") String authToken,
@PathParam("connectionID") String connectionID) {
@POST
public String createConnection(@QueryParam("token") String authToken,
@QueryParam("parentID") String parentID, APIConnection connection) {
UserContext userContext = authenticationService.getUserContextFromAuthToken(authToken);
if(connection == null)
throw new HTTPException(Status.BAD_REQUEST,
"A connection is required for this request.");
try {
ConnectionGroup parentConnectionGroup;
if(parentID == null)
parentConnectionGroup = userContext.getRootConnectionGroup();
else {
ConnectionGroup rootGroup = userContext.getRootConnectionGroup();
Directory<String, ConnectionGroup> connectionGroupDirectory = rootGroup.getConnectionGroupDirectory();
parentConnectionGroup = connectionGroupDirectory.get(parentID);
}
if(parentConnectionGroup == null)
throw new HTTPException(Status.BAD_REQUEST,
"No ConnectionGroup found with the provided parentID.");
Directory<String, Connection> connectionDirectory =
parentConnectionGroup.getConnectionDirectory();
connectionDirectory.add(connection);
return connection.getIdentifier();
} catch(GuacamoleSecurityException e) {
throw new HTTPException(Status.UNAUTHORIZED, "Permission Denied.");
} catch(GuacamoleException e) {
logger.error("Unexpected GuacamoleException caught while listing connections.", e);
throw new HTTPException(Status.INTERNAL_SERVER_ERROR,
}
}
@POST
@Path("/{connectionID}")
public void updateConnection(@QueryParam("token") String authToken,
@PathParam("connectionID") String connectionID, APIConnection connection) {
UserContext userContext = authenticationService.getUserContextFromAuthToken(authToken);
if(connection == null)
throw new HTTPException(Status.BAD_REQUEST,
"A connection is required for this request.");
try {
ConnectionGroup rootGroup = userContext.getRootConnectionGroup();
Directory<String, Connection> connectionDirectory =
rootGroup.getConnectionDirectory();
if(connectionDirectory.get(connectionID) == null)
throw new HTTPException(Status.BAD_REQUEST,
"No Connection with the provided ID.");
connectionDirectory.update(connection);
} catch(GuacamoleSecurityException e) {
throw new HTTPException(Status.UNAUTHORIZED, "Permission Denied.");
} catch(GuacamoleException e) {
logger.error("Unexpected GuacamoleException caught while listing connections.", e);
throw new HTTPException(Status.INTERNAL_SERVER_ERROR,
}
}
@PUT
@Path("/{connectionID}")
public void moveConnection(@QueryParam("token") String authToken,
@PathParam("connectionID") String connectionID, @QueryParam("parentID") String parentID) {
UserContext userContext = authenticationService.getUserContextFromAuthToken(authToken);
try {
ConnectionGroup rootGroup = userContext.getRootConnectionGroup();
Directory<String, Connection> connectionDirectory =
rootGroup.getConnectionDirectory();
Directory<String, ConnectionGroup> connectionGroupDirectory = rootGroup.getConnectionGroupDirectory();
ConnectionGroup parentConnectionGroup = connectionGroupDirectory.get(parentID);
if(parentConnectionGroup == null)
throw new HTTPException(Status.BAD_REQUEST,
"No ConnectionGroup found with the provided parentID.");
if(connectionDirectory.get(connectionID) == null)
throw new HTTPException(Status.BAD_REQUEST,
"No Connection found with the provided ID.");
connectionDirectory.move(connectionID, connectionDirectory);
} catch(GuacamoleSecurityException e) {
throw new HTTPException(Status.UNAUTHORIZED, "Permission Denied.");
} catch(GuacamoleException e) {
logger.error("Unexpected GuacamoleException caught while deleting a connection.", e);
throw new HTTPException(Status.INTERNAL_SERVER_ERROR,
}
}
object.setIdentifier(connection.getIdentifier());
object.setIdentifier(connectionGroup.getIdentifier());
import javax.ws.rs.Consumes;
@Consumes(MediaType.APPLICATION_JSON)
import org.glyptodon.guacamole.GuacamoleClientException;
throw new GuacamoleClientException("No ConnectionGroup found with the provided parentID.");
throw new HTTPException(Status.UNAUTHORIZED, e.getMessage() != null ? e.getMessage() : "Permission denied.");
} catch(GuacamoleClientException e) {
throw new HTTPException(Status.BAD_REQUEST, e.getMessage() != null ? e.getMessage() : "Invalid Request.");
throw new HTTPException(Status.INTERNAL_SERVER_ERROR, e.getMessage() != null ? e.getMessage() : "Unexpected server error.");
throw new GuacamoleClientException("No Connection found with the provided ID.");
throw new HTTPException(Status.UNAUTHORIZED, e.getMessage() != null ? e.getMessage() : "Permission denied.");
} catch(GuacamoleClientException e) {
throw new HTTPException(Status.BAD_REQUEST, e.getMessage() != null ? e.getMessage() : "Invalid Request.");
logger.error("Unexpected GuacamoleException caught while getting connection.", e);
throw new HTTPException(Status.INTERNAL_SERVER_ERROR, e.getMessage() != null ? e.getMessage() : "Unexpected server error.");
throw new GuacamoleClientException("No Connection found with the provided ID.");
throw new HTTPException(Status.UNAUTHORIZED, e.getMessage() != null ? e.getMessage() : "Permission denied.");
} catch(GuacamoleClientException e) {
throw new HTTPException(Status.BAD_REQUEST, e.getMessage() != null ? e.getMessage() : "Invalid Request.");
logger.error("Unexpected GuacamoleException caught while deleting connection.", e);
throw new HTTPException(Status.INTERNAL_SERVER_ERROR, e.getMessage() != null ? e.getMessage() : "Unexpected server error.");
if(connection == null)
throw new GuacamoleClientException("A connection is required for this request.");
throw new GuacamoleClientException("No ConnectionGroup found with the provided parentID.");
throw new HTTPException(Status.UNAUTHORIZED, e.getMessage() != null ? e.getMessage() : "Permission denied.");
} catch(GuacamoleClientException e) {
throw new HTTPException(Status.BAD_REQUEST, e.getMessage() != null ? e.getMessage() : "Invalid Request.");
logger.error("Unexpected GuacamoleException caught while creating connection.", e);
throw new HTTPException(Status.INTERNAL_SERVER_ERROR, e.getMessage() != null ? e.getMessage() : "Unexpected server error.");
if(connection == null)
throw new GuacamoleClientException("A connection is required for this request.");
throw new GuacamoleClientException("No Connection with the provided ID.");
throw new HTTPException(Status.UNAUTHORIZED, e.getMessage() != null ? e.getMessage() : "Permission denied.");
} catch(GuacamoleClientException e) {
throw new HTTPException(Status.BAD_REQUEST, e.getMessage() != null ? e.getMessage() : "Invalid Request.");
logger.error("Unexpected GuacamoleException caught updating connection.", e);
throw new HTTPException(Status.INTERNAL_SERVER_ERROR, e.getMessage() != null ? e.getMessage() : "Unexpected server error.");
throw new GuacamoleClientException("No ConnectionGroup found with the provided parentID.");
throw new GuacamoleClientException("No Connection found with the provided ID.");
throw new HTTPException(Status.UNAUTHORIZED, e.getMessage() != null ? e.getMessage() : "Permission denied.");
} catch(GuacamoleClientException e) {
throw new HTTPException(Status.BAD_REQUEST, e.getMessage() != null ? e.getMessage() : "Invalid Request.");
logger.error("Unexpected GuacamoleException caught moving connection.", e);
throw new HTTPException(Status.INTERNAL_SERVER_ERROR, e.getMessage() != null ? e.getMessage() : "Unexpected server error.");
import java.util.HashMap;
import java.util.Map;
public class APIConnection {
private Map<String, String> parameters = new HashMap<String, String>();
public Map<String, String> getParameters() {
return parameters;
public void setParameters(Map<String, String> parameters) {
this.parameters = parameters;
connectionDirectory.add(new APIConnectionWrapper(connection));
connectionDirectory.update(new APIConnectionWrapper(connection));
package org.glyptodon.guacamole.net.basic.rest.auth;
import org.glyptodon.guacamole.net.basic.rest.connectiongroup.ConnectionGroupService;
bind(ConnectionGroupService.class);
import org.glyptodon.guacamole.net.basic.rest.connectiongroup.ConnectionGroupRESTService;
bind(ConnectionGroupRESTService.class);
connectionDirectory.move(connectionID, parentConnectionGroup.getConnectionDirectory());
import org.glyptodon.guacamole.net.basic.rest.permission.PermissionService;
bind(PermissionService.class);
import org.glyptodon.guacamole.net.basic.rest.permission.PermissionRESTService;
bind(PermissionRESTService.class);
public List<APIConnection> convertConnectionList(Iterable<? extends Connection> connections)
Iterable<? extends ConnectionGroup> connectionGroups) {
Set<Permission> permissionsToRemove = new HashSet<Permission>(originalPermissions);
import org.codehaus.jackson.map.annotate.JsonSerialize;
@JsonSerialize(include=JsonSerialize.Inclusion.NON_NULL)
this.objectIdentifier = ((ConnectionPermission) permission).getObjectIdentifier();
this.objectIdentifier = ((ConnectionGroupPermission) permission).getObjectIdentifier();
this.objectIdentifier = ((UserPermission) permission).getObjectIdentifier();
public Permission toPermission() {
permissions.add(restPermission.toPermission());
if(user == null)
return null;
return user;
public void addPermission(@QueryParam("token") String authToken,
@PathParam("userID") String userID, APIPermission permission) {
user.addPermission(permission.toPermission());
logger.error("Unexpected GuacamoleException caught adding permission.", e);
throw new HTTPException(Status.INTERNAL_SERVER_ERROR, e.getMessage() != null ? e.getMessage() : "Unexpected server error.");
}
}
@POST
@Path("/{userID}/remove")
public void removePermission(@QueryParam("token") String authToken,
@PathParam("userID") String userID, APIPermission permission) {
UserContext userContext = authenticationService.getUserContextFromAuthToken(authToken);
try {
User user = userContext.getUserDirectory().get(userID);
if(user == null)
throw new HTTPException(Status.NOT_FOUND, "User not found with the provided userID.");
user.removePermission(permission.toPermission());
} catch(GuacamoleSecurityException e) {
throw new HTTPException(Status.UNAUTHORIZED, e.getMessage() != null ? e.getMessage() : "Permission denied.");
} catch(GuacamoleClientException e) {
throw new HTTPException(Status.BAD_REQUEST, e.getMessage() != null ? e.getMessage() : "Invalid Request.");
} catch(GuacamoleException e) {
logger.error("Unexpected GuacamoleException caught adding permission.", e);
@Path("/remove{userID}/")
import org.glyptodon.guacamole.net.basic.rest.user.UserService;
bind(UserService.class);
import org.glyptodon.guacamole.net.basic.rest.user.UserRESTService;
bind(UserRESTService.class);
public List<APIPermission> convertPermissionList(Iterable<? extends Permission> permissions) {
public String createUser(@QueryParam("token") String authToken, APIUser user) {
return user.getUsername();
throw new HTTPException(Status.NOT_FOUND, "No Connection found with the provided parentID.");
throw new HTTPException(Status.UNAUTHORIZED, e.getMessage() != null ? e.getMessage() : "Permission denied.");
throw new HTTPException(Status.BAD_REQUEST, e.getMessage() != null ? e.getMessage() : "Invalid Request.");
throw new HTTPException(Status.NOT_FOUND, "No Connection found with the provided parentID.");
throw new HTTPException(Status.UNAUTHORIZED, e.getMessage() != null ? e.getMessage() : "Permission denied.");
throw new HTTPException(Status.BAD_REQUEST, e.getMessage() != null ? e.getMessage() : "Invalid Request.");
throw new HTTPException(Status.NOT_FOUND, "No Connection found with the provided ID.");
throw new HTTPException(Status.UNAUTHORIZED, e.getMessage() != null ? e.getMessage() : "Permission denied.");
throw new HTTPException(Status.BAD_REQUEST, e.getMessage() != null ? e.getMessage() : "Invalid Request.");
throw new HTTPException(Status.NOT_FOUND, "No Connection found with the provided parentID.");
throw new HTTPException(Status.UNAUTHORIZED, e.getMessage() != null ? e.getMessage() : "Permission denied.");
throw new HTTPException(Status.BAD_REQUEST, e.getMessage() != null ? e.getMessage() : "Invalid Request.");
throw new HTTPException(Status.NOT_FOUND, "No Connection found with the provided ID.");
throw new HTTPException(Status.UNAUTHORIZED, e.getMessage() != null ? e.getMessage() : "Permission denied.");
throw new HTTPException(Status.BAD_REQUEST, e.getMessage() != null ? e.getMessage() : "Invalid Request.");
throw new HTTPException(Status.NOT_FOUND, "No Connection found with the provided parentID.");
throw new HTTPException(Status.UNAUTHORIZED, e.getMessage() != null ? e.getMessage() : "Permission denied.");
throw new HTTPException(Status.BAD_REQUEST, e.getMessage() != null ? e.getMessage() : "Invalid Request.");
throw new HTTPException(Status.NOT_FOUND, "No ConnectionGroup found with the provided parentID.");
throw new HTTPException(Status.UNAUTHORIZED, e.getMessage() != null ? e.getMessage() : "Permission denied.");
throw new HTTPException(Status.BAD_REQUEST, e.getMessage() != null ? e.getMessage() : "Invalid Request.");
throw new HTTPException(Status.NOT_FOUND, "No ConnectionGroup found with the provided ID.");
throw new HTTPException(Status.UNAUTHORIZED, e.getMessage() != null ? e.getMessage() : "Permission denied.");
throw new HTTPException(Status.BAD_REQUEST, e.getMessage() != null ? e.getMessage() : "Invalid Request.");
throw new HTTPException(Status.NOT_FOUND, "No ConnectionGroup found with the provided ID.");
throw new HTTPException(Status.UNAUTHORIZED, e.getMessage() != null ? e.getMessage() : "Permission denied.");
throw new HTTPException(Status.BAD_REQUEST, e.getMessage() != null ? e.getMessage() : "Invalid Request.");
throw new HTTPException(Status.NOT_FOUND, "No ConnectionGroup found with the provided parentID.");
throw new HTTPException(Status.UNAUTHORIZED, e.getMessage() != null ? e.getMessage() : "Permission denied.");
throw new HTTPException(Status.BAD_REQUEST, e.getMessage() != null ? e.getMessage() : "Invalid Request.");
throw new HTTPException(Status.NOT_FOUND, "No ConnectionGroup found with the provided ID.");
throw new HTTPException(Status.UNAUTHORIZED, e.getMessage() != null ? e.getMessage() : "Permission denied.");
throw new HTTPException(Status.BAD_REQUEST, e.getMessage() != null ? e.getMessage() : "Invalid Request.");
if(parentConnectionGroup == null)
throw new HTTPException(Status.NOT_FOUND, "No ConnectionGroup found with the provided parentID.");
throw new HTTPException(Status.UNAUTHORIZED, e.getMessage() != null ? e.getMessage() : "Permission denied.");
throw new HTTPException(Status.BAD_REQUEST, e.getMessage() != null ? e.getMessage() : "Invalid Request.");
throw new HTTPException(Status.UNAUTHORIZED, e.getMessage() != null ? e.getMessage() : "Permission denied.");
throw new HTTPException(Status.BAD_REQUEST, e.getMessage() != null ? e.getMessage() : "Invalid Request.");
throw new HTTPException(Status.UNAUTHORIZED, e.getMessage() != null ? e.getMessage() : "Permission denied.");
throw new HTTPException(Status.BAD_REQUEST, e.getMessage() != null ? e.getMessage() : "Invalid Request.");
throw new HTTPException(Status.UNAUTHORIZED, e.getMessage() != null ? e.getMessage() : "Permission denied.");
throw new HTTPException(Status.BAD_REQUEST, e.getMessage() != null ? e.getMessage() : "Invalid Request.");
throw new HTTPException(Response.Status.UNAUTHORIZED, e.getMessage() != null ? e.getMessage() : "Permission denied.");
throw new HTTPException(Response.Status.BAD_REQUEST, e.getMessage() != null ? e.getMessage() : "Invalid Request.");
throw new HTTPException(Response.Status.UNAUTHORIZED, e.getMessage() != null ? e.getMessage() : "Permission denied.");
throw new HTTPException(Response.Status.BAD_REQUEST, e.getMessage() != null ? e.getMessage() : "Invalid Request.");
throw new HTTPException(Response.Status.UNAUTHORIZED, e.getMessage() != null ? e.getMessage() : "Permission denied.");
throw new HTTPException(Response.Status.BAD_REQUEST, e.getMessage() != null ? e.getMessage() : "Invalid Request.");
throw new HTTPException(Response.Status.UNAUTHORIZED, e.getMessage() != null ? e.getMessage() : "Permission denied.");
throw new HTTPException(Response.Status.BAD_REQUEST, e.getMessage() != null ? e.getMessage() : "Invalid Request.");
throw new HTTPException(Response.Status.UNAUTHORIZED, e.getMessage() != null ? e.getMessage() : "Permission denied.");
throw new HTTPException(Response.Status.BAD_REQUEST, e.getMessage() != null ? e.getMessage() : "Invalid Request.");
logger.error("Unexpected GuacamoleException caught while creating connection group.", e);
logger.error("Unexpected GuacamoleException caught updating connection group.", e);
logger.error("Unexpected GuacamoleException caught moving connection group.", e);
logger.error("Unexpected GuacamoleException caught removing permission.", e);
logger.error("Unexpected GuacamoleException caught while listing users.", e);
logger.error("Unexpected GuacamoleException caught while getting user.", e);
logger.error("Unexpected GuacamoleException caught while creating user.", e);
logger.error("Unexpected GuacamoleException caught while updating user.", e);
logger.error("Unexpected GuacamoleException caught while deleting user.", e);
throw new HTTPException(Status.NOT_FOUND, "No ConnectionGroup found with the provided parentID.");
throw new HTTPException(Status.NOT_FOUND, "No Connection found with the provided ID.");
throw new HTTPException(Status.NOT_FOUND, "No ConnectionGroup found with the provided parentID.");
throw new HTTPException(Status.NOT_FOUND, "No ConnectionGroup found with the provided parentID.");
return connectionService.convertConnectionList(connectionDirectory);
import org.glyptodon.guacamole.net.auth.Directory;
public List<APIConnection> convertConnectionList(Directory<String, Connection> connectionDirectory)
for(String connectionID : connectionDirectory.getIdentifiers()) {
restConnections.add(new APIConnection(connectionDirectory.get(connectionID)));
return connectionGroupService.convertConnectionGroupList(connectionGroupDirectory);
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.Directory;
Directory<String, ConnectionGroup> connectionGroupDirectory) throws GuacamoleException {
for(String connectionGroupID : connectionGroupDirectory.getIdentifiers()) {
restConnectionGroups.add(new APIConnectionGroup(connectionGroupDirectory.get(connectionGroupID)));
object.setIdentifier(connection.getIdentifier());
object.setIdentifier(connectionGroup.getIdentifier());
if(user == null)
return null;
return user;
import org.glyptodon.guacamole.properties.LongGuacamoleProperty;
public static final LongGuacamoleProperty API_SESSION_TIMEOUT = new LongGuacamoleProperty() {
@Override
public String getName() { return "api-session-timeout"; }
};
for(Map.Entry<String, String> entry : parameters.entrySet())
configuration.setParameter(entry.getKey(), entry.getValue());
throw new HTTPException(Status.FORBIDDEN, e.getMessage() != null ? e.getMessage() : "Permission denied.");
throw new HTTPException(Status.FORBIDDEN, e.getMessage() != null ? e.getMessage() : "Permission denied.");
throw new HTTPException(Status.FORBIDDEN, e.getMessage() != null ? e.getMessage() : "Permission denied.");
throw new HTTPException(Status.FORBIDDEN, e.getMessage() != null ? e.getMessage() : "Permission denied.");
throw new HTTPException(Status.FORBIDDEN, e.getMessage() != null ? e.getMessage() : "Permission denied.");
throw new HTTPException(Status.FORBIDDEN, e.getMessage() != null ? e.getMessage() : "Permission denied.");
throw new HTTPException(Status.FORBIDDEN, e.getMessage() != null ? e.getMessage() : "Permission denied.");
throw new HTTPException(Status.FORBIDDEN, e.getMessage() != null ? e.getMessage() : "Permission denied.");
throw new HTTPException(Status.FORBIDDEN, e.getMessage() != null ? e.getMessage() : "Permission denied.");
throw new HTTPException(Status.FORBIDDEN, e.getMessage() != null ? e.getMessage() : "Permission denied.");
throw new HTTPException(Status.FORBIDDEN, e.getMessage() != null ? e.getMessage() : "Permission denied.");
throw new HTTPException(Status.FORBIDDEN, e.getMessage() != null ? e.getMessage() : "Permission denied.");
throw new HTTPException(Status.FORBIDDEN, e.getMessage() != null ? e.getMessage() : "Permission denied.");
throw new HTTPException(Status.FORBIDDEN, e.getMessage() != null ? e.getMessage() : "Permission denied.");
throw new HTTPException(Status.FORBIDDEN, e.getMessage() != null ? e.getMessage() : "Permission denied.");
throw new HTTPException(Response.Status.FORBIDDEN, e.getMessage() != null ? e.getMessage() : "Permission denied.");
throw new HTTPException(Response.Status.FORBIDDEN, e.getMessage() != null ? e.getMessage() : "Permission denied.");
throw new HTTPException(Response.Status.FORBIDDEN, e.getMessage() != null ? e.getMessage() : "Permission denied.");
throw new HTTPException(Response.Status.FORBIDDEN, e.getMessage() != null ? e.getMessage() : "Permission denied.");
throw new HTTPException(Response.Status.FORBIDDEN, e.getMessage() != null ? e.getMessage() : "Permission denied.");
import com.google.inject.matcher.Matchers;
bindInterceptor(Matchers.any(), Matchers.annotatedWith(AuthProviderRESTExposure.class), new AuthProviderRESTExceptionWrapper());
import org.glyptodon.guacamole.net.basic.rest.AuthProviderRESTExposure;
@AuthProviderRESTExposure
import org.glyptodon.guacamole.net.basic.rest.AuthProviderRESTExposure;
@AuthProviderRESTExposure
public List<APIConnection> getConnections(@QueryParam("token") String authToken, @QueryParam("parentID") String parentID)
throws GuacamoleException {
ConnectionGroup parentConnectionGroup;
if(parentID == null)
parentConnectionGroup = userContext.getRootConnectionGroup();
else {
ConnectionGroup rootGroup = userContext.getRootConnectionGroup();
Directory<String, ConnectionGroup> connectionGroupDirectory = rootGroup.getConnectionGroupDirectory();
parentConnectionGroup = connectionGroupDirectory.get(parentID);
if(parentConnectionGroup == null)
throw new HTTPException(Status.NOT_FOUND, "No ConnectionGroup found with the provided parentID.");
Directory<String, Connection> connectionDirectory =
parentConnectionGroup.getConnectionDirectory();
return connectionService.convertConnectionList(connectionDirectory);
@AuthProviderRESTExposure
@PathParam("connectionID") String connectionID) throws GuacamoleException {
ConnectionGroup rootGroup = userContext.getRootConnectionGroup();
Directory<String, Connection> connectionDirectory =
rootGroup.getConnectionDirectory();
Connection connection = connectionDirectory.get(connectionID);
if(connection == null)
throw new HTTPException(Status.NOT_FOUND, "No Connection found with the provided ID.");
return new APIConnection(connection);
@AuthProviderRESTExposure
public void deleteConnection(@QueryParam("token") String authToken, @PathParam("connectionID") String connectionID)
throws GuacamoleException {
ConnectionGroup rootGroup = userContext.getRootConnectionGroup();
Directory<String, Connection> connectionDirectory =
rootGroup.getConnectionDirectory();
if(connectionDirectory.get(connectionID) == null)
throw new HTTPException(Status.NOT_FOUND, "No Connection found with the provided ID.");
connectionDirectory.remove(connectionID);
@AuthProviderRESTExposure
@QueryParam("parentID") String parentID, APIConnection connection) throws GuacamoleException {
if(connection == null)
throw new GuacamoleClientException("A connection is required for this request.");
ConnectionGroup parentConnectionGroup;
if(parentID == null)
parentConnectionGroup = userContext.getRootConnectionGroup();
else {
ConnectionGroup rootGroup = userContext.getRootConnectionGroup();
Directory<String, ConnectionGroup> connectionGroupDirectory = rootGroup.getConnectionGroupDirectory();
parentConnectionGroup = connectionGroupDirectory.get(parentID);
if(parentConnectionGroup == null)
throw new HTTPException(Status.NOT_FOUND, "No ConnectionGroup found with the provided parentID.");
Directory<String, Connection> connectionDirectory =
parentConnectionGroup.getConnectionDirectory();
connectionDirectory.add(new APIConnectionWrapper(connection));
return connection.getIdentifier();
@AuthProviderRESTExposure
@PathParam("connectionID") String connectionID, APIConnection connection) throws GuacamoleException {
if(connection == null)
throw new GuacamoleClientException("A connection is required for this request.");
ConnectionGroup rootGroup = userContext.getRootConnectionGroup();
Directory<String, Connection> connectionDirectory =
rootGroup.getConnectionDirectory();
if(connectionDirectory.get(connectionID) == null)
throw new HTTPException(Status.NOT_FOUND, "No Connection found with the provided ID.");
connectionDirectory.update(new APIConnectionWrapper(connection));
@AuthProviderRESTExposure
@PathParam("connectionID") String connectionID, @QueryParam("parentID") String parentID)
throws GuacamoleException {
ConnectionGroup rootGroup = userContext.getRootConnectionGroup();
Directory<String, Connection> connectionDirectory =
rootGroup.getConnectionDirectory();
Directory<String, ConnectionGroup> connectionGroupDirectory = rootGroup.getConnectionGroupDirectory();
ConnectionGroup parentConnectionGroup = connectionGroupDirectory.get(parentID);
if(parentConnectionGroup == null)
throw new HTTPException(Status.NOT_FOUND, "No ConnectionGroup found with the provided parentID.");
connectionDirectory.move(connectionID, parentConnectionGroup.getConnectionDirectory());
import org.glyptodon.guacamole.net.basic.rest.AuthProviderRESTExposure;
@AuthProviderRESTExposure
public List<APIConnectionGroup> getConnectionGroups(@QueryParam("token") String authToken, @QueryParam("parentID") String parentID)
throws GuacamoleException {
ConnectionGroup parentConnectionGroup;
if(parentID == null)
parentConnectionGroup = userContext.getRootConnectionGroup();
else {
ConnectionGroup rootGroup = userContext.getRootConnectionGroup();
Directory<String, ConnectionGroup> connectionGroupDirectory = rootGroup.getConnectionGroupDirectory();
parentConnectionGroup = connectionGroupDirectory.get(parentID);
if(parentConnectionGroup == null)
throw new HTTPException(Status.NOT_FOUND, "No ConnectionGroup found with the provided parentID.");
Directory<String, ConnectionGroup> connectionGroupDirectory =
parentConnectionGroup.getConnectionGroupDirectory();
return connectionGroupService.convertConnectionGroupList(connectionGroupDirectory);
@AuthProviderRESTExposure
@PathParam("connectionGroupID") String connectionGroupID) throws GuacamoleException {
ConnectionGroup rootGroup = userContext.getRootConnectionGroup();
Directory<String, ConnectionGroup> connectionGroupDirectory =
rootGroup.getConnectionGroupDirectory();
ConnectionGroup connectionGroup = connectionGroupDirectory.get(connectionGroupID);
if(connectionGroup == null)
throw new HTTPException(Status.NOT_FOUND, "No ConnectionGroup found with the provided ID.");
return new APIConnectionGroup(connectionGroup);
@AuthProviderRESTExposure
public void deleteConnectionGroup(@QueryParam("token") String authToken,
@PathParam("connectionGroupID") String connectionGroupID) throws GuacamoleException {
ConnectionGroup rootGroup = userContext.getRootConnectionGroup();
Directory<String, ConnectionGroup> connectionGroupDirectory =
rootGroup.getConnectionGroupDirectory();
if(connectionGroupDirectory.get(connectionGroupID) == null)
throw new HTTPException(Status.NOT_FOUND, "No ConnectionGroup found with the provided ID.");
connectionGroupDirectory.remove(connectionGroupID);
@AuthProviderRESTExposure
@QueryParam("parentID") String parentID, APIConnectionGroup connectionGroup) throws GuacamoleException {
if(connectionGroup == null)
throw new GuacamoleClientException("A connection group is required for this request.");
ConnectionGroup parentConnectionGroup;
if(parentID == null)
parentConnectionGroup = userContext.getRootConnectionGroup();
else {
ConnectionGroup rootGroup = userContext.getRootConnectionGroup();
Directory<String, ConnectionGroup> connectionGroupDirectory = rootGroup.getConnectionGroupDirectory();
parentConnectionGroup = connectionGroupDirectory.get(parentID);
if(parentConnectionGroup == null)
throw new HTTPException(Status.NOT_FOUND, "No ConnectionGroup found with the provided parentID.");
Directory<String, ConnectionGroup> connectionGroupDirectory =
parentConnectionGroup.getConnectionGroupDirectory();
connectionGroupDirectory.add(new APIConnectionGroupWrapper(connectionGroup));
return connectionGroup.getIdentifier();
@AuthProviderRESTExposure
@PathParam("connectionGroupID") String connectionGroupID, APIConnectionGroup connectionGroup)
throws GuacamoleException {
if(connectionGroup == null)
throw new GuacamoleClientException("A connection group is required for this request.");
ConnectionGroup rootGroup = userContext.getRootConnectionGroup();
Directory<String, ConnectionGroup> connectionGroupDirectory =
rootGroup.getConnectionGroupDirectory();
if(connectionGroupDirectory.get(connectionGroupID) == null)
throw new HTTPException(Status.NOT_FOUND, "No ConnectionGroup found with the provided ID.");
connectionGroupDirectory.update(new APIConnectionGroupWrapper(connectionGroup));
@AuthProviderRESTExposure
@PathParam("connectionGroupID") String connectionGroupID,
@QueryParam("parentID") String parentID) throws GuacamoleException {
ConnectionGroup rootGroup = userContext.getRootConnectionGroup();
Directory<String, ConnectionGroup> connectionGroupDirectory =
rootGroup.getConnectionGroupDirectory();
Directory<String, ConnectionGroup> newConnectionGroupDirectory = rootGroup.getConnectionGroupDirectory();
ConnectionGroup parentConnectionGroup = newConnectionGroupDirectory.get(parentID);
if(parentConnectionGroup == null)
throw new HTTPException(Status.NOT_FOUND, "No ConnectionGroup found with the provided parentID.");
connectionGroupDirectory.move(connectionGroupID, parentConnectionGroup.getConnectionGroupDirectory());
import org.glyptodon.guacamole.net.basic.rest.AuthProviderRESTExposure;
@AuthProviderRESTExposure
public List<APIPermission> getPermissions(@QueryParam("token") String authToken, @PathParam("userID") String userID)
throws GuacamoleException {
User user = userContext.getUserDirectory().get(userID);
if(user == null)
throw new HTTPException(Status.NOT_FOUND, "User not found with the provided userID.");
return permissionService.convertPermissionList(user.getPermissions());
@AuthProviderRESTExposure
@PathParam("userID") String userID, APIPermission permission)
throws GuacamoleException {
User user = userContext.getUserDirectory().get(userID);
if(user == null)
throw new HTTPException(Status.NOT_FOUND, "User not found with the provided userID.");
user.addPermission(permission.toPermission());
@AuthProviderRESTExposure
@PathParam("userID") String userID, APIPermission permission)
throws GuacamoleException {
User user = userContext.getUserDirectory().get(userID);
if(user == null)
throw new HTTPException(Status.NOT_FOUND, "User not found with the provided userID.");
user.removePermission(permission.toPermission());
import org.glyptodon.guacamole.net.basic.rest.AuthProviderRESTExposure;
@AuthProviderRESTExposure
public List<APIUser> getUsers(@QueryParam("token") String authToken) throws GuacamoleException {
Directory<String, User> userDirectory = userContext.getUserDirectory();
return userService.convertUserList(userDirectory);
@AuthProviderRESTExposure
public APIUser getUser(@QueryParam("token") String authToken, @PathParam("userID") String userID)
throws GuacamoleException {
Directory<String, User> userDirectory = userContext.getUserDirectory();
User user = userDirectory.get(userID);
if(user == null)
throw new HTTPException(Response.Status.NOT_FOUND, "User not found with the provided userID.");
return new APIUser(user);
@AuthProviderRESTExposure
public String createUser(@QueryParam("token") String authToken, APIUser user)
throws GuacamoleException {
Directory<String, User> userDirectory = userContext.getUserDirectory();
userDirectory.add(new APIUserWrapper(user));
return user.getUsername();
@AuthProviderRESTExposure
public void updateUser(@QueryParam("token") String authToken, @PathParam("userID") String userID, APIUser user)
throws GuacamoleException {
Directory<String, User> userDirectory = userContext.getUserDirectory();
if(!user.getUsername().equals(userID))
throw new HTTPException(Response.Status.BAD_REQUEST, "Username does not match provided userID.");
User existingUser = userDirectory.get(userID);
if(existingUser == null)
throw new HTTPException(Response.Status.NOT_FOUND, "User not found with the provided userID.");
userDirectory.update(new APIUserWrapper(user, existingUser.getPermissions()));
@AuthProviderRESTExposure
public void deleteUser(@QueryParam("token") String authToken, @PathParam("userID") String userID)
throws GuacamoleException {
Directory<String, User> userDirectory = userContext.getUserDirectory();
User existingUser = userDirectory.get(userID);
if(existingUser == null)
throw new HTTPException(Response.Status.NOT_FOUND, "User not found with the provided userID.");
userDirectory.remove(userID);
Integer.toString(info.getOptimalScreenHeight()),
Integer.toString(info.getOptimalResolution())
private int optimalResolution = 96;
private final List<String> audioMimetypes = new ArrayList<String>();
private final List<String> videoMimetypes = new ArrayList<String>();
public int getOptimalResolution() {
return optimalResolution;
}
public void setOptimalResolution(int optimalResolution) {
this.optimalResolution = optimalResolution;
}
String dpi = request.getParameter("dpi");
if (dpi != null)
info.setOptimalResolution(Integer.parseInt(dpi));
package org.glyptodon.guacamole.net.basic;
package org.glyptodon.guacamole.net.basic;
package org.glyptodon.guacamole.net.basic;
package org.glyptodon.guacamole.net.basic;
package org.glyptodon.guacamole.net.basic;
package org.glyptodon.guacamole.net.basic.auth;
package org.glyptodon.guacamole.net.basic.crud.connectiongroups;
package org.glyptodon.guacamole.net.basic.crud.connectiongroups;
package org.glyptodon.guacamole.net.basic.crud.connectiongroups;
package org.glyptodon.guacamole.net.basic.crud.connectiongroups;
package org.glyptodon.guacamole.net.basic.crud.connectiongroups;
package org.glyptodon.guacamole.net.basic.crud.connections;
package org.glyptodon.guacamole.net.basic.crud.connections;
package org.glyptodon.guacamole.net.basic.crud.connections;
package org.glyptodon.guacamole.net.basic.crud.connections;
package org.glyptodon.guacamole.net.basic.crud.connections;
package org.glyptodon.guacamole.net.basic.crud.permissions;
package org.glyptodon.guacamole.net.basic.crud.protocols;
package org.glyptodon.guacamole.net.basic.crud.users;
package org.glyptodon.guacamole.net.basic.crud.users;
package org.glyptodon.guacamole.net.basic.crud.users;
package org.glyptodon.guacamole.net.basic.crud.users;
package org.glyptodon.guacamole.net.basic.event;
package org.glyptodon.guacamole.net.basic.properties;
package org.glyptodon.guacamole.net.basic.properties;
package org.glyptodon.guacamole.net.basic.rest;
package org.glyptodon.guacamole.net.basic.rest;
package org.glyptodon.guacamole.net.basic.rest;
package org.glyptodon.guacamole.net.basic.rest;
package org.glyptodon.guacamole.net.basic.rest;
package org.glyptodon.guacamole.net.basic.rest.auth;
package org.glyptodon.guacamole.net.basic.rest.auth;
package org.glyptodon.guacamole.net.basic.rest.auth;
package org.glyptodon.guacamole.net.basic.rest.auth;
package org.glyptodon.guacamole.net.basic.rest.auth;
package org.glyptodon.guacamole.net.basic.rest.auth;
package org.glyptodon.guacamole.net.basic.rest.connection;
package org.glyptodon.guacamole.net.basic.rest.connection;
package org.glyptodon.guacamole.net.basic.rest.connection;
package org.glyptodon.guacamole.net.basic.rest.connectiongroup;
package org.glyptodon.guacamole.net.basic.rest.connectiongroup;
package org.glyptodon.guacamole.net.basic.rest.permission;
package org.glyptodon.guacamole.net.basic.rest.permission;
package org.glyptodon.guacamole.net.basic.rest.user;
package org.glyptodon.guacamole.net.basic.websocket.jetty;
package org.glyptodon.guacamole.net.basic.websocket.jetty;
package org.glyptodon.guacamole.net.basic.websocket.tomcat;
package org.glyptodon.guacamole.net.basic.websocket.tomcat;
package org.glyptodon.guacamole.net.basic.xml;
package org.glyptodon.guacamole.net.basic.xml;
package org.glyptodon.guacamole.net.basic.xml.protocol;
package org.glyptodon.guacamole.net.basic.xml.protocol;
package org.glyptodon.guacamole.net.basic.xml.protocol;
package org.glyptodon.guacamole.net.basic.xml.user_mapping;
package org.glyptodon.guacamole.net.basic.xml.user_mapping;
package org.glyptodon.guacamole.net.basic.xml.user_mapping;
package org.glyptodon.guacamole.net.basic.xml.user_mapping;
package org.glyptodon.guacamole.net.basic.xml.user_mapping;
package net.sourceforge.guacamole.net.auth.mysql;
package net.sourceforge.guacamole.net.auth.mysql.properties;
package net.sourceforge.guacamole.net.auth.mysql.service;
package net.sourceforge.guacamole.net.auth.mysql.service;
package org.glyptodon.guacamole.net.auth;
import org.glyptodon.guacamole.GuacamoleClientException;
import org.glyptodon.guacamole.GuacamoleResourceNotFoundException;
import org.glyptodon.guacamole.GuacamoleSecurityException;
private static final Logger logger = LoggerFactory.getLogger(GuacamoleWebSocketTunnelServlet.class);
try {
while ((readMessage = reader.read()) != null) {
buffer.append(readMessage);
if (!reader.available() || buffer.length() >= BUFFER_SIZE) {
connection.sendMessage(buffer.toString());
buffer.setLength(0);
}
catch (GuacamoleSecurityException e) {
logger.warn("Authorization failed.", e);
}
catch (GuacamoleResourceNotFoundException e) {
logger.debug("Resource not found.", e);
}
catch (GuacamoleClientException e) {
logger.warn("Error in client request.", e);
}
catch (GuacamoleException e) {
logger.error("Server error in tunnel", e);
}
import org.apache.catalina.websocket.Constants;
import org.glyptodon.guacamole.GuacamoleClientException;
import org.glyptodon.guacamole.GuacamoleResourceNotFoundException;
import org.glyptodon.guacamole.GuacamoleSecurityException;
private final Logger logger = LoggerFactory.getLogger(GuacamoleWebSocketTunnelServlet.class);
try {
while ((readMessage = reader.read()) != null) {
buffer.append(readMessage);
if (!reader.available() || buffer.length() >= BUFFER_SIZE) {
outbound.writeTextMessage(CharBuffer.wrap(buffer));
buffer.setLength(0);
}
catch (GuacamoleSecurityException e) {
logger.warn("Authorization failed.", e);
outbound.close(Constants.STATUS_POLICY_VIOLATION, null);
}
catch (GuacamoleResourceNotFoundException e) {
logger.debug("Resource not found.", e);
outbound.close(Constants.STATUS_PROTOCOL_ERROR, null);
}
catch (GuacamoleClientException e) {
logger.warn("Error in client request.", e);
outbound.close(Constants.STATUS_PROTOCOL_ERROR, null);
}
catch (GuacamoleException e) {
logger.error("Server error in tunnel", e);
outbound.close(Constants.STATUS_UNEXPECTED_CONDITION, null);
}
logger.debug("I/O error prevents further reads.", e);
outbound.close(Constants.STATUS_SHUTDOWN, null);
this.setParentIdentifier(String.valueOf(parentID));
this.setParentID(parentID);
this.setParentIdentifier(String.valueOf(parentID));
this.setParentID(parentID);
private String parentIdentifier;
public String getParentIdentifier() {
return parentIdentifier;
}
@Override
public void setParentIdentifier(String parentIdentifier) {
this.parentIdentifier = parentIdentifier;
}
@Override
private String parentIdentifier;
@Override
public String getParentIdentifier() {
return parentIdentifier;
}
@Override
public void setParentIdentifier(String parentIdentifier) {
this.parentIdentifier = parentIdentifier;
}
public String getParentIdentifier();
public void setParentIdentifier(String parentIdentifier);
public String getParentIdentifier();
public void setParentIdentifier(String parentIdentifier);
private String parentIdentifier;
this.parentIdentifier = connection.getParentIdentifier();
public String getParentIdentifier() {
return parentIdentifier;
}
public void setParentIdentifier(String parentIdentifier) {
this.parentIdentifier = parentIdentifier;
}
public String getParentIdentifier() {
return apiConnection.getParentIdentifier();
}
@Override
public void setParentIdentifier(String parentIdentifier) {
apiConnection.setParentIdentifier(parentIdentifier);
}
@Override
private String parentIdentifier;
this.parentIdentifier = connectionGroup.getParentIdentifier();
public String getParentIdentifier() {
return parentIdentifier;
}
public void setParentIdentifier(String parentIdentifier) {
this.parentIdentifier = parentIdentifier;
}
public String getParentIdentifier() {
return apiConnectionGroup.getParentIdentifier();
}
@Override
public void setParentIdentifier(String parentIdentifier) {
apiConnectionGroup.setParentIdentifier(parentIdentifier);
}
@Override
import org.glyptodon.guacamole.io.GuacamoleReader;
public GuacamoleReader acquireReader() {
return new MonitoringGuacamoleReader(listeners, super.acquireReader());
}
@Override
public static final String CLIPBOARD_ATTRIBUTE = "GUAC_CLIP";
public static ClipboardState getClipboardState(HttpSession session) {
ClipboardState clipboard = (ClipboardState) session.getAttribute(CLIPBOARD_ATTRIBUTE);
if (clipboard == null) {
clipboard = new ClipboardState();
session.setAttribute(CLIPBOARD_ATTRIBUTE, clipboard);
}
return clipboard;
}
final ClipboardState clipboard = AuthenticatingHttpServlet.getClipboardState(httpSession);
return new MonitoringGuacamoleReader(clipboard, super.acquireReader());
package org.glyptodon.guacamole.net.basic;
public class ClipboardState {
private String contents = "";
public String getContents() {
return contents;
public void setContents(String contents) {
this.contents = contents;
private final ClipboardState clipboard;
public MonitoringGuacamoleReader(ClipboardState clipboard,
this.clipboard = clipboard;
clipboard.setContents(args.get(0));
response.getWriter().print(clipboard.waitForContents(CLIPBOARD_TIMEOUT));
private long last_update = 0;
public synchronized void setContents(String contents) {
last_update = System.currentTimeMillis();
this.notifyAll();
}
public synchronized String waitForContents(int timeout) {
if (System.currentTimeMillis() - last_update > timeout) {
try {
this.wait(timeout);
}
}
return getContents();
import org.glyptodon.guacamole.properties.BooleanGuacamoleProperty;
import org.glyptodon.guacamole.properties.GuacamoleProperties;
public static final BooleanGuacamoleProperty INTEGRATION_ENABLED = new BooleanGuacamoleProperty() {
@Override
public String getName() { return "enable-clipboard-integration"; }
};
if (GuacamoleProperties.getProperty(INTEGRATION_ENABLED, false)) {
final HttpSession session = request.getSession(true);
final ClipboardState clipboard = getClipboardState(session);
try {
response.setContentType("text/plain");
response.getWriter().print(clipboard.waitForContents(CLIPBOARD_TIMEOUT));
}
catch (IOException e) {
throw new GuacamoleServerException("Unable to send clipboard contents", e);
}
}
GuacamoleInstruction instruction = readInstruction();
if (instruction == null)
return null;
return instruction.toString().toCharArray();
if (instruction == null)
return null;
public synchronized String getContents() {
import org.glyptodon.guacamole.protocol.GuacamoleStatus;
@Override
public GuacamoleStatus getStatus() {
return GuacamoleStatus.CLIENT_BAD_REQUEST;
}
import org.glyptodon.guacamole.protocol.GuacamoleStatus;
public GuacamoleStatus getStatus() {
return GuacamoleStatus.SERVER_ERROR;
}
import org.glyptodon.guacamole.protocol.GuacamoleStatus;
@Override
public GuacamoleStatus getStatus() {
return GuacamoleStatus.RESOURCE_NOT_FOUND;
}
import org.glyptodon.guacamole.protocol.GuacamoleStatus;
@Override
public GuacamoleStatus getStatus() {
return GuacamoleStatus.CLIENT_FORBIDDEN;
}
import org.glyptodon.guacamole.protocol.GuacamoleStatus;
@Override
public GuacamoleStatus getStatus() {
return GuacamoleStatus.SERVER_ERROR;
}
import org.glyptodon.guacamole.protocol.GuacamoleStatus;
public static void sendError(HttpServletResponse response,
GuacamoleStatus guac_status, String message)
throws ServletException {
if (!response.isCommitted()) {
response.addHeader("Guacamole-Status-Code", Integer.toString(guac_status.getGuacamoleStatusCode()));
response.addHeader("Guacamole-Error-Message", message);
response.sendError(guac_status.getHttpStatusCode());
}
logger.warn("Client request rejected: {}", e.getMessage());
sendError(response, e.getStatus(), e.getMessage());
logger.error("Internal server error.", e);
sendError(response, e.getStatus(), "Internal server error.");
import org.glyptodon.guacamole.protocol.GuacamoleStatus;
public static void sendError(HttpServletResponse response,
GuacamoleStatus guac_status, String message)
throws ServletException {
response.addHeader("Guacamole-Status-Code", Integer.toString(guac_status.getGuacamoleStatusCode()));
response.sendError(guac_status.getHttpStatusCode());
logger.warn("Client request rejected: {}", e.getMessage());
sendError(response, e.getStatus(), e.getMessage());
sendError(response, e.getStatus(), "Internal server error.");
import org.glyptodon.guacamole.GuacamoleResourceNotFoundException;
throw new GuacamoleResourceNotFoundException
throw new GuacamoleResourceNotFoundException("History record not found.");
import org.glyptodon.guacamole.GuacamoleResourceNotFoundException;
import org.glyptodon.guacamole.GuacamoleUnsupportedException;
throw new GuacamoleUnsupportedException("Connection not from database.");
throw new GuacamoleResourceNotFoundException("Connection not found.");
throw new GuacamoleUnsupportedException("Directory not from database");
throw new GuacamoleResourceNotFoundException("Connection not found.");
import org.glyptodon.guacamole.GuacamoleResourceNotFoundException;
import org.glyptodon.guacamole.GuacamoleUnsupportedException;
throw new GuacamoleUnsupportedException("Connection not from database.");
throw new GuacamoleResourceNotFoundException("Connection group not found.");
throw new GuacamoleUnsupportedException("The root connection group cannot be moved.");
throw new GuacamoleUnsupportedException("Directory not from database");
throw new GuacamoleResourceNotFoundException("Connection group not found.");
throw new GuacamoleUnsupportedException("Connection group cycle detected.");
import org.glyptodon.guacamole.GuacamoleUnsupportedException;
throw new GuacamoleUnsupportedException("Removing your own administrative permissions is not allowed.");
throw new GuacamoleUnsupportedException("User not from database.");
throw new GuacamoleUnsupportedException("Deleting your own user is not allowed.");
import org.glyptodon.guacamole.GuacamoleClientTooManyException;
import org.glyptodon.guacamole.GuacamoleResourceNotFoundException;
import org.glyptodon.guacamole.GuacamoleServerBusyException;
throw new GuacamoleResourceNotFoundException("Invalid connection group ID.");
throw new GuacamoleResourceNotFoundException("No connections found in group.");
throw new GuacamoleServerBusyException
throw new GuacamoleClientTooManyException
import org.glyptodon.guacamole.GuacamoleClientTooManyException;
import org.glyptodon.guacamole.GuacamoleResourceConflictException;
throw new GuacamoleResourceConflictException("Cannot connect. This connection is in use.");
throw new GuacamoleClientTooManyException
SUCCESS(200, 1000, 0x0000),
UNSUPPORTED(501, 1011, 0x0100),
SERVER_ERROR(500, 1011, 0x0200),
SERVER_BUSY(503, 1008, 0x0201),
UPSTREAM_TIMEOUT(504, 1011, 0x0202),
UPSTREAM_ERROR(502, 1011, 0x0203),
RESOURCE_NOT_FOUND(404, 1002, 0x0204),
RESOURCE_CONFLICT(409, 1008, 0x0205),
CLIENT_BAD_REQUEST(400, 1002, 0x0300),
CLIENT_UNAUTHORIZED(401, 1008, 0x0301),
CLIENT_FORBIDDEN(403, 1008, 0x0303),
CLIENT_TIMEOUT(408, 1002, 0x0308),
CLIENT_OVERRUN(413, 1009, 0x030D),
CLIENT_BAD_TYPE(415, 1003, 0x030F),
CLIENT_TOO_MANY(429, 1008, 0x031D);
private final int websocket_code;
private GuacamoleStatus(int http_code, int websocket_code, int guac_code) {
this.websocket_code = websocket_code;
public int getWebSocketCode() {
return websocket_code;
}
import org.glyptodon.guacamole.protocol.GuacamoleStatus;
public static void sendError(Connection connection,
GuacamoleStatus guac_status) {
connection.close(guac_status.getWebSocketCode(),
Integer.toString(guac_status.getGuacamoleStatusCode()));
}
logger.warn("Client request rejected: {}", e.getMessage());
sendError(connection, e.getStatus());
logger.error("Internal server error.", e);
sendError(connection, e.getStatus());
import java.nio.ByteBuffer;
import org.glyptodon.guacamole.protocol.GuacamoleStatus;
public static void sendError(WsOutbound outbound,
GuacamoleStatus guac_status) throws IOException {
byte[] message = Integer.toString(guac_status.getGuacamoleStatusCode()).getBytes("UTF-8");
outbound.close(guac_status.getWebSocketCode(), ByteBuffer.wrap(message));
}
logger.warn("Client request rejected: {}", e.getMessage());
sendError(outbound, e.getStatus());
logger.error("Internal server error.", e);
sendError(outbound, e.getStatus());
public static void closeConnection(Connection connection,
closeConnection(connection, GuacamoleStatus.SUCCESS);
closeConnection(connection, e.getStatus());
closeConnection(connection, e.getStatus());
public static void closeConnection(WsOutbound outbound,
closeConnection(outbound, GuacamoleStatus.SUCCESS);
closeConnection(outbound, e.getStatus());
closeConnection(outbound, e.getStatus());
import org.glyptodon.guacamole.GuacamoleUnauthorizedException;
throw new GuacamoleUnauthorizedException("Not authenticated");
import java.net.SocketTimeoutException;
import org.glyptodon.guacamole.GuacamoleUpstreamTimeoutException;
catch (SocketTimeoutException e) {
throw new GuacamoleUpstreamTimeoutException("Connection to guacd timed out.", e);
}
import java.net.SocketTimeoutException;
import org.glyptodon.guacamole.GuacamoleUpstreamTimeoutException;
catch (SocketTimeoutException e) {
throw new GuacamoleUpstreamTimeoutException("Connection timed out.", e);
}
CLIENT_UNAUTHORIZED(403, 1008, 0x0301),
private ActiveConnectionMap activeConnectionMap;
public void init(GuacamoleSocket socket,
synchronized (activeConnectionMap) {
activeConnectionMap.closeConnection(historyID, connectionGroupID);
}
synchronized (activeConnectionMap) {
Integer leastUsedConnectionID =
activeConnectionMap.getLeastUsedConnection(connectionIDs);
if(leastUsedConnectionID == null)
throw new GuacamoleResourceNotFoundException("No connections found in group.");
if(GuacamoleProperties.getProperty(
MySQLGuacamoleProperties.MYSQL_DISALLOW_SIMULTANEOUS_CONNECTIONS, false)
&& activeConnectionMap.isActive(leastUsedConnectionID))
throw new GuacamoleServerBusyException
("Cannot connect. All connections are in use.");
if(GuacamoleProperties.getProperty(
MySQLGuacamoleProperties.MYSQL_DISALLOW_DUPLICATE_CONNECTIONS, true)
&& activeConnectionMap.isConnectionGroupUserActive(group.getConnectionGroupID(), userID))
throw new GuacamoleClientTooManyException
("Cannot connect. Connection group already in use by this user.");
MySQLConnection connection = connectionService
.retrieveConnection(leastUsedConnectionID, userID);
return connectionService.connect(connection, info, userID, group.getConnectionGroupID());
}
synchronized (activeConnectionMap) {
if(GuacamoleProperties.getProperty(
MySQLGuacamoleProperties.MYSQL_DISALLOW_SIMULTANEOUS_CONNECTIONS, false)
&& activeConnectionMap.isActive(connection.getConnectionID()))
throw new GuacamoleResourceConflictException("Cannot connect. This connection is in use.");
if(GuacamoleProperties.getProperty(
MySQLGuacamoleProperties.MYSQL_DISALLOW_DUPLICATE_CONNECTIONS, true)
&& activeConnectionMap.isConnectionUserActive(connection.getConnectionID(), userID))
throw new GuacamoleClientTooManyException
("Cannot connect. Connection already in use by this user.");
String host = GuacamoleProperties.getRequiredProperty(GuacamoleProperties.GUACD_HOSTNAME);
int port = GuacamoleProperties.getRequiredProperty(GuacamoleProperties.GUACD_PORT);
GuacamoleSocket socket;
if (GuacamoleProperties.getProperty(GuacamoleProperties.GUACD_SSL, false))
socket = new ConfiguredGuacamoleSocket(
new SSLGuacamoleSocket(host, port),
connection.getConfiguration(), info
);
else
socket = new ConfiguredGuacamoleSocket(
new InetGuacamoleSocket(host, port),
connection.getConfiguration(), info
);
int historyID = activeConnectionMap.openConnection(connection.getConnectionID(),
userID, connectionGroupID);
MySQLGuacamoleSocket mySQLGuacamoleSocket = mySQLGuacamoleSocketProvider.get();
mySQLGuacamoleSocket.init(socket, historyID, connectionGroupID);
return mySQLGuacamoleSocket;
}
if (isOpen())
activeConnectionMap.closeConnection(historyID, connectionGroupID);
socket.close();
int currentCount = getConnectionUserCount(connectionID, userID);
int currentCount = getConnectionUserCount(connectionID, userID);
import org.glyptodon.guacamole.GuacamoleUnsupportedException;
else
throw new GuacamoleUnsupportedException("Clipboard integration not supported");
import org.glyptodon.guacamole.properties.GuacamoleProperties;
try {
if (GuacamoleProperties.getProperty(CaptureClipboard.INTEGRATION_ENABLED, false))
return new MonitoringGuacamoleReader(clipboard, super.acquireReader());
}
catch (GuacamoleException e) {
logger.warn("Clipboard integration disabled due to error.", e);
}
return super.acquireReader();
synchronized (clipboard) {
clipboard.waitForContents(CLIPBOARD_TIMEOUT);
response.setContentType(clipboard.getMimetype());
response.getOutputStream().write(clipboard.getContents());
}
private static final int MAXIMUM_LENGTH = 262144;
private String mimetype = "text/plain";
private String pending_mimetype = "text/plain";
private byte[] contents = new byte[0];
private final byte[] pending = new byte[MAXIMUM_LENGTH];
private int pending_length = 0;
public synchronized byte[] getContents() {
public synchronized String getMimetype() {
return mimetype;
public synchronized void begin(String mimetype) {
pending_length = 0;
this.pending_mimetype = mimetype;
}
public synchronized void append(byte[] data) {
int length = data.length;
int remaining = pending.length - pending_length;
if (remaining < length)
length = remaining;
System.arraycopy(data, 0, pending, pending_length, length);
}
public synchronized void commit() {
mimetype = pending_mimetype;
contents = new byte[pending_length];
System.arraycopy(pending, 0, contents, 0, pending_length);
last_update = System.currentTimeMillis();
this.notifyAll();
}
public synchronized boolean waitForContents(int timeout) {
return true;
return false;
import javax.xml.bind.DatatypeConverter;
private String clipboard_stream_index = null;
if (args.size() >= 2) {
clipboard_stream_index = args.get(0);
clipboard.begin(args.get(1));
}
}
else if (instruction.getOpcode().equals("blob")) {
List<String> args = instruction.getArgs();
if (args.size() >= 2 && args.get(0).equals(clipboard_stream_index)) {
String base64 = args.get(1);
clipboard.append(DatatypeConverter.parseBase64Binary(base64));
}
}
else if (instruction.getOpcode().equals("end")) {
List<String> args = instruction.getArgs();
if (args.size() >= 1 && args.get(0).equals(clipboard_stream_index)) {
clipboard.commit();
clipboard_stream_index = null;
}
myBatisProperties.setProperty("mybatis.pooled.pingEnabled", "true");
myBatisProperties.setProperty("mybatis.pooled.pingQuery", "SELECT 1");
private boolean active;
String username, boolean active) {
this.active = active;
return active;
int user_count = activeConnectionMap.getCurrentUserCount(connectionID);
MySQLConnectionRecord connectionRecord;
if (user_count > 0 && endDate == null) {
connectionRecord = new MySQLConnectionRecord(startDate, endDate, username, true);
user_count--;
}
else
connectionRecord = new MySQLConnectionRecord(startDate, endDate, username, false);
"vnc", "rdp", "ssh", "telnet"};
private String id;
private GuacamoleInstruction expect(GuacamoleReader reader, String opcode)
throws GuacamoleException {
GuacamoleInstruction instruction = reader.readInstruction();
if (instruction == null)
if (!instruction.getOpcode().equals(opcode))
return instruction;
}
GuacamoleInstruction args = expect(reader, "args");
List<String> arg_names = args.getArgs();
GuacamoleInstruction ready = expect(reader, "ready");
List<String> ready_args = ready.getArgs();
if (ready_args.isEmpty())
throw new GuacamoleServerException("No connection ID received");
id = ready.getArgs().get(0);
public String getConnectionID() {
return id;
}
import javax.xml.bind.DatatypeConverter;
if (username == null && password == null) {
String authorization = request.getHeader("Authorization");
if (authorization != null && authorization.startsWith("Basic ")) {
String basicBase64 = authorization.substring(6);
String basicCredentials = new String(DatatypeConverter.parseBase64Binary(basicBase64), "UTF-8");
int colon = basicCredentials.indexOf(':');
if (colon != -1) {
username = basicCredentials.substring(0, colon);
}
else
logger.warn("Invalid HTTP Basic \"Authorization\" header received.");
}
private boolean useHttpAuthentication;
useHttpAuthentication = GuacamoleProperties.getProperty(BasicGuacamoleProperties.ENABLE_HTTP_AUTH, false);
logger.error("Error reading Guacamole configuration.", e);
if (useHttpAuthentication && username == null && password == null) {
import org.glyptodon.guacamole.properties.BooleanGuacamoleProperty;
public static final BooleanGuacamoleProperty ENABLE_HTTP_AUTH = new BooleanGuacamoleProperty() {
@Override
public String getName() { return "enable-http-auth"; }
};
String select_arg = config.getConnectionID();
if (select_arg == null)
select_arg = config.getProtocol();
writer.writeInstruction(new GuacamoleInstruction("select", select_arg));
private String connectionID;
public String getConnectionID() {
return connectionID;
}
public void setConnectionID(String connectionID) {
this.connectionID = connectionID;
}
public GuacamoleInstruction(String opcode, List<String> args) {
this.opcode = opcode;
this.args = Collections.unmodifiableList(args);
}
super.init();
super.init();
import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
public class AuthenticatingFilter implements Filter {
private final Logger logger = LoggerFactory.getLogger(AuthenticatingFilter.class);
public void init(FilterConfig config) throws ServletException {
public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain)
HttpServletRequest request = (HttpServletRequest) req;
HttpServletResponse response = (HttpServletResponse) resp;
else if (!notifySuccess(listeners, context, credentials))
chain.doFilter(request, response);
@Override
public void destroy() {
}
public class BasicGuacamoleTunnelServlet extends GuacamoleHTTPTunnelServlet {
private static final Logger logger = LoggerFactory.getLogger(BasicGuacamoleTunnelServlet.class);
protected GuacamoleTunnel doConnect(HttpServletRequest request) throws GuacamoleException {
return BasicTunnelRequestUtility.createTunnel(request);
public class BasicLogin extends RestrictedHttpServlet {
private final Logger logger = LoggerFactory.getLogger(BasicLogin.class);
protected void restrictedService(
private static final Logger logger = LoggerFactory.getLogger(BasicTunnelRequestUtility.class);
final Credentials credentials = AuthenticatingFilter.getCredentials(httpSession);
final UserContext context = AuthenticatingFilter.getUserContext(httpSession);
final ClipboardState clipboard = AuthenticatingFilter.getClipboardState(httpSession);
public class CaptureClipboard extends RestrictedHttpServlet {
protected void restrictedService(
final ClipboardState clipboard = AuthenticatingFilter.getClipboardState(session);
import org.glyptodon.guacamole.net.basic.RestrictedHttpServlet;
public class Create extends RestrictedHttpServlet {
protected void restrictedService(
import org.glyptodon.guacamole.net.basic.RestrictedHttpServlet;
public class Delete extends RestrictedHttpServlet {
protected void restrictedService(
import org.glyptodon.guacamole.net.basic.RestrictedHttpServlet;
public class List extends RestrictedHttpServlet {
protected void restrictedService(
import org.glyptodon.guacamole.net.basic.RestrictedHttpServlet;
public class Move extends RestrictedHttpServlet {
protected void restrictedService(
import org.glyptodon.guacamole.net.basic.RestrictedHttpServlet;
public class Update extends RestrictedHttpServlet {
protected void restrictedService(
import org.glyptodon.guacamole.net.basic.RestrictedHttpServlet;
public class Create extends RestrictedHttpServlet {
protected void restrictedService(
import org.glyptodon.guacamole.net.basic.RestrictedHttpServlet;
public class Delete extends RestrictedHttpServlet {
protected void restrictedService(
import org.glyptodon.guacamole.net.basic.RestrictedHttpServlet;
public class List extends RestrictedHttpServlet {
protected void restrictedService(
import org.glyptodon.guacamole.net.basic.RestrictedHttpServlet;
public class Move extends RestrictedHttpServlet {
protected void restrictedService(
import org.glyptodon.guacamole.net.basic.RestrictedHttpServlet;
public class Update extends RestrictedHttpServlet {
protected void restrictedService(
import org.glyptodon.guacamole.net.basic.RestrictedHttpServlet;
public class List extends RestrictedHttpServlet {
protected void restrictedService(
import org.glyptodon.guacamole.net.basic.RestrictedHttpServlet;
public class List extends RestrictedHttpServlet {
protected void restrictedService(
import org.glyptodon.guacamole.net.basic.RestrictedHttpServlet;
public class Create extends RestrictedHttpServlet {
protected void restrictedService(
import org.glyptodon.guacamole.net.basic.RestrictedHttpServlet;
public class Delete extends RestrictedHttpServlet {
protected void restrictedService(
import org.glyptodon.guacamole.net.basic.RestrictedHttpServlet;
public class List extends RestrictedHttpServlet {
protected void restrictedService(
import org.glyptodon.guacamole.net.basic.RestrictedHttpServlet;
public class Update extends RestrictedHttpServlet {
protected void restrictedService(
import org.glyptodon.guacamole.net.basic.RestrictedHttpServlet;
import org.glyptodon.guacamole.net.basic.AuthenticatingFilter;
private final Logger logger = LoggerFactory.getLogger(AuthenticatingWebSocketServlet.class);
private final RestrictedHttpServlet auth_servlet = new RestrictedHttpServlet() {
protected void restrictedService(UserContext context,
UserContext context = AuthenticatingFilter.getUserContext(session);
import org.glyptodon.guacamole.net.basic.RestrictedHttpServlet;
import org.glyptodon.guacamole.net.basic.AuthenticatingFilter;
private final Logger logger = LoggerFactory.getLogger(AuthenticatingWebSocketServlet.class);
private final RestrictedHttpServlet auth_servlet = new RestrictedHttpServlet() {
protected void restrictedService(UserContext context,
UserContext context = AuthenticatingFilter.getUserContext(session);
public class BasicGuacamoleWebSocketTunnelServlet extends GuacamoleWebSocketTunnelServlet {
protected GuacamoleTunnel doConnect(HttpServletRequest request)
throws GuacamoleException {
return BasicTunnelRequestUtility.createTunnel(request);
public class BasicGuacamoleWebSocketTunnelServlet extends GuacamoleWebSocketTunnelServlet {
protected GuacamoleTunnel doConnect(HttpServletRequest request)
throws GuacamoleException {
return BasicTunnelRequestUtility.createTunnel(request);
};
import java.util.List;
protected String selectSubProtocol(List<String> subProtocols) {
for (String protocol : subProtocols)
if ("guacamole".equals(protocol))
return "guacamole";
return null;
}
@Override
import javax.websocket.OnClose;
import javax.websocket.OnMessage;
import javax.websocket.OnOpen;
@OnOpen
GuacamoleWebSocketTunnelEndpoint.this.onMessage(message);
@OnMessage
public void onMessage(String message) {
GuacamoleWriter writer = tunnel.acquireWriter();
try {
writer.write(message.toCharArray());
}
catch (GuacamoleException e) {
logger.debug("Tunnel write failed.", e);
}
tunnel.releaseWriter();
}
@OnClose
return BasicTunnelRequestUtility.createTunnel(new HTTPTunnelRequest(request));
import java.util.List;
public static GuacamoleTunnel createTunnel(TunnelRequest request)
HttpSession httpSession = request.getSession();
if (httpSession == null)
throw new GuacamoleSecurityException("Cannot connect - user not logged in.");
TunnelRequest.IdentifierType id_type = TunnelRequest.IdentifierType.getType(id);
List<String> audio_mimetypes = request.getParameterValues("audio");
info.getAudioMimetypes().addAll(audio_mimetypes);
List<String> video_mimetypes = request.getParameterValues("video");
info.getVideoMimetypes().addAll(video_mimetypes);
logger.info("Successful connection from to \"{}\".", id);
logger.info("Successful connection to group \"{}\".", id);
import org.glyptodon.guacamole.net.basic.HTTPTunnelRequest;
return BasicTunnelRequestUtility.createTunnel(new HTTPTunnelRequest(request));
import org.glyptodon.guacamole.net.basic.HTTPTunnelRequest;
return BasicTunnelRequestUtility.createTunnel(new HTTPTunnelRequest(request));
package org.glyptodon.guacamole.websocket;
protected abstract GuacamoleTunnel createTunnel(Session session, EndpointConfig config)
throws GuacamoleException;
import org.glyptodon.guacamole.websocket.GuacamoleWebSocketTunnelEndpoint;
public Class<?> findClass(String name) throws ClassNotFoundException {
package org.glyptodon.guacamole.net.basic.websocket;
package org.glyptodon.guacamole.net.basic.websocket;
import org.glyptodon.guacamole.net.basic.GuacamoleClassLoader;
package org.glyptodon.guacamole.net.basic.websocket;
package org.glyptodon.guacamole.net.basic.websocket;
private final Logger logger = LoggerFactory.getLogger(WebSocketSupportLoader.class);
catch (ClassNotFoundException e) {}
catch (NoClassDefFoundError e) {}
loadWebSocketTunnel(sce.getServletContext(), TOMCAT_WEBSOCKET);
private static final String[] WEBSOCKET_CLASSES = {
"org.glyptodon.guacamole.net.basic.websocket.jetty8.BasicGuacamoleWebSocketTunnelServlet",
"org.glyptodon.guacamole.net.basic.websocket.tomcat.BasicGuacamoleWebSocketTunnelServlet"
};
for (String classname : WEBSOCKET_CLASSES) {
if (loadWebSocketTunnel(sce.getServletContext(), classname)) {
logger.info("Legacy (non-JSR) WebSocket support loaded: {}", classname);
return;
}
}
logger.debug("Legacy WebSocket support NOT loaded.");
"org.glyptodon.guacamole.net.basic.websocket.jetty9.BasicGuacamoleWebSocketTunnelServlet",
package org.glyptodon.guacamole.net.basic.websocket.jetty9;
import org.eclipse.jetty.websocket.api.Session;
public class BasicGuacamoleWebSocketTunnelListener extends GuacamoleWebSocketTunnelListener {
protected GuacamoleTunnel createTunnel(Session session) throws GuacamoleException {
return BasicTunnelRequestUtility.createTunnel(new WebSocketTunnelRequest(session.getUpgradeRequest()));
package org.glyptodon.guacamole.net.basic.websocket.jetty9;
import org.eclipse.jetty.websocket.servlet.WebSocketServlet;
import org.eclipse.jetty.websocket.servlet.WebSocketServletFactory;
public class BasicGuacamoleWebSocketTunnelServlet extends WebSocketServlet {
@Override
public void configure(WebSocketServletFactory factory) {
factory.setCreator(new BasicGuacamoleWebSocketCreator());
}
}
package org.glyptodon.guacamole.net.basic.websocket.jetty9;
String[] values = request.getParameterValues(name);
if (values == null)
return null;
return Arrays.asList(values);
String[] values = handshakeParameters.get(name);
if (values == null)
return null;
return Arrays.asList(values);
if (tunnel == null) {
closeConnection(connection, GuacamoleStatus.RESOURCE_NOT_FOUND);
return;
}
if (tunnel != null)
tunnel.close();
if (tunnel == null) {
try {
closeConnection(outbound, GuacamoleStatus.RESOURCE_NOT_FOUND);
}
catch (IOException e) {
logger.debug("Tunnel not found, but unable to signal closure of WebSocket.", e);
}
return;
}
if (tunnel != null)
tunnel.close();
logger.warn("Using HTTP tunnel (not WebSocket). Performance may be sub-optimal.");
private boolean implementsJSR_356() {
try {
GuacamoleClassLoader.getInstance().findClass("javax.websocket.Endpoint");
return true;
}
catch (ClassNotFoundException e) {}
catch (NoClassDefFoundError e) {}
catch (GuacamoleException e) {
logger.error("Unable to load/detect WebSocket support.", e);
}
return false;
}
if (implementsJSR_356()) {
logger.info("JSR-356 WebSocket support present.");
return;
}
logger.debug("WebSocket support NOT present. Only HTTP will be used.");
private final Map<String, String> parameters = new HashMap<String, String>();
public GuacamoleConfiguration() {
}
public GuacamoleConfiguration(GuacamoleConfiguration config) {
protocol = config.getProtocol();
connectionID = config.getConnectionID();
for (String name : config.getParameterNames())
parameters.put(name, config.getParameter(name));
}
import java.net.SocketException;
import org.glyptodon.guacamole.GuacamoleConnectionClosedException;
catch (SocketException e) {
throw new GuacamoleConnectionClosedException("Connection to guacd is closed.", e);
}
import java.net.SocketException;
import java.net.SocketTimeoutException;
import org.glyptodon.guacamole.GuacamoleConnectionClosedException;
import org.glyptodon.guacamole.GuacamoleUpstreamTimeoutException;
catch (SocketTimeoutException e) {
throw new GuacamoleUpstreamTimeoutException("Connection to guacd timed out.", e);
}
catch (SocketException e) {
throw new GuacamoleConnectionClosedException("Connection to guacd is closed.", e);
}
import org.glyptodon.guacamole.GuacamoleConnectionClosedException;
throw new GuacamoleConnectionClosedException("Tunnel reached end of stream.");
catch (GuacamoleConnectionClosedException e) {
out.write("0.;");
out.flush();
response.flushBuffer();
}
catch (GuacamoleException e) {
session.detachTunnel(tunnel);
tunnel.close();
throw e;
}
catch (GuacamoleConnectionClosedException e) {
logger.debug("Connection closed.", e);
}
import org.glyptodon.guacamole.GuacamoleConnectionClosedException;
catch (GuacamoleConnectionClosedException e) {
logger.debug("Connection closed.", e);
closeConnection(session, GuacamoleStatus.SUCCESS);
}
catch (GuacamoleConnectionClosedException e) {
logger.debug("Connection closed.", e);
}
import org.glyptodon.guacamole.GuacamoleConnectionClosedException;
catch (GuacamoleConnectionClosedException e) {
logger.debug("Connection closed.", e);
}
catch (GuacamoleConnectionClosedException e) {
logger.debug("Connection closed.", e);
closeConnection(connection, GuacamoleStatus.SUCCESS);
}
import org.glyptodon.guacamole.GuacamoleConnectionClosedException;
catch (GuacamoleConnectionClosedException e) {
logger.debug("Connection closed.", e);
closeConnection(session, GuacamoleStatus.SUCCESS);
}
catch (GuacamoleConnectionClosedException e) {
logger.debug("Connection closed.", e);
}
import org.glyptodon.guacamole.GuacamoleConnectionClosedException;
catch (GuacamoleConnectionClosedException e) {
logger.debug("Connection closed.", e);
}
catch (GuacamoleConnectionClosedException e) {
logger.debug("Connection closed.", e);
closeConnection(outbound, GuacamoleStatus.SUCCESS);
}
import org.glyptodon.guacamole.GuacamoleUnsupportedException;
catch (GuacamoleUnsupportedException e) {
logger.debug("Unsupported operation.", e);
sendError(response, e.getStatus(), e.getMessage());
}
logger.warn("HTTP tunnel request rejected: {}", e.getMessage());
logger.error("HTTP tunnel request failed: {}", e.getMessage());
logger.debug("Internal error in HTTP tunnel.", e);
logger.debug("Unable to close WebSocket connection.", e);
logger.error("Connection failed: {}", e.getMessage());
logger.debug("Error connecting WebSocket tunnel.", e);
logger.error("Connection terminated abnormally: {}", e.getMessage());
logger.debug("Internal error during connection.", e);
logger.error("Unable to read Guacamole configuration: {}", e.getMessage());
logger.debug("Error reading Guacamole configuration.", e);
logger.debug("Error notifying AuthenticationFailureListener: {}", e);
logger.error("Authentication failed internally: {}", e.getMessage());
logger.debug("Internal server error.", e);
logger.error("Authentication canceled: failed to retrieve listeners: {}", e.getMessage());
logger.debug("Error retrieving listeners.", e);
logger.error("Request failed: {}", e.getMessage());
logger.debug("Internal server error.", e);
logger.error("Unable to read \"{}\": {}", file.getAbsolutePath(), e.getMessage());
logger.debug("Error reading protocol XML.", e);
logger.error("Unable to load/detect WebSocket support: {}", e.getMessage());
logger.debug("Error loading/detecting WebSocket support.", e);
logger.error("Unable to load WebSocket tunnel servlet: {}", e.getMessage());
logger.debug("Error loading WebSocket tunnel servlet.", e);
logger.error("Unable to load WebSocket tunnel servlet: {}", e.getMessage());
logger.debug("Error loading WebSocket tunnel servlet.", e);
logger.error("Unable to load/detect WebSocket support: {}", e.getMessage());
logger.debug("Error loading/detecting WebSocket support.", e);
logger.error("Connection failed: {}", e.getMessage());
logger.debug("Error connecting WebSocket tunnel.", e);
logger.error("Connection terminated abnormally: {}", e.getMessage());
logger.debug("Internal error during connection.", e);
logger.debug("Unable to close WebSocket connection.", e);
logger.error("Connection failed: {}", e.getMessage());
logger.debug("Error connecting WebSocket tunnel.", e);
logger.error("Connection terminated abnormally: {}", e.getMessage());
logger.debug("Internal error during connection.", e);
logger.error("Connection failed: {}", e.getMessage());
logger.debug("Error connecting WebSocket tunnel.", e);
logger.error("Connection terminated abnormally: {}", e.getMessage());
logger.debug("Internal error during connection.", e);
import org.glyptodon.guacamole.GuacamoleServerException;
if (credentials.getUsername() == null) {
logger.debug("Anonymous bind is not currently allowed by the LDAP authentication provider.");
return null;
}
if (credentials.getPassword() == null
|| credentials.getPassword().length() == 0) {
logger.debug("Anonymous bind is not currently allowed by the LDAP authentication provider.");
return null;
}
LDAPConnection ldapConnection;
ldapConnection = new LDAPConnection();
}
catch (LDAPException e) {
throw new GuacamoleServerException("Unable to connect to LDAP server.", e);
}
String username_attribute = GuacamoleProperties.getRequiredProperty(
LDAPGuacamoleProperties.LDAP_USERNAME_ATTRIBUTE
);
String user_base_dn = GuacamoleProperties.getRequiredProperty(
LDAPGuacamoleProperties.LDAP_USER_BASE_DN
);
String user_dn =
try {
}
catch (LDAPException e) {
logger.debug("LDAP bind failed.", e);
return null;
}
String config_base_dn = GuacamoleProperties.getRequiredProperty(
LDAPGuacamoleProperties.LDAP_CONFIG_BASE_DN
);
try {
throw new GuacamoleServerException("Error while querying for connections.", e);
else
import java.util.regex.Pattern;
private static final String IPV4_ADDRESS_REGEX = "([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})";
private static final String IPV6_ADDRESS_REGEX = "([0-9a-fA-F]*(:[0-9a-fA-F]*){0,7})";
private String getLoggableAddress(HttpServletRequest request) {
String header = request.getHeader("X-Forwarded-For");
if (header != null && X_FORWARDED_FOR.matcher(header).matches())
return request.getRemoteAddr();
}
if (context != null && logger.isInfoEnabled())
context.self().getUsername(), getLoggableAddress(request));
if (logger.isWarnEnabled())
logger.warn("Authentication attempt from {} for user \"{}\" failed.",
getLoggableAddress(request), credentials.getUsername());
logger.info("Successful connection to \"{}\".", id);
return new SimpleUserContext(credentials.getUsername(), configs);
import java.util.UUID;
this(UUID.randomUUID().toString(), configs);
}
public SimpleUserContext(String username, Map<String, GuacamoleConfiguration> configs) {
this.self = new SimpleUser(username,
logger.debug("Reading configuration file: \"{}\"", configFile);
throw new GuacamoleServerException("Error reading configuration file.", e);
throw new GuacamoleServerException("Error parsing XML file.", e);
logger.debug("Configuration file \"{}\" has been modified.", configFile);
logger.debug("Connection to guacd closed.", e);
logger.error("Creation of WebSocket tunnel to guacd failed: {}", e.getMessage());
logger.info("WebSocket connection terminated: {}", e.getMessage());
logger.debug("WebSocket connection terminated due to client error.", e);
logger.debug("Connection to guacd closed.", e);
logger.error("Connection to guacd terminated abnormally: {}", e.getMessage());
logger.debug("Internal error during connection to guacd.", e);
logger.debug("Connection to guacd closed.", e);
logger.debug("WebSocket tunnel write failed.", e);
logger.debug("Reading user mapping file: \"{}\"", user_mapping_file);
logger.error("Unable to read guacamole.properties: {}", e.getMessage());
logger.debug("Error reading guacamole.properties.", e);
logger.info("Invalid HTTP Basic \"Authorization\" header received.");
if (logger.isWarnEnabled()) {
if (credentials.getUsername() != null)
logger.info("Authentication attempt from {} for user \"{}\" failed.",
getLoggableAddress(request), credentials.getUsername());
else
logger.debug("Authentication attempt from {} without username failed.",
getLoggableAddress(request));
}
logger.info("HTTP request rejected: {}", e.getMessage());
logger.debug("HTTP request rejected by AuthenticatingFilter.", e);
logger.debug("Internal server error during authentication.", e);
GuacamoleTunnel tunnel = BasicTunnelRequestUtility.createTunnel(new HTTPTunnelRequest(request));
logger.info("Using HTTP tunnel (not WebSocket). Performance may be sub-optimal.");
return tunnel;
logger.debug("Login was successful for user \"{}\".", context.self().getUsername());
logger.error("Creation of tunnel to guacd aborted: Failed to retrieve listeners: {}", e.getMessage());
logger.info("Connection \"{}\" does not exist for user \"{}\".", id, context.self().getUsername());
logger.info("User \"{}\" successfully connected to \"{}\".", context.self().getUsername(), id);
logger.info("Connection group \"{}\" does not exist for user \"{}\".", id, context.self().getUsername());
logger.info("User \"{}\" successfully connected to group \"{}\".", context.self().getUsername(), id);
logger.warn("Clipboard integration failed to initialize: {}", e.getMessage());
logger.debug("Error setting up clipboard integration.", e);
logger.info("Successful connection canceled by hook.");
logger.info("HTTP request rejected: {}", message);
logger.debug("HTTP request rejected by RestrictedHttpServlet.", e);
logger.error("HTTP request failed: {}", e.getMessage());
logger.debug("Internal server error while handling HTTP request to restricted resource.", e);
logger.debug("Keep-alive signal received from user \"{}\".", context.self().getUsername());
logger.error("Unable to read connection parameter information from \"{}\": {}", file.getAbsolutePath(), e.getMessage());
context.reset();
logger.info("WebSocket support NOT present. Only HTTP will be used.");
logger.error("Creation of WebSocket tunnel to guacd failed: {}", e.getMessage());
logger.debug("Connection to guacd closed.", e);
logger.debug("WebSocket tunnel write failed.", e);
logger.info("WebSocket connection terminated: {}", e.getMessage());
logger.debug("WebSocket connection terminated due to client error.", e);
logger.debug("Connection to guacd closed.", e);
logger.error("Connection to guacd terminated abnormally: {}", e.getMessage());
logger.debug("Internal error during connection to guacd.", e);
logger.debug("WebSocket tunnel read failed due to I/O error.", e);
logger.debug("Unable to close connection to guacd.", e);
logger.error("Creation of WebSocket tunnel to guacd failed: {}", e.getMessage());
logger.info("WebSocket connection terminated: {}", e.getMessage());
logger.debug("WebSocket connection terminated due to client error.", e);
logger.debug("Connection to guacd closed.", e);
logger.error("Connection to guacd terminated abnormally: {}", e.getMessage());
logger.debug("Internal error during connection to guacd.", e);
logger.debug("Connection to guacd closed.", e);
logger.debug("WebSocket tunnel write failed.", e);
logger.debug("Unable to close connection to guacd.", e);
logger.debug("Unable to close connection to guacd.", e);
public void closeConnection(WsOutbound outbound, GuacamoleStatus guac_status) {
try {
byte[] message = Integer.toString(guac_status.getGuacamoleStatusCode()).getBytes("UTF-8");
outbound.close(guac_status.getWebSocketCode(), ByteBuffer.wrap(message));
}
catch (IOException e) {
logger.debug("Unable to close WebSocket tunnel.", e);
}
logger.error("Creation of WebSocket tunnel to guacd failed: {}", e.getMessage());
logger.debug("Connection to guacd closed.", e);
logger.debug("WebSocket tunnel write failed.", e);
closeConnection(outbound, GuacamoleStatus.RESOURCE_NOT_FOUND);
logger.info("WebSocket connection terminated: {}", e.getMessage());
logger.debug("WebSocket connection terminated due to client error.", e);
logger.debug("Connection to guacd closed.", e);
logger.error("Connection to guacd terminated abnormally: {}", e.getMessage());
logger.debug("Internal error during connection to guacd.", e);
logger.debug("Unable to close connection to guacd.", e);
import com.google.inject.Inject;
import com.google.inject.Singleton;
@Singleton
@Inject
private TunnelRequestService tunnelRequestService;
GuacamoleTunnel tunnel = tunnelRequestService.createTunnel(new HTTPTunnelRequest(request));
import com.google.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.QueryParam;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.basic.rest.AuthProviderRESTExposure;
import org.glyptodon.guacamole.net.basic.rest.auth.AuthenticationService;
@Path("/keep-alive")
public class SessionKeepAlive {
@Inject
private AuthenticationService authenticationService;
@GET
@AuthProviderRESTExposure
public void updateSession(@QueryParam("token") String authToken) throws GuacamoleException {
UserContext context = authenticationService.getUserContext(authToken);
import com.google.inject.Inject;
import com.google.inject.Singleton;
import org.glyptodon.guacamole.net.basic.rest.clipboard.ClipboardRESTService;
import org.glyptodon.guacamole.net.basic.rest.auth.AuthenticationService;
@Singleton
public class TunnelRequestService {
private final Logger logger = LoggerFactory.getLogger(TunnelRequestService.class);
@Inject
private AuthenticationService authenticationService;
private boolean notifyConnect(Collection listeners, UserContext context,
private boolean notifyClose(Collection listeners, UserContext context,
public GuacamoleTunnel createTunnel(TunnelRequest request)
String authToken = request.getParameter("authToken");
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
final Credentials credentials = session.getCredentials();
final UserContext context = session.getUserContext();
final ClipboardState clipboard = session.getClipboardState();
if (GuacamoleProperties.getProperty(ClipboardRESTService.INTEGRATION_ENABLED, false))
import com.google.inject.AbstractModule;
public class LogModule extends AbstractModule {
private final Logger logger = LoggerFactory.getLogger(LogModule.class);
protected void configure() {
package org.glyptodon.guacamole.net.basic.rest;
public class APIConstants  {
public static final String ROOT_CONNECTION_GROUP_IDENTIFIER = "ROOT";
}
package org.glyptodon.guacamole.net.basic.rest;
public class APIError {
private final String message;
public String getMessage() {
return message;
}
public APIError(String message) {
this.message = message;
}
}
package org.glyptodon.guacamole.net.basic.rest;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD})
public @interface AuthProviderRESTExposure {}
package org.glyptodon.guacamole.net.basic.rest;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import javax.ws.rs.HttpMethod;
@Target({ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@HttpMethod("PATCH")
public @interface PATCH {}
package org.glyptodon.guacamole.net.basic.rest.auth;
public interface AuthTokenGenerator {
public String getToken();
}
package org.glyptodon.guacamole.net.basic.rest.auth;
import java.security.SecureRandom;
import org.apache.commons.codec.binary.Hex;
public class SecureRandomAuthTokenGenerator implements AuthTokenGenerator {
private final SecureRandom secureRandom = new SecureRandom();
@Override
public String getToken() {
byte[] bytes = new byte[32];
secureRandom.nextBytes(bytes);
return Hex.encodeHexString(bytes);
}
}
package org.glyptodon.guacamole.net.basic.rest.auth;
package org.glyptodon.guacamole.net.basic.rest.clipboard;
import com.google.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.QueryParam;
import javax.ws.rs.core.Response;
import org.glyptodon.guacamole.net.basic.ClipboardState;
import org.glyptodon.guacamole.net.basic.GuacamoleSession;
import org.glyptodon.guacamole.net.basic.rest.AuthProviderRESTExposure;
import org.glyptodon.guacamole.net.basic.rest.auth.AuthenticationService;
@Path("/clipboard")
public class ClipboardRESTService {
@Inject
private AuthenticationService authenticationService;
@GET
@AuthProviderRESTExposure
public Response getClipboard(@QueryParam("token") String authToken)
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
final ClipboardState clipboard = session.getClipboardState();
synchronized (clipboard) {
clipboard.waitForContents(CLIPBOARD_TIMEOUT);
return Response.ok(clipboard.getContents(),
clipboard.getMimetype()).build();
package org.glyptodon.guacamole.net.basic.rest.connection;
package org.glyptodon.guacamole.net.basic.rest.connectiongroup;
package org.glyptodon.guacamole.net.basic.rest;
package org.glyptodon.guacamole.net.basic.rest.permission;
package org.glyptodon.guacamole.net.basic.rest.protocol;
package org.glyptodon.guacamole.net.basic.rest.user;
import com.google.inject.Provider;
import org.glyptodon.guacamole.net.basic.TunnelRequestService;
private final Provider<TunnelRequestService> tunnelRequestServiceProvider;
public Configurator(Provider<TunnelRequestService> tunnelRequestServiceProvider) {
this.tunnelRequestServiceProvider = tunnelRequestServiceProvider;
}
TunnelRequestService tunnelRequestService = tunnelRequestServiceProvider.get();
GuacamoleTunnel tunnel = tunnelRequestService.createTunnel(new WebSocketTunnelRequest(request));
import com.google.inject.Inject;
import com.google.inject.Singleton;
import org.glyptodon.guacamole.net.basic.TunnelRequestService;
@Singleton
@Inject
private TunnelRequestService tunnelRequestService;
return tunnelRequestService.createTunnel(new HTTPTunnelRequest(request));
import com.google.inject.Inject;
import com.google.inject.Singleton;
import org.glyptodon.guacamole.net.basic.TunnelRequestService;
@Singleton
@Inject
private TunnelRequestService tunnelRequestService;
return tunnelRequestService.createTunnel(new WebSocketTunnelRequest(session.getUpgradeRequest()));
import com.google.inject.Inject;
import com.google.inject.Singleton;
import org.glyptodon.guacamole.net.basic.TunnelRequestService;
@Singleton
@Inject
private TunnelRequestService tunnelRequestService;
return tunnelRequestService.createTunnel(new HTTPTunnelRequest(request));
import javax.ws.rs.FormParam;
public APIAuthToken login(@FormParam("username") String username,
@FormParam("password") String password,
import org.glyptodon.guacamole.net.basic.SessionKeepAlive;
import org.glyptodon.guacamole.net.basic.rest.clipboard.ClipboardRESTService;
bind(ClipboardRESTService.class);
bind(SessionKeepAlive.class);
final Collection listeners = session.getListeners();
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import org.glyptodon.guacamole.net.GuacamoleTunnel;
private final Map<String, GuacamoleTunnel> tunnels = new ConcurrentHashMap<String, GuacamoleTunnel>();
public boolean hasTunnels() {
return !tunnels.isEmpty();
}
public Map<String, GuacamoleTunnel> getTunnels() {
return tunnels;
}
public void addTunnel(GuacamoleTunnel tunnel) {
tunnels.put(tunnel.getUUID().toString(), tunnel);
}
public boolean removeTunnel(String uuid) {
return tunnels.remove(uuid) != null;
}
private boolean notifyConnect(GuacamoleSession session, GuacamoleTunnel tunnel)
TunnelConnectEvent event = new TunnelConnectEvent(
session.getUserContext(),
session.getCredentials(),
tunnel);
for (Object listener : session.getListeners()) {
private boolean notifyClose(GuacamoleSession session, GuacamoleTunnel tunnel)
TunnelCloseEvent event = new TunnelCloseEvent(
session.getUserContext(),
session.getCredentials(),
tunnel);
for (Object listener : session.getListeners()) {
final GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
UserContext context = session.getUserContext();
UserContext context = session.getUserContext();
private final ClipboardState clipboard = session.getClipboardState();
if (!notifyClose(session, this))
session.removeTunnel(getUUID().toString());
if (!notifyConnect(session, tunnel)) {
private boolean isSessionActive(String authToken) {
GuacamoleSession session = sessionMap.get(authToken);
if (session == null)
return false;
if (session.hasTunnels())
return true;
if (isSessionActive(authToken)) {
import java.util.Date;
private long lastAccessedTime;
this.lastAccessedTime = System.currentTimeMillis();
public void access() {
lastAccessedTime = System.currentTimeMillis();
}
public long getLastAccessedTime() {
return lastAccessedTime;
}
final String authToken = request.getParameter("authToken");
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
if (GuacamoleProperties.getProperty(ClipboardRESTService.INTEGRATION_ENABLED, false)) {
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
ClipboardState clipboard = session.getClipboardState();
}
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);
private final Map<String, GuacamoleSession> sessionMap =
Collections.synchronizedMap(new LinkedHashMap<String, GuacamoleSession>(16, 0.75f, true));
logger.error("Unable to read guacamole.properties: {}", e.getMessage());
logger.debug("Error while reading session timeout value.", e);
executor.scheduleAtFixedRate(new SessionEvictionTask(sessionTimeoutValue), 1, 1, TimeUnit.MINUTES);
private class SessionEvictionTask implements Runnable {
private final long sessionTimeout;
public SessionEvictionTask(long sessionTimeout) {
this.sessionTimeout = sessionTimeout;
}
@Override
public void run() {
long now = System.currentTimeMillis();
logger.debug("Checking for expired sessions...");
Iterator<Map.Entry<String, GuacamoleSession>> entries = sessionMap.entrySet().iterator();
while (entries.hasNext()) {
Map.Entry<String, GuacamoleSession> entry = entries.next();
GuacamoleSession session = entry.getValue();
long age = now - session.getLastAccessedTime();
if (age >= sessionTimeout) {
logger.debug("Session \"{}\" has timed out.", entry.getKey());
entries.remove();
}
else
break;
}
logger.debug("Session check complete.");
}
GuacamoleSession session = sessionMap.get(authToken);
if (session != null)
session.access();
return session;
}
@Override
public void shutdown() {
executor.shutdownNow();
public void shutdown();
import org.glyptodon.guacamole.properties.IntegerGuacamoleProperty;
public static final IntegerGuacamoleProperty API_SESSION_TIMEOUT = new IntegerGuacamoleProperty() {
int sessionTimeoutValue;
sessionTimeoutValue = GuacamoleProperties.getProperty(BasicGuacamoleProperties.API_SESSION_TIMEOUT, 60);
sessionTimeoutValue = 60;
logger.info("Sessions will expire after {} minutes of inactivity.", sessionTimeoutValue);
executor.scheduleAtFixedRate(new SessionEvictionTask(sessionTimeoutValue * 60000l), 1, 1, TimeUnit.MINUTES);
import javax.servlet.ServletContextEvent;
import org.glyptodon.guacamole.net.basic.rest.RESTAuthModule;
import org.glyptodon.guacamole.net.basic.rest.auth.BasicTokenSessionMap;
import org.glyptodon.guacamole.net.basic.rest.auth.TokenSessionMap;
private final TokenSessionMap sessionMap = new BasicTokenSessionMap();
new RESTAuthModule(sessionMap),
}
@Override
public void contextDestroyed(ServletContextEvent servletContextEvent) {
sessionMap.shutdown();
super.contextDestroyed(servletContextEvent);
import com.google.inject.Singleton;
@Singleton
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
private static final Logger logger = LoggerFactory.getLogger(GuacamoleSession.class);
public void invalidate() {
for (GuacamoleTunnel tunnel : tunnels.values()) {
try {
tunnel.close();
}
catch (GuacamoleException e) {
logger.debug("Unable to close tunnel.", e);
}
}
}
import org.glyptodon.guacamole.net.basic.rest.auth.TokenRESTService;
bind(TokenRESTService.class);
session.invalidate();
public GuacamoleSession remove(String authToken) {
return sessionMap.remove(authToken);
}
@Override
import javax.ws.rs.DELETE;
import javax.ws.rs.PathParam;
@Path("/token")
public class TokenRESTService {
private static final Logger logger = LoggerFactory.getLogger(TokenRESTService.class);
public APIAuthToken createToken(@FormParam("username") String username,
@DELETE
@Path("/{token}")
@AuthProviderRESTExposure
public void invalidateToken(@PathParam("token") String authToken) {
GuacamoleSession session = tokenSessionMap.remove(authToken);
if (session == null)
throw new HTTPException(Status.NOT_FOUND, "No such token.");
session.invalidate();
}
public GuacamoleSession remove(String authToken);
import org.glyptodon.guacamole.GuacamoleUnauthorizedException;
GuacamoleSession session;
try {
session = authenticationService.getGuacamoleSession(authToken);
}
catch (GuacamoleUnauthorizedException e) {
logger.debug("Session destroyed prior to tunnel closure.", e);
super.close();
return;
}
session.addTunnel(tunnel);
if (session.hasTunnels())
continue;
import java.lang.reflect.InvocationTargetException;
private static final String[] WEBSOCKET_MODULES = {
"org.glyptodon.guacamole.net.basic.websocket.WebSocketTunnelModule",
"org.glyptodon.guacamole.net.basic.websocket.jetty8.WebSocketTunnelModule",
"org.glyptodon.guacamole.net.basic.websocket.jetty9.WebSocketTunnelModule",
"org.glyptodon.guacamole.net.basic.websocket.tomcat.WebSocketTunnelModule"
private boolean loadWebSocketModule(String classname) {
Class<TunnelLoader> module = (Class<TunnelLoader>)
TunnelLoader loader = module.getConstructor().newInstance();
if (loader.isSupported()) {
install(loader);
return true;
}
catch (NoSuchMethodException e) {}
catch (InstantiationException e) {
logger.debug("Error instantiating WebSocket module.", e);
}
catch (IllegalAccessException e) {
logger.debug("Error instantiating WebSocket module.", e);
}
catch (InvocationTargetException e) {
logger.debug("Error instantiating WebSocket module.", e);
}
for (String classname : WEBSOCKET_MODULES) {
if (loadWebSocketModule(classname)) {
logger.debug("WebSocket module loaded: {}", classname);
import org.glyptodon.guacamole.net.basic.TunnelRequestService;
private final TunnelRequestService tunnelRequestService;
public BasicGuacamoleWebSocketCreator(TunnelRequestService tunnelRequestService) {
this.tunnelRequestService = tunnelRequestService;
}
return new BasicGuacamoleWebSocketTunnelListener(tunnelRequestService);
private final TunnelRequestService tunnelRequestService;
public BasicGuacamoleWebSocketTunnelListener(TunnelRequestService tunnelRequestService) {
this.tunnelRequestService = tunnelRequestService;
}
import com.google.inject.Inject;
import com.google.inject.Singleton;
import org.glyptodon.guacamole.net.basic.TunnelRequestService;
@Singleton
@Inject
private TunnelRequestService tunnelRequestService;
factory.setCreator(new BasicGuacamoleWebSocketCreator(tunnelRequestService));
USERNAME,
case USERNAME:
xml.writeAttribute("type", "username");
break;
else if ("username".equals(type))
protocolParameter.setType(ProtocolParameter.Type.USERNAME);
USERNAME,
else if ("username".equals(type))
protocolParameter.setType(ProtocolParameter.Type.USERNAME);
import org.glyptodon.guacamole.environment.Environment;
import org.glyptodon.guacamole.environment.LocalEnvironment;
Environment env = new LocalEnvironment();
String hostname = env.getProperty(Environment.GUACD_HOSTNAME);
int port = env.getProperty(Environment.GUACD_PORT);
if (env.getProperty(Environment.GUACD_SSL, false))
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
private static final Logger logger = LoggerFactory.getLogger(GuacamoleHome.class);
static {
logger.warn("GuacamoleHome is deprecated. Please use Environment instead.");
}
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
private static final Logger logger = LoggerFactory.getLogger(GuacamoleProperties.class);
static {
logger.warn("GuacamoleProperties is deprecated. Please use Environment instead.");
}
import java.util.Map;
import org.glyptodon.guacamole.protocols.ProtocolInfo;
public Map<String, ProtocolInfo> getProtocols();
public ProtocolInfo getProtocol(String name);
import java.io.BufferedInputStream;
import java.io.FilenameFilter;
import java.util.HashMap;
import java.util.Map;
import org.glyptodon.guacamole.protocols.ProtocolInfo;
import org.glyptodon.guacamole.xml.DocumentHandler;
import org.glyptodon.guacamole.xml.protocol.ProtocolTagHandler;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.XMLReaderFactory;
private static final Logger logger = LoggerFactory.getLogger(LocalEnvironment.class);
private static final String[] KNOWN_PROTOCOLS = new String[]{
"vnc", "rdp", "ssh", "telnet"};
private final Map<String, ProtocolInfo> availableProtocols;
properties = new Properties();
availableProtocols = readProtocols();
private ProtocolInfo readProtocol(InputStream input)
throws GuacamoleException {
try {
ProtocolTagHandler protocolTagHandler =
new ProtocolTagHandler();
DocumentHandler contentHandler = new DocumentHandler(
"protocol", protocolTagHandler);
XMLReader parser = XMLReaderFactory.createXMLReader();
parser.setContentHandler(contentHandler);
InputStream xml = new BufferedInputStream(input);
parser.parse(new InputSource(xml));
xml.close();
return protocolTagHandler.asProtocolInfo();
}
catch (IOException e) {
throw new GuacamoleException("Error reading basic user mapping file.", e);
}
catch (SAXException e) {
throw new GuacamoleException("Error parsing basic user mapping XML.", e);
}
}
private Map<String, ProtocolInfo> readProtocols() throws GuacamoleException {
Map<String, ProtocolInfo> protocols = new HashMap<String, ProtocolInfo>();
File protocol_directory = new File(getGuacamoleHome(), "protocols");
if (protocol_directory.isDirectory()) {
File[] files = protocol_directory.listFiles(
new FilenameFilter() {
@Override
public boolean accept(File file, String string) {
return string.endsWith(".xml");
}
}
);
for (File file : files) {
try {
FileInputStream stream = new FileInputStream(file);
ProtocolInfo protocol = readProtocol(stream);
stream.close();
protocols.put(protocol.getName(), protocol);
}
catch (IOException e) {
logger.error("Unable to read connection parameter information from \"{}\": {}", file.getAbsolutePath(), e.getMessage());
logger.debug("Error reading protocol XML.", e);
}
}
}
for (String protocol : KNOWN_PROTOCOLS) {
if (!protocols.containsKey(protocol)) {
InputStream stream = LocalEnvironment.class.getResourceAsStream(
"/org/glyptodon/guacamole/protocols/"
if (stream != null)
protocols.put(protocol, readProtocol(stream));
}
}
return protocols;
}
@Override
public Map<String, ProtocolInfo> getProtocols() {
return availableProtocols;
}
@Override
public ProtocolInfo getProtocol(String name) {
return availableProtocols.get(name);
}
package org.glyptodon.guacamole.protocols;
package org.glyptodon.guacamole.protocols;
package org.glyptodon.guacamole.protocols;
package org.glyptodon.guacamole.xml;
package org.glyptodon.guacamole.xml;
package org.glyptodon.guacamole.xml;
package org.glyptodon.guacamole.xml.protocol;
import org.glyptodon.guacamole.protocols.ProtocolParameterOption;
import org.glyptodon.guacamole.xml.TagHandler;
package org.glyptodon.guacamole.xml.protocol;
import org.glyptodon.guacamole.protocols.ProtocolParameter;
import org.glyptodon.guacamole.xml.TagHandler;
package org.glyptodon.guacamole.xml.protocol;
import org.glyptodon.guacamole.protocols.ProtocolInfo;
import org.glyptodon.guacamole.xml.TagHandler;
package org.glyptodon.guacamole.xml.protocol;
import org.glyptodon.guacamole.xml.DocumentHandler;
import org.glyptodon.guacamole.environment.Environment;
import org.glyptodon.guacamole.environment.LocalEnvironment;
import org.glyptodon.guacamole.protocols.ProtocolInfo;
import org.glyptodon.guacamole.protocols.ProtocolParameter;
import org.glyptodon.guacamole.protocols.ProtocolParameterOption;
Environment env = new LocalEnvironment();
Map<String, ProtocolInfo> protocols = env.getProtocols();
import org.glyptodon.guacamole.xml.TagHandler;
import org.glyptodon.guacamole.xml.TagHandler;
import org.glyptodon.guacamole.xml.TagHandler;
import org.glyptodon.guacamole.xml.TagHandler;
import org.glyptodon.guacamole.xml.TagHandler;
if (parentID != null)
this.setParentIdentifier(String.valueOf(parentID));
else
this.setParentIdentifier(null);
if (parentID != null)
this.setParentIdentifier(String.valueOf(parentID));
else
this.setParentIdentifier(null);
if (parentID != null)
this.setParentIdentifier(String.valueOf(parentID));
else
this.setParentIdentifier(null);
if (parentID != null)
this.setParentIdentifier(String.valueOf(parentID));
else
this.setParentIdentifier(null);
if (parentID != null)
this.setParentIdentifier(String.valueOf(parentID));
else
this.setParentIdentifier(null);
if (parentID != null)
this.setParentIdentifier(String.valueOf(parentID));
else
this.setParentIdentifier(null);
import java.util.ArrayList;
import org.glyptodon.guacamole.net.auth.permission.UserPermission;
public List<APIUser> getUsers(@QueryParam("token") String authToken,
@QueryParam("permission") UserPermission.Type permission)
throws GuacamoleException {
User self = userContext.self();
List<APIUser> users = new ArrayList<APIUser>();
for (String username : userDirectory.getIdentifiers()) {
if (permission == null || self.hasPermission(new UserPermission(permission, username)))
users.add(new APIUser(userDirectory.get(username)));
}
return users;
import javax.ws.rs.core.Response.Status;
import org.glyptodon.guacamole.net.auth.permission.ConnectionGroupPermission;
import org.glyptodon.guacamole.net.auth.permission.ConnectionPermission;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermission;
import org.glyptodon.guacamole.net.auth.permission.Permission;
import org.glyptodon.guacamole.net.auth.permission.SystemPermission;
import org.glyptodon.guacamole.net.basic.rest.APIPatch;
import static org.glyptodon.guacamole.net.basic.rest.APIPatch.Operation.add;
import static org.glyptodon.guacamole.net.basic.rest.APIPatch.Operation.remove;
import org.glyptodon.guacamole.net.basic.rest.PATCH;
import org.glyptodon.guacamole.net.basic.rest.permission.APIPermissionSet;
private static final String CONNECTION_PERMISSION_PATCH_PATH_PREFIX = "/connectionPermissions/";
private static final String CONNECTION_GROUP_PERMISSION_PATCH_PATH_PREFIX = "/connectionGroupPermissions/";
private static final String USER_PERMISSION_PATCH_PATH_PREFIX = "/userPermissions/";
private static final String SYSTEM_PERMISSION_PATCH_PATH = "/systemPermissions";
@GET
@Path("/{userID}/permissions")
@AuthProviderRESTExposure
public APIPermissionSet getPermissions(@QueryParam("token") String authToken, @PathParam("userID") String userID)
throws GuacamoleException {
UserContext userContext = authenticationService.getUserContext(authToken);
User user = userContext.getUserDirectory().get(userID);
if (user == null)
throw new HTTPException(Status.NOT_FOUND, "User not found with the provided userID.");
return new APIPermissionSet(user.getPermissions());
}
@PATCH
@Path("/{userID}/permissions")
@AuthProviderRESTExposure
public void patchPermissions(@QueryParam("token") String authToken,
@PathParam("userID") String userID,
List<APIPatch<String>> patches) throws GuacamoleException {
UserContext userContext = authenticationService.getUserContext(authToken);
Directory<String, User> userDirectory = userContext.getUserDirectory();
User user = userContext.getUserDirectory().get(userID);
if (user == null)
throw new HTTPException(Status.NOT_FOUND, "User not found with the provided userID.");
for (APIPatch<String> patch : patches) {
Permission permission;
String path = patch.getPath();
if (path.startsWith(CONNECTION_PERMISSION_PATCH_PATH_PREFIX)) {
String identifier = path.substring(CONNECTION_PERMISSION_PATCH_PATH_PREFIX.length());
ObjectPermission.Type type = ObjectPermission.Type.valueOf(patch.getValue());
permission = new ConnectionPermission(type, identifier);
}
else if (path.startsWith(CONNECTION_GROUP_PERMISSION_PATCH_PATH_PREFIX)) {
String identifier = path.substring(CONNECTION_GROUP_PERMISSION_PATCH_PATH_PREFIX.length());
ObjectPermission.Type type = ObjectPermission.Type.valueOf(patch.getValue());
permission = new ConnectionGroupPermission(type, identifier);
}
else if (path.startsWith(USER_PERMISSION_PATCH_PATH_PREFIX)) {
String identifier = path.substring(USER_PERMISSION_PATCH_PATH_PREFIX.length());
ObjectPermission.Type type = ObjectPermission.Type.valueOf(patch.getValue());
permission = new UserPermission(type, identifier);
}
else if (path.startsWith(SYSTEM_PERMISSION_PATCH_PATH)) {
SystemPermission.Type type = SystemPermission.Type.valueOf(patch.getValue());
permission = new SystemPermission(type);
}
else
switch (patch.getOp()) {
case add:
user.addPermission(permission);
break;
case remove:
user.removePermission(permission);
break;
default:
}
userDirectory.update(user);
}
import org.glyptodon.guacamole.net.basic.rest.connectiongroup.APIConnectionGroup;
this.parentIdentifier = APIConnectionGroup.ROOT_IDENTIFIER;
public static final String ROOT_IDENTIFIER = "ROOT";
this.parentIdentifier = ROOT_IDENTIFIER;
import java.util.Collection;
import org.glyptodon.guacamole.net.basic.rest.connection.APIConnection;
private Collection<APIConnectionGroup> childConnectionGroups;
private Collection<APIConnection> childConnections;
public Collection<APIConnectionGroup> getChildConnectionGroups() {
return childConnectionGroups;
}
public void setChildConnectionGroups(Collection<APIConnectionGroup> childConnectionGroups) {
this.childConnectionGroups = childConnectionGroups;
}
public Collection<APIConnection> getChildConnections() {
return childConnections;
}
public void setChildConnections(Collection<APIConnection> childConnections) {
this.childConnections = childConnections;
}
import java.util.ArrayList;
import java.util.Collection;
import org.glyptodon.guacamole.GuacamoleResourceNotFoundException;
import org.glyptodon.guacamole.net.auth.Connection;
import org.glyptodon.guacamole.net.basic.rest.connection.APIConnection;
private APIConnectionGroup retrieveConnectionGroup(UserContext userContext,
String identifier, boolean includeDescendants)
ConnectionGroup rootGroup = userContext.getRootConnectionGroup();
ConnectionGroup connectionGroup;
if (identifier == null || identifier.equals(APIConnectionGroup.ROOT_IDENTIFIER))
connectionGroup = rootGroup;
Directory<String, ConnectionGroup> connectionGroupDirectory =
rootGroup.getConnectionGroupDirectory();
connectionGroup = connectionGroupDirectory.get(identifier);
if (connectionGroup == null)
return null;
APIConnectionGroup apiConnectionGroup = new APIConnectionGroup(connectionGroup);
if (includeDescendants) {
Collection<APIConnection> apiConnections = new ArrayList<APIConnection>();
Directory<String, Connection> connectionDirectory = connectionGroup.getConnectionDirectory();
for (String childIdentifier : connectionDirectory.getIdentifiers()) {
Connection childConnection = connectionDirectory.get(childIdentifier);
if (childConnection == null)
continue;
apiConnections.add(new APIConnection(childConnection));
}
apiConnectionGroup.setChildConnections(apiConnections);
Collection<APIConnectionGroup> apiConnectionGroups = new ArrayList<APIConnectionGroup>();
Directory<String, ConnectionGroup> groupDirectory = connectionGroup.getConnectionGroupDirectory();
for (String childIdentifier : groupDirectory.getIdentifiers()) {
APIConnectionGroup childConnectionGroup = retrieveConnectionGroup(userContext, childIdentifier, true);
if (childConnectionGroup == null)
continue;
apiConnectionGroups.add(childConnectionGroup);
}
apiConnectionGroup.setChildConnectionGroups(apiConnectionGroups);
}
return apiConnectionGroup;
APIConnectionGroup connectionGroup = retrieveConnectionGroup(userContext, connectionGroupID, false);
return connectionGroup;
@GET
@Path("/{connectionGroupID}/tree")
@AuthProviderRESTExposure
public APIConnectionGroup getConnectionGroupTree(@QueryParam("token") String authToken,
@PathParam("connectionGroupID") String connectionGroupID) throws GuacamoleException {
UserContext userContext = authenticationService.getUserContext(authToken);
APIConnectionGroup connectionGroup = retrieveConnectionGroup(userContext, connectionGroupID, true);
if (connectionGroup == null)
return connectionGroup;
}
if (connectionGroupID != null && connectionGroupID.equals(APIConnectionGroup.ROOT_IDENTIFIER))
if (connectionGroupID != null && connectionGroupID.equals(APIConnectionGroup.ROOT_IDENTIFIER))
if (connectionGroupID != null && connectionGroupID.equals(APIConnectionGroup.ROOT_IDENTIFIER))
import org.glyptodon.guacamole.net.auth.User;
import org.glyptodon.guacamole.net.auth.permission.ConnectionPermission;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermission;
String identifier, boolean includeDescendants, ObjectPermission.Type permission)
User self = userContext.self();
if (permission == null || self.hasPermission(new ConnectionPermission(permission, childIdentifier)))
apiConnections.add(new APIConnection(childConnection));
APIConnectionGroup childConnectionGroup = retrieveConnectionGroup(userContext, childIdentifier, true, permission);
APIConnectionGroup connectionGroup = retrieveConnectionGroup(userContext, connectionGroupID, false, null);
@PathParam("connectionGroupID") String connectionGroupID,
@QueryParam("permission") ObjectPermission.Type permission)
throws GuacamoleException {
APIConnectionGroup connectionGroup = retrieveConnectionGroup(userContext, connectionGroupID, true, permission);
private Map<String, String> parameters;
this.parentIdentifier = connection.getParentIdentifier();
import java.util.Collections;
import java.util.HashMap;
Map<String, String> parameters = apiConnection.getParameters();
if (parameters != null) {
for (Map.Entry<String, String> entry : parameters.entrySet())
configuration.setParameter(entry.getKey(), entry.getValue());
}
Map<String, String> parameters = new HashMap<String, String>();
for (String key : config.getParameterNames())
apiConnection.setParameters(parameters);
return Collections.EMPTY_LIST;
import java.util.HashMap;
import java.util.Map;
import org.glyptodon.guacamole.net.auth.ConnectionRecord;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
@GET
@Path("/{connectionID}/parameters")
@AuthProviderRESTExposure
public Map<String, String> getConnectionParameters(@QueryParam("token") String authToken,
@PathParam("connectionID") String connectionID) throws GuacamoleException {
UserContext userContext = authenticationService.getUserContext(authToken);
ConnectionGroup rootGroup = userContext.getRootConnectionGroup();
Directory<String, Connection> connectionDirectory =
rootGroup.getConnectionDirectory();
Connection connection = connectionDirectory.get(connectionID);
if (connection == null)
throw new HTTPException(Status.NOT_FOUND, "No Connection found with the provided ID.");
GuacamoleConfiguration config = connection.getConfiguration();
Map<String, String> parameters = new HashMap<String, String>();
for (String key : config.getParameterNames())
parameters.put(key, config.getParameter(key));
return parameters;
}
@GET
@Path("/{connectionID}/history")
@AuthProviderRESTExposure
public List<? extends ConnectionRecord> getConnectionHistory(@QueryParam("token") String authToken,
@PathParam("connectionID") String connectionID) throws GuacamoleException {
UserContext userContext = authenticationService.getUserContext(authToken);
ConnectionGroup rootGroup = userContext.getRootConnectionGroup();
Directory<String, Connection> connectionDirectory =
rootGroup.getConnectionDirectory();
Connection connection = connectionDirectory.get(connectionID);
if (connection == null)
throw new HTTPException(Status.NOT_FOUND, "No Connection found with the provided ID.");
return connection.getHistory();
}
import org.glyptodon.guacamole.GuacamoleResourceNotFoundException;
import org.glyptodon.guacamole.net.basic.rest.connectiongroup.APIConnectionGroup;
@Path("/connections")
private ConnectionGroup retrieveConnectionGroup(UserContext userContext,
String identifier) throws GuacamoleException {
ConnectionGroup rootGroup = userContext.getRootConnectionGroup();
if (identifier == null || identifier.equals(APIConnectionGroup.ROOT_IDENTIFIER))
return rootGroup;
Directory<String, ConnectionGroup> directory = rootGroup.getConnectionGroupDirectory();
ConnectionGroup connectionGroup = directory.get(identifier);
if (connectionGroup == null)
return connectionGroup;
}
public String createConnection(@QueryParam("token") String authToken,
APIConnection connection) throws GuacamoleException {
throw new GuacamoleClientException("Connection JSON must be submitted when creating connections.");
String parentID = connection.getParentIdentifier();
ConnectionGroup parentConnectionGroup = retrieveConnectionGroup(userContext, parentID);
Directory<String, Connection> connectionDirectory = parentConnectionGroup.getConnectionDirectory();
@PUT
throw new GuacamoleClientException("Connection JSON must be submitted when updating connections.");
Connection existingConnection = connectionDirectory.get(connectionID);
if (existingConnection == null)
Connection wrappedConnection = new APIConnectionWrapper(connection);
existingConnection.setConfiguration(wrappedConnection.getConfiguration());
existingConnection.setName(wrappedConnection.getName());
connectionDirectory.update(existingConnection);
@Path("/connectionGroups")
public String createConnectionGroup(@QueryParam("token") String authToken,
APIConnectionGroup connectionGroup) throws GuacamoleException {
throw new GuacamoleClientException("Connection group JSON must be submitted when creating connections groups.");
String parentID = connectionGroup.getParentIdentifier();
ConnectionGroup rootGroup = userContext.getRootConnectionGroup();
parentConnectionGroup = rootGroup;
if (parentConnectionGroup == null)
Directory<String, ConnectionGroup> connectionGroupDirectory = parentConnectionGroup.getConnectionGroupDirectory();
@PUT
throw new GuacamoleClientException("Connection group JSON must be submitted when updating connection groups.");
import javax.ws.rs.QueryParam;
import org.glyptodon.guacamole.net.basic.rest.auth.AuthenticationService;
@Path("/protocols")
@Inject
private AuthenticationService authenticationService;
public Map<String, ProtocolInfo> getProtocols(@QueryParam("token") String authToken) throws GuacamoleException {
authenticationService.getUserContext(authToken);
@Path("/users")
@Path("/tokens")
import javax.ws.rs.PUT;
import org.glyptodon.guacamole.GuacamoleResourceNotFoundException;
@Path("/{username}")
public APIUser getUser(@QueryParam("token") String authToken, @PathParam("username") String username)
User user = userDirectory.get(username);
@PUT
@Path("/{username}")
public void updateUser(@QueryParam("token") String authToken,
@PathParam("username") String username, APIUser user)
if (!user.getUsername().equals(username))
throw new HTTPException(Response.Status.BAD_REQUEST,
"Username in path does not match username provided JSON data.");
User existingUser = userDirectory.get(username);
if (user.getPassword() != null)
userDirectory.update(existingUser);
@Path("/{username}")
public void deleteUser(@QueryParam("token") String authToken,
@PathParam("username") String username)
User existingUser = userDirectory.get(username);
userDirectory.remove(username);
@Path("/{username}/permissions")
public APIPermissionSet getPermissions(@QueryParam("token") String authToken,
@PathParam("username") String username)
User user = userContext.getUserDirectory().get(username);
@Path("/{username}/permissions")
@PathParam("username") String username,
User user = userContext.getUserDirectory().get(username);
throw new HTTPException(Status.BAD_REQUEST,
public Map<String, String> getParameters() {
return parameters;
}
public void setParameters(Map<String, String> parameters) {
this.parameters.clear();
this.parameters.putAll(parameters);
}
if (parameters != null)
configuration.setParameters(parameters);
apiConnection.setParameters(config.getParameters());
return config.getParameters();
GuacamoleConfiguration config = new GuacamoleConfiguration();
config.setProtocol(connection.getProtocol());
config.setParameters(connection.getParameters());
existingConnection.setConfiguration(config);
existingConnection.setName(connection.getName());
public Map<String, String> getParameters() {
return parameters;
}
public void setParameters(Map<String, String> parameters) {
this.parameters.clear();
this.parameters.putAll(parameters);
}
@Path("/tokens")
import org.glyptodon.guacamole.net.basic.rest.connectiongroup.APIConnectionGroup;
private Map<String, String> parameters;
this.parentIdentifier = APIConnectionGroup.ROOT_IDENTIFIER;
import java.util.Collections;
Map<String, String> parameters = apiConnection.getParameters();
if (parameters != null)
configuration.setParameters(parameters);
apiConnection.setParameters(config.getParameters());
return Collections.EMPTY_LIST;
import java.util.Map;
import org.glyptodon.guacamole.GuacamoleResourceNotFoundException;
import org.glyptodon.guacamole.net.auth.ConnectionRecord;
import org.glyptodon.guacamole.net.basic.rest.connectiongroup.APIConnectionGroup;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
@Path("/connections")
@GET
@Path("/{connectionID}/parameters")
@AuthProviderRESTExposure
public Map<String, String> getConnectionParameters(@QueryParam("token") String authToken,
@PathParam("connectionID") String connectionID) throws GuacamoleException {
UserContext userContext = authenticationService.getUserContext(authToken);
ConnectionGroup rootGroup = userContext.getRootConnectionGroup();
Directory<String, Connection> connectionDirectory =
rootGroup.getConnectionDirectory();
Connection connection = connectionDirectory.get(connectionID);
if (connection == null)
GuacamoleConfiguration config = connection.getConfiguration();
return config.getParameters();
}
@GET
@Path("/{connectionID}/history")
@AuthProviderRESTExposure
public List<? extends ConnectionRecord> getConnectionHistory(@QueryParam("token") String authToken,
@PathParam("connectionID") String connectionID) throws GuacamoleException {
UserContext userContext = authenticationService.getUserContext(authToken);
ConnectionGroup rootGroup = userContext.getRootConnectionGroup();
Directory<String, Connection> connectionDirectory =
rootGroup.getConnectionDirectory();
Connection connection = connectionDirectory.get(connectionID);
if (connection == null)
return connection.getHistory();
}
private ConnectionGroup retrieveConnectionGroup(UserContext userContext,
String identifier) throws GuacamoleException {
ConnectionGroup rootGroup = userContext.getRootConnectionGroup();
if (identifier == null || identifier.equals(APIConnectionGroup.ROOT_IDENTIFIER))
return rootGroup;
Directory<String, ConnectionGroup> directory = rootGroup.getConnectionGroupDirectory();
ConnectionGroup connectionGroup = directory.get(identifier);
if (connectionGroup == null)
return connectionGroup;
}
public String createConnection(@QueryParam("token") String authToken,
APIConnection connection) throws GuacamoleException {
throw new GuacamoleClientException("Connection JSON must be submitted when creating connections.");
String parentID = connection.getParentIdentifier();
ConnectionGroup parentConnectionGroup = retrieveConnectionGroup(userContext, parentID);
Directory<String, Connection> connectionDirectory = parentConnectionGroup.getConnectionDirectory();
@PUT
throw new GuacamoleClientException("Connection JSON must be submitted when updating connections.");
Connection existingConnection = connectionDirectory.get(connectionID);
if (existingConnection == null)
GuacamoleConfiguration config = new GuacamoleConfiguration();
config.setProtocol(connection.getProtocol());
config.setParameters(connection.getParameters());
existingConnection.setConfiguration(config);
existingConnection.setName(connection.getName());
connectionDirectory.update(existingConnection);
import java.util.Collection;
import org.glyptodon.guacamole.net.basic.rest.connection.APIConnection;
public static final String ROOT_IDENTIFIER = "ROOT";
private Collection<APIConnectionGroup> childConnectionGroups;
private Collection<APIConnection> childConnections;
this.parentIdentifier = ROOT_IDENTIFIER;
public Collection<APIConnectionGroup> getChildConnectionGroups() {
return childConnectionGroups;
}
public void setChildConnectionGroups(Collection<APIConnectionGroup> childConnectionGroups) {
this.childConnectionGroups = childConnectionGroups;
}
public Collection<APIConnection> getChildConnections() {
return childConnections;
}
public void setChildConnections(Collection<APIConnection> childConnections) {
this.childConnections = childConnections;
}
import java.util.ArrayList;
import java.util.Collection;
import org.glyptodon.guacamole.GuacamoleResourceNotFoundException;
import org.glyptodon.guacamole.net.auth.Connection;
import org.glyptodon.guacamole.net.auth.User;
import org.glyptodon.guacamole.net.auth.permission.ConnectionPermission;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermission;
import org.glyptodon.guacamole.net.basic.rest.connection.APIConnection;
@Path("/connectionGroups")
private APIConnectionGroup retrieveConnectionGroup(UserContext userContext,
String identifier, boolean includeDescendants, ObjectPermission.Type permission)
User self = userContext.self();
ConnectionGroup rootGroup = userContext.getRootConnectionGroup();
ConnectionGroup connectionGroup;
if (identifier == null || identifier.equals(APIConnectionGroup.ROOT_IDENTIFIER))
connectionGroup = rootGroup;
Directory<String, ConnectionGroup> connectionGroupDirectory =
rootGroup.getConnectionGroupDirectory();
connectionGroup = connectionGroupDirectory.get(identifier);
if (connectionGroup == null)
return null;
APIConnectionGroup apiConnectionGroup = new APIConnectionGroup(connectionGroup);
if (includeDescendants) {
Collection<APIConnection> apiConnections = new ArrayList<APIConnection>();
Directory<String, Connection> connectionDirectory = connectionGroup.getConnectionDirectory();
for (String childIdentifier : connectionDirectory.getIdentifiers()) {
Connection childConnection = connectionDirectory.get(childIdentifier);
if (childConnection == null)
continue;
if (permission == null || self.hasPermission(new ConnectionPermission(permission, childIdentifier)))
apiConnections.add(new APIConnection(childConnection));
}
apiConnectionGroup.setChildConnections(apiConnections);
Collection<APIConnectionGroup> apiConnectionGroups = new ArrayList<APIConnectionGroup>();
Directory<String, ConnectionGroup> groupDirectory = connectionGroup.getConnectionGroupDirectory();
for (String childIdentifier : groupDirectory.getIdentifiers()) {
APIConnectionGroup childConnectionGroup = retrieveConnectionGroup(userContext, childIdentifier, true, permission);
if (childConnectionGroup == null)
continue;
apiConnectionGroups.add(childConnectionGroup);
}
apiConnectionGroup.setChildConnectionGroups(apiConnectionGroups);
}
return apiConnectionGroup;
APIConnectionGroup connectionGroup = retrieveConnectionGroup(userContext, connectionGroupID, false, null);
return connectionGroup;
@GET
@Path("/{connectionGroupID}/tree")
@AuthProviderRESTExposure
public APIConnectionGroup getConnectionGroupTree(@QueryParam("token") String authToken,
@PathParam("connectionGroupID") String connectionGroupID,
@QueryParam("permission") ObjectPermission.Type permission)
throws GuacamoleException {
UserContext userContext = authenticationService.getUserContext(authToken);
APIConnectionGroup connectionGroup = retrieveConnectionGroup(userContext, connectionGroupID, true, permission);
if (connectionGroup == null)
return connectionGroup;
}
if (connectionGroupID != null && connectionGroupID.equals(APIConnectionGroup.ROOT_IDENTIFIER))
public String createConnectionGroup(@QueryParam("token") String authToken,
APIConnectionGroup connectionGroup) throws GuacamoleException {
throw new GuacamoleClientException("Connection group JSON must be submitted when creating connections groups.");
String parentID = connectionGroup.getParentIdentifier();
ConnectionGroup rootGroup = userContext.getRootConnectionGroup();
parentConnectionGroup = rootGroup;
if (parentConnectionGroup == null)
Directory<String, ConnectionGroup> connectionGroupDirectory = parentConnectionGroup.getConnectionGroupDirectory();
@PUT
throw new GuacamoleClientException("Connection group JSON must be submitted when updating connection groups.");
if (connectionGroupID != null && connectionGroupID.equals(APIConnectionGroup.ROOT_IDENTIFIER))
import javax.ws.rs.QueryParam;
import org.glyptodon.guacamole.net.basic.rest.auth.AuthenticationService;
@Path("/protocols")
@Inject
private AuthenticationService authenticationService;
public Map<String, ProtocolInfo> getProtocols(@QueryParam("token") String authToken) throws GuacamoleException {
authenticationService.getUserContext(authToken);
import java.util.ArrayList;
import javax.ws.rs.PUT;
import javax.ws.rs.core.Response.Status;
import org.glyptodon.guacamole.GuacamoleResourceNotFoundException;
import org.glyptodon.guacamole.net.auth.permission.ConnectionGroupPermission;
import org.glyptodon.guacamole.net.auth.permission.ConnectionPermission;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermission;
import org.glyptodon.guacamole.net.auth.permission.Permission;
import org.glyptodon.guacamole.net.auth.permission.SystemPermission;
import org.glyptodon.guacamole.net.auth.permission.UserPermission;
import org.glyptodon.guacamole.net.basic.rest.APIPatch;
import static org.glyptodon.guacamole.net.basic.rest.APIPatch.Operation.add;
import static org.glyptodon.guacamole.net.basic.rest.APIPatch.Operation.remove;
import org.glyptodon.guacamole.net.basic.rest.PATCH;
import org.glyptodon.guacamole.net.basic.rest.permission.APIPermissionSet;
@Path("/users")
private static final String CONNECTION_PERMISSION_PATCH_PATH_PREFIX = "/connectionPermissions/";
private static final String CONNECTION_GROUP_PERMISSION_PATCH_PATH_PREFIX = "/connectionGroupPermissions/";
private static final String USER_PERMISSION_PATCH_PATH_PREFIX = "/userPermissions/";
private static final String SYSTEM_PERMISSION_PATCH_PATH = "/systemPermissions";
public List<APIUser> getUsers(@QueryParam("token") String authToken,
@QueryParam("permission") UserPermission.Type permission)
throws GuacamoleException {
User self = userContext.self();
List<APIUser> users = new ArrayList<APIUser>();
for (String username : userDirectory.getIdentifiers()) {
if (permission == null || self.hasPermission(new UserPermission(permission, username)))
users.add(new APIUser(userDirectory.get(username)));
}
return users;
@Path("/{username}")
public APIUser getUser(@QueryParam("token") String authToken, @PathParam("username") String username)
User user = userDirectory.get(username);
@PUT
@Path("/{username}")
public void updateUser(@QueryParam("token") String authToken,
@PathParam("username") String username, APIUser user)
if (!user.getUsername().equals(username))
throw new HTTPException(Response.Status.BAD_REQUEST,
"Username in path does not match username provided JSON data.");
User existingUser = userDirectory.get(username);
if (user.getPassword() != null)
userDirectory.update(existingUser);
@Path("/{username}")
public void deleteUser(@QueryParam("token") String authToken,
@PathParam("username") String username)
User existingUser = userDirectory.get(username);
userDirectory.remove(username);
}
@GET
@Path("/{username}/permissions")
@AuthProviderRESTExposure
public APIPermissionSet getPermissions(@QueryParam("token") String authToken,
@PathParam("username") String username)
throws GuacamoleException {
UserContext userContext = authenticationService.getUserContext(authToken);
User user = userContext.getUserDirectory().get(username);
if (user == null)
return new APIPermissionSet(user.getPermissions());
}
@PATCH
@Path("/{username}/permissions")
@AuthProviderRESTExposure
public void patchPermissions(@QueryParam("token") String authToken,
@PathParam("username") String username,
List<APIPatch<String>> patches) throws GuacamoleException {
UserContext userContext = authenticationService.getUserContext(authToken);
Directory<String, User> userDirectory = userContext.getUserDirectory();
User user = userContext.getUserDirectory().get(username);
if (user == null)
for (APIPatch<String> patch : patches) {
Permission permission;
String path = patch.getPath();
if (path.startsWith(CONNECTION_PERMISSION_PATCH_PATH_PREFIX)) {
String identifier = path.substring(CONNECTION_PERMISSION_PATCH_PATH_PREFIX.length());
ObjectPermission.Type type = ObjectPermission.Type.valueOf(patch.getValue());
permission = new ConnectionPermission(type, identifier);
}
else if (path.startsWith(CONNECTION_GROUP_PERMISSION_PATCH_PATH_PREFIX)) {
String identifier = path.substring(CONNECTION_GROUP_PERMISSION_PATCH_PATH_PREFIX.length());
ObjectPermission.Type type = ObjectPermission.Type.valueOf(patch.getValue());
permission = new ConnectionGroupPermission(type, identifier);
}
else if (path.startsWith(USER_PERMISSION_PATCH_PATH_PREFIX)) {
String identifier = path.substring(USER_PERMISSION_PATCH_PATH_PREFIX.length());
ObjectPermission.Type type = ObjectPermission.Type.valueOf(patch.getValue());
permission = new UserPermission(type, identifier);
}
else if (path.startsWith(SYSTEM_PERMISSION_PATCH_PATH)) {
SystemPermission.Type type = SystemPermission.Type.valueOf(patch.getValue());
permission = new SystemPermission(type);
}
else
switch (patch.getOp()) {
case add:
user.addPermission(permission);
break;
case remove:
user.removePermission(permission);
break;
default:
throw new HTTPException(Status.BAD_REQUEST,
}
userDirectory.update(user);
if (identifier != null && identifier.equals(APIConnectionGroup.ROOT_IDENTIFIER))
ConnectionGroup updatedParentGroup = retrieveConnectionGroup(userContext, connection.getParentIdentifier());
connectionDirectory.move(connectionID, updatedParentGroup.getConnectionDirectory());
bind(ObjectRetrievalService.class);
import org.glyptodon.guacamole.net.basic.rest.ObjectRetrievalService;
@Inject
private ObjectRetrievalService retrievalService;
return new APIConnection(retrievalService.retrieveConnection(userContext, connectionID));
Connection connection = retrievalService.retrieveConnection(userContext, connectionID);
Connection connection = retrievalService.retrieveConnection(userContext, connectionID);
ConnectionGroup parentConnectionGroup = retrievalService.retrieveConnectionGroup(userContext, parentID);
Connection existingConnection = retrievalService.retrieveConnection(userContext, connectionID);
ConnectionGroup updatedParentGroup = retrievalService.retrieveConnectionGroup(userContext, connection.getParentIdentifier());
import org.glyptodon.guacamole.net.basic.rest.ObjectRetrievalService;
@Inject
private ObjectRetrievalService retrievalService;
try {
connectionGroup = retrievalService.retrieveConnectionGroup(userContext, identifier);
}
catch (GuacamoleResourceNotFoundException e) {
return null;
ConnectionGroup parentConnectionGroup = retrievalService.retrieveConnectionGroup(userContext, parentID);
ConnectionGroup existingConnectionGroup = connectionGroupDirectory.get(connectionGroupID);
existingConnectionGroup.setName(connectionGroup.getName());
existingConnectionGroup.setType(connectionGroup.getType());
connectionGroupDirectory.update(existingConnectionGroup);
ConnectionGroup updatedParentGroup = retrievalService.retrieveConnectionGroup(userContext, connectionGroup.getParentIdentifier());
connectionGroupDirectory.move(connectionGroupID, updatedParentGroup.getConnectionGroupDirectory());
import org.glyptodon.guacamole.net.basic.rest.ObjectRetrievalService;
@Inject
private ObjectRetrievalService retrievalService;
User user = retrievalService.retrieveUser(userContext, username);
User existingUser = retrievalService.retrieveUser(userContext, username);
bind(ObjectRetrievalService.class);
import org.glyptodon.guacamole.net.basic.rest.ObjectRetrievalService;
@Inject
private ObjectRetrievalService retrievalService;
return new APIConnection(retrievalService.retrieveConnection(userContext, connectionID));
Connection connection = retrievalService.retrieveConnection(userContext, connectionID);
Connection connection = retrievalService.retrieveConnection(userContext, connectionID);
ConnectionGroup parentConnectionGroup = retrievalService.retrieveConnectionGroup(userContext, parentID);
Connection existingConnection = retrievalService.retrieveConnection(userContext, connectionID);
ConnectionGroup updatedParentGroup = retrievalService.retrieveConnectionGroup(userContext, connection.getParentIdentifier());
connectionDirectory.move(connectionID, updatedParentGroup.getConnectionDirectory());
import org.glyptodon.guacamole.net.basic.rest.ObjectRetrievalService;
@Inject
private ObjectRetrievalService retrievalService;
try {
connectionGroup = retrievalService.retrieveConnectionGroup(userContext, identifier);
}
catch (GuacamoleResourceNotFoundException e) {
return null;
ConnectionGroup parentConnectionGroup = retrievalService.retrieveConnectionGroup(userContext, parentID);
ConnectionGroup existingConnectionGroup = connectionGroupDirectory.get(connectionGroupID);
existingConnectionGroup.setName(connectionGroup.getName());
existingConnectionGroup.setType(connectionGroup.getType());
connectionGroupDirectory.update(existingConnectionGroup);
ConnectionGroup updatedParentGroup = retrievalService.retrieveConnectionGroup(userContext, connectionGroup.getParentIdentifier());
connectionGroupDirectory.move(connectionGroupID, updatedParentGroup.getConnectionGroupDirectory());
import org.glyptodon.guacamole.net.basic.rest.ObjectRetrievalService;
@Inject
private ObjectRetrievalService retrievalService;
User user = retrievalService.retrieveUser(userContext, username);
User existingUser = retrievalService.retrieveUser(userContext, username);
import org.glyptodon.guacamole.environment.Environment;
import org.glyptodon.guacamole.environment.LocalEnvironment;
Environment env = new LocalEnvironment();
String hostname = env.getProperty(Environment.GUACD_HOSTNAME);
int port = env.getProperty(Environment.GUACD_PORT);
if (env.getProperty(Environment.GUACD_SSL, false))
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
private static final Logger logger = LoggerFactory.getLogger(GuacamoleHome.class);
static {
logger.warn("GuacamoleHome is deprecated. Please use Environment instead.");
}
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
private static final Logger logger = LoggerFactory.getLogger(GuacamoleProperties.class);
static {
logger.warn("GuacamoleProperties is deprecated. Please use Environment instead.");
}
package org.glyptodon.guacamole.protocols;
package org.glyptodon.guacamole.protocols;
package org.glyptodon.guacamole.protocols;
package org.glyptodon.guacamole.xml;
package org.glyptodon.guacamole.xml;
package org.glyptodon.guacamole.xml;
package org.glyptodon.guacamole.xml.protocol;
import org.glyptodon.guacamole.protocols.ProtocolParameterOption;
import org.glyptodon.guacamole.xml.TagHandler;
package org.glyptodon.guacamole.xml.protocol;
import org.glyptodon.guacamole.protocols.ProtocolParameter;
import org.glyptodon.guacamole.xml.TagHandler;
package org.glyptodon.guacamole.xml.protocol;
import org.glyptodon.guacamole.protocols.ProtocolInfo;
import org.glyptodon.guacamole.xml.TagHandler;
package org.glyptodon.guacamole.xml.protocol;
import org.glyptodon.guacamole.xml.DocumentHandler;
import org.glyptodon.guacamole.environment.Environment;
import org.glyptodon.guacamole.environment.LocalEnvironment;
import org.glyptodon.guacamole.protocols.ProtocolInfo;
Environment env = new LocalEnvironment();
return env.getProtocols();
import org.glyptodon.guacamole.xml.TagHandler;
import org.glyptodon.guacamole.xml.TagHandler;
import org.glyptodon.guacamole.xml.TagHandler;
import org.glyptodon.guacamole.xml.TagHandler;
import org.glyptodon.guacamole.xml.TagHandler;
File[] files = libDirectory.listFiles(new FilenameFilter() {
});
if (files == null)
for (File file : files) {
DocumentHandlerState current = getCurrentState();
if (current == null)
throw new SAXException("Character data not allowed outside XML document.");
current.getTextContent().append(ch, start, length);
if (files == null) {
logger.error("Unable to read contents of \"{}\".", protocol_directory.getAbsolutePath());
files = new File[0];
}
if (files == null) {
logger.error("Unable to read contents of \"{}\".", protocol_directory.getAbsolutePath());
files = new File[0];
}
DocumentHandlerState current = getCurrentState();
if (current == null)
throw new SAXException("Character data not allowed outside XML document.");
current.getTextContent().append(ch, start, length);
File[] files = libDirectory.listFiles(new FilenameFilter() {
});
if (files == null)
for (File file : files) {
User user;
if (userContext.self().getUsername().equals(username))
user = userContext.self();
else {
user = userContext.getUserDirectory().get(username);
if (user == null)
}
User user;
if (userContext.self().getUsername().equals(username))
user = userContext.self();
else {
user = userContext.getUserDirectory().get(username);
if (user == null)
}
import org.glyptodon.guacamole.GuacamoleSecurityException;
import org.glyptodon.guacamole.net.auth.User;
import org.glyptodon.guacamole.net.auth.permission.ConnectionPermission;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermission;
import org.glyptodon.guacamole.net.auth.permission.Permission;
import org.glyptodon.guacamole.net.auth.permission.SystemPermission;
private static final Permission SYSTEM_PERMISSION =
new SystemPermission(SystemPermission.Type.ADMINISTER);
User self = userContext.self();
if (!self.hasPermission(SYSTEM_PERMISSION)
&& !self.hasPermission(new ConnectionPermission(ObjectPermission.Type.UPDATE, connectionID)))
throw new GuacamoleSecurityException("Permission to read connection parameters denied.");
import org.glyptodon.guacamole.GuacamoleSecurityException;
import org.glyptodon.guacamole.net.auth.User;
import org.glyptodon.guacamole.net.auth.permission.ConnectionPermission;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermission;
import org.glyptodon.guacamole.net.auth.permission.Permission;
import org.glyptodon.guacamole.net.auth.permission.SystemPermission;
private static final Permission SYSTEM_PERMISSION =
new SystemPermission(SystemPermission.Type.ADMINISTER);
User self = userContext.self();
if (!self.hasPermission(SYSTEM_PERMISSION)
&& !self.hasPermission(new ConnectionPermission(ObjectPermission.Type.UPDATE, connectionID)))
throw new GuacamoleSecurityException("Permission to read connection parameters denied.");
String oldParentIdentifier = existingConnection.getParentIdentifier();
if (    (oldParentIdentifier != null && !oldParentIdentifier.equals(updatedParentGroup.getParentIdentifier()))
|| (oldParentIdentifier == null && updatedParentGroup.getParentIdentifier() != null))
connectionDirectory.move(connectionID, updatedParentGroup.getConnectionDirectory());
String oldParentIdentifier = existingConnectionGroup.getParentIdentifier();
if (    (oldParentIdentifier != null && !oldParentIdentifier.equals(updatedParentGroup.getParentIdentifier()))
|| (oldParentIdentifier == null && updatedParentGroup.getParentIdentifier() != null))
connectionGroupDirectory.move(connectionGroupID, updatedParentGroup.getConnectionGroupDirectory());
String oldParentIdentifier = existingConnection.getParentIdentifier();
if (    (oldParentIdentifier != null && !oldParentIdentifier.equals(updatedParentGroup.getParentIdentifier()))
|| (oldParentIdentifier == null && updatedParentGroup.getParentIdentifier() != null))
connectionDirectory.move(connectionID, updatedParentGroup.getConnectionDirectory());
String oldParentIdentifier = existingConnectionGroup.getParentIdentifier();
if (    (oldParentIdentifier != null && !oldParentIdentifier.equals(updatedParentGroup.getParentIdentifier()))
|| (oldParentIdentifier == null && updatedParentGroup.getParentIdentifier() != null))
connectionGroupDirectory.move(connectionGroupID, updatedParentGroup.getConnectionGroupDirectory());
if (    (oldParentIdentifier != null && !oldParentIdentifier.equals(updatedParentGroup.getIdentifier()))
|| (oldParentIdentifier == null && updatedParentGroup.getIdentifier() != null))
if (    (oldParentIdentifier != null && !oldParentIdentifier.equals(updatedParentGroup.getIdentifier()))
|| (oldParentIdentifier == null && updatedParentGroup.getIdentifier() != null))
if (    (oldParentIdentifier != null && !oldParentIdentifier.equals(updatedParentGroup.getIdentifier()))
|| (oldParentIdentifier == null && updatedParentGroup.getIdentifier() != null))
if (    (oldParentIdentifier != null && !oldParentIdentifier.equals(updatedParentGroup.getIdentifier()))
|| (oldParentIdentifier == null && updatedParentGroup.getIdentifier() != null))
this.setParentIdentifier(MySQLConstants.CONNECTION_GROUP_ROOT_IDENTIFIER);
this.setParentIdentifier(MySQLConstants.CONNECTION_GROUP_ROOT_IDENTIFIER);
this.setParentIdentifier(MySQLConstants.CONNECTION_GROUP_ROOT_IDENTIFIER);
this.setParentIdentifier(MySQLConstants.CONNECTION_GROUP_ROOT_IDENTIFIER);
private Credentials credentials;
private UserContext userContext;
public void setCredentials(Credentials credentials) {
this.credentials = credentials;
}
public void setUserContext(UserContext userContext) {
this.userContext = userContext;
}
@FormParam("password") String password,
@FormParam("token") String token,
GuacamoleSession existingSession;
if (token != null)
existingSession = tokenSessionMap.get(token);
else
existingSession = null;
if (existingSession != null)
userContext = authProvider.updateUserContext(existingSession.getUserContext(), credentials);
else
userContext = authProvider.getUserContext(credentials);
String authToken;
if (existingSession != null) {
authToken = token;
existingSession.setCredentials(credentials);
existingSession.setUserContext(userContext);
}
else {
authToken = authTokenGenerator.getToken();
tokenSessionMap.put(authToken, new GuacamoleSession(credentials, userContext));
}
import java.io.UnsupportedEncodingException;
import javax.xml.bind.DatatypeConverter;
if (username == null && password == null) {
String authorization = request.getHeader("Authorization");
if (authorization != null && authorization.startsWith("Basic ")) {
try {
String basicBase64 = authorization.substring(6);
String basicCredentials = new String(DatatypeConverter.parseBase64Binary(basicBase64), "UTF-8");
int colon = basicCredentials.indexOf(':');
if (colon != -1) {
username = basicCredentials.substring(0, colon);
}
else
logger.debug("Invalid HTTP Basic \"Authorization\" header received.");
}
catch (UnsupportedEncodingException e) {
throw new UnsupportedOperationException("Unexpected lack of UTF-8 support.", e);
}
}
return new APIAuthToken(authToken, userContext.self().getUsername());
private Credentials credentials;
private UserContext userContext;
public void setCredentials(Credentials credentials) {
this.credentials = credentials;
}
public void setUserContext(UserContext userContext) {
this.userContext = userContext;
}
import java.io.UnsupportedEncodingException;
import javax.xml.bind.DatatypeConverter;
@FormParam("password") String password,
@FormParam("token") String token,
GuacamoleSession existingSession;
if (token != null)
existingSession = tokenSessionMap.get(token);
else
existingSession = null;
if (username == null && password == null) {
String authorization = request.getHeader("Authorization");
if (authorization != null && authorization.startsWith("Basic ")) {
try {
String basicBase64 = authorization.substring(6);
String basicCredentials = new String(DatatypeConverter.parseBase64Binary(basicBase64), "UTF-8");
int colon = basicCredentials.indexOf(':');
if (colon != -1) {
username = basicCredentials.substring(0, colon);
}
else
logger.debug("Invalid HTTP Basic \"Authorization\" header received.");
}
catch (UnsupportedEncodingException e) {
throw new UnsupportedOperationException("Unexpected lack of UTF-8 support.", e);
}
}
if (existingSession != null)
userContext = authProvider.updateUserContext(existingSession.getUserContext(), credentials);
else
userContext = authProvider.getUserContext(credentials);
String authToken;
if (existingSession != null) {
authToken = token;
existingSession.setCredentials(credentials);
existingSession.setUserContext(userContext);
}
else {
authToken = authTokenGenerator.getToken();
tokenSessionMap.put(authToken, new GuacamoleSession(credentials, userContext));
}
return new APIAuthToken(authToken, userContext.self().getUsername());
public void filterValues(Map<?, String> map) {
for (Map.Entry<?, String> entry : map.entrySet()) {
String value = entry.getValue();
if (value != null)
entry.setValue(filter(value));
}
}
import org.glyptodon.guacamole.token.StandardTokens;
import org.glyptodon.guacamole.token.TokenFilter;
TokenFilter tokenFilter = new TokenFilter();
StandardTokens.addStandardTokens(tokenFilter, credentials);
for (GuacamoleConfiguration config : configs.values())
tokenFilter.filterValues(config.getParameters());
import org.glyptodon.guacamole.token.StandardTokens;
import org.glyptodon.guacamole.token.TokenFilter;
TokenFilter tokenFilter = new TokenFilter();
StandardTokens.addStandardTokens(tokenFilter, credentials);
for (GuacamoleConfiguration config : configs.values())
tokenFilter.filterValues(config.getParameters());
private AuthenticatedUser currentUser;
public void init(AuthenticatedUser currentUser, Integer parentID) {
this.currentUser = currentUser;
connectionService.retrieveConnection(identifier, currentUser);
(connection.getParentID(), currentUser, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
currentUser,
(parentID, currentUser, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
return permissionCheckService.retrieveConnectionIdentifiers(currentUser,
permissionCheckService.verifySystemAccess(currentUser,
permissionCheckService.verifyConnectionGroupAccess(currentUser,
(parentID, currentUser, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
connectionService.retrieveConnection(name, parentID, currentUser);
name, object.getConfiguration().getProtocol(), currentUser, parentID);
newConnectionPermission.setUser_id(currentUser.getUserID());
permissionCheckService.verifyConnectionAccess(currentUser,
connectionService.retrieveConnection(identifier, currentUser);
(mySQLConnection.getParentID(), currentUser, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
permissionCheckService.verifyConnectionAccess(currentUser,
connectionService.retrieveConnection(identifier, currentUser);
permissionCheckService.verifyConnectionAccess(currentUser,
(mySQLConnection.getParentID(), currentUser, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
permissionCheckService.verifyConnectionGroupAccess(currentUser,
(toConnectionGroupID, currentUser, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
permissionCheckService.verifyConnectionGroupAccess(currentUser,
toConnectionGroupID, currentUser);
private AuthenticatedUser currentUser;
public void init(AuthenticatedUser currentUser, Integer parentID) {
this.currentUser = currentUser;
connectionGroupService.retrieveConnectionGroup(identifier, currentUser);
(connectionGroup.getParentID(), currentUser, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
currentUser,
(parentID, currentUser, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
return permissionCheckService.retrieveConnectionGroupIdentifiers(currentUser,
permissionCheckService.verifySystemAccess(currentUser,
permissionCheckService.verifyConnectionGroupAccess(currentUser,
(parentID, currentUser, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
connectionGroupService.retrieveConnectionGroup(name, parentID, currentUser);
.createConnectionGroup(name, currentUser, parentID, mySQLType);
newConnectionGroupPermission.setUser_id(currentUser.getUserID());
permissionCheckService.verifyConnectionAccess(currentUser,
connectionGroupService.retrieveConnectionGroup(identifier, currentUser);
(mySQLConnectionGroup.getParentID(), currentUser, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
permissionCheckService.verifyConnectionGroupAccess(currentUser,
connectionGroupService.retrieveConnectionGroup(identifier, currentUser);
permissionCheckService.verifyConnectionAccess(currentUser,
(mySQLConnectionGroup.getParentID(), currentUser, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
permissionCheckService.verifyConnectionGroupAccess(currentUser,
(toConnectionGroupID, currentUser, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
permissionCheckService.verifyConnectionGroupAccess(currentUser,
toConnectionGroupID, currentUser);
retrieveConnectionGroup(relativeParentID, currentUser);
context.init(new AuthenticatedUser(authenticatedUser.getUserID(), credentials));
private AuthenticatedUser currentUser;
List<? extends ConnectionRecord> history,
AuthenticatedUser currentUser) {
this.currentUser = currentUser;
return connectionService.connect(this, info, currentUser, null);
private AuthenticatedUser currentUser;
String identifier, ConnectionGroup.Type type, AuthenticatedUser currentUser) {
this.currentUser = currentUser;
connectionDirectory.init(currentUser, connectionGroupID);
connectionGroupDirectory.init(currentUser, connectionGroupID);
(this.connectionGroupID, currentUser, MySQLConstants.CONNECTION_GROUP_BALANCING);
permissionCheckService.verifyConnectionGroupAccess(currentUser,
return connectionGroupService.connect(this, info, currentUser);
import org.glyptodon.guacamole.net.auth.Credentials;
private AuthenticatedUser currentUser;
public void init(AuthenticatedUser currentUser) {
this.currentUser = currentUser;
userDirectory.init(currentUser);
ConnectionGroup.Type.ORGANIZATIONAL, currentUser);
return userService.retrieveUser(currentUser.getUserID());
private AuthenticatedUser currentUser;
public void init(AuthenticatedUser currentUser) {
this.currentUser = currentUser;
permissionCheckService.verifyUserAccess(currentUser,
return permissionCheckService.retrieveUsernames(currentUser,
permissionCheckService.verifySystemAccess(currentUser,
newUserPermission.setUser_id(currentUser.getUserID());
permissionCheckService.retrieveUserIDs(currentUser,
newPermission.setUser_id(currentUser.getUserID());
permissionCheckService.retrieveUserIDs(currentUser,
permissionCheckService.retrieveConnectionIDs(currentUser,
permissionCheckService.retrieveConnectionGroupIDs(currentUser,
permissionCheckService.retrieveConnectionIDs(currentUser,
permissionCheckService.retrieveConnectionGroupIDs(currentUser,
currentUser, SystemPermission.Type.ADMINISTER.name());
if (user_id == currentUser.getUserID())
permissionCheckService.verifyUserAccess(currentUser,
if (user.getUserID() == currentUser.getUserID())
permissionCheckService.verifyUserAccess(currentUser,
import net.sourceforge.guacamole.net.auth.mysql.AuthenticatedUser;
AuthenticatedUser currentUser) {
return toMySQLConnectionGroup(connectionGroups.get(0), currentUser);
AuthenticatedUser currentUser) throws GuacamoleException {
return retrieveConnectionGroup(connectionGroupID, currentUser);
public MySQLConnectionGroup retrieveConnectionGroup(Integer id, AuthenticatedUser currentUser) {
currentUser);
return toMySQLConnectionGroup(connectionGroup, currentUser);
GuacamoleClientInformation info, AuthenticatedUser currentUser)
throws GuacamoleException {
&& activeConnectionMap.isConnectionGroupUserActive(group.getConnectionGroupID(), currentUser.getUserID()))
.retrieveConnection(leastUsedConnectionID, currentUser);
return connectionService.connect(connection, info, currentUser, group.getConnectionGroupID());
private MySQLConnectionGroup toMySQLConnectionGroup(ConnectionGroup connectionGroup,
AuthenticatedUser currentUser) {
currentUser
public MySQLConnectionGroup createConnectionGroup(String name, AuthenticatedUser currentUser,
return toMySQLConnectionGroup(connectionGroup, currentUser);
import net.sourceforge.guacamole.net.auth.mysql.AuthenticatedUser;
import org.glyptodon.guacamole.token.StandardTokens;
import org.glyptodon.guacamole.token.TokenFilter;
AuthenticatedUser currentUser) {
return toMySQLConnection(connections.get(0), currentUser);
public MySQLConnection retrieveConnection(String uniqueIdentifier, AuthenticatedUser currentUser) {
return retrieveConnection(connectionID, currentUser);
public MySQLConnection retrieveConnection(int id, AuthenticatedUser currentUser) {
return toMySQLConnection(connection, currentUser);
private MySQLConnection toMySQLConnection(Connection connection, AuthenticatedUser currentUser) {
currentUser
GuacamoleClientInformation info, AuthenticatedUser currentUser,
Integer connectionGroupID)
&& activeConnectionMap.isConnectionUserActive(connection.getConnectionID(), currentUser.getUserID()))
TokenFilter tokenFilter = new TokenFilter();
StandardTokens.addStandardTokens(tokenFilter, currentUser.getCredentials());
GuacamoleConfiguration config = new GuacamoleConfiguration(connection.getConfiguration());
tokenFilter.filterValues(config.getParameters());
config, info
config, info
currentUser.getUserID(), connectionGroupID);
AuthenticatedUser currentUser, Integer parentID) {
return toMySQLConnection(connection, currentUser);
import net.sourceforge.guacamole.net.auth.mysql.AuthenticatedUser;
public void verifyUserAccess(AuthenticatedUser currentUser, int affectedUserID,
if(!checkUserAccess(currentUser, affectedUserID, permissionType))
public void verifyConnectionAccess(AuthenticatedUser currentUser,
int affectedConnectionID, String permissionType) throws GuacamoleSecurityException {
if(!checkConnectionAccess(currentUser, affectedConnectionID, permissionType))
public void verifyConnectionGroupAccess(AuthenticatedUser currentUser,
Integer affectedConnectionGroupID, String permissionType) throws GuacamoleSecurityException {
if(!checkConnectionGroupAccess(currentUser, affectedConnectionGroupID, permissionType))
public void verifySystemAccess(AuthenticatedUser currentUser, String systemPermissionType)
if(!checkSystemAccess(currentUser, systemPermissionType))
public boolean checkUserAccess(AuthenticatedUser currentUser,
Integer affectedUserID, String permissionType) {
if(checkSystemAdministratorAccess(currentUser))
example.createCriteria().andUser_idEqualTo(currentUser.getUserID()).andAffected_user_idEqualTo(affectedUserID).andPermissionEqualTo(permissionType);
public boolean checkConnectionAccess(AuthenticatedUser currentUser,
Integer affectedConnectionID, String permissionType) {
if(checkSystemAdministratorAccess(currentUser))
example.createCriteria().andUser_idEqualTo(currentUser.getUserID()).andConnection_idEqualTo(affectedConnectionID).andPermissionEqualTo(permissionType);
public boolean checkConnectionGroupAccess(AuthenticatedUser currentUser,
Integer affectedConnectionGroupID, String permissionType) {
if(checkSystemAdministratorAccess(currentUser))
example.createCriteria().andUser_idEqualTo(currentUser.getUserID()).andConnection_group_idEqualTo(affectedConnectionGroupID).andPermissionEqualTo(permissionType);
private boolean checkSystemAccess(AuthenticatedUser currentUser, String systemPermissionType) {
if(checkSystemAdministratorAccess(currentUser))
example.createCriteria().andUser_idEqualTo(currentUser.getUserID()).andPermissionEqualTo(systemPermissionType);
private boolean checkSystemAdministratorAccess(AuthenticatedUser currentUser) {
example.createCriteria().andUser_idEqualTo(currentUser.getUserID())
.andPermissionEqualTo(MySQLConstants.SYSTEM_ADMINISTER);
AuthenticatedUser currentUser, String type) throws GuacamoleSecurityException {
if(!checkConnectionGroupUsageAccess(connectionGroupID, currentUser, type))
Integer connectionGroupID, AuthenticatedUser currentUser, String usage) {
if(checkSystemAdministratorAccess(currentUser))
if(checkConnectionGroupAccess(currentUser, connectionGroupID,
retrieveConnectionGroup(connectionGroupID, currentUser);
public List<Integer> retrieveUserIDs(AuthenticatedUser currentUser, String permissionType) {
if(checkSystemAdministratorAccess(currentUser))
example.createCriteria().andUser_idEqualTo(currentUser.getUserID()).andPermissionEqualTo(permissionType);
List<Integer> currentUsers = new ArrayList<Integer>(userPermissions.size());
currentUsers.add(permission.getAffected_user_id());
return currentUsers;
public List<Integer> retrieveConnectionIDs(AuthenticatedUser currentUser,
return retrieveConnectionIDs(currentUser, null, permissionType, false);
public List<Integer> retrieveConnectionIDs(AuthenticatedUser currentUser, Integer parentID,
return retrieveConnectionIDs(currentUser, parentID, permissionType, true);
private List<Integer> retrieveConnectionIDs(AuthenticatedUser currentUser, Integer parentID,
if(checkSystemAdministratorAccess(currentUser)) {
Criteria criteria = example.createCriteria().andUser_idEqualTo(currentUser.getUserID())
public List<Integer> retrieveConnectionGroupIDs(AuthenticatedUser currentUser,
return retrieveConnectionGroupIDs(currentUser, null, permissionType, false);
public List<Integer> retrieveConnectionGroupIDs(AuthenticatedUser currentUser, Integer parentID,
return retrieveConnectionGroupIDs(currentUser, parentID, permissionType, true);
private List<Integer> retrieveConnectionGroupIDs(AuthenticatedUser currentUser, Integer parentID,
if(checkSystemAdministratorAccess(currentUser)) {
example.createCriteria().andUser_idEqualTo(currentUser.getUserID())
public Set<String> retrieveUsernames(AuthenticatedUser currentUser, String permissionType) {
if(checkSystemAdministratorAccess(currentUser))
List<Integer> currentUsers =
retrieveUserIDs(currentUser, MySQLConstants.USER_READ);
return userService.translateUsernames(currentUsers).keySet();
public Set<String> retrieveConnectionIdentifiers(AuthenticatedUser currentUser, Integer parentID,
if(checkSystemAdministratorAccess(currentUser))
retrieveConnectionIDs(currentUser, parentID, permissionType);
public Set<String> retrieveConnectionGroupIdentifiers(AuthenticatedUser currentUser, Integer parentID,
if(checkSystemAdministratorAccess(currentUser))
retrieveConnectionGroupIDs(currentUser, parentID, permissionType);
private AuthenticatedUser currentUser;
public void init(AuthenticatedUser currentUser, Integer parentID) {
this.currentUser = currentUser;
connectionService.retrieveConnection(identifier, currentUser);
(connection.getParentID(), currentUser, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
currentUser,
(parentID, currentUser, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
return permissionCheckService.retrieveConnectionIdentifiers(currentUser,
permissionCheckService.verifySystemAccess(currentUser,
permissionCheckService.verifyConnectionGroupAccess(currentUser,
(parentID, currentUser, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
connectionService.retrieveConnection(name, parentID, currentUser);
name, object.getConfiguration().getProtocol(), currentUser, parentID);
newConnectionPermission.setUser_id(currentUser.getUserID());
permissionCheckService.verifyConnectionAccess(currentUser,
connectionService.retrieveConnection(identifier, currentUser);
(mySQLConnection.getParentID(), currentUser, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
permissionCheckService.verifyConnectionAccess(currentUser,
connectionService.retrieveConnection(identifier, currentUser);
permissionCheckService.verifyConnectionAccess(currentUser,
(mySQLConnection.getParentID(), currentUser, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
permissionCheckService.verifyConnectionGroupAccess(currentUser,
(toConnectionGroupID, currentUser, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
permissionCheckService.verifyConnectionGroupAccess(currentUser,
toConnectionGroupID, currentUser);
private AuthenticatedUser currentUser;
public void init(AuthenticatedUser currentUser, Integer parentID) {
this.currentUser = currentUser;
connectionGroupService.retrieveConnectionGroup(identifier, currentUser);
(connectionGroup.getParentID(), currentUser, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
currentUser,
(parentID, currentUser, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
return permissionCheckService.retrieveConnectionGroupIdentifiers(currentUser,
permissionCheckService.verifySystemAccess(currentUser,
permissionCheckService.verifyConnectionGroupAccess(currentUser,
(parentID, currentUser, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
connectionGroupService.retrieveConnectionGroup(name, parentID, currentUser);
.createConnectionGroup(name, currentUser, parentID, mySQLType);
newConnectionGroupPermission.setUser_id(currentUser.getUserID());
permissionCheckService.verifyConnectionAccess(currentUser,
connectionGroupService.retrieveConnectionGroup(identifier, currentUser);
(mySQLConnectionGroup.getParentID(), currentUser, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
permissionCheckService.verifyConnectionGroupAccess(currentUser,
connectionGroupService.retrieveConnectionGroup(identifier, currentUser);
permissionCheckService.verifyConnectionAccess(currentUser,
(mySQLConnectionGroup.getParentID(), currentUser, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
permissionCheckService.verifyConnectionGroupAccess(currentUser,
(toConnectionGroupID, currentUser, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
permissionCheckService.verifyConnectionGroupAccess(currentUser,
toConnectionGroupID, currentUser);
retrieveConnectionGroup(relativeParentID, currentUser);
context.init(new AuthenticatedUser(authenticatedUser.getUserID(), credentials));
private AuthenticatedUser currentUser;
List<? extends ConnectionRecord> history,
AuthenticatedUser currentUser) {
this.currentUser = currentUser;
return connectionService.connect(this, info, currentUser, null);
private AuthenticatedUser currentUser;
String identifier, ConnectionGroup.Type type, AuthenticatedUser currentUser) {
this.currentUser = currentUser;
connectionDirectory.init(currentUser, connectionGroupID);
connectionGroupDirectory.init(currentUser, connectionGroupID);
(this.connectionGroupID, currentUser, MySQLConstants.CONNECTION_GROUP_BALANCING);
permissionCheckService.verifyConnectionGroupAccess(currentUser,
return connectionGroupService.connect(this, info, currentUser);
import org.glyptodon.guacamole.net.auth.Credentials;
private AuthenticatedUser currentUser;
public void init(AuthenticatedUser currentUser) {
this.currentUser = currentUser;
userDirectory.init(currentUser);
ConnectionGroup.Type.ORGANIZATIONAL, currentUser);
return userService.retrieveUser(currentUser.getUserID());
private AuthenticatedUser currentUser;
public void init(AuthenticatedUser currentUser) {
this.currentUser = currentUser;
permissionCheckService.verifyUserAccess(currentUser,
return permissionCheckService.retrieveUsernames(currentUser,
permissionCheckService.verifySystemAccess(currentUser,
newUserPermission.setUser_id(currentUser.getUserID());
permissionCheckService.retrieveUserIDs(currentUser,
newPermission.setUser_id(currentUser.getUserID());
permissionCheckService.retrieveUserIDs(currentUser,
permissionCheckService.retrieveConnectionIDs(currentUser,
permissionCheckService.retrieveConnectionGroupIDs(currentUser,
permissionCheckService.retrieveConnectionIDs(currentUser,
permissionCheckService.retrieveConnectionGroupIDs(currentUser,
currentUser, SystemPermission.Type.ADMINISTER.name());
if (user_id == currentUser.getUserID())
permissionCheckService.verifyUserAccess(currentUser,
if (user.getUserID() == currentUser.getUserID())
permissionCheckService.verifyUserAccess(currentUser,
import net.sourceforge.guacamole.net.auth.mysql.AuthenticatedUser;
AuthenticatedUser currentUser) {
return toMySQLConnectionGroup(connectionGroups.get(0), currentUser);
AuthenticatedUser currentUser) throws GuacamoleException {
return retrieveConnectionGroup(connectionGroupID, currentUser);
public MySQLConnectionGroup retrieveConnectionGroup(Integer id, AuthenticatedUser currentUser) {
currentUser);
return toMySQLConnectionGroup(connectionGroup, currentUser);
GuacamoleClientInformation info, AuthenticatedUser currentUser)
throws GuacamoleException {
&& activeConnectionMap.isConnectionGroupUserActive(group.getConnectionGroupID(), currentUser.getUserID()))
.retrieveConnection(leastUsedConnectionID, currentUser);
return connectionService.connect(connection, info, currentUser, group.getConnectionGroupID());
private MySQLConnectionGroup toMySQLConnectionGroup(ConnectionGroup connectionGroup,
AuthenticatedUser currentUser) {
currentUser
public MySQLConnectionGroup createConnectionGroup(String name, AuthenticatedUser currentUser,
return toMySQLConnectionGroup(connectionGroup, currentUser);
import net.sourceforge.guacamole.net.auth.mysql.AuthenticatedUser;
import org.glyptodon.guacamole.token.StandardTokens;
import org.glyptodon.guacamole.token.TokenFilter;
AuthenticatedUser currentUser) {
return toMySQLConnection(connections.get(0), currentUser);
public MySQLConnection retrieveConnection(String uniqueIdentifier, AuthenticatedUser currentUser) {
return retrieveConnection(connectionID, currentUser);
public MySQLConnection retrieveConnection(int id, AuthenticatedUser currentUser) {
return toMySQLConnection(connection, currentUser);
private MySQLConnection toMySQLConnection(Connection connection, AuthenticatedUser currentUser) {
currentUser
GuacamoleClientInformation info, AuthenticatedUser currentUser,
Integer connectionGroupID)
&& activeConnectionMap.isConnectionUserActive(connection.getConnectionID(), currentUser.getUserID()))
TokenFilter tokenFilter = new TokenFilter();
StandardTokens.addStandardTokens(tokenFilter, currentUser.getCredentials());
GuacamoleConfiguration config = new GuacamoleConfiguration(connection.getConfiguration());
tokenFilter.filterValues(config.getParameters());
config, info
config, info
currentUser.getUserID(), connectionGroupID);
AuthenticatedUser currentUser, Integer parentID) {
return toMySQLConnection(connection, currentUser);
import net.sourceforge.guacamole.net.auth.mysql.AuthenticatedUser;
public void verifyUserAccess(AuthenticatedUser currentUser, int affectedUserID,
if(!checkUserAccess(currentUser, affectedUserID, permissionType))
public void verifyConnectionAccess(AuthenticatedUser currentUser,
int affectedConnectionID, String permissionType) throws GuacamoleSecurityException {
if(!checkConnectionAccess(currentUser, affectedConnectionID, permissionType))
public void verifyConnectionGroupAccess(AuthenticatedUser currentUser,
Integer affectedConnectionGroupID, String permissionType) throws GuacamoleSecurityException {
if(!checkConnectionGroupAccess(currentUser, affectedConnectionGroupID, permissionType))
public void verifySystemAccess(AuthenticatedUser currentUser, String systemPermissionType)
if(!checkSystemAccess(currentUser, systemPermissionType))
public boolean checkUserAccess(AuthenticatedUser currentUser,
Integer affectedUserID, String permissionType) {
if(checkSystemAdministratorAccess(currentUser))
example.createCriteria().andUser_idEqualTo(currentUser.getUserID()).andAffected_user_idEqualTo(affectedUserID).andPermissionEqualTo(permissionType);
public boolean checkConnectionAccess(AuthenticatedUser currentUser,
Integer affectedConnectionID, String permissionType) {
if(checkSystemAdministratorAccess(currentUser))
example.createCriteria().andUser_idEqualTo(currentUser.getUserID()).andConnection_idEqualTo(affectedConnectionID).andPermissionEqualTo(permissionType);
public boolean checkConnectionGroupAccess(AuthenticatedUser currentUser,
Integer affectedConnectionGroupID, String permissionType) {
if(checkSystemAdministratorAccess(currentUser))
example.createCriteria().andUser_idEqualTo(currentUser.getUserID()).andConnection_group_idEqualTo(affectedConnectionGroupID).andPermissionEqualTo(permissionType);
private boolean checkSystemAccess(AuthenticatedUser currentUser, String systemPermissionType) {
if(checkSystemAdministratorAccess(currentUser))
example.createCriteria().andUser_idEqualTo(currentUser.getUserID()).andPermissionEqualTo(systemPermissionType);
private boolean checkSystemAdministratorAccess(AuthenticatedUser currentUser) {
example.createCriteria().andUser_idEqualTo(currentUser.getUserID())
.andPermissionEqualTo(MySQLConstants.SYSTEM_ADMINISTER);
AuthenticatedUser currentUser, String type) throws GuacamoleSecurityException {
if(!checkConnectionGroupUsageAccess(connectionGroupID, currentUser, type))
Integer connectionGroupID, AuthenticatedUser currentUser, String usage) {
if(checkSystemAdministratorAccess(currentUser))
if(checkConnectionGroupAccess(currentUser, connectionGroupID,
retrieveConnectionGroup(connectionGroupID, currentUser);
public List<Integer> retrieveUserIDs(AuthenticatedUser currentUser, String permissionType) {
if(checkSystemAdministratorAccess(currentUser))
example.createCriteria().andUser_idEqualTo(currentUser.getUserID()).andPermissionEqualTo(permissionType);
List<Integer> currentUsers = new ArrayList<Integer>(userPermissions.size());
currentUsers.add(permission.getAffected_user_id());
return currentUsers;
public List<Integer> retrieveConnectionIDs(AuthenticatedUser currentUser,
return retrieveConnectionIDs(currentUser, null, permissionType, false);
public List<Integer> retrieveConnectionIDs(AuthenticatedUser currentUser, Integer parentID,
return retrieveConnectionIDs(currentUser, parentID, permissionType, true);
private List<Integer> retrieveConnectionIDs(AuthenticatedUser currentUser, Integer parentID,
if(checkSystemAdministratorAccess(currentUser)) {
Criteria criteria = example.createCriteria().andUser_idEqualTo(currentUser.getUserID())
public List<Integer> retrieveConnectionGroupIDs(AuthenticatedUser currentUser,
return retrieveConnectionGroupIDs(currentUser, null, permissionType, false);
public List<Integer> retrieveConnectionGroupIDs(AuthenticatedUser currentUser, Integer parentID,
return retrieveConnectionGroupIDs(currentUser, parentID, permissionType, true);
private List<Integer> retrieveConnectionGroupIDs(AuthenticatedUser currentUser, Integer parentID,
if(checkSystemAdministratorAccess(currentUser)) {
example.createCriteria().andUser_idEqualTo(currentUser.getUserID())
public Set<String> retrieveUsernames(AuthenticatedUser currentUser, String permissionType) {
if(checkSystemAdministratorAccess(currentUser))
List<Integer> currentUsers =
retrieveUserIDs(currentUser, MySQLConstants.USER_READ);
return userService.translateUsernames(currentUsers).keySet();
public Set<String> retrieveConnectionIdentifiers(AuthenticatedUser currentUser, Integer parentID,
if(checkSystemAdministratorAccess(currentUser))
retrieveConnectionIDs(currentUser, parentID, permissionType);
public Set<String> retrieveConnectionGroupIdentifiers(AuthenticatedUser currentUser, Integer parentID,
if(checkSystemAdministratorAccess(currentUser))
retrieveConnectionGroupIDs(currentUser, parentID, permissionType);
import org.glyptodon.guacamole.net.auth.permission.SystemPermission;
boolean isAdmin = self.hasPermission(new SystemPermission(SystemPermission.Type.ADMINISTER));
if (isAdmin || permission == null || self.hasPermission(new ConnectionPermission(permission, childIdentifier)))
import java.util.List;
private boolean hasConnectionPermission(User user, String identifier,
List<ObjectPermission.Type> permissions) throws GuacamoleException {
for (ObjectPermission.Type permission : permissions) {
ConnectionPermission connectionPermission = new ConnectionPermission(permission, identifier);
if (user.hasPermission(connectionPermission))
return true;
}
return false;
}
String identifier, boolean includeDescendants, List<ObjectPermission.Type> permissions)
if (isAdmin || permissions == null || hasConnectionPermission(self, childIdentifier, permissions))
APIConnectionGroup childConnectionGroup = retrieveConnectionGroup(userContext, childIdentifier, true, permissions);
@QueryParam("permission") List<ObjectPermission.Type> permissions)
APIConnectionGroup connectionGroup = retrieveConnectionGroup(userContext, connectionGroupID, true, permissions);
import java.util.List;
import org.glyptodon.guacamole.net.auth.permission.SystemPermission;
private boolean hasConnectionPermission(User user, String identifier,
List<ObjectPermission.Type> permissions) throws GuacamoleException {
for (ObjectPermission.Type permission : permissions) {
ConnectionPermission connectionPermission = new ConnectionPermission(permission, identifier);
if (user.hasPermission(connectionPermission))
return true;
}
return false;
}
String identifier, boolean includeDescendants, List<ObjectPermission.Type> permissions)
boolean isAdmin = self.hasPermission(new SystemPermission(SystemPermission.Type.ADMINISTER));
if (isAdmin || permissions == null || hasConnectionPermission(self, childIdentifier, permissions))
APIConnectionGroup childConnectionGroup = retrieveConnectionGroup(userContext, childIdentifier, true, permissions);
@QueryParam("permission") List<ObjectPermission.Type> permissions)
APIConnectionGroup connectionGroup = retrieveConnectionGroup(userContext, connectionGroupID, true, permissions);
private boolean hasUserPermission(User user, String username,
List<ObjectPermission.Type> permissions) throws GuacamoleException {
for (ObjectPermission.Type permission : permissions) {
UserPermission userPermission = new UserPermission(permission, username);
if (user.hasPermission(userPermission))
return true;
}
return false;
}
@QueryParam("permission") List<ObjectPermission.Type> permissions)
boolean isAdmin = self.hasPermission(new SystemPermission(SystemPermission.Type.ADMINISTER));
if (isAdmin || permissions == null || hasUserPermission(self, username, permissions))
private boolean hasUserPermission(User user, String username,
List<ObjectPermission.Type> permissions) throws GuacamoleException {
for (ObjectPermission.Type permission : permissions) {
UserPermission userPermission = new UserPermission(permission, username);
if (user.hasPermission(userPermission))
return true;
}
return false;
}
@QueryParam("permission") List<ObjectPermission.Type> permissions)
boolean isAdmin = self.hasPermission(new SystemPermission(SystemPermission.Type.ADMINISTER));
if (isAdmin || permissions == null || hasUserPermission(self, username, permissions))
import java.util.Collections;
import org.glyptodon.guacamole.net.auth.permission.ConnectionGroupPermission;
private boolean hasConnectionGroupPermission(User user, String identifier,
List<ObjectPermission.Type> permissions) throws GuacamoleException {
for (ObjectPermission.Type permission : permissions) {
ConnectionGroupPermission connectionGroupPermission = new ConnectionGroupPermission(permission, identifier);
if (user.hasPermission(connectionGroupPermission))
return true;
}
return false;
}
if (includeDescendants
&& (connectionGroup.getType() != ConnectionGroup.Type.BALANCING
|| isAdmin
|| hasConnectionGroupPermission(self, identifier,
Collections.singletonList(ObjectPermission.Type.ADMINISTER)))) {
import java.util.Collections;
import org.glyptodon.guacamole.net.auth.permission.ConnectionGroupPermission;
private boolean hasConnectionGroupPermission(User user, String identifier,
List<ObjectPermission.Type> permissions) throws GuacamoleException {
for (ObjectPermission.Type permission : permissions) {
ConnectionGroupPermission connectionGroupPermission = new ConnectionGroupPermission(permission, identifier);
if (user.hasPermission(connectionGroupPermission))
return true;
}
return false;
}
if (includeDescendants
&& (connectionGroup.getType() != ConnectionGroup.Type.BALANCING
|| isAdmin
|| hasConnectionGroupPermission(self, identifier,
Collections.singletonList(ObjectPermission.Type.ADMINISTER)))) {
String username = credentials.getUsername();
if (username != null)
return new SimpleUserContext(username, configs);
else
return new SimpleUserContext(configs);
if (permissions != null && permissions.isEmpty())
permissions = null;
if (permissions != null && permissions.isEmpty())
permissions = null;
if (username != null && !username.isEmpty())
String username = credentials.getUsername();
if (username != null && !username.isEmpty())
return new SimpleUserContext(username, configs);
else
return new SimpleUserContext(configs);
if (permissions != null && permissions.isEmpty())
permissions = null;
if (permissions != null && permissions.isEmpty())
permissions = null;
import java.util.List;
import org.glyptodon.guacamole.net.auth.ConnectionRecord;
private int activeUsers;
this.activeUsers = 0;
for (ConnectionRecord history : connection.getHistory()) {
if (history.isActive())
}
public int getActiveUsers() {
return activeUsers;
}
public void setActiveUsers(int activeUsers) {
this.activeUsers = activeUsers;
}
import java.util.List;
import org.glyptodon.guacamole.net.auth.ConnectionRecord;
private int activeUsers;
this.activeUsers = 0;
for (ConnectionRecord history : connection.getHistory()) {
if (history.isActive())
}
public int getActiveUsers() {
return activeUsers;
}
public void setActiveUsers(int activeUsers) {
this.activeUsers = activeUsers;
}
import java.util.Collections;
public List<ConnectionRecord> getConnectionHistory(@QueryParam("token") String authToken,
return Collections.<ConnectionRecord>unmodifiableList(connection.getHistory());
import java.util.Collections;
public List<ConnectionRecord> getConnectionHistory(@QueryParam("token") String authToken,
return Collections.<ConnectionRecord>unmodifiableList(connection.getHistory());
protected GuacamoleClientInformation getClientInformation(TunnelRequest request) {
return info;
}
protected GuacamoleSocket createConnectedSocket(TunnelRequest request, GuacamoleSession session,
GuacamoleClientInformation info) throws GuacamoleException {
String id = request.getParameter("id");
TunnelRequest.IdentifierType id_type = TunnelRequest.IdentifierType.getType(id);
if (id_type == null)
throw new GuacamoleClientException("Illegal identifier - unknown type.");
id = id.substring(id_type.PREFIX.length());
context.getRootConnectionGroup().getConnectionDirectory();
context.getRootConnectionGroup().getConnectionGroupDirectory();
return socket;
}
protected GuacamoleTunnel createAssociatedTunnel(GuacamoleSocket socket, final String authToken) {
return new GuacamoleTunnel(socket) {
}
public GuacamoleTunnel createTunnel(TunnelRequest request)
throws GuacamoleException {
final String authToken = request.getParameter("authToken");
final GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
final GuacamoleClientInformation info = getClientInformation(request);
final GuacamoleSocket socket = createConnectedSocket(request, session, info);
GuacamoleTunnel tunnel = createAssociatedTunnel(socket, authToken);
permissionCheckService.verifyConnectionGroupAccess(currentUser,
MySQLConstants.CONNECTION_GROUP_UPDATE);
permissionCheckService.verifyConnectionGroupAccess(currentUser,
permissionCheckService.verifyConnectionGroupAccess(currentUser,
MySQLConstants.CONNECTION_GROUP_UPDATE);
permissionCheckService.verifyConnectionGroupAccess(currentUser,
import java.util.Collection;
Collection<ObjectType> getAll(Collection<IdentifierType> identifiers)
throws GuacamoleException;
public class SimpleConnectionDirectory extends SimpleDirectory<String, Connection> {
private final Map<String, Connection> connections =
new SimpleConnection(entry.getKey(), entry.getKey(),
super.setObjects(connections);
extends SimpleDirectory<String, ConnectionGroup> {
private final Map<String, ConnectionGroup> connectionGroups =
super.setObjects(connectionGroups);
public class SimpleUserDirectory extends SimpleDirectory<String, User> {
super(Collections.singletonMap(user.getUsername(), user));
import org.glyptodon.guacamole.net.auth.permission.ObjectPermissionSet;
import org.glyptodon.guacamole.net.auth.permission.SystemPermissionSet;
SystemPermissionSet getSystemPermissions() throws GuacamoleException;
ObjectPermissionSet<String, Connection> getConnectionPermissions() throws GuacamoleException;
ObjectPermissionSet<String, ConnectionGroup> getConnectionGroupPermissions() throws GuacamoleException;
ObjectPermissionSet<String, User> getUserPermissions() throws GuacamoleException;
public class ObjectPermission<IdentifierType> implements Permission<ObjectPermission.Type> {
private final IdentifierType identifier;
private final Type type;
public ObjectPermission(Type type, IdentifierType identifier) {
this.identifier = identifier;
this.type = type;
}
public IdentifierType getObjectIdentifier() {
return identifier;
}
@Override
public Type getType() {
return type;
}
@Override
public int hashCode() {
int hash = 5;
return hash;
}
@Override
public boolean equals(Object obj) {
if (obj == null) return false;
if (getClass() != obj.getClass()) return false;
final ObjectPermission other = (ObjectPermission) obj;
if (this.type != other.type)
return false;
if (identifier == null)
return other.identifier == null;
return identifier.equals(other.identifier);
}
import org.glyptodon.guacamole.net.auth.Connection;
import org.glyptodon.guacamole.net.auth.User;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermissionSet;
import org.glyptodon.guacamole.net.auth.permission.SystemPermissionSet;
private final Set<ObjectPermission<String>> connectionPermissions =
new HashSet<ObjectPermission<String>>();
private final Set<ObjectPermission<String>> connectionGroupPermissions =
new HashSet<ObjectPermission<String>>();
ObjectPermission permission = new ObjectPermission(
connectionPermissions.add(permission);
ObjectPermission permission = new ObjectPermission(
connectionGroupPermissions.add(permission);
public SystemPermissionSet getSystemPermissions()
throws GuacamoleException {
return new SimpleSystemPermissionSet();
public ObjectPermissionSet<String, Connection> getConnectionPermissions()
throws GuacamoleException {
return new SimpleObjectPermissionSet<String, Connection>(connectionPermissions);
public ObjectPermissionSet<String, ConnectionGroup> getConnectionGroupPermissions()
throws GuacamoleException {
return new SimpleObjectPermissionSet<String, ConnectionGroup>(connectionGroupPermissions);
public ObjectPermissionSet<String, User> getUserPermissions()
throws GuacamoleException {
return new SimpleObjectPermissionSet<String, User>();
ObjectPermissionSet<String> getConnectionPermissions()
throws GuacamoleException;
ObjectPermissionSet<String> getConnectionGroupPermissions()
throws GuacamoleException;
ObjectPermissionSet<String> getUserPermissions() throws GuacamoleException;
public interface ObjectPermissionSet<IdentifierType> {
public class SimpleObjectPermissionSet<IdentifierType>
implements ObjectPermissionSet<IdentifierType> {
public ObjectPermissionSet<String> getConnectionPermissions()
return new SimpleObjectPermissionSet<String>(connectionPermissions);
public ObjectPermissionSet<String> getConnectionGroupPermissions()
return new SimpleObjectPermissionSet<String>(connectionGroupPermissions);
public ObjectPermissionSet<String> getUserPermissions()
return new SimpleObjectPermissionSet<String>();
import java.util.Set;
Set<ObjectPermission<IdentifierType>> getPermissions()
throws GuacamoleException;
void addPermissions(Set<ObjectPermission<IdentifierType>> permissions)
throws GuacamoleException;
void removePermissions(Set<ObjectPermission<IdentifierType>> permissions)
throws GuacamoleException;
import java.util.Set;
Set<SystemPermission> getPermissions() throws GuacamoleException;
void addPermissions(Set<SystemPermission> permissions)
throws GuacamoleException;
void removePermissions(Set<SystemPermission> permissions)
throws GuacamoleException;
@Override
public Set<ObjectPermission<IdentifierType>> getPermissions() {
@Override
public void addPermissions(Set<ObjectPermission<IdentifierType>> permissions)
throws GuacamoleException {
throw new GuacamoleSecurityException("Permission denied.");
}
@Override
public void removePermissions(Set<ObjectPermission<IdentifierType>> permissions)
throws GuacamoleException {
throw new GuacamoleSecurityException("Permission denied.");
}
@Override
public Set<SystemPermission> getPermissions() {
@Override
public void addPermissions(Set<SystemPermission> permissions)
throws GuacamoleException {
throw new GuacamoleSecurityException("Permission denied.");
}
@Override
public void removePermissions(Set<SystemPermission> permissions)
throws GuacamoleException {
throw new GuacamoleSecurityException("Permission denied.");
}
public interface ObjectPermissionSet<IdentifierType>
extends PermissionSet<ObjectPermission<IdentifierType>> {
@Override
@Override
@Override
public interface SystemPermissionSet extends PermissionSet<SystemPermission> {
@Override
@Override
@Override
import org.glyptodon.guacamole.net.auth.permission.ObjectPermissionSet;
import org.glyptodon.guacamole.net.auth.permission.SystemPermissionSet;
SystemPermissionSet systemPermissions = self.getSystemPermissions();
ObjectPermissionSet<String> connectionPermissions = self.getConnectionPermissions();
if (!systemPermissions.hasPermission(SystemPermission.Type.ADMINISTER)
&& !connectionPermissions.hasPermission(ObjectPermission.Type.UPDATE, connectionID))
import org.glyptodon.guacamole.net.auth.permission.ObjectPermissionSet;
import org.glyptodon.guacamole.net.auth.permission.SystemPermissionSet;
ObjectPermissionSet<String> connectionPermissions = user.getConnectionPermissions();
if (connectionPermissions.hasPermission(permission, identifier))
ObjectPermissionSet<String> connectionGroupPermissions = user.getConnectionGroupPermissions();
if (connectionGroupPermissions.hasPermission(permission, identifier))
SystemPermissionSet systemPermissions = self.getSystemPermissions();
boolean isAdmin = systemPermissions.hasPermission(SystemPermission.Type.ADMINISTER);
import org.glyptodon.guacamole.net.auth.User;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermissionSet;
import org.glyptodon.guacamole.net.auth.permission.SystemPermissionSet;
private Map<String, Set<ObjectPermission.Type>> connectionPermissions =
new HashMap<String, Set<ObjectPermission.Type>>();
private Map<String, Set<ObjectPermission.Type>> connectionGroupPermissions =
new HashMap<String, Set<ObjectPermission.Type>>();
private Map<String, Set<ObjectPermission.Type>> userPermissions =
new HashMap<String, Set<ObjectPermission.Type>>();
private Set<SystemPermission.Type> systemPermissions =
EnumSet.noneOf(SystemPermission.Type.class);
private void addSystemPermissions(Set<SystemPermission.Type> permissions,
SystemPermissionSet permSet) throws GuacamoleException {
for (SystemPermission permission : permSet.getPermissions())
permissions.add(permission.getType());
private void addObjectPermissions(Map<String, Set<ObjectPermission.Type>> permissions,
ObjectPermissionSet<String> permSet) throws GuacamoleException {
for (ObjectPermission<String> permission : permSet.getPermissions()) {
String identifier = permission.getObjectIdentifier();
Set<ObjectPermission.Type> objectPermissions = permissions.get(identifier);
if (objectPermissions == null)
permissions.put(identifier, EnumSet.of(permission.getType()));
else
objectPermissions.add(permission.getType());
}
}
public APIPermissionSet(User user) throws GuacamoleException {
addSystemPermissions(systemPermissions,          user.getSystemPermissions());
addObjectPermissions(connectionPermissions,      user.getConnectionPermissions());
addObjectPermissions(connectionGroupPermissions, user.getConnectionGroupPermissions());
addObjectPermissions(userPermissions,            user.getUserPermissions());
public Map<String, Set<ObjectPermission.Type>> getConnectionPermissions() {
public Map<String, Set<ObjectPermission.Type>> getConnectionGroupPermissions() {
public Map<String, Set<ObjectPermission.Type>> getUserPermissions() {
public Set<SystemPermission.Type> getSystemPermissions() {
public void setConnectionPermissions(Map<String, Set<ObjectPermission.Type>> connectionPermissions) {
public void setConnectionGroupPermissions(Map<String, Set<ObjectPermission.Type>> connectionGroupPermissions) {
public void setUserPermissions(Map<String, Set<ObjectPermission.Type>> userPermissions) {
public void setSystemPermissions(Set<SystemPermission.Type> systemPermissions) {
import org.glyptodon.guacamole.GuacamoleUnsupportedException;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermissionSet;
import org.glyptodon.guacamole.net.auth.permission.SystemPermissionSet;
public SystemPermissionSet getSystemPermissions()
throws GuacamoleException {
throw new GuacamoleUnsupportedException("APIUserWrapper does not provide permission access.");
public ObjectPermissionSet<String> getConnectionPermissions()
throws GuacamoleException {
throw new GuacamoleUnsupportedException("APIUserWrapper does not provide permission access.");
public ObjectPermissionSet<String> getConnectionGroupPermissions()
throws GuacamoleException {
throw new GuacamoleUnsupportedException("APIUserWrapper does not provide permission access.");
public ObjectPermissionSet<String> getUserPermissions()
throws GuacamoleException {
throw new GuacamoleUnsupportedException("APIUserWrapper does not provide permission access.");
import java.util.Collections;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermissionSet;
import org.glyptodon.guacamole.net.auth.permission.PermissionSet;
import org.glyptodon.guacamole.net.auth.permission.SystemPermissionSet;
ObjectPermissionSet<String> userPermissions = user.getUserPermissions();
if (userPermissions.hasPermission(permission, username))
SystemPermissionSet systemPermissions = self.getSystemPermissions();
boolean isAdmin = systemPermissions.hasPermission(SystemPermission.Type.ADMINISTER);
return new APIPermissionSet(user);
}
private <PermissionType extends Permission> void updatePermissionSet(
APIPatch.Operation operation,
PermissionSet<PermissionType> permissionSet,
PermissionType permission) throws GuacamoleException {
switch (operation) {
case add:
permissionSet.addPermissions(Collections.singleton(permission));
break;
case remove:
permissionSet.removePermissions(Collections.singleton(permission));
break;
default:
throw new HTTPException(Status.BAD_REQUEST,
}
ObjectPermission<String> permission = new ObjectPermission<String>(type, identifier);
updatePermissionSet(patch.getOp(), user.getConnectionPermissions(), permission);
ObjectPermission<String> permission = new ObjectPermission<String>(type, identifier);
updatePermissionSet(patch.getOp(), user.getConnectionGroupPermissions(), permission);
ObjectPermission<String> permission = new ObjectPermission<String>(type, identifier);
updatePermissionSet(patch.getOp(), user.getUserPermissions(), permission);
SystemPermission permission = new SystemPermission(type);
updatePermissionSet(patch.getOp(), user.getSystemPermissions(), permission);
import java.util.Collection;
Collection<String> userIdentifiers = userDirectory.getIdentifiers();
if (!isAdmin && permissions != null) {
ObjectPermissionSet<String> userPermissions = self.getUserPermissions();
userIdentifiers = userPermissions.getAccessibleObjects(permissions, userIdentifiers);
List<APIUser> apiUsers = new ArrayList<APIUser>();
for (User user : userDirectory.getAll(userIdentifiers))
apiUsers.add(new APIUser(user));
return apiUsers;
PermissionSetPatch<PermissionType> permissionSetPatch,
PermissionType permission) {
permissionSetPatch.addPermission(permission);
permissionSetPatch.removePermission(permission);
PermissionSetPatch<ObjectPermission<String>> connectionPermissionPatch      = new PermissionSetPatch<ObjectPermission<String>>();
PermissionSetPatch<ObjectPermission<String>> connectionGroupPermissionPatch = new PermissionSetPatch<ObjectPermission<String>>();
PermissionSetPatch<ObjectPermission<String>> userPermissionPatch            = new PermissionSetPatch<ObjectPermission<String>>();
PermissionSetPatch<SystemPermission>         systemPermissionPatch          = new PermissionSetPatch<SystemPermission>();
updatePermissionSet(patch.getOp(), connectionPermissionPatch, permission);
updatePermissionSet(patch.getOp(), connectionGroupPermissionPatch, permission);
updatePermissionSet(patch.getOp(), userPermissionPatch, permission);
updatePermissionSet(patch.getOp(), systemPermissionPatch, permission);
connectionPermissionPatch.apply(user.getConnectionPermissions());
connectionGroupPermissionPatch.apply(user.getConnectionGroupPermissions());
userPermissionPatch.apply(user.getUserPermissions());
systemPermissionPatch.apply(user.getSystemPermissions());
else if (path.equals(SYSTEM_PERMISSION_PATCH_PATH)) {
public String getIdentifier() {
public void setIdentifier(String username) {
public interface Connection extends Identifiable {
public interface ConnectionGroup extends Identifiable {
ORGANIZATIONAL,
BALANCING
Directory<Connection> getConnectionDirectory()
Directory<ConnectionGroup> getConnectionGroupDirectory()
public interface Directory<ObjectType> {
ObjectType get(String identifier) throws GuacamoleException;
Collection<ObjectType> getAll(Collection<String> identifiers)
Set<String> getIdentifiers() throws GuacamoleException;
void remove(String identifier) throws GuacamoleException;
void move(String identifier, Directory<ObjectType> directory)
public interface User extends Identifiable {
ObjectPermissionSet getConnectionPermissions()
ObjectPermissionSet getConnectionGroupPermissions()
ObjectPermissionSet getUserPermissions() throws GuacamoleException;
Directory<User> getUserDirectory() throws GuacamoleException;
public class ObjectPermission implements Permission<ObjectPermission.Type> {
private final String identifier;
public ObjectPermission(Type type, String identifier) {
public String getObjectIdentifier() {
public interface ObjectPermissionSet extends PermissionSet<ObjectPermission> {
String identifier) throws GuacamoleException;
String identifier) throws GuacamoleException;
String identifier) throws GuacamoleException;
Collection<String> getAccessibleObjects(
Collection<String> identifiers) throws GuacamoleException;
Set<ObjectPermission> getPermissions()
void addPermissions(Set<ObjectPermission> permissions)
void removePermissions(Set<ObjectPermission> permissions)
public class SimpleConnectionDirectory extends SimpleDirectory<Connection> {
private final Directory<Connection> connectionDirectory;
private final Directory<ConnectionGroup> connectionGroupDirectory;
Directory<Connection> connectionDirectory,
Directory<ConnectionGroup> connectionGroupDirectory) {
public Directory<Connection> getConnectionDirectory()
public Directory<ConnectionGroup> getConnectionGroupDirectory()
extends SimpleDirectory<ConnectionGroup> {
public class SimpleDirectory<ObjectType> implements Directory<ObjectType> {
private Map<String, ObjectType> objects = Collections.EMPTY_MAP;
public SimpleDirectory(Map<String, ObjectType> objects) {
protected void setObjects(Map<String, ObjectType> objects) {
protected Map<String, ObjectType> getObjects() {
public ObjectType get(String identifier)
public Collection<ObjectType> getAll(Collection<String> identifiers)
for (String identifier : identifiers) {
public Set<String> getIdentifiers() throws GuacamoleException {
public void remove(String identifier) throws GuacamoleException {
public void move(String identifier, Directory<ObjectType> directory)
public class SimpleObjectPermissionSet implements ObjectPermissionSet {
private Set<ObjectPermission> permissions = Collections.EMPTY_SET;
public SimpleObjectPermissionSet(Set<ObjectPermission> permissions) {
protected void setPermissions(Set<ObjectPermission> permissions) {
public Set<ObjectPermission> getPermissions() {
String identifier) throws GuacamoleException {
ObjectPermission objectPermission =
new ObjectPermission(permission, identifier);
String identifier) throws GuacamoleException {
String identifier) throws GuacamoleException {
public Collection<String> getAccessibleObjects(
Collection<String> identifiers) throws GuacamoleException {
Collection<String> accessibleObjects = new ArrayList<String>(permissions.size());
for (String identifier : identifiers) {
ObjectPermission permission = new ObjectPermission(permissionType, identifier);
public void addPermissions(Set<ObjectPermission> permissions)
public void removePermissions(Set<ObjectPermission> permissions)
private final Set<ObjectPermission> connectionPermissions =
new HashSet<ObjectPermission>();
private final Set<ObjectPermission> connectionGroupPermissions =
new HashSet<ObjectPermission>();
setIdentifier(username);
public ObjectPermissionSet getConnectionPermissions()
return new SimpleObjectPermissionSet(connectionPermissions);
public ObjectPermissionSet getConnectionGroupPermissions()
return new SimpleObjectPermissionSet(connectionGroupPermissions);
public ObjectPermissionSet getUserPermissions()
return new SimpleObjectPermissionSet();
private final Directory<User> userDirectory;
public Directory<User> getUserDirectory()
public class SimpleUserDirectory extends SimpleDirectory<User> {
super(Collections.singletonMap(user.getIdentifier(), user));
Directory<Connection> directory =
logger.info("Connection \"{}\" does not exist for user \"{}\".", id, context.self().getIdentifier());
logger.info("User \"{}\" successfully connected to \"{}\".", context.self().getIdentifier(), id);
Directory<ConnectionGroup> directory =
logger.info("Connection group \"{}\" does not exist for user \"{}\".", id, context.self().getIdentifier());
logger.info("User \"{}\" successfully connected to group \"{}\".", context.self().getIdentifier(), id);
Directory<User> directory = userContext.getUserDirectory();
Directory<Connection> directory = rootGroup.getConnectionDirectory();
Directory<ConnectionGroup> directory = rootGroup.getConnectionGroupDirectory();
logger.debug("Login was successful for user \"{}\".", userContext.self().getIdentifier());
return new APIAuthToken(authToken, userContext.self().getIdentifier());
ObjectPermissionSet connectionPermissions = self.getConnectionPermissions();
Directory<Connection> connectionDirectory =
Directory<Connection> connectionDirectory = parentConnectionGroup.getConnectionDirectory();
Directory<Connection> connectionDirectory =
public Directory<Connection> getConnectionDirectory() throws GuacamoleException {
public Directory<ConnectionGroup> getConnectionGroupDirectory() throws GuacamoleException {
ObjectPermissionSet connectionPermissions = user.getConnectionPermissions();
ObjectPermissionSet connectionGroupPermissions = user.getConnectionGroupPermissions();
Directory<Connection> connectionDirectory = connectionGroup.getConnectionDirectory();
Directory<ConnectionGroup> groupDirectory = connectionGroup.getConnectionGroupDirectory();
Directory<ConnectionGroup> connectionGroupDirectory =
Directory<ConnectionGroup> connectionGroupDirectory = parentConnectionGroup.getConnectionGroupDirectory();
Directory<ConnectionGroup> connectionGroupDirectory =
ObjectPermissionSet permSet) throws GuacamoleException {
for (ObjectPermission permission : permSet.getPermissions()) {
this.username = user.getIdentifier();
public String getIdentifier() {
public void setIdentifier(String username) {
public ObjectPermissionSet getConnectionPermissions()
public ObjectPermissionSet getConnectionGroupPermissions()
public ObjectPermissionSet getUserPermissions()
Directory<User> userDirectory = userContext.getUserDirectory();
ObjectPermissionSet userPermissions = self.getUserPermissions();
Directory<User> userDirectory = userContext.getUserDirectory();
Directory<User> userDirectory = userContext.getUserDirectory();
Directory<User> userDirectory = userContext.getUserDirectory();
if (userContext.self().getIdentifier().equals(username))
PermissionSetPatch<ObjectPermission> connectionPermissionPatch      = new PermissionSetPatch<ObjectPermission>();
PermissionSetPatch<ObjectPermission> connectionGroupPermissionPatch = new PermissionSetPatch<ObjectPermission>();
PermissionSetPatch<ObjectPermission> userPermissionPatch            = new PermissionSetPatch<ObjectPermission>();
PermissionSetPatch<SystemPermission> systemPermissionPatch          = new PermissionSetPatch<SystemPermission>();
ObjectPermission permission = new ObjectPermission(type, identifier);
ObjectPermission permission = new ObjectPermission(type, identifier);
ObjectPermission permission = new ObjectPermission(type, identifier);
return new APIConnectionGroup(retrievalService.retrieveConnectionGroup(userContext, connectionGroupID));
ConnectionGroup treeRoot = retrievalService.retrieveConnectionGroup(userContext, connectionGroupID);
ConnectionGroupTree tree = new ConnectionGroupTree(treeRoot, permissions);
return tree.getRootAPIConnectionGroup();
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import org.glyptodon.guacamole.net.auth.Connection;
import org.glyptodon.guacamole.net.basic.rest.connection.APIConnection;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
private static final Logger logger = LoggerFactory.getLogger(ConnectionGroupTree.class);
private final ConnectionGroup root;
private final APIConnectionGroup rootAPIGroup;
private final Map<String, APIConnectionGroup> retrievedGroups =
new HashMap<String, APIConnectionGroup>();
private void addConnections(Collection<Connection> connections)
throws GuacamoleException {
for (Connection connection : connections) {
APIConnectionGroup parent = retrievedGroups.get(connection.getParentIdentifier());
if (parent != null) {
Collection<APIConnection> children = parent.getChildConnections();
if (children == null) {
children = new ArrayList<APIConnection>();
parent.setChildConnections(children);
}
children.add(new APIConnection(connection));
}
else
logger.debug("Connection \"{}\" cannot be added to the tree: parent \"{}\" does not actually exist.",
connection.getIdentifier(),
connection.getParentIdentifier());
}
private void addConnectionGroups(Collection<ConnectionGroup> connectionGroups) {
for (ConnectionGroup connectionGroup : connectionGroups) {
APIConnectionGroup parent = retrievedGroups.get(connectionGroup.getParentIdentifier());
if (parent != null) {
Collection<APIConnectionGroup> children = parent.getChildConnectionGroups();
if (children == null) {
children = new ArrayList<APIConnectionGroup>();
parent.setChildConnectionGroups(children);
}
APIConnectionGroup apiConnectionGroup = new APIConnectionGroup(connectionGroup);
retrievedGroups.put(connectionGroup.getIdentifier(), apiConnectionGroup);
children.add(apiConnectionGroup);
}
else
logger.debug("Connection group \"{}\" cannot be added to the tree: parent \"{}\" does not actually exist.",
connectionGroup.getIdentifier(),
connectionGroup.getParentIdentifier());
}
private void addDescendants(Collection<ConnectionGroup> parents)
throws GuacamoleException {
if (parents.isEmpty())
return;
Collection<String> childConnectionIdentifiers = new ArrayList<String>();
Collection<String> childConnectionGroupIdentifiers = new ArrayList<String>();
for (ConnectionGroup parent : parents) {
childConnectionIdentifiers.addAll(parent.getConnectionDirectory().getIdentifiers());
childConnectionGroupIdentifiers.addAll(parent.getConnectionGroupDirectory().getIdentifiers());
}
if (!childConnectionIdentifiers.isEmpty()) {
Collection<Connection> childConnections = root.getConnectionDirectory().getAll(childConnectionIdentifiers);
addConnections(childConnections);
}
if (!childConnectionGroupIdentifiers.isEmpty()) {
Collection<ConnectionGroup> childConnectionGroups = root.getConnectionGroupDirectory().getAll(childConnectionGroupIdentifiers);
addConnectionGroups(childConnectionGroups);
addDescendants(childConnectionGroups);
}
}
this.root = root;
this.rootAPIGroup = new APIConnectionGroup(root);
retrievedGroups.put(root.getIdentifier(), this.rootAPIGroup);
addDescendants(Collections.singleton(root));
return rootAPIGroup;
import java.util.Collection;
public SimpleConnectionDirectory(Collection<Connection> connections) {
for (Connection connection : connections)
this.connections.put(connection.getIdentifier(), connection);
super.setObjects(this.connections);
import java.util.ArrayList;
import java.util.Collection;
import org.glyptodon.guacamole.net.auth.Connection;
private static final String ROOT_IDENTIFIER = "ROOT";
Collection<Connection> connections = new ArrayList<Connection>(configs.size());
for (Map.Entry<String, GuacamoleConfiguration> configEntry : configs.entrySet()) {
String identifier = configEntry.getKey();
GuacamoleConfiguration config = configEntry.getValue();
Connection connection = new SimpleConnection(identifier, identifier, config);
connection.setParentIdentifier(ROOT_IDENTIFIER);
connections.add(connection);
}
this.connectionGroup = new SimpleConnectionGroup(
ROOT_IDENTIFIER, ROOT_IDENTIFIER,
new SimpleConnectionDirectory(connections),
public interface Connection extends Identifiable, Connectable {
import java.util.Set;
public interface ConnectionGroup extends Identifiable, Connectable {
public Set<String> getConnectionIdentifiers();
public Set<String> getConnectionGroupIdentifiers();
Directory<Connection> getConnectionDirectory()
throws GuacamoleException;
Directory<ConnectionGroup> getConnectionGroupDirectory()
throws GuacamoleException;
import java.util.Collection;
import java.util.HashSet;
import java.util.Set;
private final Set<String> connectionIdentifiers;
private final Set<String> connectionGroupIdentifiers;
Collection<String> connectionIdentifiers,
Collection<String> connectionGroupIdentifiers) {
this.connectionIdentifiers = new HashSet<String>(connectionIdentifiers);
this.connectionGroupIdentifiers = new HashSet<String>(connectionGroupIdentifiers);
public Set<String> getConnectionIdentifiers() {
return connectionIdentifiers;
}
@Override
public Set<String> getConnectionGroupIdentifiers() {
return connectionGroupIdentifiers;
private void addReadPermissions(Set<ObjectPermission> permissions,
Collection<String> identifiers) {
for (String identifier : identifiers) {
permissions.add(new ObjectPermission (
ObjectPermission.Type.READ,
identifier
));
}
}
Collection<String> connectionIdentifiers,
Collection<String> connectionGroupIdentifiers) {
addReadPermissions(connectionPermissions,      connectionIdentifiers);
addReadPermissions(connectionGroupPermissions, connectionGroupIdentifiers);
private final Directory<ConnectionGroup> connectionGroupDirectory;
private final Directory<Connection> connectionDirectory;
private final ConnectionGroup rootGroup;
Collection<String> connectionIdentifiers = new ArrayList<String>(configs.size());
Collection<String> connectionGroupIdentifiers = Collections.singleton(ROOT_IDENTIFIER);
connectionIdentifiers.add(identifier);
this.rootGroup = new SimpleConnectionGroup(
ROOT_IDENTIFIER, ROOT_IDENTIFIER,
connectionIdentifiers, Collections.EMPTY_LIST
);
this.self = new SimpleUser(username, connectionIdentifiers,
connectionGroupIdentifiers);
this.connectionDirectory = new SimpleConnectionDirectory(connections);
this.connectionGroupDirectory = new SimpleConnectionGroupDirectory(Collections.singleton(this.rootGroup));
public Directory<Connection> getConnectionDirectory()
throws GuacamoleException {
return connectionDirectory;
}
@Override
public Directory<ConnectionGroup> getConnectionGroupDirectory()
throws GuacamoleException {
return connectionGroupDirectory;
}
@Override
return rootGroup;
UserContext context = session.getUserContext();
Directory<Connection> directory = context.getConnectionDirectory();
UserContext context = session.getUserContext();
Directory<ConnectionGroup> directory = context.getConnectionGroupDirectory();
Directory<Connection> directory = userContext.getConnectionDirectory();
return userContext.getRootConnectionGroup();
Directory<ConnectionGroup> directory = userContext.getConnectionGroupDirectory();
Directory<Connection> connectionDirectory = userContext.getConnectionDirectory();
Directory<Connection> connectionDirectory = userContext.getConnectionDirectory();
Directory<Connection> connectionDirectory = userContext.getConnectionDirectory();
import java.util.Set;
public Set<String> getConnectionIdentifiers() {
public Set<String> getConnectionGroupIdentifiers() {
ConnectionGroupTree tree = new ConnectionGroupTree(userContext, treeRoot, permissions);
Directory<ConnectionGroup> connectionGroupDirectory = userContext.getConnectionGroupDirectory();
Directory<ConnectionGroup> connectionGroupDirectory = userContext.getConnectionGroupDirectory();
Directory<ConnectionGroup> connectionGroupDirectory = userContext.getConnectionGroupDirectory();
import org.glyptodon.guacamole.net.auth.UserContext;
private final UserContext userContext;
childConnectionIdentifiers.addAll(parent.getConnectionIdentifiers());
childConnectionGroupIdentifiers.addAll(parent.getConnectionGroupIdentifiers());
Collection<Connection> childConnections = userContext.getConnectionDirectory().getAll(childConnectionIdentifiers);
Collection<ConnectionGroup> childConnectionGroups = userContext.getConnectionGroupDirectory().getAll(childConnectionGroupIdentifiers);
public ConnectionGroupTree(UserContext userContext, ConnectionGroup root,
this.userContext = userContext;
public int getActiveConnections();
public int getActiveConnections() {
return 0;
}
@Override
public int getActiveConnections() {
return 0;
}
@Override
private int activeConnections;
this.activeConnections = connection.getActiveConnections();
public int getActiveConnections() {
return activeConnections;
public void setActiveUsers(int activeConnections) {
this.activeConnections = activeConnections;
public int getActiveConnections() {
return apiConnection.getActiveConnections();
}
@Override
private int activeConnections;
this.activeConnections = connectionGroup.getActiveConnections();
public int getActiveConnections() {
return activeConnections;
}
public void setActiveUsers(int activeConnections) {
this.activeConnections = activeConnections;
}
public int getActiveConnections() {
return apiConnectionGroup.getActiveConnections();
}
@Override
import org.glyptodon.guacamole.GuacamoleException;
public Set<String> getConnectionIdentifiers() throws GuacamoleException;
public Set<String> getConnectionGroupIdentifiers()
throws GuacamoleException;
public String getIdentifier() {
public void setIdentifier(String username) {
public interface Connection extends Identifiable, Connectable {
import java.util.Set;
public interface ConnectionGroup extends Identifiable, Connectable {
ORGANIZATIONAL,
BALANCING
public Set<String> getConnectionIdentifiers() throws GuacamoleException;
public Set<String> getConnectionGroupIdentifiers()
import java.util.Collection;
public interface Directory<ObjectType> {
ObjectType get(String identifier) throws GuacamoleException;
Collection<ObjectType> getAll(Collection<String> identifiers)
throws GuacamoleException;
Set<String> getIdentifiers() throws GuacamoleException;
void remove(String identifier) throws GuacamoleException;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermissionSet;
import org.glyptodon.guacamole.net.auth.permission.SystemPermissionSet;
public interface User extends Identifiable {
SystemPermissionSet getSystemPermissions() throws GuacamoleException;
ObjectPermissionSet getConnectionPermissions()
throws GuacamoleException;
ObjectPermissionSet getConnectionGroupPermissions()
throws GuacamoleException;
ObjectPermissionSet getUserPermissions() throws GuacamoleException;
Directory<User> getUserDirectory() throws GuacamoleException;
Directory<Connection> getConnectionDirectory()
throws GuacamoleException;
Directory<ConnectionGroup> getConnectionGroupDirectory()
throws GuacamoleException;
public class ObjectPermission implements Permission<ObjectPermission.Type> {
private final String identifier;
private final Type type;
public ObjectPermission(Type type, String identifier) {
this.identifier = identifier;
this.type = type;
}
public String getObjectIdentifier() {
return identifier;
}
@Override
public Type getType() {
return type;
}
@Override
public int hashCode() {
int hash = 5;
return hash;
}
@Override
public boolean equals(Object obj) {
if (obj == null) return false;
if (getClass() != obj.getClass()) return false;
final ObjectPermission other = (ObjectPermission) obj;
if (this.type != other.type)
return false;
if (identifier == null)
return other.identifier == null;
return identifier.equals(other.identifier);
}
public int getActiveConnections() {
return 0;
}
@Override
import java.util.Collection;
public class SimpleConnectionDirectory extends SimpleDirectory<Connection> {
private final Map<String, Connection> connections =
public SimpleConnectionDirectory(Collection<Connection> connections) {
for (Connection connection : connections)
this.connections.put(connection.getIdentifier(), connection);
super.setObjects(this.connections);
import java.util.Collection;
import java.util.HashSet;
import java.util.Set;
private final Set<String> connectionIdentifiers;
private final Set<String> connectionGroupIdentifiers;
Collection<String> connectionIdentifiers,
Collection<String> connectionGroupIdentifiers) {
this.connectionIdentifiers = new HashSet<String>(connectionIdentifiers);
this.connectionGroupIdentifiers = new HashSet<String>(connectionGroupIdentifiers);
public int getActiveConnections() {
return 0;
}
@Override
public Set<String> getConnectionIdentifiers() {
return connectionIdentifiers;
}
@Override
public Set<String> getConnectionGroupIdentifiers() {
return connectionGroupIdentifiers;
extends SimpleDirectory<ConnectionGroup> {
private final Map<String, ConnectionGroup> connectionGroups =
super.setObjects(connectionGroups);
import org.glyptodon.guacamole.net.auth.permission.ObjectPermissionSet;
import org.glyptodon.guacamole.net.auth.permission.SystemPermissionSet;
private final Set<ObjectPermission> connectionPermissions =
new HashSet<ObjectPermission>();
private final Set<ObjectPermission> connectionGroupPermissions =
new HashSet<ObjectPermission>();
private void addReadPermissions(Set<ObjectPermission> permissions,
Collection<String> identifiers) {
for (String identifier : identifiers) {
permissions.add(new ObjectPermission (
));
public SimpleUser(String username,
Collection<String> connectionIdentifiers,
Collection<String> connectionGroupIdentifiers) {
setIdentifier(username);
addReadPermissions(connectionPermissions,      connectionIdentifiers);
addReadPermissions(connectionGroupPermissions, connectionGroupIdentifiers);
public SystemPermissionSet getSystemPermissions()
throws GuacamoleException {
return new SimpleSystemPermissionSet();
public ObjectPermissionSet getConnectionPermissions()
throws GuacamoleException {
return new SimpleObjectPermissionSet(connectionPermissions);
public ObjectPermissionSet getConnectionGroupPermissions()
throws GuacamoleException {
return new SimpleObjectPermissionSet(connectionGroupPermissions);
}
@Override
public ObjectPermissionSet getUserPermissions()
throws GuacamoleException {
return new SimpleObjectPermissionSet();
import java.util.ArrayList;
import java.util.Collection;
import org.glyptodon.guacamole.net.auth.Connection;
private static final String ROOT_IDENTIFIER = "ROOT";
private final Directory<User> userDirectory;
private final Directory<ConnectionGroup> connectionGroupDirectory;
private final Directory<Connection> connectionDirectory;
private final ConnectionGroup rootGroup;
Collection<String> connectionIdentifiers = new ArrayList<String>(configs.size());
Collection<String> connectionGroupIdentifiers = Collections.singleton(ROOT_IDENTIFIER);
Collection<Connection> connections = new ArrayList<Connection>(configs.size());
for (Map.Entry<String, GuacamoleConfiguration> configEntry : configs.entrySet()) {
String identifier = configEntry.getKey();
GuacamoleConfiguration config = configEntry.getValue();
Connection connection = new SimpleConnection(identifier, identifier, config);
connection.setParentIdentifier(ROOT_IDENTIFIER);
connections.add(connection);
connectionIdentifiers.add(identifier);
}
this.rootGroup = new SimpleConnectionGroup(
ROOT_IDENTIFIER, ROOT_IDENTIFIER,
connectionIdentifiers, Collections.EMPTY_LIST
);
this.self = new SimpleUser(username, connectionIdentifiers,
connectionGroupIdentifiers);
this.connectionDirectory = new SimpleConnectionDirectory(connections);
this.connectionGroupDirectory = new SimpleConnectionGroupDirectory(Collections.singleton(this.rootGroup));
public Directory<User> getUserDirectory()
public Directory<Connection> getConnectionDirectory()
throws GuacamoleException {
return connectionDirectory;
}
@Override
public Directory<ConnectionGroup> getConnectionGroupDirectory()
throws GuacamoleException {
return connectionGroupDirectory;
}
@Override
return rootGroup;
public class SimpleUserDirectory extends SimpleDirectory<User> {
super(Collections.singletonMap(user.getIdentifier(), user));
UserContext context = session.getUserContext();
Directory<Connection> directory = context.getConnectionDirectory();
logger.info("Connection \"{}\" does not exist for user \"{}\".", id, context.self().getIdentifier());
logger.info("User \"{}\" successfully connected to \"{}\".", context.self().getIdentifier(), id);
UserContext context = session.getUserContext();
Directory<ConnectionGroup> directory = context.getConnectionGroupDirectory();
logger.info("Connection group \"{}\" does not exist for user \"{}\".", id, context.self().getIdentifier());
logger.info("User \"{}\" successfully connected to group \"{}\".", context.self().getIdentifier(), id);
Directory<User> directory = userContext.getUserDirectory();
Directory<Connection> directory = userContext.getConnectionDirectory();
return userContext.getRootConnectionGroup();
Directory<ConnectionGroup> directory = userContext.getConnectionGroupDirectory();
logger.debug("Login was successful for user \"{}\".", userContext.self().getIdentifier());
return new APIAuthToken(authToken, userContext.self().getIdentifier());
private int activeConnections;
this.activeConnections = connection.getActiveConnections();
public int getActiveConnections() {
return activeConnections;
public void setActiveUsers(int activeConnections) {
this.activeConnections = activeConnections;
public int getActiveConnections() {
return apiConnection.getActiveConnections();
}
@Override
import org.glyptodon.guacamole.net.auth.permission.ObjectPermissionSet;
import org.glyptodon.guacamole.net.auth.permission.SystemPermissionSet;
SystemPermissionSet systemPermissions = self.getSystemPermissions();
ObjectPermissionSet connectionPermissions = self.getConnectionPermissions();
if (!systemPermissions.hasPermission(SystemPermission.Type.ADMINISTER)
&& !connectionPermissions.hasPermission(ObjectPermission.Type.UPDATE, connectionID))
Directory<Connection> connectionDirectory = userContext.getConnectionDirectory();
Directory<Connection> connectionDirectory = userContext.getConnectionDirectory();
Directory<Connection> connectionDirectory = userContext.getConnectionDirectory();
private int activeConnections;
this.activeConnections = connectionGroup.getActiveConnections();
public int getActiveConnections() {
return activeConnections;
}
public void setActiveUsers(int activeConnections) {
this.activeConnections = activeConnections;
}
import java.util.Set;
public int getActiveConnections() {
return apiConnectionGroup.getActiveConnections();
}
@Override
public Set<String> getConnectionIdentifiers() {
public Set<String> getConnectionGroupIdentifiers() {
return new APIConnectionGroup(retrievalService.retrieveConnectionGroup(userContext, connectionGroupID));
ConnectionGroup treeRoot = retrievalService.retrieveConnectionGroup(userContext, connectionGroupID);
ConnectionGroupTree tree = new ConnectionGroupTree(userContext, treeRoot, permissions);
return tree.getRootAPIConnectionGroup();
Directory<ConnectionGroup> connectionGroupDirectory = userContext.getConnectionGroupDirectory();
Directory<ConnectionGroup> connectionGroupDirectory = userContext.getConnectionGroupDirectory();
Directory<ConnectionGroup> connectionGroupDirectory = userContext.getConnectionGroupDirectory();
import org.glyptodon.guacamole.net.auth.User;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermissionSet;
import org.glyptodon.guacamole.net.auth.permission.SystemPermissionSet;
private Map<String, Set<ObjectPermission.Type>> connectionPermissions =
new HashMap<String, Set<ObjectPermission.Type>>();
private Map<String, Set<ObjectPermission.Type>> connectionGroupPermissions =
new HashMap<String, Set<ObjectPermission.Type>>();
private Map<String, Set<ObjectPermission.Type>> userPermissions =
new HashMap<String, Set<ObjectPermission.Type>>();
private Set<SystemPermission.Type> systemPermissions =
EnumSet.noneOf(SystemPermission.Type.class);
private void addSystemPermissions(Set<SystemPermission.Type> permissions,
SystemPermissionSet permSet) throws GuacamoleException {
for (SystemPermission permission : permSet.getPermissions())
permissions.add(permission.getType());
private void addObjectPermissions(Map<String, Set<ObjectPermission.Type>> permissions,
ObjectPermissionSet permSet) throws GuacamoleException {
for (ObjectPermission permission : permSet.getPermissions()) {
String identifier = permission.getObjectIdentifier();
Set<ObjectPermission.Type> objectPermissions = permissions.get(identifier);
if (objectPermissions == null)
permissions.put(identifier, EnumSet.of(permission.getType()));
else
objectPermissions.add(permission.getType());
}
}
public APIPermissionSet(User user) throws GuacamoleException {
addSystemPermissions(systemPermissions,          user.getSystemPermissions());
addObjectPermissions(connectionPermissions,      user.getConnectionPermissions());
addObjectPermissions(connectionGroupPermissions, user.getConnectionGroupPermissions());
addObjectPermissions(userPermissions,            user.getUserPermissions());
public Map<String, Set<ObjectPermission.Type>> getConnectionPermissions() {
public Map<String, Set<ObjectPermission.Type>> getConnectionGroupPermissions() {
public Map<String, Set<ObjectPermission.Type>> getUserPermissions() {
public Set<SystemPermission.Type> getSystemPermissions() {
public void setConnectionPermissions(Map<String, Set<ObjectPermission.Type>> connectionPermissions) {
public void setConnectionGroupPermissions(Map<String, Set<ObjectPermission.Type>> connectionGroupPermissions) {
public void setUserPermissions(Map<String, Set<ObjectPermission.Type>> userPermissions) {
public void setSystemPermissions(Set<SystemPermission.Type> systemPermissions) {
this.username = user.getIdentifier();
import org.glyptodon.guacamole.GuacamoleUnsupportedException;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermissionSet;
import org.glyptodon.guacamole.net.auth.permission.SystemPermissionSet;
public String getIdentifier() {
public void setIdentifier(String username) {
public SystemPermissionSet getSystemPermissions()
throws GuacamoleException {
throw new GuacamoleUnsupportedException("APIUserWrapper does not provide permission access.");
public ObjectPermissionSet getConnectionPermissions()
throws GuacamoleException {
throw new GuacamoleUnsupportedException("APIUserWrapper does not provide permission access.");
public ObjectPermissionSet getConnectionGroupPermissions()
throws GuacamoleException {
throw new GuacamoleUnsupportedException("APIUserWrapper does not provide permission access.");
public ObjectPermissionSet getUserPermissions()
throws GuacamoleException {
throw new GuacamoleUnsupportedException("APIUserWrapper does not provide permission access.");
import java.util.Collection;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermissionSet;
import org.glyptodon.guacamole.net.auth.permission.SystemPermissionSet;
SystemPermissionSet systemPermissions = self.getSystemPermissions();
boolean isAdmin = systemPermissions.hasPermission(SystemPermission.Type.ADMINISTER);
Directory<User> userDirectory = userContext.getUserDirectory();
Collection<String> userIdentifiers = userDirectory.getIdentifiers();
if (!isAdmin && permissions != null) {
ObjectPermissionSet userPermissions = self.getUserPermissions();
userIdentifiers = userPermissions.getAccessibleObjects(permissions, userIdentifiers);
List<APIUser> apiUsers = new ArrayList<APIUser>();
for (User user : userDirectory.getAll(userIdentifiers))
apiUsers.add(new APIUser(user));
return apiUsers;
Directory<User> userDirectory = userContext.getUserDirectory();
Directory<User> userDirectory = userContext.getUserDirectory();
Directory<User> userDirectory = userContext.getUserDirectory();
if (userContext.self().getIdentifier().equals(username))
return new APIPermissionSet(user);
}
private <PermissionType extends Permission> void updatePermissionSet(
APIPatch.Operation operation,
PermissionSetPatch<PermissionType> permissionSetPatch,
PermissionType permission) {
switch (operation) {
case add:
permissionSetPatch.addPermission(permission);
break;
case remove:
permissionSetPatch.removePermission(permission);
break;
default:
throw new HTTPException(Status.BAD_REQUEST,
}
PermissionSetPatch<ObjectPermission> connectionPermissionPatch      = new PermissionSetPatch<ObjectPermission>();
PermissionSetPatch<ObjectPermission> connectionGroupPermissionPatch = new PermissionSetPatch<ObjectPermission>();
PermissionSetPatch<ObjectPermission> userPermissionPatch            = new PermissionSetPatch<ObjectPermission>();
PermissionSetPatch<SystemPermission> systemPermissionPatch          = new PermissionSetPatch<SystemPermission>();
ObjectPermission permission = new ObjectPermission(type, identifier);
updatePermissionSet(patch.getOp(), connectionPermissionPatch, permission);
ObjectPermission permission = new ObjectPermission(type, identifier);
updatePermissionSet(patch.getOp(), connectionGroupPermissionPatch, permission);
ObjectPermission permission = new ObjectPermission(type, identifier);
updatePermissionSet(patch.getOp(), userPermissionPatch, permission);
else if (path.equals(SYSTEM_PERMISSION_PATCH_PATH)) {
SystemPermission permission = new SystemPermission(type);
updatePermissionSet(patch.getOp(), systemPermissionPatch, permission);
connectionPermissionPatch.apply(user.getConnectionPermissions());
connectionGroupPermissionPatch.apply(user.getConnectionGroupPermissions());
userPermissionPatch.apply(user.getUserPermissions());
systemPermissionPatch.apply(user.getSystemPermissions());
existingConnection.setParentIdentifier(connection.getParentIdentifier());
existingConnectionGroup.setParentIdentifier(connectionGroup.getParentIdentifier());
existingConnection.setParentIdentifier(connection.getParentIdentifier());
existingConnectionGroup.setParentIdentifier(connectionGroup.getParentIdentifier());
import org.glyptodon.guacamole.net.auth.permission.ObjectPermissionSet;
private void addDescendants(Collection<ConnectionGroup> parents,
List<ObjectPermission.Type> permissions)
if (permissions != null && !permissions.isEmpty()) {
ObjectPermissionSet permissionSet = userContext.self().getConnectionPermissions();
childConnectionIdentifiers = permissionSet.getAccessibleObjects(permissions, childConnectionIdentifiers);
}
addDescendants(childConnectionGroups, permissions);
addDescendants(Collections.singleton(root), permissions);
import org.glyptodon.guacamole.net.auth.permission.ObjectPermissionSet;
private void addDescendants(Collection<ConnectionGroup> parents,
List<ObjectPermission.Type> permissions)
if (permissions != null && !permissions.isEmpty()) {
ObjectPermissionSet permissionSet = userContext.self().getConnectionPermissions();
childConnectionIdentifiers = permissionSet.getAccessibleObjects(permissions, childConnectionIdentifiers);
}
addDescendants(childConnectionGroups, permissions);
addDescendants(Collections.singleton(root), permissions);
private final Injector injector;
MySQLUser user = userService.retrieveUser(credentials);
if (user != null) {
context.init(user);
bind(MySQLUserContext.class);
bind(SaltService.class).to(SecureRandomSaltService.class);
bind(UserDirectory.class);
socket.close();
import com.google.inject.Inject;
import net.sourceforge.guacamole.net.auth.mysql.model.UserModel;
import net.sourceforge.guacamole.net.auth.mysql.service.PasswordEncryptionService;
import net.sourceforge.guacamole.net.auth.mysql.service.SaltService;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermissionSet;
import org.glyptodon.guacamole.net.auth.permission.SystemPermissionSet;
import org.glyptodon.guacamole.net.auth.simple.SimpleObjectPermissionSet;
import org.glyptodon.guacamole.net.auth.simple.SimpleSystemPermissionSet;
public class MySQLUser implements User, DirectoryObject<UserModel> {
@Inject
private PasswordEncryptionService encryptionService;
@Inject
private SaltService saltService;
private UserModel userModel;
private String password = null;
public MySQLUser(UserModel userModel) {
this.userModel = userModel;
public UserModel getModel() {
return userModel;
public void setModel(UserModel userModel) {
this.userModel = userModel;
this.password = null;
public String getUsername() {
return userModel.getUsername();
public void setUsername(String username) {
userModel.setUsername(username);
}
@Override
public String getPassword() {
return password;
}
@Override
public void setPassword(String password) {
this.password = password;
byte[] salt = saltService.generateSalt();
byte[] hash = encryptionService.createPasswordHash(password, salt);
userModel.setPasswordSalt(salt);
userModel.setPasswordHash(hash);
}
@Override
public SystemPermissionSet getSystemPermissions()
throws GuacamoleException {
return new SimpleSystemPermissionSet();
}
@Override
public ObjectPermissionSet<String> getConnectionPermissions()
throws GuacamoleException {
return new SimpleObjectPermissionSet<String>();
}
@Override
public ObjectPermissionSet<String> getConnectionGroupPermissions()
throws GuacamoleException {
return new SimpleObjectPermissionSet<String>();
}
@Override
public ObjectPermissionSet<String> getUserPermissions()
throws GuacamoleException {
return new SimpleObjectPermissionSet<String>();
import java.util.Collections;
import org.glyptodon.guacamole.net.auth.simple.SimpleConnectionDirectory;
import org.glyptodon.guacamole.net.auth.simple.SimpleConnectionGroup;
import org.glyptodon.guacamole.net.auth.simple.SimpleConnectionGroupDirectory;
private MySQLUser currentUser;
public void init(MySQLUser currentUser) {
return currentUser;
return new SimpleConnectionGroup("ROOT", "ROOT",
new SimpleConnectionDirectory(Collections.EMPTY_MAP),
new SimpleConnectionGroupDirectory(Collections.EMPTY_LIST)
);
import java.util.Collections;
import net.sourceforge.guacamole.net.auth.mysql.service.UserService;
@Override
public User get(String identifier) throws GuacamoleException {
return userService.retrieveObject(identifier);
}
@Override
@Transactional
public Collection<User> getAll(Collection<String> identifiers) throws GuacamoleException {
return Collections.<User>unmodifiableCollection(userService.retrieveObjects(identifiers));
}
@Override
@Transactional
public Set<String> getIdentifiers() throws GuacamoleException {
return userService.getIdentifiers();
}
@Override
@Transactional
public void add(User object) throws GuacamoleException {
MySQLUser user = (MySQLUser) object;
userService.createObject(user);
}
@Override
@Transactional
public void update(User object) throws GuacamoleException {
MySQLUser user = (MySQLUser) object;
userService.updateObject(user);
}
@Override
@Transactional
public void remove(String identifier) throws GuacamoleException {
userService.deleteObject(identifier);
}
import net.sourceforge.guacamole.net.auth.mysql.dao.DirectoryObjectMapper;
import net.sourceforge.guacamole.net.auth.mysql.model.UserModel;
public class UserService extends DirectoryObjectService<MySQLUser, UserModel> {
private UserMapper userMapper;
@Override
protected DirectoryObjectMapper<UserModel> getObjectMapper() {
return userMapper;
@Override
protected MySQLUser getObjectInstance(UserModel model) {
MySQLUser user = mySQLUserProvider.get();
user.setModel(model);
return user;
String username = credentials.getUsername();
String password = credentials.getPassword();
UserModel userModel = userMapper.selectByCredentials(username, password);
if (userModel == null)
return getObjectInstance(userModel);
private final MySQLUser user;
public AuthenticatedUser(MySQLUser user, Credentials credentials) {
this.user = user;
public MySQLUser getUser() {
return user;
context.init(new AuthenticatedUser(user, credentials));
private AuthenticatedUser currentUser;
public void init(AuthenticatedUser currentUser) {
userDirectory.init(currentUser);
return currentUser.getUser();
private AuthenticatedUser currentUser;
public void init(AuthenticatedUser currentUser) {
this.currentUser = currentUser;
}
return userService.retrieveObject(currentUser, identifier);
Collection<MySQLUser> objects = userService.retrieveObjects(currentUser, identifiers);
return Collections.<User>unmodifiableCollection(objects);
return userService.getIdentifiers(currentUser);
userService.createObject(currentUser, user);
userService.updateObject(currentUser, user);
userService.deleteObject(currentUser, identifier);
import net.sourceforge.guacamole.net.auth.mysql.AuthenticatedUser;
import org.glyptodon.guacamole.GuacamoleException;
public ObjectType retrieveObject(AuthenticatedUser user,
String identifier) {
Collection<ObjectType> objects = retrieveObjects(user, Collections.singleton(identifier));
public Collection<ObjectType> retrieveObjects(AuthenticatedUser user,
Collection<String> identifiers) {
public void createObject(AuthenticatedUser user, ObjectType object)
throws GuacamoleException {
public void deleteObject(AuthenticatedUser user, String identifier)
throws GuacamoleException {
public void updateObject(AuthenticatedUser user, ObjectType object)
throws GuacamoleException {
public Set<String> getIdentifiers(AuthenticatedUser user) {
import org.glyptodon.guacamole.net.auth.permission.SystemPermission;
public boolean isAdministrator() throws GuacamoleException {
SystemPermissionSet systemPermissionSet = getSystemPermissions();
return systemPermissionSet.hasPermission(SystemPermission.Type.ADMINISTER);
}
import net.sourceforge.guacamole.net.auth.mysql.model.UserModel;
public interface DirectoryObjectMapper<ModelType> {
Set<String> selectReadableIdentifiers(@Param("user") UserModel user);
Collection<ModelType> select(@Param("identifiers") Collection<String> identifiers);
Collection<ModelType> selectReadable(@Param("user") UserModel user,
@Param("identifiers") Collection<String> identifiers);
int insert(@Param("object") ModelType object);
int update(@Param("object") ModelType object);
String identifier) throws GuacamoleException {
Collection<String> identifiers) throws GuacamoleException {
Collection<ModelType> objects;
if (user.getUser().isAdministrator())
objects = getObjectMapper().select(identifiers);
else
objects = getObjectMapper().selectReadable(user.getUser().getModel(), identifiers);
return getObjectInstances(objects);
public Set<String> getIdentifiers(AuthenticatedUser user)
throws GuacamoleException {
if (user.getUser().isAdministrator())
return getObjectMapper().selectIdentifiers();
else
return getObjectMapper().selectReadableIdentifiers(user.getUser().getModel());
import org.glyptodon.guacamole.net.auth.Identifiable;
public interface DirectoryObject<ModelType> extends Identifiable {
public String getIdentifier() {
public void setIdentifier(String username) {
public ObjectPermissionSet getConnectionPermissions()
return new SimpleObjectPermissionSet();
public ObjectPermissionSet getConnectionGroupPermissions()
return new SimpleObjectPermissionSet();
public ObjectPermissionSet getUserPermissions()
return new SimpleObjectPermissionSet();
public Directory<User> getUserDirectory() throws GuacamoleException {
public class UserDirectory implements Directory<User> {
public void move(String identifier, Directory<User> groupIdentifier)
import org.glyptodon.guacamole.GuacamoleSecurityException;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermission;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermissionSet;
protected abstract boolean hasCreatePermission(AuthenticatedUser user)
throws GuacamoleException;
protected abstract ObjectPermissionSet getPermissionSet(AuthenticatedUser user)
throws GuacamoleException;
if (user.getUser().isAdministrator() || hasCreatePermission(user))
getObjectMapper().insert(object.getModel());
throw new GuacamoleSecurityException("Permission denied.");
ObjectPermissionSet permissionSet = getPermissionSet(user);
if (user.getUser().isAdministrator()
|| permissionSet.hasPermission(ObjectPermission.Type.DELETE, identifier))
getObjectMapper().delete(identifier);
throw new GuacamoleSecurityException("Permission denied.");
ObjectPermissionSet permissionSet = getPermissionSet(user);
if (user.getUser().isAdministrator()
|| permissionSet.hasPermission(ObjectPermission.Type.UPDATE, object.getIdentifier()))
getObjectMapper().update(object.getModel());
throw new GuacamoleSecurityException("Permission denied.");
import net.sourceforge.guacamole.net.auth.mysql.AuthenticatedUser;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermissionSet;
import org.glyptodon.guacamole.net.auth.permission.SystemPermission;
import org.glyptodon.guacamole.net.auth.permission.SystemPermissionSet;
@Override
protected boolean hasCreatePermission(AuthenticatedUser user)
throws GuacamoleException {
SystemPermissionSet permissionSet = user.getUser().getSystemPermissions();
return permissionSet.hasPermission(SystemPermission.Type.CREATE_USER);
}
@Override
protected ObjectPermissionSet getPermissionSet(AuthenticatedUser user)
throws GuacamoleException {
return user.getUser().getUserPermissions();
}
public void init(AuthenticatedUser currentUser, ModelType model);
public AuthenticatedUser getCurrentUser();
public void setCurrentUser(AuthenticatedUser currentUser);
import net.sourceforge.guacamole.net.auth.mysql.dao.SystemPermissionMapper;
import net.sourceforge.guacamole.net.auth.mysql.service.SystemPermissionService;
context.init(user.getCurrentUser());
addMapperClass(SystemPermissionMapper.class);
bind(SystemPermissionService.class);
import net.sourceforge.guacamole.net.auth.mysql.service.SystemPermissionService;
private AuthenticatedUser currentUser;
@Inject
private SystemPermissionService systemPermissionService;
@Override
public void init(AuthenticatedUser currentUser, UserModel userModel) {
this.currentUser = currentUser;
setModel(userModel);
}
@Override
public AuthenticatedUser getCurrentUser() {
return currentUser;
}
@Override
public void setCurrentUser(AuthenticatedUser currentUser) {
this.currentUser = currentUser;
return new SimpleSystemPermissionSet(systemPermissionService.retrievePermissions(getCurrentUser(), this));
protected abstract ObjectType getObjectInstance(AuthenticatedUser currentUser,
ModelType model);
protected Collection<ObjectType> getObjectInstances(AuthenticatedUser currentUser,
Collection<ModelType> models) {
objects.add(getObjectInstance(currentUser, model));
return getObjectInstances(user, objects);
protected MySQLUser getObjectInstance(AuthenticatedUser currentUser,
UserModel model) {
user.init(currentUser, model);
MySQLUser user = getObjectInstance(null, userModel);
user.setCurrentUser(new AuthenticatedUser(user, credentials));
return user;
if (user.getUser().isAdministrator() || hasCreatePermission(user)) {
return;
}
|| permissionSet.hasPermission(ObjectPermission.Type.DELETE, identifier)) {
return;
}
|| permissionSet.hasPermission(ObjectPermission.Type.UPDATE, object.getIdentifier())) {
return;
}
import java.util.ArrayList;
protected abstract ModelType getModelInstance(MySQLUser targetUser,
PermissionType permission);
protected Collection<ModelType> getModelInstances(MySQLUser targetUser,
Collection<PermissionType> permissions) {
Collection<ModelType> models = new ArrayList<ModelType>(permissions.size());
for (PermissionType permission : permissions)
models.add(getModelInstance(targetUser, permission));
return models;
}
throw new GuacamoleSecurityException("Permission denied.");
MySQLUser targetUser,
MySQLUser targetUser,
import net.sourceforge.guacamole.net.auth.mysql.MySQLUser;
import org.glyptodon.guacamole.GuacamoleSecurityException;
protected SystemPermissionModel getModelInstance(final MySQLUser targetUser,
final SystemPermission permission) {
return new SystemPermissionModel() {
private Integer userID = targetUser.getModel().getUserID();
private String username = targetUser.getModel().getUsername();
private SystemPermission.Type type = permission.getType();
@Override
public Integer getUserID() {
return userID;
}
@Override
public void setUserID(Integer userID) {
this.userID = userID;
}
@Override
public String getUsername() {
return username;
}
@Override
public void setUsername(String username) {
this.username = username;
}
@Override
public SystemPermission.Type getType() {
return type;
}
@Override
public void setType(SystemPermission.Type type) {
this.type = type;
}
};
public void createPermissions(AuthenticatedUser user, MySQLUser targetUser,
if (user.getUser().isAdministrator()) {
Collection<SystemPermissionModel> models = getModelInstances(targetUser, permissions);
systemPermissionMapper.insert(models);
return;
}
throw new GuacamoleSecurityException("Permission denied.");
}
@Override
public void deletePermissions(AuthenticatedUser user, MySQLUser targetUser,
Collection<SystemPermission> permissions) throws GuacamoleException {
if (user.getUser().isAdministrator()) {
Collection<SystemPermissionModel> models = getModelInstances(targetUser, permissions);
systemPermissionMapper.delete(models);
return;
}
throw new GuacamoleSecurityException("Permission denied.");
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import net.sourceforge.guacamole.net.auth.mysql.MySQLUser;
import org.glyptodon.guacamole.GuacamoleSecurityException;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermissionSet;
protected abstract ObjectPermissionSet getAffectedPermissionSet(AuthenticatedUser user)
protected boolean canAlterPermissions(AuthenticatedUser user, MySQLUser targetUser,
Collection<ObjectPermissionType> permissions)
throws GuacamoleException {
if (user.getUser().isAdministrator())
return true;
ObjectPermissionSet userPermissionSet = user.getUser().getUserPermissions();
if (!userPermissionSet.hasPermission(ObjectPermission.Type.UPDATE, targetUser.getIdentifier()))
return false;
Collection<String> affectedIdentifiers = new HashSet(permissions.size());
for (ObjectPermissionType permission : permissions)
affectedIdentifiers.add(permission.getObjectIdentifier());
ObjectPermissionSet affectedPermissionSet = getAffectedPermissionSet(user);
Collection<String> allowedSubset = affectedPermissionSet.getAccessibleObjects(
Collections.singleton(ObjectPermission.Type.ADMINISTER),
affectedIdentifiers
);
return affectedIdentifiers.size() == allowedSubset.size();
}
@Override
public void createPermissions(AuthenticatedUser user, MySQLUser targetUser,
Collection<ObjectPermissionType> permissions)
throws GuacamoleException {
if (canAlterPermissions(user, targetUser, permissions)) {
Collection<ModelType> models = getModelInstances(targetUser, permissions);
getPermissionMapper().insert(models);
return;
}
throw new GuacamoleSecurityException("Permission denied.");
}
@Override
public void deletePermissions(AuthenticatedUser user, MySQLUser targetUser,
Collection<ObjectPermissionType> permissions)
throws GuacamoleException {
if (canAlterPermissions(user, targetUser, permissions)) {
Collection<ModelType> models = getModelInstances(targetUser, permissions);
getPermissionMapper().delete(models);
return;
}
throw new GuacamoleSecurityException("Permission denied.");
}
bind(MySQLSystemPermissionSet.class);
return systemPermissionService.getPermissionSet(getCurrentUser(), this);
import net.sourceforge.guacamole.net.auth.mysql.model.UserModel;
import org.apache.ibatis.annotations.Param;
import org.glyptodon.guacamole.net.auth.permission.SystemPermission;
SystemPermissionModel selectOne(@Param("user") UserModel user,
@Param("type") SystemPermission.Type type);
public abstract class ObjectPermissionService<ModelType>
extends PermissionService<ObjectPermissionSet, ObjectPermission, ModelType> {
Collection<ObjectPermission> permissions)
for (ObjectPermission permission : permissions)
Collection<ObjectPermission> permissions)
Collection<ObjectPermission> permissions)
import org.glyptodon.guacamole.net.auth.permission.PermissionSet;
public abstract class PermissionService<PermissionSetType extends PermissionSet<PermissionType>,
PermissionType extends Permission, ModelType> {
public abstract PermissionSetType getPermissionSet(AuthenticatedUser user,
MySQLUser targetUser) throws GuacamoleException;
import com.google.inject.Provider;
import net.sourceforge.guacamole.net.auth.mysql.MySQLSystemPermissionSet;
extends PermissionService<MySQLSystemPermissionSet, SystemPermission, SystemPermissionModel> {
@Inject
private Provider<MySQLSystemPermissionSet> systemPermissionSetProvider;
public MySQLSystemPermissionSet getPermissionSet(AuthenticatedUser user,
MySQLUser targetUser) throws GuacamoleException {
MySQLSystemPermissionSet permissionSet = systemPermissionSetProvider.get();
permissionSet.init(user, targetUser);
return permissionSet;
}
@Override
public SystemPermission retrievePermission(AuthenticatedUser user,
MySQLUser targetUser, SystemPermission.Type type) throws GuacamoleException {
if (user.getUser().getIdentifier().equals(targetUser.getIdentifier())
|| user.getUser().isAdministrator())
return getPermissionInstance(getPermissionMapper().selectOne(targetUser.getModel(), type));
throw new GuacamoleSecurityException("Permission denied.");
}
if (password == null) {
userModel.setPasswordSalt(null);
userModel.setPasswordHash(null);
}
else {
byte[] salt = saltService.generateSalt();
byte[] hash = encryptionService.createPasswordHash(password, salt);
userModel.setPasswordSalt(salt);
userModel.setPasswordHash(hash);
}
userService.createObject(currentUser, object);
public abstract class DirectoryObjectService<InternalType extends DirectoryObject<ModelType>,
ExternalType, ModelType> {
protected abstract InternalType getObjectInstance(AuthenticatedUser currentUser,
protected abstract ModelType getModelInstance(AuthenticatedUser currentUser,
ExternalType object);
protected Collection<InternalType> getObjectInstances(AuthenticatedUser currentUser,
Collection<InternalType> objects = new ArrayList<InternalType>(models.size());
public InternalType retrieveObject(AuthenticatedUser user,
Collection<InternalType> objects = retrieveObjects(user, Collections.singleton(identifier));
public Collection<InternalType> retrieveObjects(AuthenticatedUser user,
public void createObject(AuthenticatedUser user, ExternalType object)
getObjectMapper().insert(getModelInstance(user, object));
public void updateObject(AuthenticatedUser user, InternalType object)
SystemPermissionModel model = new SystemPermissionModel();
model.setUserID(targetUser.getModel().getUserID());
model.setUsername(targetUser.getModel().getUsername());
model.setType(permission.getType());
return model;
|| user.getUser().isAdministrator()) {
SystemPermissionModel model = getPermissionMapper().selectOne(targetUser.getModel(), type);
if (model == null)
return null;
return getPermissionInstance(model);
}
import org.glyptodon.guacamole.net.auth.User;
public class UserService extends DirectoryObjectService<MySQLUser, User, UserModel> {
protected UserModel getModelInstance(AuthenticatedUser currentUser,
final User object) {
UserModel model = new UserModel();
MySQLUser user = getObjectInstance(currentUser, model);
user.setIdentifier(object.getIdentifier());
user.setPassword(object.getPassword());
return model;
}
@Override
protected void validateNewObject(AuthenticatedUser user,
ExternalType object) throws GuacamoleException {
}
protected void validateExistingObject(AuthenticatedUser user,
InternalType object) throws GuacamoleException {
}
validateNewObject(user, object);
validateExistingObject(user, object);
import java.util.Collection;
import java.util.Collections;
import org.glyptodon.guacamole.GuacamoleClientException;
@Override
protected void validateNewObject(AuthenticatedUser user, User object)
throws GuacamoleException {
if (object.getIdentifier().trim().isEmpty())
throw new GuacamoleClientException("The username must not be blank.");
Collection<UserModel> existing = userMapper.select(Collections.singleton(object.getIdentifier()));
if (!existing.isEmpty())
}
@Override
protected void validateExistingObject(AuthenticatedUser user,
MySQLUser object) throws GuacamoleException {
if (object.getIdentifier().trim().isEmpty())
throw new GuacamoleClientException("The username must not be blank.");
MySQLUser existing = retrieveObject(user, object.getIdentifier());
if (existing != null) {
UserModel existingModel = existing.getModel();
UserModel updatedModel = object.getModel();
if (!existingModel.getUserID().equals(updatedModel.getUserID()))
}
}
import org.glyptodon.guacamole.net.auth.Connection;
public Directory<Connection> getConnectionDirectory() throws GuacamoleException {
return new SimpleConnectionDirectory(Collections.EMPTY_LIST);
}
@Override
public Directory<ConnectionGroup> getConnectionGroupDirectory() throws GuacamoleException {
return new SimpleConnectionGroupDirectory(Collections.EMPTY_LIST);
}
@Override
return new SimpleConnectionGroup(
MySQLConstants.CONNECTION_GROUP_ROOT_IDENTIFIER,
MySQLConstants.CONNECTION_GROUP_ROOT_IDENTIFIER,
Collections.EMPTY_LIST,
Collections.EMPTY_LIST
import net.sourceforge.guacamole.net.auth.mysql.dao.ConnectionMapper;
import net.sourceforge.guacamole.net.auth.mysql.service.ConnectionService;
addMapperClass(ConnectionMapper.class);
bind(ConnectionDirectory.class);
bind(ConnectionService.class);
bind(MySQLConnection.class);
@Inject
private ConnectionDirectory connectionDirectory;
connectionDirectory.init(currentUser);
return connectionDirectory;
return new SimpleConnectionGroupDirectory(Collections.singleton(getRootConnectionGroup()));
bind(MySQLRootConnectionGroup.class);
import com.google.inject.Provider;
@Inject
private Provider<MySQLRootConnectionGroup> rootGroupProvider;
MySQLRootConnectionGroup rootGroup = rootGroupProvider.get();
rootGroup.init(currentUser);
return rootGroup;
import java.util.Set;
public Set<String> getRootIdentifiers(AuthenticatedUser user) throws GuacamoleException {
if (user.getUser().isAdministrator())
return connectionMapper.selectIdentifiersWithin(null);
else
return connectionMapper.selectReadableIdentifiersWithin(user.getUser().getModel(), null);
}
String parentIdentifier = connectionModel.getParentIdentifier();
if (parentIdentifier == null)
return MySQLConstants.CONNECTION_GROUP_ROOT_IDENTIFIER;
return parentIdentifier;
if (parentIdentifier != null
&& parentIdentifier.equals(MySQLConstants.CONNECTION_GROUP_ROOT_IDENTIFIER))
parentIdentifier = null;
import com.google.inject.Inject;
import net.sourceforge.guacamole.net.auth.mysql.service.ConnectionService;
@Inject
private ConnectionService connectionService;
return connectionService.connect(currentUser, this, info);
import org.glyptodon.guacamole.GuacamoleSecurityException;
import org.glyptodon.guacamole.GuacamoleUnsupportedException;
import org.glyptodon.guacamole.net.GuacamoleSocket;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermission;
import org.glyptodon.guacamole.protocol.GuacamoleClientInformation;
public GuacamoleSocket connect(AuthenticatedUser user,
MySQLConnection connection, GuacamoleClientInformation info)
throws GuacamoleException {
if (hasObjectPermission(user, connection.getIdentifier(), ObjectPermission.Type.READ)) {
throw new GuacamoleUnsupportedException("STUB - connecting not implemented at the moment");
}
throw new GuacamoleSecurityException("Permission denied.");
}
protected boolean hasObjectPermission(AuthenticatedUser user,
String identifier, ObjectPermission.Type type)
throws GuacamoleException {
ObjectPermissionSet permissionSet = getPermissionSet(user);
return user.getUser().isAdministrator()
|| permissionSet.hasPermission(type, identifier);
}
if (hasObjectPermission(user, identifier, ObjectPermission.Type.DELETE)) {
if (hasObjectPermission(user, object.getIdentifier(), ObjectPermission.Type.UPDATE)) {
import net.sourceforge.guacamole.net.auth.mysql.dao.ParameterMapper;
import org.glyptodon.guacamole.environment.Environment;
import org.glyptodon.guacamole.environment.LocalEnvironment;
final Environment environment = new LocalEnvironment();
myBatisProperties.setProperty("JDBC.host", environment.getRequiredProperty(MySQLGuacamoleProperties.MYSQL_HOSTNAME));
myBatisProperties.setProperty("JDBC.port", String.valueOf(environment.getRequiredProperty(MySQLGuacamoleProperties.MYSQL_PORT)));
myBatisProperties.setProperty("JDBC.schema", environment.getRequiredProperty(MySQLGuacamoleProperties.MYSQL_DATABASE));
myBatisProperties.setProperty("JDBC.username", environment.getRequiredProperty(MySQLGuacamoleProperties.MYSQL_USERNAME));
myBatisProperties.setProperty("JDBC.password", environment.getRequiredProperty(MySQLGuacamoleProperties.MYSQL_PASSWORD));
addMapperClass(ParameterMapper.class);
bind(Environment.class).toInstance(environment);
bind(UserDirectory.class);
bind(ConnectionService.class);
import java.util.Collection;
import net.sourceforge.guacamole.net.auth.mysql.dao.ParameterMapper;
import net.sourceforge.guacamole.net.auth.mysql.model.ParameterModel;
import org.glyptodon.guacamole.environment.Environment;
import org.glyptodon.guacamole.net.InetGuacamoleSocket;
import org.glyptodon.guacamole.protocol.ConfiguredGuacamoleSocket;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
@Inject
private Environment environment;
@Inject
private ParameterMapper parameterMapper;
String identifier = connection.getIdentifier();
if (hasObjectPermission(user, identifier, ObjectPermission.Type.READ)) {
GuacamoleConfiguration config = new GuacamoleConfiguration();
ConnectionModel model = connection.getModel();
config.setProtocol(model.getProtocol());
Collection<ParameterModel> parameters = parameterMapper.select(identifier);
for (ParameterModel parameter : parameters)
config.setParameter(parameter.getName(), parameter.getValue());
return new ConfiguredGuacamoleSocket(
new InetGuacamoleSocket(
environment.getRequiredProperty(Environment.GUACD_HOSTNAME),
environment.getRequiredProperty(Environment.GUACD_PORT)
),
config
);
bind(MySQLGuacamoleConfiguration.class);
import com.google.inject.Provider;
@Inject
private Provider<MySQLGuacamoleConfiguration> configProvider;
private GuacamoleConfiguration config = null;
public void setModel(ConnectionModel connectionModel) {
this.connectionModel = connectionModel;
this.config = null;
if (config != null)
return config;
MySQLGuacamoleConfiguration restrictedConfig = configProvider.get();
restrictedConfig.init(currentUser, connectionModel);
return restrictedConfig;
this.config = config;
import java.util.HashMap;
import java.util.Map;
public Map<String, String> retrieveParameters(AuthenticatedUser user,
String identifier) {
Map<String, String> parameterMap = new HashMap<String, String>();
Collection<ParameterModel> parameters = parameterMapper.select(identifier);
for (ParameterModel parameter : parameters)
parameterMap.put(parameter.getName(), parameter.getValue());
return parameterMap;
}
import java.util.Collections;
boolean canRetrieveParameters;
try {
canRetrieveParameters = hasObjectPermission(user, identifier,
ObjectPermission.Type.UPDATE);
}
catch (GuacamoleException e) {
return parameterMap;
}
if (canRetrieveParameters) {
for (ParameterModel parameter : parameterMapper.select(identifier))
parameterMap.put(parameter.getName(), parameter.getValue());
}
return MySQLRootConnectionGroup.IDENTIFIER;
&& parentIdentifier.equals(MySQLRootConnectionGroup.IDENTIFIER))
public static final String IDENTIFIER = "ROOT";
public static final String NAME = "ROOT";
return NAME;
return IDENTIFIER;
import net.sourceforge.guacamole.net.auth.mysql.service.GuacamoleSocketService;
import net.sourceforge.guacamole.net.auth.mysql.service.UnrestrictedGuacamoleSocketService;
bind(GuacamoleSocketService.class).to(UnrestrictedGuacamoleSocketService.class);
import net.sourceforge.guacamole.net.auth.mysql.service.GuacamoleSocketService;
@Inject
private GuacamoleSocketService socketService;
return socketService.getActiveConnections(this);
@Inject
private GuacamoleSocketService socketService;
if (hasObjectPermission(user, connection.getIdentifier(), ObjectPermission.Type.READ))
return socketService.getGuacamoleSocket(user, connection, info);
int insert(@Param("parameters") Collection<ParameterModel> parameters);
int delete(@Param("identifier") String identifier);
import java.util.ArrayList;
import java.util.Collection;
@Override
public void updateObject(AuthenticatedUser user, MySQLConnection object)
throws GuacamoleException {
super.updateObject(user, object);
String identifier = object.getIdentifier();
Map<String, String> parameters = object.getConfiguration().getParameters();
Collection<ParameterModel> parameterModels = new ArrayList(parameters.size());
for (Map.Entry<String, String> parameterEntry : parameters.entrySet()) {
String name = parameterEntry.getKey();
String value = parameterEntry.getValue();
if (value.isEmpty())
continue;
ParameterModel model = new ParameterModel();
model.setConnectionIdentifier(identifier);
model.setName(name);
model.setValue(value);
parameterModels.add(model);
}
parameterMapper.delete(identifier);
parameterMapper.insert(parameterModels);
}
import net.sourceforge.guacamole.net.auth.mysql.dao.ConnectionRecordMapper;
addMapperClass(ConnectionRecordMapper.class);
return connectionService.retrieveHistory(currentUser, this.getIdentifier());
import net.sourceforge.guacamole.net.auth.mysql.model.ConnectionRecordModel;
private ConnectionRecordModel model;
public MySQLConnectionRecord(ConnectionRecordModel model) {
this.model = model;
return model.getStartDate();
return model.getEndDate();
return model.getUsername();
return false;
import java.util.List;
import net.sourceforge.guacamole.net.auth.mysql.MySQLConnectionRecord;
import net.sourceforge.guacamole.net.auth.mysql.dao.ConnectionRecordMapper;
import net.sourceforge.guacamole.net.auth.mysql.model.ConnectionRecordModel;
@Inject
private ConnectionRecordMapper connectionRecordMapper;
public List<MySQLConnectionRecord> retrieveHistory(AuthenticatedUser user,
String identifier) throws GuacamoleException {
if (hasObjectPermission(user, identifier, ObjectPermission.Type.READ)) {
List<ConnectionRecordModel> models = connectionRecordMapper.select(identifier);
List<MySQLConnectionRecord> records = new ArrayList<MySQLConnectionRecord>(models.size());
for (ConnectionRecordModel model : models)
records.add(new MySQLConnectionRecord(model));
return records;
}
throw new GuacamoleSecurityException("Permission denied.");
}
return connectionService.retrieveHistory(currentUser, this);
return socketService.getActiveConnections(this).size();
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import net.sourceforge.guacamole.net.auth.mysql.dao.ConnectionRecordMapper;
import net.sourceforge.guacamole.net.auth.mysql.model.ConnectionRecordModel;
import net.sourceforge.guacamole.net.auth.mysql.model.UserModel;
import org.glyptodon.guacamole.net.auth.ConnectionRecord;
@Inject
private ConnectionRecordMapper connectionRecordMapper;
private final Map<String, LinkedList<ConnectionRecord>> activeConnections =
new HashMap<String, LinkedList<ConnectionRecord>>();
private void addActiveConnection(Connection connection, ConnectionRecord record) {
synchronized (activeConnections) {
String identifier = connection.getIdentifier();
LinkedList<ConnectionRecord> connections = activeConnections.get(identifier);
if (connections == null) {
connections = new LinkedList<ConnectionRecord>();
activeConnections.put(identifier, connections);
}
connections.addFirst(record);
}
private void removeActiveConnection(Connection connection, ConnectionRecord record) {
synchronized (activeConnections) {
String identifier = connection.getIdentifier();
LinkedList<ConnectionRecord> connections = activeConnections.get(identifier);
assert(connections != null);
connections.remove(record);
if (connections.isEmpty())
activeConnections.remove(identifier);
final ActiveConnectionRecord activeConnection = new ActiveConnectionRecord(user);
addActiveConnection(connection, activeConnection);
removeActiveConnection(connection, activeConnection);
UserModel userModel = user.getUser().getModel();
ConnectionRecordModel recordModel = new ConnectionRecordModel();
recordModel.setUserID(userModel.getUserID());
recordModel.setUsername(userModel.getUsername());
recordModel.setConnectionIdentifier(connection.getIdentifier());
recordModel.setStartDate(activeConnection.getStartDate());
recordModel.setEndDate(new Date());
connectionRecordMapper.insert(recordModel);
removeActiveConnection(connection, activeConnection);
public List<ConnectionRecord> getActiveConnections(Connection connection) {
synchronized (activeConnections) {
String identifier = connection.getIdentifier();
LinkedList<ConnectionRecord> connections = activeConnections.get(identifier);
if (connections != null)
return Collections.unmodifiableList(connections);
return Collections.EMPTY_LIST;
}
import org.glyptodon.guacamole.net.auth.ConnectionRecord;
public List<ConnectionRecord> retrieveHistory(AuthenticatedUser user,
MySQLConnection connection) throws GuacamoleException {
String identifier = connection.getIdentifier();
List<ConnectionRecord> records = new ArrayList<ConnectionRecord>(socketService.getActiveConnections(connection));
import java.util.List;
import org.glyptodon.guacamole.net.auth.ConnectionRecord;
public List<ConnectionRecord> getActiveConnections(Connection connection);
import org.glyptodon.guacamole.token.StandardTokens;
import org.glyptodon.guacamole.token.TokenFilter;
TokenFilter tokenFilter = new TokenFilter();
StandardTokens.addStandardTokens(tokenFilter, user.getCredentials());
tokenFilter.filterValues(config.getParameters());
import net.sourceforge.guacamole.net.auth.mysql.model.ObjectModel;
public abstract class DirectoryObject<ModelType extends ObjectModel>
extends RestrictedObject<ModelType> implements Identifiable {
@Override
public String getIdentifier() {
return getModel().getIdentifier();
}
@Override
public void setIdentifier(String identifier) {
getModel().setIdentifier(identifier);
}
}
public class MySQLConnection extends DirectoryObject<ConnectionModel>
implements Connection {
return getModel().getName();
getModel().setName(name);
String parentIdentifier = getModel().getParentIdentifier();
getModel().setParentIdentifier(parentIdentifier);
restrictedConfig.init(getCurrentUser(), getModel());
getModel().setProtocol(config.getProtocol());
return connectionService.retrieveHistory(getCurrentUser(), this);
return connectionService.connect(getCurrentUser(), this, info);
public class MySQLUser extends DirectoryObject<UserModel> implements User {
UserModel userModel = getModel();
public class ConnectionModel extends ObjectModel {
public void setParentIdentifier(String parentIdentifier) {
@Override
Integer id = getObjectID();
if (id == null)
return null;
return id.toString();
@Override
throw new UnsupportedOperationException("Connection identifiers are derived from IDs. They cannot be set.");
public class UserModel extends ObjectModel {
recordModel.setUserID(userModel.getObjectID());
recordModel.setUsername(userModel.getIdentifier());
if (object.getName().trim().isEmpty())
if (object.getName().trim().isEmpty())
import net.sourceforge.guacamole.net.auth.mysql.model.ObjectModel;
ExternalType, ModelType extends ObjectModel> {
model.setUserID(targetUser.getModel().getObjectID());
model.setUsername(targetUser.getModel().getIdentifier());
if (!existingModel.getObjectID().equals(updatedModel.getObjectID()))
private Collection<ParameterModel> getParameterModels(MySQLConnection connection) {
Map<String, String> parameters = connection.getConfiguration().getParameters();
model.setConnectionIdentifier(connection.getIdentifier());
return parameterModels;
}
@Override
public MySQLConnection createObject(AuthenticatedUser user, Connection object)
throws GuacamoleException {
MySQLConnection connection = super.createObject(user, object);
connection.setConfiguration(object.getConfiguration());
Collection<ParameterModel> parameterModels = getParameterModels(connection);
if (!parameterModels.isEmpty())
parameterMapper.insert(parameterModels);
return connection;
}
@Override
public void updateObject(AuthenticatedUser user, MySQLConnection object)
throws GuacamoleException {
super.updateObject(user, object);
Collection<ParameterModel> parameterModels = getParameterModels(object);
parameterMapper.delete(object.getIdentifier());
public InternalType createObject(AuthenticatedUser user, ExternalType object)
ModelType model = getModelInstance(user, object);
getObjectMapper().insert(model);
return getObjectInstance(user, model);
import net.sourceforge.guacamole.net.auth.mysql.dao.ConnectionGroupMapper;
import net.sourceforge.guacamole.net.auth.mysql.service.ConnectionGroupService;
addMapperClass(ConnectionGroupMapper.class);
bind(ConnectionGroupDirectory.class);
bind(MySQLConnectionGroup.class);
bind(ConnectionGroupService.class);
import net.sourceforge.guacamole.net.auth.mysql.service.ConnectionGroupService;
@Inject
private ConnectionGroupService connectionGroupService;
return connectionService.getIdentifiersWithin(currentUser, null);
return connectionGroupService.getIdentifiersWithin(currentUser, null);
@Inject
private ConnectionGroupDirectory connectionGroupDirectory;
connectionGroupDirectory.init(currentUser);
return connectionGroupDirectory;
import net.sourceforge.guacamole.net.auth.mysql.MySQLConnectionGroup;
import org.glyptodon.guacamole.net.auth.ConnectionGroup;
@Override
public GuacamoleSocket getGuacamoleSocket(AuthenticatedUser user,
MySQLConnectionGroup connectionGroup,
GuacamoleClientInformation info) throws GuacamoleException {
throw new UnsupportedOperationException("STUB");
}
@Override
public List<ConnectionRecord> getActiveConnections(ConnectionGroup connectionGroup) {
return Collections.EMPTY_LIST;
}
public Set<String> getIdentifiersWithin(AuthenticatedUser user,
String identifier)
throws GuacamoleException {
return connectionMapper.selectIdentifiersWithin(identifier);
return connectionMapper.selectReadableIdentifiersWithin(user.getUser().getModel(), identifier);
import net.sourceforge.guacamole.net.auth.mysql.MySQLConnectionGroup;
import org.glyptodon.guacamole.net.auth.ConnectionGroup;
GuacamoleSocket getGuacamoleSocket(AuthenticatedUser user,
MySQLConnectionGroup connectionGroup,
GuacamoleClientInformation info)
throws GuacamoleException;
public List<ConnectionRecord> getActiveConnections(ConnectionGroup connectionGroup);
import org.glyptodon.guacamole.auth.mysql.user.MySQLUserContext;
import org.glyptodon.guacamole.auth.mysql.connectiongroup.MySQLRootConnectionGroup;
import org.glyptodon.guacamole.auth.mysql.connectiongroup.MySQLConnectionGroup;
import org.glyptodon.guacamole.auth.mysql.connectiongroup.ConnectionGroupDirectory;
import org.glyptodon.guacamole.auth.mysql.connection.ConnectionDirectory;
import org.glyptodon.guacamole.auth.mysql.connection.MySQLGuacamoleConfiguration;
import org.glyptodon.guacamole.auth.mysql.connection.MySQLConnection;
import org.glyptodon.guacamole.auth.mysql.permission.MySQLSystemPermissionSet;
import org.glyptodon.guacamole.auth.mysql.user.MySQLUser;
import org.glyptodon.guacamole.auth.mysql.user.UserDirectory;
import org.glyptodon.guacamole.auth.mysql.connectiongroup.ConnectionGroupMapper;
import org.glyptodon.guacamole.auth.mysql.connection.ConnectionMapper;
import org.glyptodon.guacamole.auth.mysql.connection.ConnectionRecordMapper;
import org.glyptodon.guacamole.auth.mysql.connection.ParameterMapper;
import org.glyptodon.guacamole.auth.mysql.permission.SystemPermissionMapper;
import org.glyptodon.guacamole.auth.mysql.user.UserMapper;
import org.glyptodon.guacamole.auth.mysql.conf.MySQLGuacamoleProperties;
import org.glyptodon.guacamole.auth.mysql.connectiongroup.ConnectionGroupService;
import org.glyptodon.guacamole.auth.mysql.connection.ConnectionService;
import org.glyptodon.guacamole.auth.mysql.socket.GuacamoleSocketService;
import org.glyptodon.guacamole.auth.mysql.security.PasswordEncryptionService;
import org.glyptodon.guacamole.auth.mysql.security.SHA256PasswordEncryptionService;
import org.glyptodon.guacamole.auth.mysql.security.SaltService;
import org.glyptodon.guacamole.auth.mysql.security.SecureRandomSaltService;
import org.glyptodon.guacamole.auth.mysql.permission.SystemPermissionService;
import org.glyptodon.guacamole.auth.mysql.socket.UnrestrictedGuacamoleSocketService;
import org.glyptodon.guacamole.auth.mysql.user.UserService;
package org.glyptodon.guacamole.auth.mysql.base;
package org.glyptodon.guacamole.auth.mysql.base;
import org.glyptodon.guacamole.auth.mysql.user.UserModel;
package org.glyptodon.guacamole.auth.mysql.base;
import org.glyptodon.guacamole.auth.mysql.user.AuthenticatedUser;
package org.glyptodon.guacamole.auth.mysql.base;
package org.glyptodon.guacamole.auth.mysql.base;
import org.glyptodon.guacamole.auth.mysql.user.AuthenticatedUser;
package org.glyptodon.guacamole.auth.mysql.base;
package org.glyptodon.guacamole.auth.mysql.conf;
package org.glyptodon.guacamole.auth.mysql.conf;
package org.glyptodon.guacamole.auth.mysql.connection;
import org.glyptodon.guacamole.auth.mysql.user.AuthenticatedUser;
package org.glyptodon.guacamole.auth.mysql.connection;
import org.glyptodon.guacamole.auth.mysql.base.DirectoryObjectMapper;
import org.glyptodon.guacamole.auth.mysql.user.UserModel;
package org.glyptodon.guacamole.auth.mysql.connection;
import org.glyptodon.guacamole.auth.mysql.base.ObjectModel;
package org.glyptodon.guacamole.auth.mysql.connection;
package org.glyptodon.guacamole.auth.mysql.connection;
package org.glyptodon.guacamole.auth.mysql.connection;
import org.glyptodon.guacamole.auth.mysql.user.AuthenticatedUser;
import org.glyptodon.guacamole.auth.mysql.base.DirectoryObjectMapper;
import org.glyptodon.guacamole.auth.mysql.base.DirectoryObjectService;
import org.glyptodon.guacamole.auth.mysql.socket.GuacamoleSocketService;
package org.glyptodon.guacamole.auth.mysql.connection;
import org.glyptodon.guacamole.auth.mysql.base.DirectoryObject;
import org.glyptodon.guacamole.auth.mysql.connectiongroup.MySQLRootConnectionGroup;
import org.glyptodon.guacamole.auth.mysql.socket.GuacamoleSocketService;
package org.glyptodon.guacamole.auth.mysql.connection;
package org.glyptodon.guacamole.auth.mysql.connection;
import org.glyptodon.guacamole.auth.mysql.user.AuthenticatedUser;
package org.glyptodon.guacamole.auth.mysql.connection;
package org.glyptodon.guacamole.auth.mysql.connection;
package org.glyptodon.guacamole.auth.mysql.connection;
package org.glyptodon.guacamole.auth.mysql.connectiongroup;
import org.glyptodon.guacamole.auth.mysql.user.AuthenticatedUser;
package org.glyptodon.guacamole.auth.mysql.connectiongroup;
import org.glyptodon.guacamole.auth.mysql.base.DirectoryObjectMapper;
import org.glyptodon.guacamole.auth.mysql.user.UserModel;
package org.glyptodon.guacamole.auth.mysql.connectiongroup;
import org.glyptodon.guacamole.auth.mysql.base.ObjectModel;
package org.glyptodon.guacamole.auth.mysql.connectiongroup;
import org.glyptodon.guacamole.auth.mysql.user.AuthenticatedUser;
import org.glyptodon.guacamole.auth.mysql.base.DirectoryObjectMapper;
import org.glyptodon.guacamole.auth.mysql.base.DirectoryObjectService;
import org.glyptodon.guacamole.auth.mysql.socket.GuacamoleSocketService;
package org.glyptodon.guacamole.auth.mysql.connectiongroup;
import org.glyptodon.guacamole.auth.mysql.base.DirectoryObject;
import org.glyptodon.guacamole.auth.mysql.connection.ConnectionService;
import org.glyptodon.guacamole.auth.mysql.socket.GuacamoleSocketService;
package org.glyptodon.guacamole.auth.mysql.connectiongroup;
import org.glyptodon.guacamole.auth.mysql.user.AuthenticatedUser;
import org.glyptodon.guacamole.auth.mysql.connection.ConnectionService;
package org.glyptodon.guacamole.auth.mysql.connectiongroup;
package org.glyptodon.guacamole.auth.mysql.permission;
import org.glyptodon.guacamole.auth.mysql.user.MySQLUser;
import org.glyptodon.guacamole.auth.mysql.user.AuthenticatedUser;
package org.glyptodon.guacamole.auth.mysql.permission;
package org.glyptodon.guacamole.auth.mysql.permission;
package org.glyptodon.guacamole.auth.mysql.permission;
import org.glyptodon.guacamole.auth.mysql.user.AuthenticatedUser;
import org.glyptodon.guacamole.auth.mysql.user.MySQLUser;
package org.glyptodon.guacamole.auth.mysql.permission;
import org.glyptodon.guacamole.auth.mysql.user.UserModel;
package org.glyptodon.guacamole.auth.mysql.permission;
package org.glyptodon.guacamole.auth.mysql.permission;
import org.glyptodon.guacamole.auth.mysql.user.AuthenticatedUser;
import org.glyptodon.guacamole.auth.mysql.user.MySQLUser;
package org.glyptodon.guacamole.auth.mysql.permission;
import org.glyptodon.guacamole.auth.mysql.user.UserModel;
package org.glyptodon.guacamole.auth.mysql.permission;
package org.glyptodon.guacamole.auth.mysql.permission;
import org.glyptodon.guacamole.auth.mysql.user.AuthenticatedUser;
import org.glyptodon.guacamole.auth.mysql.user.MySQLUser;
package org.glyptodon.guacamole.auth.mysql.permission;
package org.glyptodon.guacamole.auth.mysql.security;
package org.glyptodon.guacamole.auth.mysql.security;
package org.glyptodon.guacamole.auth.mysql.security;
package org.glyptodon.guacamole.auth.mysql.security;
package org.glyptodon.guacamole.auth.mysql.security;
package org.glyptodon.guacamole.auth.mysql.socket;
import org.glyptodon.guacamole.auth.mysql.user.AuthenticatedUser;
import org.glyptodon.guacamole.auth.mysql.connection.MySQLConnection;
import org.glyptodon.guacamole.auth.mysql.connectiongroup.MySQLConnectionGroup;
import org.glyptodon.guacamole.auth.mysql.connection.ConnectionRecordMapper;
import org.glyptodon.guacamole.auth.mysql.connection.ParameterMapper;
import org.glyptodon.guacamole.auth.mysql.connection.ConnectionModel;
import org.glyptodon.guacamole.auth.mysql.connection.ConnectionRecordModel;
import org.glyptodon.guacamole.auth.mysql.connection.ParameterModel;
import org.glyptodon.guacamole.auth.mysql.user.UserModel;
package org.glyptodon.guacamole.auth.mysql.socket;
import org.glyptodon.guacamole.auth.mysql.user.AuthenticatedUser;
package org.glyptodon.guacamole.auth.mysql.socket;
import org.glyptodon.guacamole.auth.mysql.user.AuthenticatedUser;
import org.glyptodon.guacamole.auth.mysql.connection.MySQLConnection;
import org.glyptodon.guacamole.auth.mysql.connectiongroup.MySQLConnectionGroup;
package org.glyptodon.guacamole.auth.mysql.socket;
import org.glyptodon.guacamole.auth.mysql.user.AuthenticatedUser;
import org.glyptodon.guacamole.auth.mysql.connection.MySQLConnection;
package org.glyptodon.guacamole.auth.mysql.socket;
package org.glyptodon.guacamole.auth.mysql.user;
package org.glyptodon.guacamole.auth.mysql.user;
import org.glyptodon.guacamole.auth.mysql.base.DirectoryObject;
import org.glyptodon.guacamole.auth.mysql.security.PasswordEncryptionService;
import org.glyptodon.guacamole.auth.mysql.security.SaltService;
import org.glyptodon.guacamole.auth.mysql.permission.SystemPermissionService;
package org.glyptodon.guacamole.auth.mysql.user;
import org.glyptodon.guacamole.auth.mysql.connectiongroup.MySQLRootConnectionGroup;
import org.glyptodon.guacamole.auth.mysql.connectiongroup.ConnectionGroupDirectory;
import org.glyptodon.guacamole.auth.mysql.connection.ConnectionDirectory;
package org.glyptodon.guacamole.auth.mysql.user;
package org.glyptodon.guacamole.auth.mysql.user;
import org.glyptodon.guacamole.auth.mysql.base.DirectoryObjectMapper;
package org.glyptodon.guacamole.auth.mysql.user;
import org.glyptodon.guacamole.auth.mysql.base.ObjectModel;
package org.glyptodon.guacamole.auth.mysql.user;
import org.glyptodon.guacamole.auth.mysql.base.DirectoryObjectMapper;
import org.glyptodon.guacamole.auth.mysql.base.DirectoryObjectService;
package org.glyptodon.guacamole.auth.mysql.user;
import org.glyptodon.guacamole.auth.jdbc.JDBCAuthenticationProvider;
public class MySQLAuthenticationProvider extends JDBCAuthenticationProvider {
package org.glyptodon.guacamole.auth.jdbc.base;
package org.glyptodon.guacamole.auth.jdbc.base;
import org.glyptodon.guacamole.auth.jdbc.user.UserModel;
package org.glyptodon.guacamole.auth.jdbc.base;
import org.glyptodon.guacamole.auth.jdbc.user.AuthenticatedUser;
package org.glyptodon.guacamole.auth.jdbc.base;
package org.glyptodon.guacamole.auth.jdbc.base;
import org.glyptodon.guacamole.auth.jdbc.user.AuthenticatedUser;
package org.glyptodon.guacamole.auth.jdbc.base;
package org.glyptodon.guacamole.auth.jdbc.conf;
package org.glyptodon.guacamole.auth.jdbc.conf;
package org.glyptodon.guacamole.auth.jdbc.connection;
import org.glyptodon.guacamole.auth.jdbc.user.AuthenticatedUser;
package org.glyptodon.guacamole.auth.jdbc.connection;
import org.glyptodon.guacamole.auth.jdbc.base.DirectoryObjectMapper;
import org.glyptodon.guacamole.auth.jdbc.user.UserModel;
package org.glyptodon.guacamole.auth.jdbc.connection;
import org.glyptodon.guacamole.auth.jdbc.base.ObjectModel;
package org.glyptodon.guacamole.auth.jdbc.connection;
package org.glyptodon.guacamole.auth.jdbc.connection;
package org.glyptodon.guacamole.auth.jdbc.connection;
import org.glyptodon.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.glyptodon.guacamole.auth.jdbc.base.DirectoryObjectMapper;
import org.glyptodon.guacamole.auth.jdbc.base.DirectoryObjectService;
import org.glyptodon.guacamole.auth.jdbc.socket.GuacamoleSocketService;
package org.glyptodon.guacamole.auth.jdbc.connection;
import org.glyptodon.guacamole.auth.jdbc.base.DirectoryObject;
import org.glyptodon.guacamole.auth.jdbc.connectiongroup.MySQLRootConnectionGroup;
import org.glyptodon.guacamole.auth.jdbc.socket.GuacamoleSocketService;
package org.glyptodon.guacamole.auth.jdbc.connection;
package org.glyptodon.guacamole.auth.jdbc.connection;
import org.glyptodon.guacamole.auth.jdbc.user.AuthenticatedUser;
package org.glyptodon.guacamole.auth.jdbc.connection;
package org.glyptodon.guacamole.auth.jdbc.connection;
package org.glyptodon.guacamole.auth.jdbc.connection;
package org.glyptodon.guacamole.auth.jdbc.connectiongroup;
import org.glyptodon.guacamole.auth.jdbc.user.AuthenticatedUser;
package org.glyptodon.guacamole.auth.jdbc.connectiongroup;
import org.glyptodon.guacamole.auth.jdbc.base.DirectoryObjectMapper;
import org.glyptodon.guacamole.auth.jdbc.user.UserModel;
package org.glyptodon.guacamole.auth.jdbc.connectiongroup;
import org.glyptodon.guacamole.auth.jdbc.base.ObjectModel;
package org.glyptodon.guacamole.auth.jdbc.connectiongroup;
import org.glyptodon.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.glyptodon.guacamole.auth.jdbc.base.DirectoryObjectMapper;
import org.glyptodon.guacamole.auth.jdbc.base.DirectoryObjectService;
import org.glyptodon.guacamole.auth.jdbc.socket.GuacamoleSocketService;
package org.glyptodon.guacamole.auth.jdbc.connectiongroup;
import org.glyptodon.guacamole.auth.jdbc.base.DirectoryObject;
import org.glyptodon.guacamole.auth.jdbc.connection.ConnectionService;
import org.glyptodon.guacamole.auth.jdbc.socket.GuacamoleSocketService;
package org.glyptodon.guacamole.auth.jdbc.connectiongroup;
import org.glyptodon.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.glyptodon.guacamole.auth.jdbc.connection.ConnectionService;
package org.glyptodon.guacamole.auth.jdbc.connectiongroup;
package org.glyptodon.guacamole.auth.jdbc;
package org.glyptodon.guacamole.auth.jdbc.permission;
import org.glyptodon.guacamole.auth.jdbc.user.MySQLUser;
import org.glyptodon.guacamole.auth.jdbc.user.AuthenticatedUser;
package org.glyptodon.guacamole.auth.jdbc.permission;
package org.glyptodon.guacamole.auth.jdbc.permission;
package org.glyptodon.guacamole.auth.jdbc.permission;
import org.glyptodon.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.glyptodon.guacamole.auth.jdbc.user.MySQLUser;
package org.glyptodon.guacamole.auth.jdbc.permission;
import org.glyptodon.guacamole.auth.jdbc.user.UserModel;
package org.glyptodon.guacamole.auth.jdbc.permission;
package org.glyptodon.guacamole.auth.jdbc.permission;
import org.glyptodon.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.glyptodon.guacamole.auth.jdbc.user.MySQLUser;
package org.glyptodon.guacamole.auth.jdbc.permission;
import org.glyptodon.guacamole.auth.jdbc.user.UserModel;
package org.glyptodon.guacamole.auth.jdbc.permission;
package org.glyptodon.guacamole.auth.jdbc.permission;
import org.glyptodon.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.glyptodon.guacamole.auth.jdbc.user.MySQLUser;
package org.glyptodon.guacamole.auth.jdbc.permission;
package org.glyptodon.guacamole.auth.jdbc.security;
package org.glyptodon.guacamole.auth.jdbc.security;
package org.glyptodon.guacamole.auth.jdbc.security;
package org.glyptodon.guacamole.auth.jdbc.security;
package org.glyptodon.guacamole.auth.jdbc.security;
package org.glyptodon.guacamole.auth.jdbc.socket;
import org.glyptodon.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.glyptodon.guacamole.auth.jdbc.connection.MySQLConnection;
import org.glyptodon.guacamole.auth.jdbc.connectiongroup.MySQLConnectionGroup;
import org.glyptodon.guacamole.auth.jdbc.connection.ConnectionRecordMapper;
import org.glyptodon.guacamole.auth.jdbc.connection.ParameterMapper;
import org.glyptodon.guacamole.auth.jdbc.connection.ConnectionModel;
import org.glyptodon.guacamole.auth.jdbc.connection.ConnectionRecordModel;
import org.glyptodon.guacamole.auth.jdbc.connection.ParameterModel;
import org.glyptodon.guacamole.auth.jdbc.user.UserModel;
package org.glyptodon.guacamole.auth.jdbc.socket;
import org.glyptodon.guacamole.auth.jdbc.user.AuthenticatedUser;
package org.glyptodon.guacamole.auth.jdbc.socket;
import org.glyptodon.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.glyptodon.guacamole.auth.jdbc.connection.MySQLConnection;
import org.glyptodon.guacamole.auth.jdbc.connectiongroup.MySQLConnectionGroup;
package org.glyptodon.guacamole.auth.jdbc.socket;
import org.glyptodon.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.glyptodon.guacamole.auth.jdbc.connection.MySQLConnection;
package org.glyptodon.guacamole.auth.jdbc.socket;
package org.glyptodon.guacamole.auth.jdbc.user;
package org.glyptodon.guacamole.auth.jdbc.user;
import org.glyptodon.guacamole.auth.jdbc.base.DirectoryObject;
import org.glyptodon.guacamole.auth.jdbc.security.PasswordEncryptionService;
import org.glyptodon.guacamole.auth.jdbc.security.SaltService;
import org.glyptodon.guacamole.auth.jdbc.permission.SystemPermissionService;
package org.glyptodon.guacamole.auth.jdbc.user;
import org.glyptodon.guacamole.auth.jdbc.connectiongroup.MySQLRootConnectionGroup;
import org.glyptodon.guacamole.auth.jdbc.connectiongroup.ConnectionGroupDirectory;
import org.glyptodon.guacamole.auth.jdbc.connection.ConnectionDirectory;
package org.glyptodon.guacamole.auth.jdbc.user;
package org.glyptodon.guacamole.auth.jdbc.user;
import org.glyptodon.guacamole.auth.jdbc.base.DirectoryObjectMapper;
package org.glyptodon.guacamole.auth.jdbc.user;
import org.glyptodon.guacamole.auth.jdbc.base.ObjectModel;
package org.glyptodon.guacamole.auth.jdbc.user;
import org.glyptodon.guacamole.auth.jdbc.base.DirectoryObjectMapper;
import org.glyptodon.guacamole.auth.jdbc.base.DirectoryObjectService;
package org.glyptodon.guacamole.auth.jdbc.user;
import com.google.inject.Guice;
import com.google.inject.Injector;
import org.glyptodon.guacamole.net.auth.AuthenticationProvider;
import org.glyptodon.guacamole.net.auth.Credentials;
import org.glyptodon.guacamole.net.auth.UserContext;
import org.glyptodon.guacamole.auth.jdbc.JDBCAuthenticationProviderModule;
import org.glyptodon.guacamole.auth.jdbc.user.UserContextService;
import org.glyptodon.guacamole.environment.Environment;
import org.glyptodon.guacamole.environment.LocalEnvironment;
public class MySQLAuthenticationProvider implements AuthenticationProvider {
private final Injector injector;
Environment environment = new LocalEnvironment();
injector = Guice.createInjector(
new MySQLAuthenticationProviderModule(environment),
new JDBCAuthenticationProviderModule(environment)
);
@Override
public UserContext getUserContext(Credentials credentials)
throws GuacamoleException {
UserContextService userContextService = injector.getInstance(UserContextService.class);
return userContextService.getUserContext(credentials);
}
@Override
public UserContext updateUserContext(UserContext context,
Credentials credentials) throws GuacamoleException {
return context;
}
package net.sourceforge.guacamole.net.auth.mysql;
import org.glyptodon.guacamole.auth.jdbc.user.UserContext;
import org.glyptodon.guacamole.auth.jdbc.connectiongroup.RootConnectionGroup;
import org.glyptodon.guacamole.auth.jdbc.connectiongroup.ModeledConnectionGroup;
import org.glyptodon.guacamole.auth.jdbc.connection.ModeledGuacamoleConfiguration;
import org.glyptodon.guacamole.auth.jdbc.connection.ModeledConnection;
import org.glyptodon.guacamole.auth.jdbc.permission.SystemPermissionSet;
import org.glyptodon.guacamole.auth.jdbc.user.ModeledUser;
bind(ModeledConnection.class);
bind(ModeledConnectionGroup.class);
bind(ModeledGuacamoleConfiguration.class);
bind(ModeledUser.class);
bind(RootConnectionGroup.class);
bind(SystemPermissionSet.class);
bind(UserContext.class);
Collection<ModeledConnection> objects = connectionService.retrieveObjects(currentUser, identifiers);
ModeledConnection connection = (ModeledConnection) object;
public class ConnectionService extends DirectoryObjectService<ModeledConnection, Connection, ConnectionModel> {
private Provider<ModeledConnection> connectionProvider;
protected ModeledConnection getObjectInstance(AuthenticatedUser currentUser,
ModeledConnection connection = connectionProvider.get();
ModeledConnection connection = getObjectInstance(currentUser, model);
ModeledConnection object) throws GuacamoleException {
private Collection<ParameterModel> getParameterModels(ModeledConnection connection) {
public ModeledConnection createObject(AuthenticatedUser user, Connection object)
ModeledConnection connection = super.createObject(user, object);
public void updateObject(AuthenticatedUser user, ModeledConnection object)
ModeledConnection connection) throws GuacamoleException {
records.add(new ModeledConnectionRecord(model));
ModeledConnection connection, GuacamoleClientInformation info)
import org.glyptodon.guacamole.auth.jdbc.connectiongroup.RootConnectionGroup;
public class ModeledConnection extends DirectoryObject<ConnectionModel>
private Provider<ModeledGuacamoleConfiguration> configProvider;
public ModeledConnection() {
return RootConnectionGroup.IDENTIFIER;
&& parentIdentifier.equals(RootConnectionGroup.IDENTIFIER))
ModeledGuacamoleConfiguration restrictedConfig = configProvider.get();
public class ModeledConnectionRecord implements ConnectionRecord {
private final ConnectionRecordModel model;
public ModeledConnectionRecord(ConnectionRecordModel model) {
public class ModeledGuacamoleConfiguration extends GuacamoleConfiguration {
public ModeledGuacamoleConfiguration() {
Collection<ModeledConnectionGroup> objects = connectionGroupService.retrieveObjects(currentUser, identifiers);
ModeledConnectionGroup connectionGroup = (ModeledConnectionGroup) object;
public class ConnectionGroupService extends DirectoryObjectService<ModeledConnectionGroup,
private Provider<ModeledConnectionGroup> connectionGroupProvider;
protected ModeledConnectionGroup getObjectInstance(AuthenticatedUser currentUser,
ModeledConnectionGroup connectionGroup = connectionGroupProvider.get();
ModeledConnectionGroup connectionGroup = getObjectInstance(currentUser, model);
ModeledConnectionGroup object) throws GuacamoleException {
ModeledConnectionGroup connectionGroup, GuacamoleClientInformation info)
public class ModeledConnectionGroup extends DirectoryObject<ConnectionGroupModel>
public ModeledConnectionGroup() {
return RootConnectionGroup.IDENTIFIER;
&& parentIdentifier.equals(RootConnectionGroup.IDENTIFIER))
public class RootConnectionGroup implements ConnectionGroup {
public RootConnectionGroup() {
import org.glyptodon.guacamole.auth.jdbc.user.ModeledUser;
protected boolean canAlterPermissions(AuthenticatedUser user, ModeledUser targetUser,
public void createPermissions(AuthenticatedUser user, ModeledUser targetUser,
public void deletePermissions(AuthenticatedUser user, ModeledUser targetUser,
import org.glyptodon.guacamole.auth.jdbc.user.ModeledUser;
protected abstract ModelType getModelInstance(ModeledUser targetUser,
protected Collection<ModelType> getModelInstances(ModeledUser targetUser,
ModeledUser targetUser) throws GuacamoleException;
ModeledUser targetUser) throws GuacamoleException {
ModeledUser targetUser,
ModeledUser targetUser,
import org.glyptodon.guacamole.auth.jdbc.user.ModeledUser;
extends PermissionService<SystemPermissionSet, SystemPermission, SystemPermissionModel> {
private Provider<SystemPermissionSet> systemPermissionSetProvider;
protected SystemPermissionModel getModelInstance(final ModeledUser targetUser,
public SystemPermissionSet getPermissionSet(AuthenticatedUser user,
ModeledUser targetUser) throws GuacamoleException {
SystemPermissionSet permissionSet = systemPermissionSetProvider.get();
public void createPermissions(AuthenticatedUser user, ModeledUser targetUser,
public void deletePermissions(AuthenticatedUser user, ModeledUser targetUser,
ModeledUser targetUser, SystemPermission.Type type) throws GuacamoleException {
import org.glyptodon.guacamole.auth.jdbc.user.ModeledUser;
public class SystemPermissionSet
implements org.glyptodon.guacamole.net.auth.permission.SystemPermissionSet {
private ModeledUser user;
public SystemPermissionSet() {
public void init(AuthenticatedUser currentUser, ModeledUser user) {
import org.glyptodon.guacamole.auth.jdbc.connection.ModeledConnection;
import org.glyptodon.guacamole.auth.jdbc.connectiongroup.ModeledConnectionGroup;
ModeledConnection connection) throws GuacamoleException;
ModeledConnection connection);
final ModeledConnection connection, GuacamoleClientInformation info)
ModeledConnectionGroup connectionGroup,
import org.glyptodon.guacamole.auth.jdbc.connection.ModeledConnection;
import org.glyptodon.guacamole.auth.jdbc.connectiongroup.ModeledConnectionGroup;
ModeledConnection connection, GuacamoleClientInformation info)
ModeledConnectionGroup connectionGroup,
import org.glyptodon.guacamole.auth.jdbc.connection.ModeledConnection;
protected void acquire(AuthenticatedUser user, ModeledConnection connection)
protected void release(AuthenticatedUser user, ModeledConnection connection) {
private final ModeledUser user;
public AuthenticatedUser(ModeledUser user, Credentials credentials) {
public ModeledUser getUser() {
public class ModeledUser extends DirectoryObject<UserModel> implements User {
public ModeledUser() {
import org.glyptodon.guacamole.auth.jdbc.connectiongroup.RootConnectionGroup;
public class UserContext
implements org.glyptodon.guacamole.net.auth.UserContext {
private Provider<RootConnectionGroup> rootGroupProvider;
RootConnectionGroup rootGroup = rootGroupProvider.get();
private Provider<UserContext> userContextProvider;
public org.glyptodon.guacamole.net.auth.UserContext
getUserContext(Credentials credentials)
throws GuacamoleException {
ModeledUser user = userService.retrieveUser(credentials);
UserContext context = userContextProvider.get();
Collection<ModeledUser> objects = userService.retrieveObjects(currentUser, identifiers);
ModeledUser user = (ModeledUser) object;
public class UserService extends DirectoryObjectService<ModeledUser, User, UserModel> {
private Provider<ModeledUser> userProvider;
protected ModeledUser getObjectInstance(AuthenticatedUser currentUser,
ModeledUser user = userProvider.get();
ModeledUser user = getObjectInstance(currentUser, model);
ModeledUser object) throws GuacamoleException {
ModeledUser existing = retrieveObject(user, object.getIdentifier());
public ModeledUser retrieveUser(Credentials credentials) {
ModeledUser user = getObjectInstance(null, userModel);
import org.apache.ibatis.annotations.Param;
import org.glyptodon.guacamole.auth.jdbc.user.UserModel;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermission;
ObjectPermissionModel selectOne(@Param("user") UserModel user,
@Param("type") ObjectPermission.Type type,
@Param("identifier") String identifier);
}
public abstract class ObjectPermissionService
extends PermissionService<ObjectPermissionSet, ObjectPermission, ObjectPermissionModel> {
@Override
protected abstract ObjectPermissionMapper getPermissionMapper();
Collection<ObjectPermissionModel> models = getModelInstances(targetUser, permissions);
Collection<ObjectPermissionModel> models = getModelInstances(targetUser, permissions);
public ObjectPermission retrievePermission(AuthenticatedUser user,
ModeledUser targetUser, ObjectPermission.Type type,
String identifier) throws GuacamoleException {
if (user.getUser().getIdentifier().equals(targetUser.getIdentifier())
|| user.getUser().isAdministrator()) {
ObjectPermissionModel model = getPermissionMapper().selectOne(targetUser.getModel(), type, identifier);
if (model == null)
return null;
return getPermissionInstance(model);
}
throw new GuacamoleSecurityException("Permission denied.");
}
extends ModeledObject<ModelType> implements Identifiable {
public abstract class RestrictedObject {
public void init(AuthenticatedUser currentUser) {
}
import org.glyptodon.guacamole.auth.jdbc.base.RestrictedObject;
public class ConnectionDirectory extends RestrictedObject
implements Directory<Connection> {
return connectionService.retrieveObject(getCurrentUser(), identifier);
Collection<ModeledConnection> objects = connectionService.retrieveObjects(getCurrentUser(), identifiers);
return connectionService.getIdentifiers(getCurrentUser());
connectionService.createObject(getCurrentUser(), object);
connectionService.updateObject(getCurrentUser(), connection);
connectionService.deleteObject(getCurrentUser(), identifier);
import org.glyptodon.guacamole.auth.jdbc.base.RestrictedObject;
public class ConnectionGroupDirectory extends RestrictedObject
implements Directory<ConnectionGroup> {
return connectionGroupService.retrieveObject(getCurrentUser(), identifier);
Collection<ModeledConnectionGroup> objects = connectionGroupService.retrieveObjects(getCurrentUser(), identifiers);
return connectionGroupService.getIdentifiers(getCurrentUser());
connectionGroupService.createObject(getCurrentUser(), object);
connectionGroupService.updateObject(getCurrentUser(), connectionGroup);
connectionGroupService.deleteObject(getCurrentUser(), identifier);
import org.glyptodon.guacamole.auth.jdbc.base.RestrictedObject;
public class RootConnectionGroup extends RestrictedObject
implements ConnectionGroup {
return connectionService.getIdentifiersWithin(getCurrentUser(), null);
return connectionGroupService.getIdentifiersWithin(getCurrentUser(), null);
import org.glyptodon.guacamole.auth.jdbc.base.RestrictedObject;
public abstract class ObjectPermissionSet extends RestrictedObject
super.init(currentUser);
return getObjectPermissionService().retrievePermissions(getCurrentUser(), user);
return getObjectPermissionService().retrievePermission(getCurrentUser(), user, permission, identifier) != null;
getObjectPermissionService().createPermissions(getCurrentUser(), user, permissions);
getObjectPermissionService().deletePermissions(getCurrentUser(), user, permissions);
import org.glyptodon.guacamole.auth.jdbc.base.RestrictedObject;
public class SystemPermissionSet extends RestrictedObject
super.init(currentUser);
return systemPermissionService.retrievePermissions(getCurrentUser(), user);
return systemPermissionService.retrievePermission(getCurrentUser(), user, permission) != null;
systemPermissionService.createPermissions(getCurrentUser(), user, permissions);
systemPermissionService.deletePermissions(getCurrentUser(), user, permissions);
import org.glyptodon.guacamole.auth.jdbc.base.RestrictedObject;
public class UserContext extends RestrictedObject
@Override
super.init(currentUser);
return getCurrentUser().getUser();
rootGroup.init(getCurrentUser());
import org.glyptodon.guacamole.auth.jdbc.base.RestrictedObject;
public class UserDirectory extends RestrictedObject
implements Directory<User> {
return userService.retrieveObject(getCurrentUser(), identifier);
Collection<ModeledUser> objects = userService.retrieveObjects(getCurrentUser(), identifiers);
return userService.getIdentifiers(getCurrentUser());
userService.createObject(getCurrentUser(), object);
userService.updateObject(getCurrentUser(), user);
userService.deleteObject(getCurrentUser(), identifier);
import java.util.Collection;
Collection<String> selectAccessibleIdentifiers(@Param("user") UserModel user,
@Param("permissions") Collection<ObjectPermission.Type> permissions,
@Param("identifiers") Collection<String> identifiers);
public Collection<String> retrieveAccessibleIdentifiers(AuthenticatedUser user,
ModeledUser targetUser, Collection<ObjectPermission.Type> permissions,
Collection<String> identifiers) throws GuacamoleException {
boolean isAdmin = user.getUser().isAdministrator();
if (isAdmin || user.getUser().getIdentifier().equals(targetUser.getIdentifier())) {
if (isAdmin)
return identifiers;
return getPermissionMapper().selectAccessibleIdentifiers(targetUser.getModel(), permissions, identifiers);
}
throw new GuacamoleSecurityException("Permission denied.");
}
return getObjectPermissionService().retrieveAccessibleIdentifiers(getCurrentUser(), user, permissions, identifiers);
import org.glyptodon.guacamole.auth.jdbc.permission.ConnectionPermissionMapper;
import org.glyptodon.guacamole.auth.jdbc.permission.ConnectionPermissionService;
import org.glyptodon.guacamole.auth.jdbc.permission.ConnectionPermissionSet;
addMapperClass(ConnectionPermissionMapper.class);
bind(ConnectionPermissionSet.class);
bind(ConnectionPermissionService.class);
private String objectIdentifier;
public String getObjectIdentifier() {
return objectIdentifier;
public void setObjectIdentifier(String objectIdentifier) {
this.objectIdentifier = objectIdentifier;
@Override
protected ObjectPermission getPermissionInstance(ObjectPermissionModel model) {
return new ObjectPermission(model.getType(), model.getObjectIdentifier());
}
@Override
protected ObjectPermissionModel getModelInstance(ModeledUser targetUser,
ObjectPermission permission) {
ObjectPermissionModel model = new ObjectPermissionModel();
model.setUserID(targetUser.getModel().getObjectID());
model.setUsername(targetUser.getModel().getIdentifier());
model.setType(permission.getType());
model.setObjectIdentifier(permission.getObjectIdentifier());
return model;
}
ObjectPermissionSet affectedPermissionSet = getPermissionSet(user, user.getUser());
import org.glyptodon.guacamole.auth.jdbc.permission.ConnectionPermissionService;
@Inject
private ConnectionPermissionService connectionPermissionService;
return connectionPermissionService.getPermissionSet(getCurrentUser(), this);
import org.glyptodon.guacamole.auth.jdbc.permission.ConnectionGroupPermissionMapper;
import org.glyptodon.guacamole.auth.jdbc.permission.ConnectionGroupPermissionService;
import org.glyptodon.guacamole.auth.jdbc.permission.ConnectionGroupPermissionSet;
addMapperClass(ConnectionGroupPermissionMapper.class);
bind(ConnectionGroupPermissionSet.class);
bind(ConnectionPermissionSet.class);
bind(ConnectionGroupPermissionService.class);
bind(ConnectionGroupService.class);
import org.glyptodon.guacamole.auth.jdbc.permission.ConnectionGroupPermissionService;
@Inject
private ConnectionGroupPermissionService connectionGroupPermissionService;
return connectionGroupPermissionService.getPermissionSet(getCurrentUser(), this);
import org.glyptodon.guacamole.auth.jdbc.permission.UserPermissionMapper;
import org.glyptodon.guacamole.auth.jdbc.permission.UserPermissionService;
import org.glyptodon.guacamole.auth.jdbc.permission.UserPermissionSet;
addMapperClass(UserPermissionMapper.class);
bind(UserPermissionSet.class);
bind(UserPermissionService.class);
import org.glyptodon.guacamole.auth.jdbc.permission.UserPermissionService;
@Inject
private UserPermissionService userPermissionService;
return userPermissionService.getPermissionSet(getCurrentUser(), this);
if (identifiers.isEmpty())
return identifiers;
import org.glyptodon.guacamole.auth.jdbc.permission.ObjectPermissionMapper;
import org.glyptodon.guacamole.auth.jdbc.permission.ObjectPermissionModel;
import org.glyptodon.guacamole.auth.jdbc.user.UserModel;
private static final ObjectPermission.Type[] IMPLICIT_OBJECT_PERMISSIONS = {
ObjectPermission.Type.READ,
ObjectPermission.Type.UPDATE,
ObjectPermission.Type.DELETE,
ObjectPermission.Type.ADMINISTER
};
protected abstract ObjectPermissionMapper getPermissionMapper();
Collection<ObjectPermissionModel> implicitPermissions =
new ArrayList<ObjectPermissionModel>(IMPLICIT_OBJECT_PERMISSIONS.length);
UserModel userModel = user.getUser().getModel();
for (ObjectPermission.Type permission : IMPLICIT_OBJECT_PERMISSIONS) {
ObjectPermissionModel permissionModel = new ObjectPermissionModel();
permissionModel.setUserID(userModel.getObjectID());
permissionModel.setUsername(userModel.getIdentifier());
permissionModel.setType(permission);
permissionModel.setObjectIdentifier(model.getIdentifier());
implicitPermissions.add(permissionModel);
}
getPermissionMapper().insert(implicitPermissions);
import org.glyptodon.guacamole.auth.jdbc.permission.ConnectionPermissionMapper;
import org.glyptodon.guacamole.auth.jdbc.permission.ObjectPermissionMapper;
@Inject
private ConnectionPermissionMapper connectionPermissionMapper;
protected ObjectPermissionMapper getPermissionMapper() {
return connectionPermissionMapper;
}
@Override
import org.glyptodon.guacamole.auth.jdbc.permission.ConnectionGroupPermissionMapper;
import org.glyptodon.guacamole.auth.jdbc.permission.ObjectPermissionMapper;
@Inject
private ConnectionGroupPermissionMapper connectionGroupPermissionMapper;
protected ObjectPermissionMapper getPermissionMapper() {
return connectionGroupPermissionMapper;
}
@Override
import org.glyptodon.guacamole.auth.jdbc.permission.ObjectPermissionMapper;
import org.glyptodon.guacamole.auth.jdbc.permission.UserPermissionMapper;
@Inject
private UserPermissionMapper userPermissionMapper;
protected ObjectPermissionMapper getPermissionMapper() {
return userPermissionMapper;
}
@Override
protected void validateNewModel(AuthenticatedUser user,
ModelType model) throws GuacamoleException {
protected void validateExistingModel(AuthenticatedUser user,
ModelType model) throws GuacamoleException {
ModelType model = getModelInstance(user, object);
validateNewModel(user, model);
ModelType model = object.getModel();
validateExistingModel(user, model);
getObjectMapper().update(model);
ConnectionModel selectOneByName(@Param("parentIdentifier") String parentIdentifier,
@Param("name") String name);
protected void validateNewModel(AuthenticatedUser user,
ConnectionModel model) throws GuacamoleException {
if (model.getName().trim().isEmpty())
ConnectionModel existing = connectionMapper.selectOneByName(model.getParentIdentifier(), model.getName());
if (existing != null)
protected void validateExistingModel(AuthenticatedUser user,
ConnectionModel model) throws GuacamoleException {
if (model.getName().trim().isEmpty())
ConnectionModel existing = connectionMapper.selectOneByName(model.getParentIdentifier(), model.getName());
if (existing != null) {
if (!existing.getObjectID().equals(model.getObjectID()))
}
if (!parameterModels.isEmpty())
parameterMapper.insert(parameterModels);
ConnectionGroupModel selectOneByName(@Param("parentIdentifier") String parentIdentifier,
@Param("name") String name);
protected void validateNewModel(AuthenticatedUser user,
ConnectionGroupModel model) throws GuacamoleException {
if (model.getName().trim().isEmpty())
ConnectionGroupModel existing = connectionGroupMapper.selectOneByName(model.getParentIdentifier(), model.getName());
if (existing != null)
protected void validateExistingModel(AuthenticatedUser user,
ConnectionGroupModel model) throws GuacamoleException {
if (model.getName().trim().isEmpty())
ConnectionGroupModel existing = connectionGroupMapper.selectOneByName(model.getParentIdentifier(), model.getName());
if (existing != null) {
if (!existing.getObjectID().equals(model.getObjectID()))
}
UserModel selectOneByCredentials(@Param("username") String username,
UserModel selectOne(@Param("username") String username);
protected void validateNewModel(AuthenticatedUser user, UserModel model)
if (model.getIdentifier().trim().isEmpty())
Collection<UserModel> existing = userMapper.select(Collections.singleton(model.getIdentifier()));
protected void validateExistingModel(AuthenticatedUser user,
UserModel model) throws GuacamoleException {
if (model.getIdentifier().trim().isEmpty())
UserModel existing = userMapper.selectOne(model.getIdentifier());
if (!existing.getObjectID().equals(model.getObjectID()))
UserModel userModel = userMapper.selectOneByCredentials(username, password);
package org.glyptodon.guacamole.auth.jdbc.base;
package org.glyptodon.guacamole.auth.jdbc.connection;
package org.glyptodon.guacamole.auth.jdbc.connectiongroup;
package org.glyptodon.guacamole.auth.jdbc;
package org.glyptodon.guacamole.auth.jdbc.permission;
public interface ConnectionGroupPermissionMapper extends ObjectPermissionMapper {}
package org.glyptodon.guacamole.auth.jdbc.permission;
import com.google.inject.Inject;
public class ConnectionGroupPermissionSet extends ObjectPermissionSet {
@Inject
private ConnectionGroupPermissionService connectionGroupPermissionService;
protected ObjectPermissionService getObjectPermissionService() {
return connectionGroupPermissionService;
package org.glyptodon.guacamole.auth.jdbc.permission;
public interface ConnectionPermissionMapper extends ObjectPermissionMapper {}
package org.glyptodon.guacamole.auth.jdbc.permission;
import com.google.inject.Inject;
public class ConnectionPermissionSet extends ObjectPermissionSet {
@Inject
private ConnectionPermissionService connectionPermissionService;
protected ObjectPermissionService getObjectPermissionService() {
return connectionPermissionService;
package org.glyptodon.guacamole.auth.jdbc.permission;
import org.glyptodon.guacamole.net.auth.permission.SystemPermission;
public class SystemPermissionModel extends PermissionModel<SystemPermission.Type> {
public SystemPermissionModel() {
}
package org.glyptodon.guacamole.auth.jdbc.permission;
public interface UserPermissionMapper extends ObjectPermissionMapper {}
package org.glyptodon.guacamole.auth.jdbc.permission;
import com.google.inject.Inject;
public class UserPermissionSet extends ObjectPermissionSet {
@Inject
private UserPermissionService userPermissionService;
protected ObjectPermissionService getObjectPermissionService() {
return userPermissionService;
package org.glyptodon.guacamole.auth.jdbc.permission;
package org.glyptodon.guacamole.auth.jdbc.security;
package org.glyptodon.guacamole.auth.jdbc.security;
package org.glyptodon.guacamole.auth.jdbc.security;
package org.glyptodon.guacamole.auth.jdbc.security;
package org.glyptodon.guacamole.auth.jdbc.security;
package org.glyptodon.guacamole.auth.jdbc.socket;
package org.glyptodon.guacamole.auth.jdbc.user;
private final ModeledUser user;
public AuthenticatedUser(ModeledUser user, Credentials credentials) {
this.user = user;
public ModeledUser getUser() {
return user;
package org.glyptodon.guacamole.auth.jdbc.user;
package net.sourceforge.guacamole.net.auth.mysql;
import com.google.inject.Provider;
import java.util.ArrayList;
import org.glyptodon.guacamole.GuacamoleSecurityException;
import org.glyptodon.guacamole.auth.jdbc.connection.ConnectionMapper;
import org.mybatis.guice.transactional.Transactional;
@Inject
private ConnectionMapper connectionMapper;
@Inject
private Provider<ModeledConnection> connectionProvider;
protected abstract ModeledConnection acquire(AuthenticatedUser user,
List<ModeledConnection> connections) throws GuacamoleException;
private GuacamoleSocket connect(final AuthenticatedUser user,
@Transactional
public GuacamoleSocket getGuacamoleSocket(final AuthenticatedUser user,
final ModeledConnection connection, GuacamoleClientInformation info)
throws GuacamoleException {
acquire(user, Collections.singletonList(connection));
return connect(user, connection, info);
}
@Override
@Transactional
if (connectionGroup.getType() != ConnectionGroup.Type.BALANCING)
throw new GuacamoleSecurityException("Permission denied.");
Collection<String> identifiers = connectionMapper.selectIdentifiersWithin(connectionGroup.getIdentifier());
if (identifiers.isEmpty())
throw new GuacamoleSecurityException("Permission denied.");
Collection<ConnectionModel> models = connectionMapper.select(identifiers);
List<ModeledConnection> connections = new ArrayList<ModeledConnection>(models.size());
for (ConnectionModel model : models) {
ModeledConnection connection = connectionProvider.get();
connection.init(user, model);
connections.add(connection);
}
ModeledConnection connection = acquire(user, connections);
return connect(user, connection, info);
import java.util.List;
protected ModeledConnection acquire(AuthenticatedUser user,
List<ModeledConnection> connections) throws GuacamoleException {
ModeledConnection chosen = null;
int lowestUsage = 0;
for (ModeledConnection connection : connections) {
int usage = getActiveConnections(connection).size();
if (chosen == null || usage < lowestUsage) {
chosen = connection;
lowestUsage = usage;
}
}
return chosen;
private final ActiveConnectionMultimap activeConnections = new ActiveConnectionMultimap();
private final ActiveConnectionMultimap activeConnectionGroups = new ActiveConnectionMultimap();
final String identifier = connection.getIdentifier();
final String parentIdentifier = connection.getParentIdentifier();
Collection<ParameterModel> parameters = parameterMapper.select(identifier);
activeConnections.put(identifier, activeConnection);
activeConnectionGroups.put(parentIdentifier, activeConnection);
activeConnections.remove(identifier, activeConnection);
activeConnectionGroups.remove(parentIdentifier, activeConnection);
recordModel.setConnectionIdentifier(identifier);
activeConnections.remove(identifier, activeConnection);
activeConnectionGroups.remove(parentIdentifier, activeConnection);
return activeConnections.get(connection.getIdentifier());
if (connectionGroup.getType() != ConnectionGroup.Type.BALANCING)
return Collections.EMPTY_LIST;
return activeConnectionGroups.get(connectionGroup.getIdentifier());
import java.util.Collections;
Collections.reverse(records);
public Collection<ConnectionRecord> getActiveConnections(Connection connection) {
public Collection<ConnectionRecord> getActiveConnections(ConnectionGroup connectionGroup) {
import java.util.Collection;
import java.util.LinkedHashMap;
import java.util.Set;
private final Map<String, Set<ConnectionRecord>> records =
new HashMap<String, Set<ConnectionRecord>>();
Set<ConnectionRecord> connections = records.get(identifier);
connections = Collections.newSetFromMap(new LinkedHashMap<ConnectionRecord, Boolean>());
connections.add(record);
Set<ConnectionRecord> connections = records.get(identifier);
public Collection<ConnectionRecord> get(String identifier) {
Collection<ConnectionRecord> connections = records.get(identifier);
return Collections.unmodifiableCollection(connections);
import java.util.Collection;
public Collection<ConnectionRecord> getActiveConnections(Connection connection);
public Collection<ConnectionRecord> getActiveConnections(ConnectionGroup connectionGroup);
import java.util.Collections;
Collections.reverse(records);
import com.google.inject.Provider;
import java.util.ArrayList;
import org.glyptodon.guacamole.GuacamoleSecurityException;
import org.glyptodon.guacamole.auth.jdbc.connection.ConnectionMapper;
import org.mybatis.guice.transactional.Transactional;
@Inject
private ConnectionMapper connectionMapper;
@Inject
private Provider<ModeledConnection> connectionProvider;
private final ActiveConnectionMultimap activeConnections = new ActiveConnectionMultimap();
private final ActiveConnectionMultimap activeConnectionGroups = new ActiveConnectionMultimap();
protected abstract ModeledConnection acquire(AuthenticatedUser user,
List<ModeledConnection> connections) throws GuacamoleException;
private GuacamoleSocket connect(final AuthenticatedUser user,
final String identifier = connection.getIdentifier();
final String parentIdentifier = connection.getParentIdentifier();
Collection<ParameterModel> parameters = parameterMapper.select(identifier);
activeConnections.put(identifier, activeConnection);
activeConnectionGroups.put(parentIdentifier, activeConnection);
activeConnections.remove(identifier, activeConnection);
activeConnectionGroups.remove(parentIdentifier, activeConnection);
recordModel.setConnectionIdentifier(identifier);
activeConnections.remove(identifier, activeConnection);
activeConnectionGroups.remove(parentIdentifier, activeConnection);
@Transactional
public GuacamoleSocket getGuacamoleSocket(final AuthenticatedUser user,
final ModeledConnection connection, GuacamoleClientInformation info)
throws GuacamoleException {
acquire(user, Collections.singletonList(connection));
return connect(user, connection, info);
public Collection<ConnectionRecord> getActiveConnections(Connection connection) {
return activeConnections.get(connection.getIdentifier());
}
@Override
@Transactional
if (connectionGroup.getType() != ConnectionGroup.Type.BALANCING)
throw new GuacamoleSecurityException("Permission denied.");
Collection<String> identifiers = connectionMapper.selectIdentifiersWithin(connectionGroup.getIdentifier());
if (identifiers.isEmpty())
throw new GuacamoleSecurityException("Permission denied.");
Collection<ConnectionModel> models = connectionMapper.select(identifiers);
List<ModeledConnection> connections = new ArrayList<ModeledConnection>(models.size());
for (ConnectionModel model : models) {
ModeledConnection connection = connectionProvider.get();
connection.init(user, model);
connections.add(connection);
}
ModeledConnection connection = acquire(user, connections);
return connect(user, connection, info);
public Collection<ConnectionRecord> getActiveConnections(ConnectionGroup connectionGroup) {
if (connectionGroup.getType() != ConnectionGroup.Type.BALANCING)
return Collections.EMPTY_LIST;
return activeConnectionGroups.get(connectionGroup.getIdentifier());
import java.util.Collection;
public Collection<ConnectionRecord> getActiveConnections(Connection connection);
public Collection<ConnectionRecord> getActiveConnections(ConnectionGroup connectionGroup);
import java.util.List;
protected ModeledConnection acquire(AuthenticatedUser user,
List<ModeledConnection> connections) throws GuacamoleException {
ModeledConnection chosen = null;
int lowestUsage = 0;
for (ModeledConnection connection : connections) {
int usage = getActiveConnections(connection).size();
if (chosen == null || usage < lowestUsage) {
chosen = connection;
lowestUsage = usage;
}
}
return chosen;
private final Class<? extends GuacamoleSocketService> socketServiceClass;
public JDBCAuthenticationProviderModule(Environment environment,
Class<? extends GuacamoleSocketService> socketServiceClass) {
this.socketServiceClass = socketServiceClass;
bind(GuacamoleSocketService.class).to(socketServiceClass);
import org.glyptodon.guacamole.auth.jdbc.socket.GuacamoleSocketService;
import org.glyptodon.guacamole.auth.jdbc.socket.MultiseatGuacamoleSocketService;
import org.glyptodon.guacamole.auth.jdbc.socket.ReservedGuacamoleSocketService;
import org.glyptodon.guacamole.auth.jdbc.socket.SingleSeatGuacamoleSocketService;
import org.glyptodon.guacamole.auth.jdbc.socket.UnrestrictedGuacamoleSocketService;
import org.glyptodon.guacamole.properties.GuacamoleProperties;
private Class<? extends GuacamoleSocketService>
getSocketServiceClass(Environment environment)
throws GuacamoleException {
boolean disallowSimultaneous = environment.getProperty(MySQLGuacamoleProperties.MYSQL_DISALLOW_SIMULTANEOUS_CONNECTIONS, false);
boolean disallowDuplicate    = environment.getProperty(MySQLGuacamoleProperties.MYSQL_DISALLOW_DUPLICATE_CONNECTIONS, true);
if (disallowSimultaneous) {
if (disallowDuplicate)
return SingleSeatGuacamoleSocketService.class;
else
return ReservedGuacamoleSocketService.class;
}
else {
if (disallowDuplicate)
return MultiseatGuacamoleSocketService.class;
else
return UnrestrictedGuacamoleSocketService.class;
}
}
new JDBCAuthenticationProviderModule(environment, getSocketServiceClass(environment))
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import org.glyptodon.guacamole.GuacamoleResourceConflictException;
private static class Reservation {
private final String username;
private int count = 1;
public Reservation(String username) {
this.username = username;
}
public boolean acquire(String username) {
if (!this.username.equals(username))
return false;
synchronized (this) {
if (count == 0)
return false;
return true;
}
}
public boolean release() {
synchronized (this) {
count--;
return count == 0;
}
}
}
private final ConcurrentMap<String, Reservation> reservations =
new ConcurrentHashMap<String, Reservation>();
String username = user.getUser().getIdentifier();
for (ModeledConnection connection : connections) {
String identifier = connection.getIdentifier();
Reservation reservation = reservations.putIfAbsent(identifier, new Reservation(username));
if (reservation == null || reservation.acquire(username))
return connection;
}
throw new GuacamoleResourceConflictException("Cannot connect. This connection is in use.");
String identifier = connection.getIdentifier();
Reservation reservation = reservations.get(identifier);
assert(reservation != null);
if (reservation.release())
reservations.remove(identifier);
import java.util.concurrent.atomic.AtomicBoolean;
final AtomicBoolean released = new AtomicBoolean(false);
if (released.compareAndSet(false, true)) {
activeConnections.remove(identifier, activeConnection);
activeConnectionGroups.remove(parentIdentifier, activeConnection);
release(user, connection);
UserModel userModel = user.getUser().getModel();
ConnectionRecordModel recordModel = new ConnectionRecordModel();
recordModel.setUserID(userModel.getObjectID());
recordModel.setUsername(userModel.getIdentifier());
recordModel.setConnectionIdentifier(identifier);
recordModel.setStartDate(activeConnection.getStartDate());
recordModel.setEndDate(new Date());
connectionRecordMapper.insert(recordModel);
}
if (released.compareAndSet(false, true)) {
activeConnections.remove(identifier, activeConnection);
activeConnectionGroups.remove(parentIdentifier, activeConnection);
release(user, connection);
}
private GuacamoleConfiguration getGuacamoleConfiguration(AuthenticatedUser user,
ModeledConnection connection) {
GuacamoleConfiguration config = new GuacamoleConfiguration();
ConnectionModel model = connection.getModel();
config.setProtocol(model.getProtocol());
Collection<ParameterModel> parameters = parameterMapper.select(connection.getIdentifier());
for (ParameterModel parameter : parameters)
config.setParameter(parameter.getName(), parameter.getValue());
TokenFilter tokenFilter = new TokenFilter();
StandardTokens.addStandardTokens(tokenFilter, user.getCredentials());
tokenFilter.filterValues(config.getParameters());
return config;
}
private void saveConnectionRecord(String identifier,
ActiveConnectionRecord record) {
AuthenticatedUser user = record.getUser();
UserModel userModel = user.getUser().getModel();
ConnectionRecordModel recordModel = new ConnectionRecordModel();
recordModel.setUserID(userModel.getObjectID());
recordModel.setUsername(userModel.getIdentifier());
recordModel.setConnectionIdentifier(identifier);
recordModel.setStartDate(record.getStartDate());
recordModel.setEndDate(new Date());
connectionRecordMapper.insert(recordModel);
}
getGuacamoleConfiguration(user, connection)
saveConnectionRecord(identifier, activeConnection);
public AuthenticatedUser getUser() {
return user;
}
private GuacamoleSocket getUnconfiguredGuacamoleSocket()
throws GuacamoleException {
if (environment.getProperty(Environment.GUACD_SSL, true))
return new InetGuacamoleSocket(
environment.getRequiredProperty(Environment.GUACD_HOSTNAME),
environment.getRequiredProperty(Environment.GUACD_PORT)
);
return new InetGuacamoleSocket(
environment.getRequiredProperty(Environment.GUACD_HOSTNAME),
environment.getRequiredProperty(Environment.GUACD_PORT)
);
}
getUnconfiguredGuacamoleSocket(),
getGuacamoleConfiguration(user, connection),
info
private final Class<? extends GuacamoleSocketService> socketServiceClass;
public JDBCAuthenticationProviderModule(Environment environment,
Class<? extends GuacamoleSocketService> socketServiceClass) {
this.socketServiceClass = socketServiceClass;
bind(GuacamoleSocketService.class).to(socketServiceClass);
import java.util.concurrent.atomic.AtomicBoolean;
private GuacamoleConfiguration getGuacamoleConfiguration(AuthenticatedUser user,
ModeledConnection connection) {
GuacamoleConfiguration config = new GuacamoleConfiguration();
ConnectionModel model = connection.getModel();
config.setProtocol(model.getProtocol());
Collection<ParameterModel> parameters = parameterMapper.select(connection.getIdentifier());
for (ParameterModel parameter : parameters)
config.setParameter(parameter.getName(), parameter.getValue());
TokenFilter tokenFilter = new TokenFilter();
StandardTokens.addStandardTokens(tokenFilter, user.getCredentials());
tokenFilter.filterValues(config.getParameters());
return config;
}
private void saveConnectionRecord(String identifier,
ActiveConnectionRecord record) {
AuthenticatedUser user = record.getUser();
UserModel userModel = user.getUser().getModel();
ConnectionRecordModel recordModel = new ConnectionRecordModel();
recordModel.setUserID(userModel.getObjectID());
recordModel.setUsername(userModel.getIdentifier());
recordModel.setConnectionIdentifier(identifier);
recordModel.setStartDate(record.getStartDate());
recordModel.setEndDate(new Date());
connectionRecordMapper.insert(recordModel);
}
private GuacamoleSocket getUnconfiguredGuacamoleSocket()
throws GuacamoleException {
if (environment.getProperty(Environment.GUACD_SSL, true))
return new InetGuacamoleSocket(
environment.getRequiredProperty(Environment.GUACD_HOSTNAME),
environment.getRequiredProperty(Environment.GUACD_PORT)
);
return new InetGuacamoleSocket(
environment.getRequiredProperty(Environment.GUACD_HOSTNAME),
environment.getRequiredProperty(Environment.GUACD_PORT)
);
}
final AtomicBoolean released = new AtomicBoolean(false);
getUnconfiguredGuacamoleSocket(),
getGuacamoleConfiguration(user, connection),
info
if (released.compareAndSet(false, true)) {
activeConnections.remove(identifier, activeConnection);
activeConnectionGroups.remove(parentIdentifier, activeConnection);
release(user, connection);
saveConnectionRecord(identifier, activeConnection);
}
if (released.compareAndSet(false, true)) {
activeConnections.remove(identifier, activeConnection);
activeConnectionGroups.remove(parentIdentifier, activeConnection);
release(user, connection);
}
public AuthenticatedUser getUser() {
return user;
}
import org.glyptodon.guacamole.auth.jdbc.socket.GuacamoleSocketService;
import org.glyptodon.guacamole.auth.jdbc.socket.MultiseatGuacamoleSocketService;
import org.glyptodon.guacamole.auth.jdbc.socket.ReservedGuacamoleSocketService;
import org.glyptodon.guacamole.auth.jdbc.socket.SingleSeatGuacamoleSocketService;
import org.glyptodon.guacamole.auth.jdbc.socket.UnrestrictedGuacamoleSocketService;
import org.glyptodon.guacamole.properties.GuacamoleProperties;
private Class<? extends GuacamoleSocketService>
getSocketServiceClass(Environment environment)
throws GuacamoleException {
boolean disallowSimultaneous = environment.getProperty(MySQLGuacamoleProperties.MYSQL_DISALLOW_SIMULTANEOUS_CONNECTIONS, false);
boolean disallowDuplicate    = environment.getProperty(MySQLGuacamoleProperties.MYSQL_DISALLOW_DUPLICATE_CONNECTIONS, true);
if (disallowSimultaneous) {
if (disallowDuplicate)
return SingleSeatGuacamoleSocketService.class;
else
return ReservedGuacamoleSocketService.class;
}
else {
if (disallowDuplicate)
return MultiseatGuacamoleSocketService.class;
else
return UnrestrictedGuacamoleSocketService.class;
}
}
new JDBCAuthenticationProviderModule(environment, getSocketServiceClass(environment))
import java.util.Arrays;
import org.glyptodon.guacamole.auth.jdbc.security.PasswordEncryptionService;
@Inject
private PasswordEncryptionService encryptionService;
UserModel userModel = userMapper.selectOne(username);
byte[] hash = encryptionService.createPasswordHash(password, userModel.getPasswordSalt());
if (Arrays.equals(hash, userModel.getPasswordHash())) {
ModeledUser user = getObjectInstance(null, userModel);
user.setCurrentUser(new AuthenticatedUser(user, credentials));
return user;
}
return null;
ConnectionGroup existingConnectionGroup = retrievalService.retrieveConnectionGroup(userContext, connectionGroupID);
ConnectionGroup existingConnectionGroup = retrievalService.retrieveConnectionGroup(userContext, connectionGroupID);
import java.util.Arrays;
import org.glyptodon.guacamole.auth.jdbc.security.PasswordEncryptionService;
@Inject
private PasswordEncryptionService encryptionService;
UserModel userModel = userMapper.selectOne(username);
byte[] hash = encryptionService.createPasswordHash(password, userModel.getPasswordSalt());
if (Arrays.equals(hash, userModel.getPasswordHash())) {
ModeledUser user = getObjectInstance(null, userModel);
user.setCurrentUser(new AuthenticatedUser(user, credentials));
return user;
}
return null;
protected Collection<ObjectPermissionModel> getImplicitPermissions(AuthenticatedUser user,
ModelType model) {
Collection<ObjectPermissionModel> implicitPermissions =
new ArrayList<ObjectPermissionModel>(IMPLICIT_OBJECT_PERMISSIONS.length);
UserModel userModel = user.getUser().getModel();
for (ObjectPermission.Type permission : IMPLICIT_OBJECT_PERMISSIONS) {
ObjectPermissionModel permissionModel = new ObjectPermissionModel();
permissionModel.setUserID(userModel.getObjectID());
permissionModel.setUsername(userModel.getIdentifier());
permissionModel.setType(permission);
permissionModel.setObjectIdentifier(model.getIdentifier());
implicitPermissions.add(permissionModel);
}
return implicitPermissions;
}
getPermissionMapper().insert(getImplicitPermissions(user, model));
import org.glyptodon.guacamole.auth.jdbc.permission.ObjectPermissionModel;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermission;
private static final ObjectPermission.Type[] IMPLICIT_USER_PERMISSIONS = {
ObjectPermission.Type.READ,
ObjectPermission.Type.UPDATE
};
@Override
protected Collection<ObjectPermissionModel>
getImplicitPermissions(AuthenticatedUser user, UserModel model) {
Collection<ObjectPermissionModel> implicitPermissions = super.getImplicitPermissions(user, model);
for (ObjectPermission.Type permissionType : IMPLICIT_USER_PERMISSIONS) {
ObjectPermissionModel permissionModel = new ObjectPermissionModel();
permissionModel.setUserID(model.getObjectID());
permissionModel.setUsername(model.getIdentifier());
permissionModel.setType(permissionType);
permissionModel.setObjectIdentifier(model.getIdentifier());
implicitPermissions.add(permissionModel);
}
return implicitPermissions;
}
protected abstract void acquire(AuthenticatedUser user,
ModeledConnectionGroup connectionGroup) throws GuacamoleException;
protected abstract void release(AuthenticatedUser user,
ModeledConnectionGroup connectionGroup);
final ModeledConnectionGroup balancingGroup,
if (balancingGroup != null)
release(user, balancingGroup);
if (balancingGroup != null)
release(user, balancingGroup);
return connect(user, null, connection, info);
acquire(user, connectionGroup);
return connect(user, connectionGroup, connection, info);
import org.glyptodon.guacamole.auth.jdbc.connectiongroup.ModeledConnectionGroup;
private final Set<Seat> activeGroupSeats =
Collections.newSetFromMap(new ConcurrentHashMap<Seat, Boolean>());
@Override
protected void acquire(AuthenticatedUser user,
ModeledConnectionGroup connectionGroup) throws GuacamoleException {
Seat seat = new Seat(user.getUser().getIdentifier(), connectionGroup.getIdentifier());
if (!activeGroupSeats.add(seat))
throw new GuacamoleResourceConflictException("Cannot connect. This connection is in use.");
}
@Override
protected void release(AuthenticatedUser user,
ModeledConnectionGroup connectionGroup) {
activeGroupSeats.remove(new Seat(user.getUser().getIdentifier(), connectionGroup.getIdentifier()));
}
import org.glyptodon.guacamole.auth.jdbc.connectiongroup.ModeledConnectionGroup;
private final Set<Seat> activeGroupSeats =
Collections.newSetFromMap(new ConcurrentHashMap<Seat, Boolean>());
@Override
protected void acquire(AuthenticatedUser user,
ModeledConnectionGroup connectionGroup) throws GuacamoleException {
Seat seat = new Seat(user.getUser().getIdentifier(), connectionGroup.getIdentifier());
if (!activeGroupSeats.add(seat))
throw new GuacamoleResourceConflictException("Cannot connect. This connection is in use.");
}
@Override
protected void release(AuthenticatedUser user,
ModeledConnectionGroup connectionGroup) {
activeGroupSeats.remove(new Seat(user.getUser().getIdentifier(), connectionGroup.getIdentifier()));
}
import org.glyptodon.guacamole.auth.jdbc.connectiongroup.ModeledConnectionGroup;
@Override
protected void acquire(AuthenticatedUser user,
ModeledConnectionGroup connectionGroup) throws GuacamoleException {
}
@Override
protected void release(AuthenticatedUser user,
ModeledConnectionGroup connectionGroup) {
}
import org.glyptodon.guacamole.auth.jdbc.socket.BalancedGuacamoleSocketService;
return BalancedGuacamoleSocketService.class;
import java.util.Arrays;
import java.util.Comparator;
ModeledConnection[] sortedConnections = connections.toArray(new ModeledConnection[connections.size()]);
Arrays.sort(sortedConnections, new Comparator<ModeledConnection>() {
@Override
public int compare(ModeledConnection a, ModeledConnection b) {
return getActiveConnections(a).size()
- getActiveConnections(b).size();
}
});
for (ModeledConnection connection : sortedConnections) {
import org.glyptodon.guacamole.GuacamoleClientTooManyException;
throw new GuacamoleClientTooManyException("Cannot connect. Connection group already in use by this user.");
import org.glyptodon.guacamole.GuacamoleClientTooManyException;
throw new GuacamoleClientTooManyException("Cannot connect. Connection group already in use by this user.");
private void saveConnectionRecord(ActiveConnectionRecord record) {
ModeledConnection connection = record.getConnection();
recordModel.setConnectionIdentifier(connection.getIdentifier());
private GuacamoleSocket getUnconfiguredGuacamoleSocket(Runnable socketClosedCallback)
return new ManagedInetGuacamoleSocket(
environment.getRequiredProperty(Environment.GUACD_PORT),
socketClosedCallback
return new ManagedInetGuacamoleSocket(
environment.getRequiredProperty(Environment.GUACD_PORT),
socketClosedCallback
private class ConnectionCleanupTask implements Runnable {
private final AtomicBoolean hasRun = new AtomicBoolean(false);
private final ActiveConnectionRecord activeConnection;
public ConnectionCleanupTask(ActiveConnectionRecord activeConnection) {
this.activeConnection = activeConnection;
}
@Override
public void run() {
if (!hasRun.compareAndSet(false, true))
return;
AuthenticatedUser user = activeConnection.getUser();
ModeledConnection connection = activeConnection.getConnection();
String identifier = connection.getIdentifier();
String parentIdentifier = connection.getParentIdentifier();
activeConnections.remove(identifier, activeConnection);
activeConnectionGroups.remove(parentIdentifier, activeConnection);
release(user, connection);
if (activeConnection.hasBalancingGroup())
release(user, activeConnection.getBalancingGroup());
saveConnectionRecord(activeConnection);
}
}
private GuacamoleSocket getGuacamoleSocket(ActiveConnectionRecord activeConnection,
GuacamoleClientInformation info)
ModeledConnection connection = activeConnection.getConnection();
Runnable cleanupTask = new ConnectionCleanupTask(activeConnection);
activeConnections.put(connection.getIdentifier(), activeConnection);
activeConnectionGroups.put(connection.getParentIdentifier(), activeConnection);
getUnconfiguredGuacamoleSocket(cleanupTask),
getGuacamoleConfiguration(activeConnection.getUser(), connection),
);
cleanupTask.run();
private List<ModeledConnection> getBalancedConnections(AuthenticatedUser user,
ModeledConnectionGroup connectionGroup) {
if (connectionGroup.getType() != ConnectionGroup.Type.BALANCING)
return Collections.EMPTY_LIST;
Collection<String> identifiers = connectionMapper.selectIdentifiersWithin(connectionGroup.getIdentifier());
if (identifiers.isEmpty())
return Collections.EMPTY_LIST;
Collection<ConnectionModel> models = connectionMapper.select(identifiers);
List<ModeledConnection> connections = new ArrayList<ModeledConnection>(models.size());
for (ConnectionModel model : models) {
ModeledConnection connection = connectionProvider.get();
connection.init(user, model);
connections.add(connection);
}
return connections;
}
return getGuacamoleSocket(new ActiveConnectionRecord(user, connection), info);
List<ModeledConnection> connections = getBalancedConnections(user, connectionGroup);
if (connections.isEmpty())
return getGuacamoleSocket(new ActiveConnectionRecord(user, connectionGroup, connection), info);
import org.glyptodon.guacamole.auth.jdbc.connection.ModeledConnection;
import org.glyptodon.guacamole.auth.jdbc.connectiongroup.ModeledConnectionGroup;
private final ModeledConnectionGroup balancingGroup;
private final ModeledConnection connection;
public ActiveConnectionRecord(AuthenticatedUser user,
ModeledConnectionGroup balancingGroup,
ModeledConnection connection) {
this.balancingGroup = balancingGroup;
this.connection = connection;
}
public ActiveConnectionRecord(AuthenticatedUser user,
ModeledConnection connection) {
this(user, null, connection);
public ModeledConnectionGroup getBalancingGroup() {
return balancingGroup;
}
public ModeledConnection getConnection() {
return connection;
}
public boolean hasBalancingGroup() {
return balancingGroup != null;
}
if (canReadPermissions(user, targetUser)) {
if (canReadPermissions(user, targetUser)) {
if (user.getUser().isAdministrator())
import org.glyptodon.guacamole.net.auth.permission.ObjectPermission;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermissionSet;
protected boolean canReadPermissions(AuthenticatedUser user,
ModeledUser targetUser) throws GuacamoleException {
if (user.getUser().getIdentifier().equals(targetUser.getIdentifier()))
return true;
if (user.getUser().isAdministrator())
return true;
ObjectPermissionSet userPermissionSet = user.getUser().getUserPermissions();
return userPermissionSet.hasPermission(ObjectPermission.Type.READ, targetUser.getIdentifier());
}
if (canReadPermissions(user, targetUser))
if (canReadPermissions(user, targetUser)) {
if (canReadPermissions(user, targetUser)) {
if (user.getUser().isAdministrator())
import org.glyptodon.guacamole.net.auth.permission.ObjectPermission;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermissionSet;
protected boolean canReadPermissions(AuthenticatedUser user,
ModeledUser targetUser) throws GuacamoleException {
if (user.getUser().getIdentifier().equals(targetUser.getIdentifier()))
return true;
if (user.getUser().isAdministrator())
return true;
ObjectPermissionSet userPermissionSet = user.getUser().getUserPermissions();
return userPermissionSet.hasPermission(ObjectPermission.Type.READ, targetUser.getIdentifier());
}
if (canReadPermissions(user, targetUser))
protected abstract void acquire(AuthenticatedUser user,
ModeledConnectionGroup connectionGroup) throws GuacamoleException;
protected abstract void release(AuthenticatedUser user,
ModeledConnectionGroup connectionGroup);
private void saveConnectionRecord(ActiveConnectionRecord record) {
ModeledConnection connection = record.getConnection();
recordModel.setConnectionIdentifier(connection.getIdentifier());
private GuacamoleSocket getUnconfiguredGuacamoleSocket(Runnable socketClosedCallback)
return new ManagedInetGuacamoleSocket(
environment.getRequiredProperty(Environment.GUACD_PORT),
socketClosedCallback
return new ManagedInetGuacamoleSocket(
environment.getRequiredProperty(Environment.GUACD_PORT),
socketClosedCallback
private class ConnectionCleanupTask implements Runnable {
private final AtomicBoolean hasRun = new AtomicBoolean(false);
private final ActiveConnectionRecord activeConnection;
public ConnectionCleanupTask(ActiveConnectionRecord activeConnection) {
this.activeConnection = activeConnection;
}
@Override
public void run() {
if (!hasRun.compareAndSet(false, true))
return;
AuthenticatedUser user = activeConnection.getUser();
ModeledConnection connection = activeConnection.getConnection();
String identifier = connection.getIdentifier();
String parentIdentifier = connection.getParentIdentifier();
activeConnections.remove(identifier, activeConnection);
activeConnectionGroups.remove(parentIdentifier, activeConnection);
release(user, connection);
if (activeConnection.hasBalancingGroup())
release(user, activeConnection.getBalancingGroup());
saveConnectionRecord(activeConnection);
}
}
private GuacamoleSocket getGuacamoleSocket(ActiveConnectionRecord activeConnection,
GuacamoleClientInformation info)
ModeledConnection connection = activeConnection.getConnection();
Runnable cleanupTask = new ConnectionCleanupTask(activeConnection);
activeConnections.put(connection.getIdentifier(), activeConnection);
activeConnectionGroups.put(connection.getParentIdentifier(), activeConnection);
getUnconfiguredGuacamoleSocket(cleanupTask),
getGuacamoleConfiguration(activeConnection.getUser(), connection),
);
cleanupTask.run();
private List<ModeledConnection> getBalancedConnections(AuthenticatedUser user,
ModeledConnectionGroup connectionGroup) {
if (connectionGroup.getType() != ConnectionGroup.Type.BALANCING)
return Collections.EMPTY_LIST;
Collection<String> identifiers = connectionMapper.selectIdentifiersWithin(connectionGroup.getIdentifier());
if (identifiers.isEmpty())
return Collections.EMPTY_LIST;
Collection<ConnectionModel> models = connectionMapper.select(identifiers);
List<ModeledConnection> connections = new ArrayList<ModeledConnection>(models.size());
for (ConnectionModel model : models) {
ModeledConnection connection = connectionProvider.get();
connection.init(user, model);
connections.add(connection);
}
return connections;
}
return getGuacamoleSocket(new ActiveConnectionRecord(user, connection), info);
List<ModeledConnection> connections = getBalancedConnections(user, connectionGroup);
if (connections.isEmpty())
acquire(user, connectionGroup);
return getGuacamoleSocket(new ActiveConnectionRecord(user, connectionGroup, connection), info);
import org.glyptodon.guacamole.auth.jdbc.connection.ModeledConnection;
import org.glyptodon.guacamole.auth.jdbc.connectiongroup.ModeledConnectionGroup;
private final ModeledConnectionGroup balancingGroup;
private final ModeledConnection connection;
public ActiveConnectionRecord(AuthenticatedUser user,
ModeledConnectionGroup balancingGroup,
ModeledConnection connection) {
this.balancingGroup = balancingGroup;
this.connection = connection;
}
public ActiveConnectionRecord(AuthenticatedUser user,
ModeledConnection connection) {
this(user, null, connection);
public ModeledConnectionGroup getBalancingGroup() {
return balancingGroup;
}
public ModeledConnection getConnection() {
return connection;
}
public boolean hasBalancingGroup() {
return balancingGroup != null;
}
import java.util.Arrays;
import java.util.Comparator;
import org.glyptodon.guacamole.GuacamoleClientTooManyException;
import org.glyptodon.guacamole.auth.jdbc.connectiongroup.ModeledConnectionGroup;
private final Set<Seat> activeGroupSeats =
Collections.newSetFromMap(new ConcurrentHashMap<Seat, Boolean>());
ModeledConnection[] sortedConnections = connections.toArray(new ModeledConnection[connections.size()]);
Arrays.sort(sortedConnections, new Comparator<ModeledConnection>() {
@Override
public int compare(ModeledConnection a, ModeledConnection b) {
return getActiveConnections(a).size()
- getActiveConnections(b).size();
}
});
for (ModeledConnection connection : sortedConnections) {
@Override
protected void acquire(AuthenticatedUser user,
ModeledConnectionGroup connectionGroup) throws GuacamoleException {
Seat seat = new Seat(user.getUser().getIdentifier(), connectionGroup.getIdentifier());
if (!activeGroupSeats.add(seat))
throw new GuacamoleClientTooManyException("Cannot connect. Connection group already in use by this user.");
}
@Override
protected void release(AuthenticatedUser user,
ModeledConnectionGroup connectionGroup) {
activeGroupSeats.remove(new Seat(user.getUser().getIdentifier(), connectionGroup.getIdentifier()));
}
import org.glyptodon.guacamole.GuacamoleClientTooManyException;
import org.glyptodon.guacamole.auth.jdbc.connectiongroup.ModeledConnectionGroup;
private final Set<Seat> activeGroupSeats =
Collections.newSetFromMap(new ConcurrentHashMap<Seat, Boolean>());
@Override
protected void acquire(AuthenticatedUser user,
ModeledConnectionGroup connectionGroup) throws GuacamoleException {
Seat seat = new Seat(user.getUser().getIdentifier(), connectionGroup.getIdentifier());
if (!activeGroupSeats.add(seat))
throw new GuacamoleClientTooManyException("Cannot connect. Connection group already in use by this user.");
}
@Override
protected void release(AuthenticatedUser user,
ModeledConnectionGroup connectionGroup) {
activeGroupSeats.remove(new Seat(user.getUser().getIdentifier(), connectionGroup.getIdentifier()));
}
import org.glyptodon.guacamole.auth.jdbc.connectiongroup.ModeledConnectionGroup;
@Override
protected void acquire(AuthenticatedUser user,
ModeledConnectionGroup connectionGroup) throws GuacamoleException {
}
@Override
protected void release(AuthenticatedUser user,
ModeledConnectionGroup connectionGroup) {
}
import org.glyptodon.guacamole.auth.jdbc.socket.BalancedGuacamoleSocketService;
return BalancedGuacamoleSocketService.class;
if (salt != null)
builder.append(DatatypeConverter.printHexBinary(salt));
catch (UnsupportedEncodingException e) {
throw new UnsupportedOperationException("Unexpected lack of UTF-8 support.", e);
catch (NoSuchAlgorithmException e) {
throw new UnsupportedOperationException("Unexpected lack of SHA-256 support.", e);
if (salt != null)
builder.append(DatatypeConverter.printHexBinary(salt));
catch (UnsupportedEncodingException e) {
throw new UnsupportedOperationException("Unexpected lack of UTF-8 support.", e);
catch (NoSuchAlgorithmException e) {
throw new UnsupportedOperationException("Unexpected lack of SHA-256 support.", e);
import org.glyptodon.guacamole.auth.jdbc.base.GroupedObjectModel;
public class ConnectionModel extends GroupedObjectModel {
import org.glyptodon.guacamole.auth.jdbc.base.GroupedDirectoryObject;
public class ModeledConnection extends GroupedDirectoryObject<ConnectionModel>
import org.glyptodon.guacamole.auth.jdbc.base.GroupedObjectModel;
public class ConnectionGroupModel extends GroupedObjectModel {
import org.glyptodon.guacamole.auth.jdbc.base.GroupedDirectoryObject;
public class ModeledConnectionGroup extends GroupedDirectoryObject<ConnectionGroupModel>
protected void beforeCreate(AuthenticatedUser user,
ModelType model ) throws GuacamoleException {
if (!user.getUser().isAdministrator() && !hasCreatePermission(user))
throw new GuacamoleSecurityException("Permission denied.");
protected void beforeUpdate(AuthenticatedUser user,
if (!hasObjectPermission(user, model.getIdentifier(), ObjectPermission.Type.UPDATE))
throw new GuacamoleSecurityException("Permission denied.");
}
protected void beforeDelete(AuthenticatedUser user,
String identifier) throws GuacamoleException {
if (!hasObjectPermission(user, identifier, ObjectPermission.Type.DELETE))
throw new GuacamoleSecurityException("Permission denied.");
ModelType model = getModelInstance(user, object);
beforeCreate(user, model);
getObjectMapper().insert(model);
Collection<ObjectPermissionModel> implicitPermissions =
new ArrayList<ObjectPermissionModel>(IMPLICIT_OBJECT_PERMISSIONS.length);
UserModel userModel = user.getUser().getModel();
for (ObjectPermission.Type permission : IMPLICIT_OBJECT_PERMISSIONS) {
ObjectPermissionModel permissionModel = new ObjectPermissionModel();
permissionModel.setUserID(userModel.getObjectID());
permissionModel.setUsername(userModel.getIdentifier());
permissionModel.setType(permission);
permissionModel.setObjectIdentifier(model.getIdentifier());
implicitPermissions.add(permissionModel);
getPermissionMapper().insert(implicitPermissions);
return getObjectInstance(user, model);
beforeDelete(user, identifier);
getObjectMapper().delete(identifier);
ModelType model = object.getModel();
beforeUpdate(user, model);
getObjectMapper().update(model);
import org.glyptodon.guacamole.auth.jdbc.base.GroupedDirectoryObjectService;
public class ConnectionService extends GroupedDirectoryObjectService<ModeledConnection, Connection, ConnectionModel> {
protected void beforeCreate(AuthenticatedUser user,
super.beforeCreate(user, model);
protected void beforeUpdate(AuthenticatedUser user,
super.beforeUpdate(user, model);
import org.glyptodon.guacamole.auth.jdbc.base.GroupedDirectoryObjectService;
public class ConnectionGroupService extends GroupedDirectoryObjectService<ModeledConnectionGroup,
protected void beforeCreate(AuthenticatedUser user,
super.beforeCreate(user, model);
protected void beforeUpdate(AuthenticatedUser user,
super.beforeUpdate(user, model);
protected void beforeCreate(AuthenticatedUser user, UserModel model)
super.beforeCreate(user, model);
protected void beforeUpdate(AuthenticatedUser user,
super.beforeUpdate(user, model);
protected void beforeCreate(AuthenticatedUser user,
ModelType model ) throws GuacamoleException {
if (!user.getUser().isAdministrator() && !hasCreatePermission(user))
throw new GuacamoleSecurityException("Permission denied.");
protected void beforeUpdate(AuthenticatedUser user,
if (!hasObjectPermission(user, model.getIdentifier(), ObjectPermission.Type.UPDATE))
throw new GuacamoleSecurityException("Permission denied.");
}
protected void beforeDelete(AuthenticatedUser user,
String identifier) throws GuacamoleException {
if (!hasObjectPermission(user, identifier, ObjectPermission.Type.DELETE))
throw new GuacamoleSecurityException("Permission denied.");
ModelType model = getModelInstance(user, object);
beforeCreate(user, model);
getObjectMapper().insert(model);
Collection<ObjectPermissionModel> implicitPermissions =
new ArrayList<ObjectPermissionModel>(IMPLICIT_OBJECT_PERMISSIONS.length);
UserModel userModel = user.getUser().getModel();
for (ObjectPermission.Type permission : IMPLICIT_OBJECT_PERMISSIONS) {
ObjectPermissionModel permissionModel = new ObjectPermissionModel();
permissionModel.setUserID(userModel.getObjectID());
permissionModel.setUsername(userModel.getIdentifier());
permissionModel.setType(permission);
permissionModel.setObjectIdentifier(model.getIdentifier());
implicitPermissions.add(permissionModel);
getPermissionMapper().insert(implicitPermissions);
return getObjectInstance(user, model);
beforeDelete(user, identifier);
getObjectMapper().delete(identifier);
ModelType model = object.getModel();
beforeUpdate(user, model);
getObjectMapper().update(model);
import org.glyptodon.guacamole.auth.jdbc.base.GroupedObjectModel;
public class ConnectionModel extends GroupedObjectModel {
import org.glyptodon.guacamole.auth.jdbc.base.GroupedDirectoryObjectService;
public class ConnectionService extends GroupedDirectoryObjectService<ModeledConnection, Connection, ConnectionModel> {
protected void beforeCreate(AuthenticatedUser user,
super.beforeCreate(user, model);
protected void beforeUpdate(AuthenticatedUser user,
super.beforeUpdate(user, model);
import org.glyptodon.guacamole.auth.jdbc.base.GroupedDirectoryObject;
public class ModeledConnection extends GroupedDirectoryObject<ConnectionModel>
import org.glyptodon.guacamole.auth.jdbc.base.GroupedObjectModel;
public class ConnectionGroupModel extends GroupedObjectModel {
import org.glyptodon.guacamole.auth.jdbc.base.GroupedDirectoryObjectService;
public class ConnectionGroupService extends GroupedDirectoryObjectService<ModeledConnectionGroup,
protected void beforeCreate(AuthenticatedUser user,
super.beforeCreate(user, model);
protected void beforeUpdate(AuthenticatedUser user,
super.beforeUpdate(user, model);
import org.glyptodon.guacamole.auth.jdbc.base.GroupedDirectoryObject;
public class ModeledConnectionGroup extends GroupedDirectoryObject<ConnectionGroupModel>
protected void beforeCreate(AuthenticatedUser user, UserModel model)
super.beforeCreate(user, model);
protected void beforeUpdate(AuthenticatedUser user,
super.beforeUpdate(user, model);
import org.glyptodon.guacamole.GuacamoleUnsupportedException;
@Override
protected void beforeDelete(AuthenticatedUser user, String identifier) throws GuacamoleException {
super.beforeDelete(user, identifier);
if (identifier.equals(user.getUser().getIdentifier()))
throw new GuacamoleUnsupportedException("Deleting your own user is not allowed.");
}
import org.glyptodon.guacamole.GuacamoleUnsupportedException;
if (user.getUser().getIdentifier().equals(targetUser.getIdentifier()))
throw new GuacamoleUnsupportedException("Removing your own administrative permissions is not allowed.");
import org.glyptodon.guacamole.GuacamoleUnsupportedException;
if (user.getUser().getIdentifier().equals(targetUser.getIdentifier()))
throw new GuacamoleUnsupportedException("Removing your own administrative permissions is not allowed.");
import org.glyptodon.guacamole.GuacamoleUnsupportedException;
@Override
protected void beforeDelete(AuthenticatedUser user, String identifier) throws GuacamoleException {
super.beforeDelete(user, identifier);
if (identifier.equals(user.getUser().getIdentifier()))
throw new GuacamoleUnsupportedException("Deleting your own user is not allowed.");
}
import org.glyptodon.guacamole.GuacamoleUnsupportedException;
String relativeParentIdentifier = model.getParentIdentifier();
while (relativeParentIdentifier != null) {
if (relativeParentIdentifier.equals(model.getIdentifier()))
throw new GuacamoleUnsupportedException("A connection group may not contain itself.");
ModeledConnectionGroup relativeParentGroup = retrieveObject(user, relativeParentIdentifier);
relativeParentIdentifier = relativeParentGroup.getModel().getParentIdentifier();
}
import org.glyptodon.guacamole.GuacamoleUnsupportedException;
String relativeParentIdentifier = model.getParentIdentifier();
while (relativeParentIdentifier != null) {
if (relativeParentIdentifier.equals(model.getIdentifier()))
throw new GuacamoleUnsupportedException("A connection group may not contain itself.");
ModeledConnectionGroup relativeParentGroup = retrieveObject(user, relativeParentIdentifier);
relativeParentIdentifier = relativeParentGroup.getModel().getParentIdentifier();
}
protected void beforeCreate(AuthenticatedUser user,
ModelType model ) throws GuacamoleException {
if (!user.getUser().isAdministrator() && !hasCreatePermission(user))
throw new GuacamoleSecurityException("Permission denied.");
protected void beforeUpdate(AuthenticatedUser user,
if (!hasObjectPermission(user, model.getIdentifier(), ObjectPermission.Type.UPDATE))
throw new GuacamoleSecurityException("Permission denied.");
}
protected void beforeDelete(AuthenticatedUser user,
String identifier) throws GuacamoleException {
if (!hasObjectPermission(user, identifier, ObjectPermission.Type.DELETE))
throw new GuacamoleSecurityException("Permission denied.");
ModelType model = getModelInstance(user, object);
beforeCreate(user, model);
getObjectMapper().insert(model);
getPermissionMapper().insert(getImplicitPermissions(user, model));
return getObjectInstance(user, model);
beforeDelete(user, identifier);
getObjectMapper().delete(identifier);
ModelType model = object.getModel();
beforeUpdate(user, model);
getObjectMapper().update(model);
import org.glyptodon.guacamole.auth.jdbc.base.GroupedObjectModel;
public class ConnectionModel extends GroupedObjectModel {
import org.glyptodon.guacamole.auth.jdbc.base.GroupedDirectoryObjectService;
public class ConnectionService extends GroupedDirectoryObjectService<ModeledConnection, Connection, ConnectionModel> {
protected void beforeCreate(AuthenticatedUser user,
super.beforeCreate(user, model);
protected void beforeUpdate(AuthenticatedUser user,
super.beforeUpdate(user, model);
import org.glyptodon.guacamole.auth.jdbc.base.GroupedDirectoryObject;
public class ModeledConnection extends GroupedDirectoryObject<ConnectionModel>
import org.glyptodon.guacamole.auth.jdbc.base.GroupedObjectModel;
public class ConnectionGroupModel extends GroupedObjectModel {
import org.glyptodon.guacamole.GuacamoleUnsupportedException;
import org.glyptodon.guacamole.auth.jdbc.base.GroupedDirectoryObjectService;
public class ConnectionGroupService extends GroupedDirectoryObjectService<ModeledConnectionGroup,
protected void beforeCreate(AuthenticatedUser user,
super.beforeCreate(user, model);
protected void beforeUpdate(AuthenticatedUser user,
super.beforeUpdate(user, model);
String relativeParentIdentifier = model.getParentIdentifier();
while (relativeParentIdentifier != null) {
if (relativeParentIdentifier.equals(model.getIdentifier()))
throw new GuacamoleUnsupportedException("A connection group may not contain itself.");
ModeledConnectionGroup relativeParentGroup = retrieveObject(user, relativeParentIdentifier);
relativeParentIdentifier = relativeParentGroup.getModel().getParentIdentifier();
}
import org.glyptodon.guacamole.auth.jdbc.base.GroupedDirectoryObject;
public class ModeledConnectionGroup extends GroupedDirectoryObject<ConnectionGroupModel>
if (canReadPermissions(user, targetUser)) {
if (canReadPermissions(user, targetUser)) {
if (user.getUser().isAdministrator())
import org.glyptodon.guacamole.net.auth.permission.ObjectPermission;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermissionSet;
protected boolean canReadPermissions(AuthenticatedUser user,
ModeledUser targetUser) throws GuacamoleException {
if (user.getUser().getIdentifier().equals(targetUser.getIdentifier()))
return true;
if (user.getUser().isAdministrator())
return true;
ObjectPermissionSet userPermissionSet = user.getUser().getUserPermissions();
return userPermissionSet.hasPermission(ObjectPermission.Type.READ, targetUser.getIdentifier());
}
if (canReadPermissions(user, targetUser))
import org.glyptodon.guacamole.GuacamoleUnsupportedException;
if (user.getUser().getIdentifier().equals(targetUser.getIdentifier()))
throw new GuacamoleUnsupportedException("Removing your own administrative permissions is not allowed.");
if (salt != null)
builder.append(DatatypeConverter.printHexBinary(salt));
catch (UnsupportedEncodingException e) {
throw new UnsupportedOperationException("Unexpected lack of UTF-8 support.", e);
catch (NoSuchAlgorithmException e) {
throw new UnsupportedOperationException("Unexpected lack of SHA-256 support.", e);
protected abstract void acquire(AuthenticatedUser user,
ModeledConnectionGroup connectionGroup) throws GuacamoleException;
protected abstract void release(AuthenticatedUser user,
ModeledConnectionGroup connectionGroup);
private void saveConnectionRecord(ActiveConnectionRecord record) {
ModeledConnection connection = record.getConnection();
recordModel.setConnectionIdentifier(connection.getIdentifier());
private GuacamoleSocket getUnconfiguredGuacamoleSocket(Runnable socketClosedCallback)
return new ManagedInetGuacamoleSocket(
environment.getRequiredProperty(Environment.GUACD_PORT),
socketClosedCallback
return new ManagedInetGuacamoleSocket(
environment.getRequiredProperty(Environment.GUACD_PORT),
socketClosedCallback
private class ConnectionCleanupTask implements Runnable {
private final AtomicBoolean hasRun = new AtomicBoolean(false);
private final ActiveConnectionRecord activeConnection;
public ConnectionCleanupTask(ActiveConnectionRecord activeConnection) {
this.activeConnection = activeConnection;
}
@Override
public void run() {
if (!hasRun.compareAndSet(false, true))
return;
AuthenticatedUser user = activeConnection.getUser();
ModeledConnection connection = activeConnection.getConnection();
String identifier = connection.getIdentifier();
String parentIdentifier = connection.getParentIdentifier();
activeConnections.remove(identifier, activeConnection);
activeConnectionGroups.remove(parentIdentifier, activeConnection);
release(user, connection);
if (activeConnection.hasBalancingGroup())
release(user, activeConnection.getBalancingGroup());
saveConnectionRecord(activeConnection);
}
}
private GuacamoleSocket getGuacamoleSocket(ActiveConnectionRecord activeConnection,
GuacamoleClientInformation info)
ModeledConnection connection = activeConnection.getConnection();
Runnable cleanupTask = new ConnectionCleanupTask(activeConnection);
activeConnections.put(connection.getIdentifier(), activeConnection);
activeConnectionGroups.put(connection.getParentIdentifier(), activeConnection);
getUnconfiguredGuacamoleSocket(cleanupTask),
getGuacamoleConfiguration(activeConnection.getUser(), connection),
);
cleanupTask.run();
private List<ModeledConnection> getBalancedConnections(AuthenticatedUser user,
ModeledConnectionGroup connectionGroup) {
if (connectionGroup.getType() != ConnectionGroup.Type.BALANCING)
return Collections.EMPTY_LIST;
Collection<String> identifiers = connectionMapper.selectIdentifiersWithin(connectionGroup.getIdentifier());
if (identifiers.isEmpty())
return Collections.EMPTY_LIST;
Collection<ConnectionModel> models = connectionMapper.select(identifiers);
List<ModeledConnection> connections = new ArrayList<ModeledConnection>(models.size());
for (ConnectionModel model : models) {
ModeledConnection connection = connectionProvider.get();
connection.init(user, model);
connections.add(connection);
}
return connections;
}
return getGuacamoleSocket(new ActiveConnectionRecord(user, connection), info);
List<ModeledConnection> connections = getBalancedConnections(user, connectionGroup);
if (connections.isEmpty())
acquire(user, connectionGroup);
return getGuacamoleSocket(new ActiveConnectionRecord(user, connectionGroup, connection), info);
import org.glyptodon.guacamole.auth.jdbc.connection.ModeledConnection;
import org.glyptodon.guacamole.auth.jdbc.connectiongroup.ModeledConnectionGroup;
private final ModeledConnectionGroup balancingGroup;
private final ModeledConnection connection;
public ActiveConnectionRecord(AuthenticatedUser user,
ModeledConnectionGroup balancingGroup,
ModeledConnection connection) {
this.balancingGroup = balancingGroup;
this.connection = connection;
}
public ActiveConnectionRecord(AuthenticatedUser user,
ModeledConnection connection) {
this(user, null, connection);
public ModeledConnectionGroup getBalancingGroup() {
return balancingGroup;
}
public ModeledConnection getConnection() {
return connection;
}
public boolean hasBalancingGroup() {
return balancingGroup != null;
}
import java.util.Arrays;
import java.util.Comparator;
import org.glyptodon.guacamole.GuacamoleClientTooManyException;
import org.glyptodon.guacamole.auth.jdbc.connectiongroup.ModeledConnectionGroup;
private final Set<Seat> activeGroupSeats =
Collections.newSetFromMap(new ConcurrentHashMap<Seat, Boolean>());
ModeledConnection[] sortedConnections = connections.toArray(new ModeledConnection[connections.size()]);
Arrays.sort(sortedConnections, new Comparator<ModeledConnection>() {
@Override
public int compare(ModeledConnection a, ModeledConnection b) {
return getActiveConnections(a).size()
- getActiveConnections(b).size();
}
});
for (ModeledConnection connection : sortedConnections) {
@Override
protected void acquire(AuthenticatedUser user,
ModeledConnectionGroup connectionGroup) throws GuacamoleException {
Seat seat = new Seat(user.getUser().getIdentifier(), connectionGroup.getIdentifier());
if (!activeGroupSeats.add(seat))
throw new GuacamoleClientTooManyException("Cannot connect. Connection group already in use by this user.");
}
@Override
protected void release(AuthenticatedUser user,
ModeledConnectionGroup connectionGroup) {
activeGroupSeats.remove(new Seat(user.getUser().getIdentifier(), connectionGroup.getIdentifier()));
}
import org.glyptodon.guacamole.GuacamoleClientTooManyException;
import org.glyptodon.guacamole.auth.jdbc.connectiongroup.ModeledConnectionGroup;
private final Set<Seat> activeGroupSeats =
Collections.newSetFromMap(new ConcurrentHashMap<Seat, Boolean>());
@Override
protected void acquire(AuthenticatedUser user,
ModeledConnectionGroup connectionGroup) throws GuacamoleException {
Seat seat = new Seat(user.getUser().getIdentifier(), connectionGroup.getIdentifier());
if (!activeGroupSeats.add(seat))
throw new GuacamoleClientTooManyException("Cannot connect. Connection group already in use by this user.");
}
@Override
protected void release(AuthenticatedUser user,
ModeledConnectionGroup connectionGroup) {
activeGroupSeats.remove(new Seat(user.getUser().getIdentifier(), connectionGroup.getIdentifier()));
}
import org.glyptodon.guacamole.auth.jdbc.connectiongroup.ModeledConnectionGroup;
@Override
protected void acquire(AuthenticatedUser user,
ModeledConnectionGroup connectionGroup) throws GuacamoleException {
}
@Override
protected void release(AuthenticatedUser user,
ModeledConnectionGroup connectionGroup) {
}
import org.glyptodon.guacamole.GuacamoleUnsupportedException;
protected void beforeCreate(AuthenticatedUser user, UserModel model)
super.beforeCreate(user, model);
protected void beforeUpdate(AuthenticatedUser user,
super.beforeUpdate(user, model);
}
@Override
protected void beforeDelete(AuthenticatedUser user, String identifier) throws GuacamoleException {
super.beforeDelete(user, identifier);
if (identifier.equals(user.getUser().getIdentifier()))
throw new GuacamoleUnsupportedException("Deleting your own user is not allowed.");
import org.glyptodon.guacamole.auth.jdbc.socket.BalancedGuacamoleSocketService;
return BalancedGuacamoleSocketService.class;
import javax.servlet.http.HttpServletRequest;
import javax.ws.rs.core.Context;
import org.glyptodon.guacamole.net.auth.AuthenticationProvider;
import org.glyptodon.guacamole.net.auth.Credentials;
@Inject
private AuthenticationProvider authProvider;
if (userContext.self().getIdentifier().equals(user.getUsername())) {
throw new HTTPException(Response.Status.FORBIDDEN,
"Permission denied.");
}
@PUT
@Path("/{username}/password")
@AuthProviderRESTExposure
public void updatePassword(@QueryParam("token") String authToken,
@PathParam("username") String username,
APIUserPasswordUpdate userPasswordUpdate,
@Context HttpServletRequest request) throws GuacamoleException {
UserContext userContext = authenticationService.getUserContext(authToken);
Credentials credentials = new Credentials();
credentials.setUsername(username);
credentials.setPassword(userPasswordUpdate.getOldPassword());
credentials.setRequest(request);
credentials.setSession(request.getSession(true));
if (authProvider.getUserContext(credentials) == null) {
throw new HTTPException(Response.Status.FORBIDDEN,
"Permission denied.");
}
Directory<User> userDirectory = userContext.getUserDirectory();
User user = retrievalService.retrieveUser(userContext, username);
user.setPassword(userPasswordUpdate.getNewPassword());
userDirectory.update(user);
}
protected Collection<ObjectPermissionModel> getImplicitPermissions(AuthenticatedUser user,
ModelType model) {
Collection<ObjectPermissionModel> implicitPermissions =
new ArrayList<ObjectPermissionModel>(IMPLICIT_OBJECT_PERMISSIONS.length);
UserModel userModel = user.getUser().getModel();
for (ObjectPermission.Type permission : IMPLICIT_OBJECT_PERMISSIONS) {
ObjectPermissionModel permissionModel = new ObjectPermissionModel();
permissionModel.setUserID(userModel.getObjectID());
permissionModel.setUsername(userModel.getIdentifier());
permissionModel.setType(permission);
permissionModel.setObjectIdentifier(model.getIdentifier());
implicitPermissions.add(permissionModel);
}
return implicitPermissions;
}
getPermissionMapper().insert(getImplicitPermissions(user, model));
import org.glyptodon.guacamole.auth.jdbc.permission.ObjectPermissionModel;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermission;
private static final ObjectPermission.Type[] IMPLICIT_USER_PERMISSIONS = {
ObjectPermission.Type.READ,
ObjectPermission.Type.UPDATE
};
protected Collection<ObjectPermissionModel>
getImplicitPermissions(AuthenticatedUser user, UserModel model) {
Collection<ObjectPermissionModel> implicitPermissions = super.getImplicitPermissions(user, model);
for (ObjectPermission.Type permissionType : IMPLICIT_USER_PERMISSIONS) {
ObjectPermissionModel permissionModel = new ObjectPermissionModel();
permissionModel.setUserID(model.getObjectID());
permissionModel.setUsername(model.getIdentifier());
permissionModel.setType(permissionType);
permissionModel.setObjectIdentifier(model.getIdentifier());
implicitPermissions.add(permissionModel);
}
return implicitPermissions;
}
@Override
import javax.servlet.http.HttpServletRequest;
import javax.ws.rs.core.Context;
import org.glyptodon.guacamole.net.auth.AuthenticationProvider;
import org.glyptodon.guacamole.net.auth.Credentials;
@Inject
private AuthenticationProvider authProvider;
if (userContext.self().getIdentifier().equals(user.getUsername())) {
throw new HTTPException(Response.Status.FORBIDDEN,
"Permission denied.");
}
@PUT
@Path("/{username}/password")
@AuthProviderRESTExposure
public void updatePassword(@QueryParam("token") String authToken,
@PathParam("username") String username,
APIUserPasswordUpdate userPasswordUpdate,
@Context HttpServletRequest request) throws GuacamoleException {
UserContext userContext = authenticationService.getUserContext(authToken);
Credentials credentials = new Credentials();
credentials.setUsername(username);
credentials.setPassword(userPasswordUpdate.getOldPassword());
credentials.setRequest(request);
credentials.setSession(request.getSession(true));
if (authProvider.getUserContext(credentials) == null) {
throw new HTTPException(Response.Status.FORBIDDEN,
"Permission denied.");
}
Directory<User> userDirectory = userContext.getUserDirectory();
User user = retrievalService.retrieveUser(userContext, username);
user.setPassword(userPasswordUpdate.getNewPassword());
userDirectory.update(user);
}
import java.util.ArrayList;
public List<APIConnectionRecord> getConnectionHistory(@QueryParam("token") String authToken,
List<APIConnectionRecord> apiRecords = new ArrayList<APIConnectionRecord>();
for (ConnectionRecord record : connection.getHistory())
apiRecords.add(new APIConnectionRecord(record));
return apiRecords;
import java.util.ArrayList;
public List<APIConnectionRecord> getConnectionHistory(@QueryParam("token") String authToken,
List<APIConnectionRecord> apiRecords = new ArrayList<APIConnectionRecord>();
for (ConnectionRecord record : connection.getHistory())
apiRecords.add(new APIConnectionRecord(record));
return apiRecords;
import org.glyptodon.guacamole.net.GuacamoleSocket;
public String getRemoteHost() {
return "STUB";
}
@Override
@Override
public GuacamoleSocket getActiveSocket() {
return null;
}
import org.glyptodon.guacamole.net.GuacamoleSocket;
public String getRemoteHost() {
return "STUB";
}
@Override
@Override
public GuacamoleSocket getActiveSocket() {
return null;
}
import java.util.Collection;
import java.util.Collections;
import org.glyptodon.guacamole.net.auth.ConnectionRecord;
@Override
public Collection<ConnectionRecord> getActiveConnections() throws GuacamoleException {
return Collections.EMPTY_LIST;
}
import org.glyptodon.guacamole.net.GuacamoleSocket;
public String getRemoteHost();
public GuacamoleSocket getActiveSocket();
import java.util.Collection;
Collection<ConnectionRecord> getActiveConnections()
throws GuacamoleException;
import org.glyptodon.guacamole.net.auth.ConnectionRecord;
@Override
public Collection<ConnectionRecord> getActiveConnections()
throws GuacamoleException {
return Collections.EMPTY_LIST;
}
private final String remoteHost;
this.startDate  = record.getStartDate();
this.endDate    = record.getEndDate();
this.remoteHost = record.getRemoteHost();
this.username   = record.getUsername();
this.active     = record.isActive();
public String getRemoteHost() {
return remoteHost;
}
import org.glyptodon.guacamole.net.basic.rest.tunnel.TunnelRESTService;
bind(TunnelRESTService.class);
public String getIdentifier() {
return model.getConnectionIdentifier();
}
@Override
@Override
public String getIdentifier() {
return connection.getIdentifier();
}
public String getIdentifier();
private final String identifier;
this.identifier = record.getIdentifier();
public String getIdentifier() {
return identifier;
}
connections = Collections.synchronizedSet(Collections.newSetFromMap(new LinkedHashMap<ConnectionRecord, Boolean>()));
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
private final Set<ConnectionRecord> activeConnectionRecords =
Collections.newSetFromMap(new ConcurrentHashMap<ConnectionRecord, Boolean>());
activeConnectionRecords.remove(activeConnection);
activeConnectionRecords.add(activeConnection);
public Collection<ConnectionRecord> getActiveConnections(AuthenticatedUser user)
throws GuacamoleException {
if (!user.getUser().isAdministrator())
return Collections.EMPTY_LIST;
return Collections.unmodifiableCollection(activeConnectionRecords);
}
@Override
public Collection<ConnectionRecord> getActiveConnections(AuthenticatedUser user)
throws GuacamoleException;
import org.glyptodon.guacamole.auth.jdbc.socket.GuacamoleSocketService;
@Inject
private GuacamoleSocketService socketService;
return socketService.getActiveConnections(getCurrentUser());
private GuacamoleSocket assignGuacamoleSocket(ActiveConnectionRecord activeConnection,
GuacamoleSocket socket = new ConfiguredGuacamoleSocket(
activeConnection.setActiveSocket(socket);
return socket;
return assignGuacamoleSocket(new ActiveConnectionRecord(user, connection), info);
return assignGuacamoleSocket(new ActiveConnectionRecord(user, connectionGroup, connection), info);
private GuacamoleSocket socket;
return socket;
}
public void setActiveSocket(GuacamoleSocket socket) {
this.socket = socket;
public GuacamoleSocket getSocket() {
activeConnection.setSocket(socket);
public GuacamoleSocket getSocket() {
public void setSocket(GuacamoleSocket socket) {
public GuacamoleSocket getSocket();
import org.glyptodon.guacamole.net.GuacamoleTunnel;
public GuacamoleTunnel connect(AuthenticatedUser user,
return socketService.getGuacamoleTunnel(user, connection, info);
import org.glyptodon.guacamole.net.GuacamoleTunnel;
public GuacamoleTunnel connect(GuacamoleClientInformation info) throws GuacamoleException {
import org.glyptodon.guacamole.net.GuacamoleTunnel;
public GuacamoleTunnel getTunnel() {
import org.glyptodon.guacamole.net.GuacamoleTunnel;
public GuacamoleTunnel connect(AuthenticatedUser user,
return socketService.getGuacamoleTunnel(user, connectionGroup, info);
import org.glyptodon.guacamole.net.GuacamoleTunnel;
public GuacamoleTunnel connect(GuacamoleClientInformation info)
import org.glyptodon.guacamole.net.GuacamoleTunnel;
public GuacamoleTunnel connect(GuacamoleClientInformation info)
import org.glyptodon.guacamole.net.GuacamoleTunnel;
import org.glyptodon.guacamole.net.SynchronizedGuacamoleTunnel;
private GuacamoleTunnel assignGuacamoleTunnel(ActiveConnectionRecord activeConnection,
GuacamoleTunnel tunnel = new SynchronizedGuacamoleTunnel(socket);
activeConnection.setTunnel(tunnel);
return tunnel;
public GuacamoleTunnel getGuacamoleTunnel(final AuthenticatedUser user,
return assignGuacamoleTunnel(new ActiveConnectionRecord(user, connection), info);
public GuacamoleTunnel getGuacamoleTunnel(AuthenticatedUser user,
return assignGuacamoleTunnel(new ActiveConnectionRecord(user, connectionGroup, connection), info);
import org.glyptodon.guacamole.net.GuacamoleTunnel;
private GuacamoleTunnel tunnel;
public GuacamoleTunnel getTunnel() {
return tunnel;
public void setTunnel(GuacamoleTunnel tunnel) {
this.tunnel = tunnel;
import org.glyptodon.guacamole.net.GuacamoleTunnel;
GuacamoleTunnel getGuacamoleTunnel(AuthenticatedUser user,
GuacamoleTunnel getGuacamoleTunnel(AuthenticatedUser user,
public Collection<ConnectionRecord> getActiveConnections()
throws GuacamoleException {
@Override
public ConnectionRecord getActiveConnection(String tunnelUUID)
throws GuacamoleException {
return null;
}
public interface GuacamoleTunnel {
GuacamoleReader acquireReader();
void releaseReader();
public boolean hasQueuedReaderThreads();
public GuacamoleWriter acquireWriter();
public void releaseWriter();
public boolean hasQueuedWriterThreads();
public UUID getUUID();
public GuacamoleSocket getSocket();
public void close() throws GuacamoleException;
public boolean isOpen();
import org.glyptodon.guacamole.net.GuacamoleTunnel;
public GuacamoleTunnel connect(GuacamoleClientInformation info)
import org.glyptodon.guacamole.net.GuacamoleTunnel;
public GuacamoleTunnel getTunnel();
ConnectionRecord getActiveConnection(String tunnelUUID)
throws GuacamoleException;
import org.glyptodon.guacamole.net.GuacamoleTunnel;
import org.glyptodon.guacamole.net.SynchronizedGuacamoleTunnel;
public GuacamoleTunnel connect(GuacamoleClientInformation info)
GuacamoleSocket socket;
socket = new ConfiguredGuacamoleSocket(
else
socket = new ConfiguredGuacamoleSocket(
new InetGuacamoleSocket(hostname, port),
config, info
);
return new SynchronizedGuacamoleTunnel(socket);
import org.glyptodon.guacamole.net.GuacamoleTunnel;
public GuacamoleTunnel connect(GuacamoleClientInformation info)
@Override
public ConnectionRecord getActiveConnection(String tunnelUUID)
throws GuacamoleException {
return null;
}
import org.glyptodon.guacamole.net.DelegatingGuacamoleTunnel;
GuacamoleTunnel tunnel;
tunnel = connection.connect(info);
tunnel = group.connect(info);
GuacamoleTunnel monitoredTunnel = new DelegatingGuacamoleTunnel(tunnel) {
if (!notifyConnect(session, monitoredTunnel)) {
session.addTunnel(monitoredTunnel);
return monitoredTunnel;
import org.glyptodon.guacamole.net.GuacamoleTunnel;
public GuacamoleTunnel connect(GuacamoleClientInformation info) throws GuacamoleException {
import org.glyptodon.guacamole.net.GuacamoleTunnel;
public GuacamoleTunnel connect(GuacamoleClientInformation info) throws GuacamoleException {
import org.glyptodon.guacamole.auth.jdbc.tunnel.GuacamoleTunnelService;
private final Class<? extends GuacamoleTunnelService> tunnelServiceClass;
Class<? extends GuacamoleTunnelService> tunnelServiceClass) {
this.tunnelServiceClass = tunnelServiceClass;
bind(GuacamoleTunnelService.class).to(tunnelServiceClass);
import org.glyptodon.guacamole.auth.jdbc.tunnel.GuacamoleTunnelService;
private GuacamoleTunnelService tunnelService;
List<ConnectionRecord> records = new ArrayList<ConnectionRecord>(tunnelService.getActiveConnections(connection));
return tunnelService.getGuacamoleTunnel(user, connection, info);
import org.glyptodon.guacamole.auth.jdbc.tunnel.GuacamoleTunnelService;
private GuacamoleTunnelService tunnelService;
return tunnelService.getActiveConnections(this).size();
import org.glyptodon.guacamole.auth.jdbc.tunnel.GuacamoleTunnelService;
private GuacamoleTunnelService tunnelService;
return tunnelService.getGuacamoleTunnel(user, connectionGroup, info);
import org.glyptodon.guacamole.auth.jdbc.tunnel.GuacamoleTunnelService;
private GuacamoleTunnelService tunnelService;
return tunnelService.getActiveConnections(this).size();
package org.glyptodon.guacamole.auth.jdbc.tunnel;
public abstract class AbstractGuacamoleTunnelService implements GuacamoleTunnelService {
package org.glyptodon.guacamole.auth.jdbc.tunnel;
package org.glyptodon.guacamole.auth.jdbc.tunnel;
package org.glyptodon.guacamole.auth.jdbc.tunnel;
public class BalancedGuacamoleTunnelService
extends AbstractGuacamoleTunnelService {
package org.glyptodon.guacamole.auth.jdbc.tunnel;
public interface GuacamoleTunnelService {
package org.glyptodon.guacamole.auth.jdbc.tunnel;
package org.glyptodon.guacamole.auth.jdbc.tunnel;
public class MultiseatGuacamoleTunnelService
extends AbstractGuacamoleTunnelService {
package org.glyptodon.guacamole.auth.jdbc.tunnel;
package org.glyptodon.guacamole.auth.jdbc.tunnel;
public class SingleSeatGuacamoleTunnelService
extends AbstractGuacamoleTunnelService {
package org.glyptodon.guacamole.auth.jdbc.tunnel;
public class UnrestrictedGuacamoleTunnelService
extends AbstractGuacamoleTunnelService {
package org.glyptodon.guacamole.auth.jdbc.tunnel;
import org.glyptodon.guacamole.auth.jdbc.tunnel.GuacamoleTunnelService;
private GuacamoleTunnelService tunnelService;
return tunnelService.getActiveConnections(getCurrentUser());
import org.glyptodon.guacamole.auth.jdbc.tunnel.GuacamoleTunnelService;
import org.glyptodon.guacamole.auth.jdbc.tunnel.MultiseatGuacamoleTunnelService;
import org.glyptodon.guacamole.auth.jdbc.tunnel.BalancedGuacamoleTunnelService;
import org.glyptodon.guacamole.auth.jdbc.tunnel.SingleSeatGuacamoleTunnelService;
import org.glyptodon.guacamole.auth.jdbc.tunnel.UnrestrictedGuacamoleTunnelService;
private Class<? extends GuacamoleTunnelService>
return SingleSeatGuacamoleTunnelService.class;
return BalancedGuacamoleTunnelService.class;
return MultiseatGuacamoleTunnelService.class;
return UnrestrictedGuacamoleTunnelService.class;
import org.glyptodon.guacamole.auth.jdbc.tunnel.BalancedGuacamoleTunnelService;
import org.glyptodon.guacamole.auth.jdbc.tunnel.GuacamoleTunnelService;
import org.glyptodon.guacamole.auth.jdbc.tunnel.MultiseatGuacamoleTunnelService;
import org.glyptodon.guacamole.auth.jdbc.tunnel.SingleSeatGuacamoleTunnelService;
import org.glyptodon.guacamole.auth.jdbc.tunnel.UnrestrictedGuacamoleTunnelService;
private Class<? extends GuacamoleTunnelService>
return SingleSeatGuacamoleTunnelService.class;
return BalancedGuacamoleTunnelService.class;
return MultiseatGuacamoleTunnelService.class;
return UnrestrictedGuacamoleTunnelService.class;
public APITunnel(ConnectionRecord record, String uuid) {
this.uuid       = uuid;
import org.glyptodon.guacamole.GuacamoleResourceNotFoundException;
import org.glyptodon.guacamole.net.GuacamoleTunnel;
for (ConnectionRecord record : userContext.getActiveConnections()) {
GuacamoleTunnel tunnel = record.getTunnel();
if (tunnel != null)
apiTunnels.add(new APITunnel(record, tunnel.getUUID().toString()));
}
ConnectionRecord record = userContext.getActiveConnection(tunnelUUID);
if (record == null)
GuacamoleTunnel tunnel = record.getTunnel();
if (tunnel != null && tunnel.isOpen())
tunnel.close();
return null;
return user.getRemoteHost();
import javax.servlet.http.HttpServletRequest;
private final String remoteHost;
private static String getRemoteHost(Credentials credentials) {
HttpServletRequest request = credentials.getRequest();
return request.getRemoteAddr();
}
this.remoteHost = getRemoteHost(credentials);
public String getRemoteHost() {
return remoteHost;
}
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
public abstract class AbstractGuacamoleTunnel implements GuacamoleTunnel {
public AbstractGuacamoleTunnel() {
return getSocket().getReader();
return getSocket().getWriter();
getSocket().close();
return getSocket().isOpen();
import org.glyptodon.guacamole.net.SimpleGuacamoleTunnel;
return new SimpleGuacamoleTunnel(socket);
import java.util.Map;
private final Map<String, ConnectionRecord> activeTunnels =
new ConcurrentHashMap<String, ConnectionRecord>();
activeTunnels.remove(activeConnection.getUUID().toString());
activeTunnels.put(activeConnection.getUUID().toString(), activeConnection);
return activeConnection.assignGuacamoleTunnel(socket);
return Collections.unmodifiableCollection(activeTunnels.values());
public ConnectionRecord getActiveConnection(AuthenticatedUser user,
String tunnelUUID) throws GuacamoleException {
if (!user.getUser().isAdministrator())
return null;
return activeTunnels.get(tunnelUUID);
}
@Override
import java.util.UUID;
import org.glyptodon.guacamole.net.AbstractGuacamoleTunnel;
import org.glyptodon.guacamole.net.GuacamoleSocket;
private final UUID uuid = UUID.randomUUID();
public GuacamoleTunnel assignGuacamoleTunnel(final GuacamoleSocket socket) {
this.tunnel = new AbstractGuacamoleTunnel() {
@Override
public GuacamoleSocket getSocket() {
return socket;
}
@Override
public UUID getUUID() {
return uuid;
}
};
return this.tunnel;
public UUID getUUID() {
return uuid;
}
public ConnectionRecord getActiveConnection(AuthenticatedUser user,
String tunnelUUID)
throws GuacamoleException;
return tunnelService.getActiveConnection(getCurrentUser(), tunnelUUID);
boolean hasQueuedReaderThreads();
GuacamoleWriter acquireWriter();
void releaseWriter();
boolean hasQueuedWriterThreads();
UUID getUUID();
GuacamoleSocket getSocket();
void close() throws GuacamoleException;
boolean isOpen();
import org.glyptodon.guacamole.auth.jdbc.tunnel.GuacamoleTunnelService;
private final Class<? extends GuacamoleTunnelService> tunnelServiceClass;
Class<? extends GuacamoleTunnelService> tunnelServiceClass) {
this.tunnelServiceClass = tunnelServiceClass;
bind(GuacamoleTunnelService.class).to(tunnelServiceClass);
import org.glyptodon.guacamole.auth.jdbc.tunnel.GuacamoleTunnelService;
import org.glyptodon.guacamole.net.GuacamoleTunnel;
private GuacamoleTunnelService tunnelService;
List<ConnectionRecord> records = new ArrayList<ConnectionRecord>(tunnelService.getActiveConnections(connection));
public GuacamoleTunnel connect(AuthenticatedUser user,
return tunnelService.getGuacamoleTunnel(user, connection, info);
import org.glyptodon.guacamole.auth.jdbc.tunnel.GuacamoleTunnelService;
import org.glyptodon.guacamole.net.GuacamoleTunnel;
private GuacamoleTunnelService tunnelService;
public GuacamoleTunnel connect(GuacamoleClientInformation info) throws GuacamoleException {
return tunnelService.getActiveConnections(this).size();
import org.glyptodon.guacamole.net.GuacamoleTunnel;
public String getIdentifier() {
return model.getConnectionIdentifier();
}
@Override
public String getRemoteHost() {
return null;
}
@Override
@Override
public GuacamoleTunnel getTunnel() {
return null;
}
import org.glyptodon.guacamole.auth.jdbc.tunnel.GuacamoleTunnelService;
import org.glyptodon.guacamole.net.GuacamoleTunnel;
private GuacamoleTunnelService tunnelService;
public GuacamoleTunnel connect(AuthenticatedUser user,
return tunnelService.getGuacamoleTunnel(user, connectionGroup, info);
import org.glyptodon.guacamole.auth.jdbc.tunnel.GuacamoleTunnelService;
import org.glyptodon.guacamole.net.GuacamoleTunnel;
private GuacamoleTunnelService tunnelService;
public GuacamoleTunnel connect(GuacamoleClientInformation info)
return tunnelService.getActiveConnections(this).size();
import org.glyptodon.guacamole.net.GuacamoleTunnel;
public GuacamoleTunnel connect(GuacamoleClientInformation info)
package org.glyptodon.guacamole.auth.jdbc.tunnel;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import org.glyptodon.guacamole.net.GuacamoleTunnel;
public abstract class AbstractGuacamoleTunnelService implements GuacamoleTunnelService {
private final Map<String, ConnectionRecord> activeTunnels =
new ConcurrentHashMap<String, ConnectionRecord>();
activeTunnels.remove(activeConnection.getUUID().toString());
private GuacamoleTunnel assignGuacamoleTunnel(ActiveConnectionRecord activeConnection,
activeTunnels.put(activeConnection.getUUID().toString(), activeConnection);
GuacamoleSocket socket = new ConfiguredGuacamoleSocket(
return activeConnection.assignGuacamoleTunnel(socket);
public Collection<ConnectionRecord> getActiveConnections(AuthenticatedUser user)
throws GuacamoleException {
if (!user.getUser().isAdministrator())
return Collections.EMPTY_LIST;
return Collections.unmodifiableCollection(activeTunnels.values());
}
@Override
public ConnectionRecord getActiveConnection(AuthenticatedUser user,
String tunnelUUID) throws GuacamoleException {
if (!user.getUser().isAdministrator())
return null;
return activeTunnels.get(tunnelUUID);
}
@Override
public GuacamoleTunnel getGuacamoleTunnel(final AuthenticatedUser user,
return assignGuacamoleTunnel(new ActiveConnectionRecord(user, connection), info);
public GuacamoleTunnel getGuacamoleTunnel(AuthenticatedUser user,
return assignGuacamoleTunnel(new ActiveConnectionRecord(user, connectionGroup, connection), info);
package org.glyptodon.guacamole.auth.jdbc.tunnel;
connections = Collections.synchronizedSet(Collections.newSetFromMap(new LinkedHashMap<ConnectionRecord, Boolean>()));
package org.glyptodon.guacamole.auth.jdbc.tunnel;
import java.util.UUID;
import org.glyptodon.guacamole.net.AbstractGuacamoleTunnel;
import org.glyptodon.guacamole.net.GuacamoleSocket;
import org.glyptodon.guacamole.net.GuacamoleTunnel;
private final UUID uuid = UUID.randomUUID();
private GuacamoleTunnel tunnel;
@Override
public String getIdentifier() {
return connection.getIdentifier();
}
public String getRemoteHost() {
return user.getRemoteHost();
}
@Override
@Override
public GuacamoleTunnel getTunnel() {
return tunnel;
}
public GuacamoleTunnel assignGuacamoleTunnel(final GuacamoleSocket socket) {
this.tunnel = new AbstractGuacamoleTunnel() {
@Override
public GuacamoleSocket getSocket() {
return socket;
}
@Override
public UUID getUUID() {
return uuid;
}
};
return this.tunnel;
}
public UUID getUUID() {
return uuid;
}
package org.glyptodon.guacamole.auth.jdbc.tunnel;
public class BalancedGuacamoleTunnelService
extends AbstractGuacamoleTunnelService {
package org.glyptodon.guacamole.auth.jdbc.tunnel;
import org.glyptodon.guacamole.net.GuacamoleTunnel;
public interface GuacamoleTunnelService {
public Collection<ConnectionRecord> getActiveConnections(AuthenticatedUser user)
throws GuacamoleException;
public ConnectionRecord getActiveConnection(AuthenticatedUser user,
String tunnelUUID)
throws GuacamoleException;
GuacamoleTunnel getGuacamoleTunnel(AuthenticatedUser user,
GuacamoleTunnel getGuacamoleTunnel(AuthenticatedUser user,
package org.glyptodon.guacamole.auth.jdbc.tunnel;
package org.glyptodon.guacamole.auth.jdbc.tunnel;
public class MultiseatGuacamoleTunnelService
extends AbstractGuacamoleTunnelService {
package org.glyptodon.guacamole.auth.jdbc.tunnel;
package org.glyptodon.guacamole.auth.jdbc.tunnel;
public class SingleSeatGuacamoleTunnelService
extends AbstractGuacamoleTunnelService {
package org.glyptodon.guacamole.auth.jdbc.tunnel;
public class UnrestrictedGuacamoleTunnelService
extends AbstractGuacamoleTunnelService {
package org.glyptodon.guacamole.auth.jdbc.tunnel;
import javax.servlet.http.HttpServletRequest;
private final String remoteHost;
private static String getRemoteHost(Credentials credentials) {
HttpServletRequest request = credentials.getRequest();
return request.getRemoteAddr();
}
this.remoteHost = getRemoteHost(credentials);
public String getRemoteHost() {
return remoteHost;
}
import java.util.Collection;
import org.glyptodon.guacamole.auth.jdbc.tunnel.GuacamoleTunnelService;
import org.glyptodon.guacamole.net.auth.ConnectionRecord;
@Inject
private GuacamoleTunnelService tunnelService;
@Override
public Collection<ConnectionRecord> getActiveConnections()
throws GuacamoleException {
return tunnelService.getActiveConnections(getCurrentUser());
}
@Override
public ConnectionRecord getActiveConnection(String tunnelUUID)
throws GuacamoleException {
return tunnelService.getActiveConnection(getCurrentUser(), tunnelUUID);
}
import org.glyptodon.guacamole.auth.jdbc.tunnel.GuacamoleTunnelService;
import org.glyptodon.guacamole.auth.jdbc.tunnel.MultiseatGuacamoleTunnelService;
import org.glyptodon.guacamole.auth.jdbc.tunnel.BalancedGuacamoleTunnelService;
import org.glyptodon.guacamole.auth.jdbc.tunnel.SingleSeatGuacamoleTunnelService;
import org.glyptodon.guacamole.auth.jdbc.tunnel.UnrestrictedGuacamoleTunnelService;
private Class<? extends GuacamoleTunnelService>
return SingleSeatGuacamoleTunnelService.class;
return BalancedGuacamoleTunnelService.class;
return MultiseatGuacamoleTunnelService.class;
return UnrestrictedGuacamoleTunnelService.class;
import org.glyptodon.guacamole.auth.jdbc.tunnel.BalancedGuacamoleTunnelService;
import org.glyptodon.guacamole.auth.jdbc.tunnel.GuacamoleTunnelService;
import org.glyptodon.guacamole.auth.jdbc.tunnel.MultiseatGuacamoleTunnelService;
import org.glyptodon.guacamole.auth.jdbc.tunnel.SingleSeatGuacamoleTunnelService;
import org.glyptodon.guacamole.auth.jdbc.tunnel.UnrestrictedGuacamoleTunnelService;
private Class<? extends GuacamoleTunnelService>
return SingleSeatGuacamoleTunnelService.class;
return BalancedGuacamoleTunnelService.class;
return MultiseatGuacamoleTunnelService.class;
return UnrestrictedGuacamoleTunnelService.class;
public interface GuacamoleTunnel {
GuacamoleReader acquireReader();
void releaseReader();
boolean hasQueuedReaderThreads();
GuacamoleWriter acquireWriter();
void releaseWriter();
boolean hasQueuedWriterThreads();
UUID getUUID();
GuacamoleSocket getSocket();
void close() throws GuacamoleException;
boolean isOpen();
import org.glyptodon.guacamole.net.GuacamoleTunnel;
public GuacamoleTunnel connect(GuacamoleClientInformation info)
import org.glyptodon.guacamole.net.GuacamoleTunnel;
public String getIdentifier();
public String getRemoteHost();
public GuacamoleTunnel getTunnel();
import java.util.Collection;
Collection<ConnectionRecord> getActiveConnections()
throws GuacamoleException;
ConnectionRecord getActiveConnection(String tunnelUUID)
throws GuacamoleException;
import org.glyptodon.guacamole.net.GuacamoleTunnel;
import org.glyptodon.guacamole.net.SimpleGuacamoleTunnel;
public GuacamoleTunnel connect(GuacamoleClientInformation info)
GuacamoleSocket socket;
socket = new ConfiguredGuacamoleSocket(
else
socket = new ConfiguredGuacamoleSocket(
new InetGuacamoleSocket(hostname, port),
config, info
);
return new SimpleGuacamoleTunnel(socket);
import org.glyptodon.guacamole.net.GuacamoleTunnel;
public GuacamoleTunnel connect(GuacamoleClientInformation info)
import org.glyptodon.guacamole.net.auth.ConnectionRecord;
@Override
public Collection<ConnectionRecord> getActiveConnections()
throws GuacamoleException {
return Collections.EMPTY_LIST;
}
@Override
public ConnectionRecord getActiveConnection(String tunnelUUID)
throws GuacamoleException {
return null;
}
import org.glyptodon.guacamole.net.DelegatingGuacamoleTunnel;
GuacamoleTunnel tunnel;
tunnel = connection.connect(info);
tunnel = group.connect(info);
GuacamoleTunnel monitoredTunnel = new DelegatingGuacamoleTunnel(tunnel) {
if (!notifyConnect(session, monitoredTunnel)) {
session.addTunnel(monitoredTunnel);
return monitoredTunnel;
import org.glyptodon.guacamole.net.basic.rest.tunnel.TunnelRESTService;
bind(TunnelRESTService.class);
private final String remoteHost;
this.startDate  = record.getStartDate();
this.endDate    = record.getEndDate();
this.remoteHost = record.getRemoteHost();
this.username   = record.getUsername();
this.active     = record.isActive();
public String getRemoteHost() {
return remoteHost;
}
import org.glyptodon.guacamole.net.GuacamoleTunnel;
public GuacamoleTunnel connect(GuacamoleClientInformation info) throws GuacamoleException {
import org.glyptodon.guacamole.net.GuacamoleTunnel;
public GuacamoleTunnel connect(GuacamoleClientInformation info) throws GuacamoleException {
import java.util.ArrayList;
public Collection<ConnectionRecord> getActiveConnections(Collection<String> tunnelUUIDs)
Collection<ConnectionRecord> records = new ArrayList<ConnectionRecord>(tunnelUUIDs.size());
for (String tunnelUUID : tunnelUUIDs) {
ConnectionRecord record = tunnelService.getActiveConnection(getCurrentUser(), tunnelUUID);
if (record != null)
records.add(record);
}
return records;
Collection<ConnectionRecord> getActiveConnections(Collection<String> tunnelUUIDs)
public Collection<ConnectionRecord> getActiveConnections(Collection<String> tunnelUUID)
return Collections.EMPTY_LIST;
import java.util.Collection;
@Path("/")
public void deleteTunnels(@QueryParam("token") String authToken,
@QueryParam("tunnelUUID") Collection<String> tunnelUUIDs)
Collection<ConnectionRecord> records = userContext.getActiveConnections(tunnelUUIDs);
for (ConnectionRecord record : records) {
GuacamoleTunnel tunnel = record.getTunnel();
if (tunnel != null && tunnel.isOpen())
tunnel.close();
}
import java.util.HashMap;
import java.util.Map;
import org.glyptodon.guacamole.GuacamoleClientException;
import org.glyptodon.guacamole.GuacamoleUnsupportedException;
import org.glyptodon.guacamole.net.basic.rest.APIPatch;
import org.glyptodon.guacamole.net.basic.rest.PATCH;
public Map<String, APITunnel> getTunnels(@QueryParam("token") String authToken)
Map<String, APITunnel> apiTunnels = new HashMap<String, APITunnel>();
if (tunnel != null) {
APITunnel apiTunnel = new APITunnel(record, tunnel.getUUID().toString());
apiTunnels.put(apiTunnel.getUUID(), apiTunnel);
}
@PATCH
public void patchTunnels(@QueryParam("token") String authToken,
List<APIPatch<String>> patches) throws GuacamoleException {
Collection<String> tunnelUUIDs = new ArrayList<String>(patches.size());
for (APIPatch<String> patch : patches) {
if (patch.getOp() != APIPatch.Operation.remove)
throw new GuacamoleUnsupportedException("Only the \"remove\" operation is supported when patching tunnels.");
String path = patch.getPath();
if (!path.startsWith("/"))
throw new GuacamoleClientException("Patch paths must start with \"/\".");
tunnelUUIDs.add(path.substring(1));
}
Collection<ConnectionRecord> records = userContext.getActiveConnections(tunnelUUIDs);
import java.util.ArrayList;
public Collection<ConnectionRecord> getActiveConnections(Collection<String> tunnelUUIDs)
Collection<ConnectionRecord> records = new ArrayList<ConnectionRecord>(tunnelUUIDs.size());
for (String tunnelUUID : tunnelUUIDs) {
ConnectionRecord record = tunnelService.getActiveConnection(getCurrentUser(), tunnelUUID);
if (record != null)
records.add(record);
}
return records;
Collection<ConnectionRecord> getActiveConnections(Collection<String> tunnelUUIDs)
public Collection<ConnectionRecord> getActiveConnections(Collection<String> tunnelUUID)
return Collections.EMPTY_LIST;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import org.glyptodon.guacamole.GuacamoleClientException;
import org.glyptodon.guacamole.net.basic.rest.APIPatch;
import org.glyptodon.guacamole.net.basic.rest.PATCH;
public Map<String, APITunnel> getTunnels(@QueryParam("token") String authToken)
Map<String, APITunnel> apiTunnels = new HashMap<String, APITunnel>();
if (tunnel != null) {
APITunnel apiTunnel = new APITunnel(record, tunnel.getUUID().toString());
apiTunnels.put(apiTunnel.getUUID(), apiTunnel);
}
@PATCH
@Path("/")
public void patchTunnels(@QueryParam("token") String authToken,
List<APIPatch<String>> patches) throws GuacamoleException {
Collection<String> tunnelUUIDs = new ArrayList<String>(patches.size());
for (APIPatch<String> patch : patches) {
if (patch.getOp() != APIPatch.Operation.remove)
throw new GuacamoleUnsupportedException("Only the \"remove\" operation is supported when patching tunnels.");
String path = patch.getPath();
if (!path.startsWith("/"))
throw new GuacamoleClientException("Patch paths must start with \"/\".");
tunnelUUIDs.add(path.substring(1));
}
Collection<ConnectionRecord> records = userContext.getActiveConnections(tunnelUUIDs);
for (ConnectionRecord record : records) {
GuacamoleTunnel tunnel = record.getTunnel();
if (tunnel != null && tunnel.isOpen())
tunnel.close();
}
import java.util.regex.Pattern;
private static final String IPV4_ADDRESS_REGEX = "([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})";
private static final String IPV6_ADDRESS_REGEX = "([0-9a-fA-F]*(:[0-9a-fA-F]*){0,7})";
private String getLoggableAddress(HttpServletRequest request) {
String header = request.getHeader("X-Forwarded-For");
if (header != null && X_FORWARDED_FOR.matcher(header).matches())
return request.getRemoteAddr();
}
else {
if (userContext != null && logger.isInfoEnabled())
logger.info("User \"{}\" successfully authenticated from {}.",
userContext.self().getIdentifier(), getLoggableAddress(request));
}
if (userContext == null) {
if (username != null) {
if (logger.isWarnEnabled())
logger.warn("Authentication attempt from {} for user \"{}\" failed.",
getLoggableAddress(request), username);
}
else if (logger.isDebugEnabled())
logger.debug("Anonymous authentication attempt from {} failed.",
getLoggableAddress(request), username);
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
private static final String IPV4_ADDRESS_REGEX = "([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})";
private static final String IPV6_ADDRESS_REGEX = "([0-9a-fA-F]*(:[0-9a-fA-F]*){0,7})";
String header = request.getHeader("X-Forwarded-For");
if (header != null) {
Matcher matcher = X_FORWARDED_FOR.matcher(header);
if (matcher.matches())
return matcher.group(1);
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
private static final String IPV4_ADDRESS_REGEX = "([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})";
private static final String IPV6_ADDRESS_REGEX = "([0-9a-fA-F]*(:[0-9a-fA-F]*){0,7})";
String header = request.getHeader("X-Forwarded-For");
if (header != null) {
Matcher matcher = X_FORWARDED_FOR.matcher(header);
if (matcher.matches())
return matcher.group(1);
}
import java.util.regex.Pattern;
private static final String IPV4_ADDRESS_REGEX = "([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})";
private static final String IPV6_ADDRESS_REGEX = "([0-9a-fA-F]*(:[0-9a-fA-F]*){0,7})";
private String getLoggableAddress(HttpServletRequest request) {
String header = request.getHeader("X-Forwarded-For");
if (header != null && X_FORWARDED_FOR.matcher(header).matches())
return request.getRemoteAddr();
}
else {
if (userContext != null && logger.isInfoEnabled())
logger.info("User \"{}\" successfully authenticated from {}.",
userContext.self().getIdentifier(), getLoggableAddress(request));
}
if (userContext == null) {
if (username != null) {
if (logger.isWarnEnabled())
logger.warn("Authentication attempt from {} for user \"{}\" failed.",
getLoggableAddress(request), username);
}
else if (logger.isDebugEnabled())
logger.debug("Anonymous authentication attempt from {} failed.",
getLoggableAddress(request), username);
}
ExternalType, ModelType extends ObjectModel>
implements IdentifiableObjectService<InternalType, ExternalType> {
@Override
@Override
@Override
@Override
@Override
@Override
public interface DirectoryObjectService<InternalType, ExternalType> {
InternalType retrieveObject(AuthenticatedUser user, String identifier)
throws GuacamoleException;
Collection<InternalType> retrieveObjects(AuthenticatedUser user,
Collection<String> identifiers) throws GuacamoleException;
InternalType createObject(AuthenticatedUser user, ExternalType object)
throws GuacamoleException;
void deleteObject(AuthenticatedUser user, String identifier)
throws GuacamoleException;
void updateObject(AuthenticatedUser user, InternalType object)
throws GuacamoleException;
Set<String> getIdentifiers(AuthenticatedUser user) throws GuacamoleException;
public abstract class ModeledDirectoryObject<ModelType extends ObjectModel>
public interface ModeledDirectoryObjectMapper<ModelType> {
public abstract class ModeledGroupedDirectoryObject<ModelType extends GroupedObjectModel>
extends ModeledDirectoryObject<ModelType> {
public abstract class ModeledGroupedDirectoryObjectService<InternalType extends ModeledGroupedDirectoryObject<ModelType>,
extends ModeledDirectoryObjectService<InternalType, ExternalType, ModelType> {
import org.glyptodon.guacamole.auth.jdbc.base.ModeledDirectoryObjectMapper;
public interface ConnectionMapper extends ModeledDirectoryObjectMapper<ConnectionModel> {
import org.glyptodon.guacamole.auth.jdbc.base.ModeledDirectoryObjectMapper;
import org.glyptodon.guacamole.auth.jdbc.base.ModeledGroupedDirectoryObjectService;
public class ConnectionService extends ModeledGroupedDirectoryObjectService<ModeledConnection, Connection, ConnectionModel> {
protected ModeledDirectoryObjectMapper<ConnectionModel> getObjectMapper() {
import org.glyptodon.guacamole.auth.jdbc.base.ModeledGroupedDirectoryObject;
public class ModeledConnection extends ModeledGroupedDirectoryObject<ConnectionModel>
import org.glyptodon.guacamole.auth.jdbc.base.ModeledDirectoryObjectMapper;
public interface ConnectionGroupMapper extends ModeledDirectoryObjectMapper<ConnectionGroupModel> {
import org.glyptodon.guacamole.auth.jdbc.base.ModeledDirectoryObjectMapper;
import org.glyptodon.guacamole.auth.jdbc.base.ModeledGroupedDirectoryObjectService;
public class ConnectionGroupService extends ModeledGroupedDirectoryObjectService<ModeledConnectionGroup,
protected ModeledDirectoryObjectMapper<ConnectionGroupModel> getObjectMapper() {
import org.glyptodon.guacamole.auth.jdbc.base.ModeledGroupedDirectoryObject;
public class ModeledConnectionGroup extends ModeledGroupedDirectoryObject<ConnectionGroupModel>
import org.glyptodon.guacamole.auth.jdbc.base.ModeledDirectoryObject;
public class ModeledUser extends ModeledDirectoryObject<UserModel> implements User {
import org.glyptodon.guacamole.auth.jdbc.base.ModeledDirectoryObjectMapper;
public interface UserMapper extends ModeledDirectoryObjectMapper<UserModel> {
import org.glyptodon.guacamole.auth.jdbc.base.ModeledDirectoryObjectMapper;
import org.glyptodon.guacamole.auth.jdbc.base.ModeledDirectoryObjectService;
public class UserService extends ModeledDirectoryObjectService<ModeledUser, User, UserModel> {
protected ModeledDirectoryObjectMapper<UserModel> getObjectMapper() {
import org.glyptodon.guacamole.auth.jdbc.activeconnection.ActiveConnectionDirectory;
import org.glyptodon.guacamole.auth.jdbc.activeconnection.ActiveConnectionService;
import org.glyptodon.guacamole.auth.jdbc.activeconnection.TrackedActiveConnection;
bind(ActiveConnectionDirectory.class);
bind(TrackedActiveConnection.class);
bind(ActiveConnectionService.class);
private final Map<String, ActiveConnectionRecord> activeTunnels =
new ConcurrentHashMap<String, ActiveConnectionRecord>();
public Collection<ActiveConnectionRecord> getActiveConnections(AuthenticatedUser user)
public ActiveConnectionRecord getActiveConnection(AuthenticatedUser user,
public Collection<ActiveConnectionRecord> getActiveConnections(Connection connection) {
public Collection<ActiveConnectionRecord> getActiveConnections(ConnectionGroup connectionGroup) {
private final Map<String, Set<ActiveConnectionRecord>> records =
new HashMap<String, Set<ActiveConnectionRecord>>();
public void put(String identifier, ActiveConnectionRecord record) {
Set<ActiveConnectionRecord> connections = records.get(identifier);
connections = Collections.synchronizedSet(Collections.newSetFromMap(new LinkedHashMap<ActiveConnectionRecord, Boolean>()));
public void remove(String identifier, ActiveConnectionRecord record) {
Set<ActiveConnectionRecord> connections = records.get(identifier);
public Collection<ActiveConnectionRecord> get(String identifier) {
Collection<ActiveConnectionRecord> connections = records.get(identifier);
public Collection<ActiveConnectionRecord> getActiveConnections(AuthenticatedUser user)
public ActiveConnectionRecord getActiveConnection(AuthenticatedUser user,
public Collection<ActiveConnectionRecord> getActiveConnections(Connection connection);
public Collection<ActiveConnectionRecord> getActiveConnections(ConnectionGroup connectionGroup);
import org.glyptodon.guacamole.GuacamoleUnsupportedException;
public ObjectPermissionSet getActiveConnectionPermissions()
throws GuacamoleException {
throw new GuacamoleUnsupportedException("STUB");
}
@Override
import org.glyptodon.guacamole.auth.jdbc.activeconnection.ActiveConnectionDirectory;
import org.glyptodon.guacamole.net.auth.ActiveConnection;
@Inject
private ActiveConnectionDirectory activeConnectionDirectory;
activeConnectionDirectory.init(currentUser);
public Directory<ActiveConnection> getActiveConnectionDirectory()
throws GuacamoleException {
return activeConnectionDirectory;
}
@Override
ObjectPermissionSet getActiveConnectionPermissions()
throws GuacamoleException;
Directory<ActiveConnection> getActiveConnectionDirectory()
throws GuacamoleException;
@Override
public ObjectPermissionSet getActiveConnectionPermissions()
throws GuacamoleException {
return new SimpleObjectPermissionSet();
}
import org.glyptodon.guacamole.net.auth.ActiveConnection;
public Directory<ActiveConnection> getActiveConnectionDirectory()
return new SimpleDirectory<ActiveConnection>();
import org.glyptodon.guacamole.net.basic.rest.activeconnection.ActiveConnectionRESTService;
bind(ActiveConnectionRESTService.class);
package org.glyptodon.guacamole.net.basic.rest.activeconnection;
import org.glyptodon.guacamole.net.auth.ActiveConnection;
public class APIActiveConnection {
private final String connectionIdentifier;
public APIActiveConnection(ActiveConnection connection) {
this.identifier           = connection.getIdentifier();
this.connectionIdentifier = connection.getConnectionIdentifier();
this.startDate            = connection.getStartDate();
this.remoteHost           = connection.getRemoteHost();
this.username             = connection.getUsername();
public String getConnectionIdentifier() {
return connectionIdentifier;
public String getIdentifier() {
return identifier;
private Map<String, Set<ObjectPermission.Type>> activeConnectionPermissions =
new HashMap<String, Set<ObjectPermission.Type>>();
addSystemPermissions(systemPermissions,           user.getSystemPermissions());
addObjectPermissions(connectionPermissions,       user.getConnectionPermissions());
addObjectPermissions(connectionGroupPermissions,  user.getConnectionGroupPermissions());
addObjectPermissions(activeConnectionPermissions, user.getActiveConnectionPermissions());
addObjectPermissions(userPermissions,             user.getUserPermissions());
public Map<String, Set<ObjectPermission.Type>> getActiveConnectionPermissions() {
return activeConnectionPermissions;
}
public void setActiveConnectionPermissions(Map<String, Set<ObjectPermission.Type>> activeConnectionPermissions) {
this.activeConnectionPermissions = activeConnectionPermissions;
}
@Override
public ObjectPermissionSet getActiveConnectionPermissions()
throws GuacamoleException {
throw new GuacamoleUnsupportedException("APIUserWrapper does not provide permission access.");
}
private static final String ACTIVE_CONNECTION_PERMISSION_PATCH_PATH_PREFIX = "/activeConnectionPermissions/";
PermissionSetPatch<ObjectPermission> connectionPermissionPatch       = new PermissionSetPatch<ObjectPermission>();
PermissionSetPatch<ObjectPermission> connectionGroupPermissionPatch  = new PermissionSetPatch<ObjectPermission>();
PermissionSetPatch<ObjectPermission> activeConnectionPermissionPatch = new PermissionSetPatch<ObjectPermission>();
PermissionSetPatch<ObjectPermission> userPermissionPatch             = new PermissionSetPatch<ObjectPermission>();
PermissionSetPatch<SystemPermission> systemPermissionPatch           = new PermissionSetPatch<SystemPermission>();
else if (path.startsWith(ACTIVE_CONNECTION_PERMISSION_PATCH_PATH_PREFIX)) {
String identifier = path.substring(ACTIVE_CONNECTION_PERMISSION_PATCH_PATH_PREFIX.length());
ObjectPermission.Type type = ObjectPermission.Type.valueOf(patch.getValue());
ObjectPermission permission = new ObjectPermission(type, identifier);
updatePermissionSet(patch.getOp(), activeConnectionPermissionPatch, permission);
}
activeConnectionPermissionPatch.apply(user.getActiveConnectionPermissions());
public class ConnectionGroupPermissionService extends ModeledObjectPermissionService {
public class ConnectionPermissionService extends ModeledObjectPermissionService {
public interface ObjectPermissionService
extends PermissionService<ObjectPermissionSet, ObjectPermission> {
ObjectPermission retrievePermission(AuthenticatedUser user,
String identifier) throws GuacamoleException;
Collection<String> retrieveAccessibleIdentifiers(AuthenticatedUser user,
Collection<String> identifiers) throws GuacamoleException;
public interface PermissionService<PermissionSetType extends PermissionSet<PermissionType>,
PermissionType extends Permission> {
PermissionSetType getPermissionSet(AuthenticatedUser user,
Set<PermissionType> retrievePermissions(AuthenticatedUser user,
ModeledUser targetUser) throws GuacamoleException;
void createPermissions(AuthenticatedUser user, ModeledUser targetUser,
void deletePermissions(AuthenticatedUser user, ModeledUser targetUser,
extends ModeledPermissionService<SystemPermissionSet, SystemPermission, SystemPermissionModel> {
public class UserPermissionService extends ModeledObjectPermissionService {
extends AbstractPermissionService<PermissionSetType, PermissionType> {
import org.glyptodon.guacamole.auth.jdbc.activeconnection.ActiveConnectionPermissionService;
import org.glyptodon.guacamole.auth.jdbc.activeconnection.ActiveConnectionPermissionSet;
bind(ActiveConnectionPermissionSet.class);
bind(ActiveConnectionPermissionService.class);
import org.glyptodon.guacamole.auth.jdbc.activeconnection.ActiveConnectionPermissionService;
@Inject
private ActiveConnectionPermissionService activeConnectionPermissionService;
return activeConnectionPermissionService.getPermissionSet(getCurrentUser(), this);
ObjectPermissionSet activeConnectionPermissions = self.getActiveConnectionPermissions();
activeConnectionIdentifiers = activeConnectionPermissions.getAccessibleObjects(permissions, activeConnectionIdentifiers);
import org.glyptodon.guacamole.auth.jdbc.activeconnection.ActiveConnectionDirectory;
import org.glyptodon.guacamole.auth.jdbc.activeconnection.ActiveConnectionPermissionService;
import org.glyptodon.guacamole.auth.jdbc.activeconnection.ActiveConnectionPermissionSet;
import org.glyptodon.guacamole.auth.jdbc.activeconnection.ActiveConnectionService;
import org.glyptodon.guacamole.auth.jdbc.activeconnection.TrackedActiveConnection;
bind(ActiveConnectionDirectory.class);
bind(ActiveConnectionPermissionSet.class);
bind(TrackedActiveConnection.class);
bind(ActiveConnectionService.class);
bind(ActiveConnectionPermissionService.class);
public interface DirectoryObjectService<InternalType, ExternalType> {
InternalType retrieveObject(AuthenticatedUser user, String identifier)
throws GuacamoleException;
Collection<InternalType> retrieveObjects(AuthenticatedUser user,
Collection<String> identifiers) throws GuacamoleException;
InternalType createObject(AuthenticatedUser user, ExternalType object)
throws GuacamoleException;
void deleteObject(AuthenticatedUser user, String identifier)
throws GuacamoleException;
void updateObject(AuthenticatedUser user, InternalType object)
throws GuacamoleException;
Set<String> getIdentifiers(AuthenticatedUser user) throws GuacamoleException;
public abstract class ModeledDirectoryObject<ModelType extends ObjectModel>
public interface ModeledDirectoryObjectMapper<ModelType> {
public abstract class ModeledGroupedDirectoryObject<ModelType extends GroupedObjectModel>
extends ModeledDirectoryObject<ModelType> {
public abstract class ModeledGroupedDirectoryObjectService<InternalType extends ModeledGroupedDirectoryObject<ModelType>,
extends ModeledDirectoryObjectService<InternalType, ExternalType, ModelType> {
import org.glyptodon.guacamole.auth.jdbc.base.ModeledDirectoryObjectMapper;
public interface ConnectionMapper extends ModeledDirectoryObjectMapper<ConnectionModel> {
import org.glyptodon.guacamole.auth.jdbc.base.ModeledDirectoryObjectMapper;
import org.glyptodon.guacamole.auth.jdbc.base.ModeledGroupedDirectoryObjectService;
public class ConnectionService extends ModeledGroupedDirectoryObjectService<ModeledConnection, Connection, ConnectionModel> {
protected ModeledDirectoryObjectMapper<ConnectionModel> getObjectMapper() {
import org.glyptodon.guacamole.auth.jdbc.base.ModeledGroupedDirectoryObject;
public class ModeledConnection extends ModeledGroupedDirectoryObject<ConnectionModel>
import org.glyptodon.guacamole.auth.jdbc.base.ModeledDirectoryObjectMapper;
public interface ConnectionGroupMapper extends ModeledDirectoryObjectMapper<ConnectionGroupModel> {
import org.glyptodon.guacamole.auth.jdbc.base.ModeledDirectoryObjectMapper;
import org.glyptodon.guacamole.auth.jdbc.base.ModeledGroupedDirectoryObjectService;
public class ConnectionGroupService extends ModeledGroupedDirectoryObjectService<ModeledConnectionGroup,
protected ModeledDirectoryObjectMapper<ConnectionGroupModel> getObjectMapper() {
import org.glyptodon.guacamole.auth.jdbc.base.ModeledGroupedDirectoryObject;
public class ModeledConnectionGroup extends ModeledGroupedDirectoryObject<ConnectionGroupModel>
public class ConnectionGroupPermissionService extends ModeledObjectPermissionService {
public class ConnectionPermissionService extends ModeledObjectPermissionService {
public interface ObjectPermissionService
extends PermissionService<ObjectPermissionSet, ObjectPermission> {
ObjectPermission retrievePermission(AuthenticatedUser user,
String identifier) throws GuacamoleException;
Collection<String> retrieveAccessibleIdentifiers(AuthenticatedUser user,
Collection<String> identifiers) throws GuacamoleException;
public interface PermissionService<PermissionSetType extends PermissionSet<PermissionType>,
PermissionType extends Permission> {
PermissionSetType getPermissionSet(AuthenticatedUser user,
Set<PermissionType> retrievePermissions(AuthenticatedUser user,
ModeledUser targetUser) throws GuacamoleException;
void createPermissions(AuthenticatedUser user, ModeledUser targetUser,
void deletePermissions(AuthenticatedUser user, ModeledUser targetUser,
extends ModeledPermissionService<SystemPermissionSet, SystemPermission, SystemPermissionModel> {
public class UserPermissionService extends ModeledObjectPermissionService {
private final Map<String, ActiveConnectionRecord> activeTunnels =
new ConcurrentHashMap<String, ActiveConnectionRecord>();
public Collection<ActiveConnectionRecord> getActiveConnections(AuthenticatedUser user)
public ActiveConnectionRecord getActiveConnection(AuthenticatedUser user,
public Collection<ActiveConnectionRecord> getActiveConnections(Connection connection) {
public Collection<ActiveConnectionRecord> getActiveConnections(ConnectionGroup connectionGroup) {
private final Map<String, Set<ActiveConnectionRecord>> records =
new HashMap<String, Set<ActiveConnectionRecord>>();
public void put(String identifier, ActiveConnectionRecord record) {
Set<ActiveConnectionRecord> connections = records.get(identifier);
connections = Collections.synchronizedSet(Collections.newSetFromMap(new LinkedHashMap<ActiveConnectionRecord, Boolean>()));
public void remove(String identifier, ActiveConnectionRecord record) {
Set<ActiveConnectionRecord> connections = records.get(identifier);
public Collection<ActiveConnectionRecord> get(String identifier) {
Collection<ActiveConnectionRecord> connections = records.get(identifier);
public Collection<ActiveConnectionRecord> getActiveConnections(AuthenticatedUser user)
public ActiveConnectionRecord getActiveConnection(AuthenticatedUser user,
public Collection<ActiveConnectionRecord> getActiveConnections(Connection connection);
public Collection<ActiveConnectionRecord> getActiveConnections(ConnectionGroup connectionGroup);
import org.glyptodon.guacamole.auth.jdbc.base.ModeledDirectoryObject;
import org.glyptodon.guacamole.auth.jdbc.activeconnection.ActiveConnectionPermissionService;
public class ModeledUser extends ModeledDirectoryObject<UserModel> implements User {
@Inject
private ActiveConnectionPermissionService activeConnectionPermissionService;
public ObjectPermissionSet getActiveConnectionPermissions()
throws GuacamoleException {
return activeConnectionPermissionService.getPermissionSet(getCurrentUser(), this);
}
@Override
import org.glyptodon.guacamole.auth.jdbc.activeconnection.ActiveConnectionDirectory;
import org.glyptodon.guacamole.net.auth.ActiveConnection;
@Inject
private ActiveConnectionDirectory activeConnectionDirectory;
activeConnectionDirectory.init(currentUser);
public Directory<ActiveConnection> getActiveConnectionDirectory()
throws GuacamoleException {
return activeConnectionDirectory;
}
@Override
import org.glyptodon.guacamole.auth.jdbc.base.ModeledDirectoryObjectMapper;
public interface UserMapper extends ModeledDirectoryObjectMapper<UserModel> {
import org.glyptodon.guacamole.auth.jdbc.base.ModeledDirectoryObjectMapper;
import org.glyptodon.guacamole.auth.jdbc.base.ModeledDirectoryObjectService;
public class UserService extends ModeledDirectoryObjectService<ModeledUser, User, UserModel> {
protected ModeledDirectoryObjectMapper<UserModel> getObjectMapper() {
ObjectPermissionSet getActiveConnectionPermissions()
throws GuacamoleException;
Directory<ActiveConnection> getActiveConnectionDirectory()
throws GuacamoleException;
@Override
public ObjectPermissionSet getActiveConnectionPermissions()
throws GuacamoleException {
return new SimpleObjectPermissionSet();
}
import org.glyptodon.guacamole.net.auth.ActiveConnection;
public Directory<ActiveConnection> getActiveConnectionDirectory()
return new SimpleDirectory<ActiveConnection>();
import org.glyptodon.guacamole.net.basic.rest.activeconnection.ActiveConnectionRESTService;
bind(ActiveConnectionRESTService.class);
package org.glyptodon.guacamole.net.basic.rest.activeconnection;
import org.glyptodon.guacamole.net.auth.ActiveConnection;
public class APIActiveConnection {
private final String connectionIdentifier;
public APIActiveConnection(ActiveConnection connection) {
this.identifier           = connection.getIdentifier();
this.connectionIdentifier = connection.getConnectionIdentifier();
this.startDate            = connection.getStartDate();
this.remoteHost           = connection.getRemoteHost();
this.username             = connection.getUsername();
public String getConnectionIdentifier() {
return connectionIdentifier;
public String getIdentifier() {
return identifier;
private Map<String, Set<ObjectPermission.Type>> activeConnectionPermissions =
new HashMap<String, Set<ObjectPermission.Type>>();
addSystemPermissions(systemPermissions,           user.getSystemPermissions());
addObjectPermissions(connectionPermissions,       user.getConnectionPermissions());
addObjectPermissions(connectionGroupPermissions,  user.getConnectionGroupPermissions());
addObjectPermissions(activeConnectionPermissions, user.getActiveConnectionPermissions());
addObjectPermissions(userPermissions,             user.getUserPermissions());
public Map<String, Set<ObjectPermission.Type>> getActiveConnectionPermissions() {
return activeConnectionPermissions;
}
public void setActiveConnectionPermissions(Map<String, Set<ObjectPermission.Type>> activeConnectionPermissions) {
this.activeConnectionPermissions = activeConnectionPermissions;
}
@Override
public ObjectPermissionSet getActiveConnectionPermissions()
throws GuacamoleException {
throw new GuacamoleUnsupportedException("APIUserWrapper does not provide permission access.");
}
private static final String ACTIVE_CONNECTION_PERMISSION_PATCH_PATH_PREFIX = "/activeConnectionPermissions/";
PermissionSetPatch<ObjectPermission> connectionPermissionPatch       = new PermissionSetPatch<ObjectPermission>();
PermissionSetPatch<ObjectPermission> connectionGroupPermissionPatch  = new PermissionSetPatch<ObjectPermission>();
PermissionSetPatch<ObjectPermission> activeConnectionPermissionPatch = new PermissionSetPatch<ObjectPermission>();
PermissionSetPatch<ObjectPermission> userPermissionPatch             = new PermissionSetPatch<ObjectPermission>();
PermissionSetPatch<SystemPermission> systemPermissionPatch           = new PermissionSetPatch<SystemPermission>();
else if (path.startsWith(ACTIVE_CONNECTION_PERMISSION_PATCH_PATH_PREFIX)) {
String identifier = path.substring(ACTIVE_CONNECTION_PERMISSION_PATCH_PATH_PREFIX.length());
ObjectPermission.Type type = ObjectPermission.Type.valueOf(patch.getValue());
ObjectPermission permission = new ObjectPermission(type, identifier);
updatePermissionSet(patch.getOp(), activeConnectionPermissionPatch, permission);
}
activeConnectionPermissionPatch.apply(user.getActiveConnectionPermissions());
protected GuacamoleClientInformation getClientInformation(TunnelRequest request) {
return info;
}
protected GuacamoleTunnel createConnectedTunnel(TunnelRequest request, GuacamoleSession session,
GuacamoleClientInformation info) throws GuacamoleException {
String id = request.getParameter("id");
TunnelRequest.IdentifierType id_type = TunnelRequest.IdentifierType.getType(id);
if (id_type == null)
throw new GuacamoleClientException("Illegal identifier - unknown type.");
id = id.substring(id_type.PREFIX.length());
return tunnel;
}
protected GuacamoleTunnel createAssociatedTunnel(GuacamoleTunnel tunnel, final String authToken) {
return new DelegatingGuacamoleTunnel(tunnel) {
}
public GuacamoleTunnel createTunnel(TunnelRequest request)
throws GuacamoleException {
final String authToken = request.getParameter("authToken");
final GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
final GuacamoleClientInformation info = getClientInformation(request);
final GuacamoleTunnel tunnel = createConnectedTunnel(request, session, info);
final GuacamoleTunnel monitoredTunnel = createAssociatedTunnel(tunnel, authToken);
protected GuacamoleTunnel createConnectedTunnel(UserContext context, String id,
TunnelRequest.IdentifierType id_type = TunnelRequest.IdentifierType.getType(id);
protected GuacamoleTunnel createAssociatedTunnel(final GuacamoleSession session,
GuacamoleTunnel tunnel) throws GuacamoleException {
GuacamoleTunnel monitoredTunnel = new DelegatingGuacamoleTunnel(tunnel) {
if (!notifyConnect(session, monitoredTunnel)) {
logger.info("Successful connection canceled by hook.");
return null;
}
session.addTunnel(monitoredTunnel);
return monitoredTunnel;
final String id = request.getParameter("id");
final GuacamoleTunnel tunnel = createConnectedTunnel(session.getUserContext(), id, info);
return createAssociatedTunnel(session, tunnel);
protected GuacamoleClientInformation getClientInformation(TunnelRequest request) {
return info;
}
protected GuacamoleTunnel createConnectedTunnel(UserContext context, String id,
GuacamoleClientInformation info) throws GuacamoleException {
TunnelRequest.IdentifierType id_type = TunnelRequest.IdentifierType.getType(id);
if (id_type == null)
throw new GuacamoleClientException("Illegal identifier - unknown type.");
id = id.substring(id_type.PREFIX.length());
return tunnel;
}
protected GuacamoleTunnel createAssociatedTunnel(final GuacamoleSession session,
GuacamoleTunnel tunnel) throws GuacamoleException {
}
public GuacamoleTunnel createTunnel(TunnelRequest request)
throws GuacamoleException {
final String authToken = request.getParameter("authToken");
final GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
final String id = request.getParameter("id");
final GuacamoleClientInformation info = getClientInformation(request);
final GuacamoleTunnel tunnel = createConnectedTunnel(session.getUserContext(), id, info);
return createAssociatedTunnel(session, tunnel);
protected GuacamoleClientInformation getClientInformation(TunnelRequest request) {
return info;
}
protected GuacamoleTunnel createConnectedTunnel(UserContext context, String id,
GuacamoleClientInformation info) throws GuacamoleException {
TunnelRequest.IdentifierType id_type = TunnelRequest.IdentifierType.getType(id);
if (id_type == null)
throw new GuacamoleClientException("Illegal identifier - unknown type.");
id = id.substring(id_type.PREFIX.length());
return tunnel;
}
protected GuacamoleTunnel createAssociatedTunnel(final GuacamoleSession session,
GuacamoleTunnel tunnel) throws GuacamoleException {
}
public GuacamoleTunnel createTunnel(TunnelRequest request)
throws GuacamoleException {
final String authToken = request.getParameter("authToken");
final GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
final String id = request.getParameter("id");
final GuacamoleClientInformation info = getClientInformation(request);
final GuacamoleTunnel tunnel = createConnectedTunnel(session.getUserContext(), id, info);
return createAssociatedTunnel(session, tunnel);
boolean isAdmin = targetUser.isAdministrator();
permissions.add(new ObjectPermission(ObjectPermission.Type.READ, identifier));
if (isAdmin)
permissions.add(new ObjectPermission(ObjectPermission.Type.DELETE, identifier));
import java.util.Collections;
Collection<TrackedActiveConnection> objects = retrieveObjects(user, Collections.singleton(identifier));
if (objects.isEmpty())
assert(objects.size() == 1);
return objects.iterator().next();
Set<String> identifierSet = new HashSet<String>(identifiers);
Collection<ActiveConnectionRecord> records = tunnelService.getActiveConnections(user);
Collection<TrackedActiveConnection> activeConnections = new ArrayList<TrackedActiveConnection>(identifiers.size());
for (ActiveConnectionRecord record : records) {
if (identifierSet.contains(record.getUUID().toString())) {
TrackedActiveConnection activeConnection = trackedActiveConnectionProvider.get();
activeConnection.init(user, record);
}
if (!user.getUser().isAdministrator())
throw new GuacamoleSecurityException("Permission denied.");
import java.util.HashSet;
import java.util.Set;
Collection<ActiveConnectionRecord> records = activeTunnels.values();
if (records.isEmpty())
Set<String> identifiers = new HashSet<String>(records.size());
for (ActiveConnectionRecord record : records)
identifiers.add(record.getConnection().getIdentifier());
Collection<ConnectionModel> connections = connectionMapper.selectReadable(user.getUser().getModel(), identifiers);
identifiers.clear();
for (ConnectionModel connection : connections)
identifiers.add(connection.getIdentifier());
Collection<ActiveConnectionRecord> visibleRecords = new ArrayList<ActiveConnectionRecord>(records.size());
for (ActiveConnectionRecord record : records) {
if (identifiers.contains(record.getConnection().getIdentifier()))
visibleRecords.add(record);
}
return visibleRecords;
boolean isAdmin = user.getUser().isAdministrator();
activeConnection.init(user, record, isAdmin);
ActiveConnectionRecord activeConnectionRecord,
boolean includeSensitiveInformation) {
if (includeSensitiveInformation) {
this.remoteHost = activeConnectionRecord.getRemoteHost();
this.tunnel     = activeConnectionRecord.getTunnel();
this.username   = activeConnectionRecord.getUsername();
}
boolean isAdmin = targetUser.isAdministrator();
permissions.add(new ObjectPermission(ObjectPermission.Type.READ, identifier));
if (isAdmin)
permissions.add(new ObjectPermission(ObjectPermission.Type.DELETE, identifier));
import java.util.Collections;
Collection<TrackedActiveConnection> objects = retrieveObjects(user, Collections.singleton(identifier));
if (objects.isEmpty())
assert(objects.size() == 1);
return objects.iterator().next();
boolean isAdmin = user.getUser().isAdministrator();
Set<String> identifierSet = new HashSet<String>(identifiers);
Collection<ActiveConnectionRecord> records = tunnelService.getActiveConnections(user);
Collection<TrackedActiveConnection> activeConnections = new ArrayList<TrackedActiveConnection>(identifiers.size());
for (ActiveConnectionRecord record : records) {
if (identifierSet.contains(record.getUUID().toString())) {
TrackedActiveConnection activeConnection = trackedActiveConnectionProvider.get();
activeConnection.init(user, record, isAdmin);
}
if (!user.getUser().isAdministrator())
throw new GuacamoleSecurityException("Permission denied.");
ActiveConnectionRecord activeConnectionRecord,
boolean includeSensitiveInformation) {
if (includeSensitiveInformation) {
this.remoteHost = activeConnectionRecord.getRemoteHost();
this.tunnel     = activeConnectionRecord.getTunnel();
this.username   = activeConnectionRecord.getUsername();
}
import java.util.HashSet;
import java.util.Set;
Collection<ActiveConnectionRecord> records = activeTunnels.values();
if (records.isEmpty())
Set<String> identifiers = new HashSet<String>(records.size());
for (ActiveConnectionRecord record : records)
identifiers.add(record.getConnection().getIdentifier());
Collection<ConnectionModel> connections = connectionMapper.selectReadable(user.getUser().getModel(), identifiers);
identifiers.clear();
for (ConnectionModel connection : connections)
identifiers.add(connection.getIdentifier());
Collection<ActiveConnectionRecord> visibleRecords = new ArrayList<ActiveConnectionRecord>(records.size());
for (ActiveConnectionRecord record : records) {
if (identifiers.contains(record.getConnection().getIdentifier()))
visibleRecords.add(record);
}
return visibleRecords;
import javax.ws.rs.core.MultivaluedMap;
import org.glyptodon.guacamole.net.basic.rest.APIRequest;
@Context HttpServletRequest consumedRequest,
MultivaluedMap<String, String> parameters)
throws GuacamoleException {
HttpServletRequest request = new APIRequest(consumedRequest, parameters);
import javax.ws.rs.core.MultivaluedMap;
import org.glyptodon.guacamole.net.basic.rest.APIRequest;
@Context HttpServletRequest consumedRequest,
MultivaluedMap<String, String> parameters)
throws GuacamoleException {
HttpServletRequest request = new APIRequest(consumedRequest, parameters);
if (message == null) {
session.detachTunnel(tunnel);
}
session.detachTunnel(tunnel);
tunnel.close();
if (message == null) {
session.detachTunnel(tunnel);
}
session.detachTunnel(tunnel);
tunnel.close();
package org.glyptodon.guacamole.form;
public class ParameterOption {
public ParameterOption() {
}
public ParameterOption(String value, String title) {
this.value = value;
this.title = title;
}
import org.glyptodon.guacamole.form.Parameter;
private Collection<Parameter> parameters;
public ProtocolInfo() {
this.parameters = new ArrayList<Parameter>();
}
public ProtocolInfo(String name, String title) {
this.name       = name;
this.title      = title;
this.parameters = new ArrayList<Parameter>();
}
public ProtocolInfo(String name, String title, Collection<Parameter> parameters) {
this.name       = name;
this.title      = title;
this.parameters = parameters;
}
public Collection<Parameter> getParameters() {
public void setParameters(Collection<Parameter> parameters) {
this.parameters = parameters;
}
import org.glyptodon.guacamole.form.ParameterOption;
private ParameterOption option = new ParameterOption();
public ParameterOption asParameterOption() {
import org.glyptodon.guacamole.form.Parameter;
private Parameter protocolParameter = new Parameter();
protocolParameter.setType(Parameter.Type.TEXT);
protocolParameter.setType(Parameter.Type.NUMERIC);
protocolParameter.setType(Parameter.Type.USERNAME);
protocolParameter.setType(Parameter.Type.PASSWORD);
protocolParameter.setType(Parameter.Type.ENUM);
protocolParameter.setType(Parameter.Type.MULTILINE);
protocolParameter.setType(Parameter.Type.BOOLEAN);
tagHandler.asParameterOption());
public Parameter asParameter() {
info.getParameters().add(tagHandler.asParameter());
import org.glyptodon.guacamole.net.auth.credentials.CredentialsInfo;
import org.glyptodon.guacamole.net.auth.credentials.GuacamoleInvalidCredentialsException;
if (userContext == null)
throw new GuacamoleInvalidCredentialsException("Permission Denied.",
CredentialsInfo.USERNAME_PASSWORD);
catch (GuacamoleException e) {
throw e;
import org.glyptodon.guacamole.net.auth.credentials.CredentialsInfo;
import org.glyptodon.guacamole.net.auth.credentials.GuacamoleInsufficientCredentialsException;
import org.glyptodon.guacamole.net.auth.credentials.GuacamoleInvalidCredentialsException;
catch (GuacamoleInsufficientCredentialsException e) {
String message = e.getMessage();
if (message == null)
message = "Permission denied.";
throw new HTTPException(Response.Status.FORBIDDEN, new APICredentialError(
APICredentialError.Type.INSUFFICIENT,
message,
e.getCredentialsInfo()
));
catch (GuacamoleInvalidCredentialsException e) {
String message = e.getMessage();
if (message == null)
message = "Permission denied.";
throw new HTTPException(Response.Status.FORBIDDEN, new APICredentialError(
APICredentialError.Type.INVALID,
message,
e.getCredentialsInfo()
));
catch (GuacamoleSecurityException e) {
String message = e.getMessage();
if (message == null)
message = "Permission denied.";
throw new HTTPException(Response.Status.FORBIDDEN, message);
}
catch (GuacamoleClientException e) {
String message = e.getMessage();
if (message == null)
message = "Invalid request.";
throw new HTTPException(Response.Status.BAD_REQUEST, message);
}
catch (GuacamoleException e) {
String message = e.getMessage();
if (message == null)
message = "Unexpected server error.";
logger.debug("Unexpected exception in REST endpoint.", e);
throw new HTTPException(Response.Status.INTERNAL_SERVER_ERROR, message);
import java.util.Collection;
import javax.ws.rs.core.Response;
import org.glyptodon.guacamole.form.Parameter;
private final Collection<Parameter> expected;
private final Type type;
public enum Type {
BAD_REQUEST(Response.Status.BAD_REQUEST),
INVALID_CREDENTIALS(Response.Status.FORBIDDEN),
INSUFFICIENT_CREDENTIALS(Response.Status.FORBIDDEN),
INTERNAL_ERROR(Response.Status.INTERNAL_SERVER_ERROR),
NOT_FOUND(Response.Status.NOT_FOUND),
PERMISSION_DENIED(Response.Status.FORBIDDEN);
private final Response.Status status;
Type(Response.Status status) {
this.status = status;
}
public Response.Status getStatus() {
return status;
}
}
public APIError(Type type, String message) {
this.type     = type;
this.message  = message;
this.expected = null;
}
public APIError(Type type, String message, Collection<Parameter> expected) {
this.type     = type;
this.message  = message;
this.expected = expected;
}
public Type getType() {
return type;
}
public Collection<Parameter> getExpected() {
return expected;
}
import org.glyptodon.guacamole.GuacamoleResourceNotFoundException;
throw new HTTPException(
APIError.Type.INSUFFICIENT_CREDENTIALS,
message,
e.getCredentialsInfo().getParameters()
);
throw new HTTPException(
APIError.Type.INVALID_CREDENTIALS,
message,
e.getCredentialsInfo().getParameters()
);
throw new HTTPException(
APIError.Type.PERMISSION_DENIED,
message
);
catch (GuacamoleResourceNotFoundException e) {
String message = e.getMessage();
if (message == null)
message = "Not found.";
throw new HTTPException(
APIError.Type.NOT_FOUND,
message
);
}
throw new HTTPException(
APIError.Type.BAD_REQUEST,
message
);
throw new HTTPException(
APIError.Type.INTERNAL_ERROR,
message
);
import java.util.Collection;
import org.glyptodon.guacamole.form.Parameter;
public HTTPException(APIError error) {
super(Response.status(error.getType().getStatus()).entity(error).build());
public HTTPException(APIError.Type type, String message) {
this(new APIError(type, message));
public HTTPException(APIError.Type type, String message, Collection<Parameter> expected) {
this(new APIError(type, message, expected));
}
import org.glyptodon.guacamole.net.basic.rest.APIError;
throw new HTTPException(APIError.Type.NOT_FOUND, "No such token.");
import org.glyptodon.guacamole.net.basic.rest.APIError;
throw new HTTPException(APIError.Type.BAD_REQUEST,
throw new HTTPException(APIError.Type.PERMISSION_DENIED,
throw new HTTPException(APIError.Type.PERMISSION_DENIED,
throw new HTTPException(APIError.Type.BAD_REQUEST,
public class APIException extends WebApplicationException {
public APIException(APIError error) {
public APIException(APIError.Type type, String message) {
public APIException(APIError.Type type, String message, Collection<Parameter> expected) {
throw new APIException(
throw new APIException(
throw new APIException(
throw new APIException(
throw new APIException(
throw new APIException(
import org.glyptodon.guacamole.net.basic.rest.APIException;
throw new APIException(APIError.Type.NOT_FOUND, "No such token.");
import org.glyptodon.guacamole.net.basic.rest.APIException;
throw new APIException(APIError.Type.BAD_REQUEST,
throw new APIException(APIError.Type.PERMISSION_DENIED,
throw new APIException(APIError.Type.PERMISSION_DENIED,
throw new APIException(APIError.Type.BAD_REQUEST,
package org.glyptodon.guacamole.form;
public class ParameterOption {
public ParameterOption() {
}
public ParameterOption(String value, String title) {
this.value = value;
this.title = title;
}
import org.glyptodon.guacamole.form.Parameter;
private Collection<Parameter> parameters;
public ProtocolInfo() {
this.parameters = new ArrayList<Parameter>();
}
public ProtocolInfo(String name, String title) {
this.name       = name;
this.title      = title;
this.parameters = new ArrayList<Parameter>();
}
public ProtocolInfo(String name, String title, Collection<Parameter> parameters) {
this.name       = name;
this.title      = title;
this.parameters = parameters;
}
public Collection<Parameter> getParameters() {
public void setParameters(Collection<Parameter> parameters) {
this.parameters = parameters;
}
import org.glyptodon.guacamole.form.ParameterOption;
private ParameterOption option = new ParameterOption();
public ParameterOption asParameterOption() {
import org.glyptodon.guacamole.form.Parameter;
private Parameter protocolParameter = new Parameter();
protocolParameter.setType(Parameter.Type.TEXT);
protocolParameter.setType(Parameter.Type.NUMERIC);
protocolParameter.setType(Parameter.Type.USERNAME);
protocolParameter.setType(Parameter.Type.PASSWORD);
protocolParameter.setType(Parameter.Type.ENUM);
protocolParameter.setType(Parameter.Type.MULTILINE);
protocolParameter.setType(Parameter.Type.BOOLEAN);
tagHandler.asParameterOption());
public Parameter asParameter() {
info.getParameters().add(tagHandler.asParameter());
import java.util.Collection;
import javax.ws.rs.core.Response;
import org.glyptodon.guacamole.form.Parameter;
private final Collection<Parameter> expected;
private final Type type;
public enum Type {
BAD_REQUEST(Response.Status.BAD_REQUEST),
INVALID_CREDENTIALS(Response.Status.FORBIDDEN),
INSUFFICIENT_CREDENTIALS(Response.Status.FORBIDDEN),
INTERNAL_ERROR(Response.Status.INTERNAL_SERVER_ERROR),
NOT_FOUND(Response.Status.NOT_FOUND),
PERMISSION_DENIED(Response.Status.FORBIDDEN);
private final Response.Status status;
Type(Response.Status status) {
this.status = status;
}
public Response.Status getStatus() {
return status;
}
}
public APIError(Type type, String message) {
this.type     = type;
this.message  = message;
this.expected = null;
}
public APIError(Type type, String message, Collection<Parameter> expected) {
this.type     = type;
this.message  = message;
this.expected = expected;
}
public Type getType() {
return type;
}
public Collection<Parameter> getExpected() {
return expected;
}
import org.glyptodon.guacamole.GuacamoleResourceNotFoundException;
import org.glyptodon.guacamole.net.auth.credentials.CredentialsInfo;
import org.glyptodon.guacamole.net.auth.credentials.GuacamoleInsufficientCredentialsException;
import org.glyptodon.guacamole.net.auth.credentials.GuacamoleInvalidCredentialsException;
catch (GuacamoleInsufficientCredentialsException e) {
String message = e.getMessage();
if (message == null)
message = "Permission denied.";
throw new APIException(
APIError.Type.INSUFFICIENT_CREDENTIALS,
message,
e.getCredentialsInfo().getParameters()
);
catch (GuacamoleInvalidCredentialsException e) {
String message = e.getMessage();
if (message == null)
message = "Permission denied.";
throw new APIException(
APIError.Type.INVALID_CREDENTIALS,
message,
e.getCredentialsInfo().getParameters()
);
catch (GuacamoleSecurityException e) {
String message = e.getMessage();
if (message == null)
message = "Permission denied.";
throw new APIException(
APIError.Type.PERMISSION_DENIED,
message
);
}
catch (GuacamoleResourceNotFoundException e) {
String message = e.getMessage();
if (message == null)
message = "Not found.";
throw new APIException(
APIError.Type.NOT_FOUND,
message
);
}
catch (GuacamoleClientException e) {
String message = e.getMessage();
if (message == null)
message = "Invalid request.";
throw new APIException(
APIError.Type.BAD_REQUEST,
message
);
}
catch (GuacamoleException e) {
String message = e.getMessage();
if (message == null)
message = "Unexpected server error.";
logger.debug("Unexpected exception in REST endpoint.", e);
throw new APIException(
APIError.Type.INTERNAL_ERROR,
message
);
import org.glyptodon.guacamole.net.auth.credentials.CredentialsInfo;
import org.glyptodon.guacamole.net.auth.credentials.GuacamoleInvalidCredentialsException;
import org.glyptodon.guacamole.net.basic.rest.APIError;
import org.glyptodon.guacamole.net.basic.rest.APIException;
if (userContext == null)
throw new GuacamoleInvalidCredentialsException("Permission Denied.",
CredentialsInfo.USERNAME_PASSWORD);
catch (GuacamoleException e) {
throw e;
throw new APIException(APIError.Type.NOT_FOUND, "No such token.");
import org.glyptodon.guacamole.net.basic.rest.APIError;
import org.glyptodon.guacamole.net.basic.rest.APIException;
throw new APIException(APIError.Type.BAD_REQUEST,
throw new APIException(APIError.Type.PERMISSION_DENIED,
throw new APIException(APIError.Type.PERMISSION_DENIED,
throw new APIException(APIError.Type.BAD_REQUEST,
import org.glyptodon.guacamole.net.basic.rest.language.LanguageRESTService;
bind(ClipboardRESTService.class);
bind(ConnectionGroupRESTService.class);
bind(ConnectionRESTService.class);
bind(LanguageRESTService.class);
bind(ProtocolRESTService.class);
bind(TokenRESTService.class);
bind(UserRESTService.class);
private static final String TRANSLATION_PATH = "/translations";
Set<String> resourcePaths = servletContext.getResourcePaths(TRANSLATION_PATH);
for (String resourcePath : resourcePaths) {
import org.glyptodon.guacamole.net.basic.rest.language.LanguageRESTService;
bind(ClipboardRESTService.class);
bind(ConnectionGroupRESTService.class);
bind(ConnectionRESTService.class);
bind(LanguageRESTService.class);
bind(ProtocolRESTService.class);
bind(TokenRESTService.class);
bind(UserRESTService.class);
package org.glyptodon.guacamole.net.basic.rest.language;
if (model.getName() == null || model.getName().trim().isEmpty())
if (model.getName() == null || model.getName().trim().isEmpty())
if (value == null || value.isEmpty())
if (model.getName() == null || model.getName().trim().isEmpty())
if (model.getName() == null || model.getName().trim().isEmpty())
if (model.getIdentifier() == null || model.getIdentifier().trim().isEmpty())
if (model.getIdentifier() == null || model.getIdentifier().trim().isEmpty())
if (model.getName() == null || model.getName().trim().isEmpty())
if (model.getName() == null || model.getName().trim().isEmpty())
if (value == null || value.isEmpty())
if (model.getName() == null || model.getName().trim().isEmpty())
if (model.getName() == null || model.getName().trim().isEmpty())
if (model.getIdentifier() == null || model.getIdentifier().trim().isEmpty())
if (model.getIdentifier() == null || model.getIdentifier().trim().isEmpty())
import org.glyptodon.guacamole.net.SimpleGuacamoleTunnel;
GuacamoleTunnel tunnel = new SimpleGuacamoleTunnel(socket);
return Collections.<InternalType>emptyList();
return Collections.<String>emptyList();
return Collections.<ModeledConnection>emptyList();
return Collections.<ModeledConnection>emptyList();
return Collections.<ActiveConnectionRecord>emptyList();
return Collections.<ActiveConnectionRecord>emptyList();
return Collections.<ActiveConnectionRecord>emptyList();
public static final CredentialsInfo EMPTY = new CredentialsInfo(Collections.<Parameter>emptyList());
return Collections.<ConnectionRecord>emptyList();
private Map<String, ObjectType> objects = Collections.<String, ObjectType>emptyMap();
private Set<ObjectPermission> permissions = Collections.<ObjectPermission>emptySet();
private Set<SystemPermission> permissions = Collections.<SystemPermission>emptySet();
connectionIdentifiers, Collections.<String>emptyList()
return Collections.<ConnectionRecord>emptyList();
return Collections.<String, String>emptyMap();
import org.glyptodon.guacamole.environment.Environment;
import org.glyptodon.guacamole.environment.LocalEnvironment;
private final Environment environment;
public LDAPAuthenticationProvider() throws GuacamoleException {
environment = new LocalEnvironment();
}
environment.getRequiredProperty(LDAPGuacamoleProperties.LDAP_HOSTNAME),
environment.getRequiredProperty(LDAPGuacamoleProperties.LDAP_PORT)
String username_attribute = environment.getRequiredProperty(
String user_base_dn = environment.getRequiredProperty(
String config_base_dn = environment.getRequiredProperty(
import org.glyptodon.guacamole.environment.Environment;
import org.glyptodon.guacamole.environment.LocalEnvironment;
private final Environment environment;
public NoAuthenticationProvider() throws GuacamoleException {
environment = new LocalEnvironment();
}
return environment.getRequiredProperty(NOAUTH_CONFIG);
import org.glyptodon.guacamole.environment.Environment;
import org.glyptodon.guacamole.environment.LocalEnvironment;
private final Environment environment;
public BasicFileAuthenticationProvider() throws GuacamoleException {
environment = new LocalEnvironment();
}
environment.getRequiredProperty(BASIC_USER_MAPPING);
import org.glyptodon.guacamole.environment.Environment;
import org.glyptodon.guacamole.environment.LocalEnvironment;
Environment environment = new LocalEnvironment();
environment.getProperty(BasicGuacamoleProperties.LIB_DIRECTORY)
import org.glyptodon.guacamole.environment.Environment;
public GuacamoleSession(Environment environment, Credentials credentials,
UserContext userContext) throws GuacamoleException {
environment.getProperty(BasicGuacamoleProperties.EVENT_LISTENERS);
import org.glyptodon.guacamole.environment.Environment;
@Inject
private Environment environment;
if (environment.getProperty(ClipboardRESTService.INTEGRATION_ENABLED, false)) {
import org.glyptodon.guacamole.environment.Environment;
import org.glyptodon.guacamole.environment.LocalEnvironment;
private Environment environment;
environment = new LocalEnvironment();
bind(Environment.class).toInstance(environment);
authProvider = environment.getRequiredProperty(BasicGuacamoleProperties.AUTH_PROVIDER);
import com.google.inject.Inject;
import org.glyptodon.guacamole.environment.Environment;
@Inject
private Environment environment;
sessionTimeoutValue = environment.getProperty(BasicGuacamoleProperties.API_SESSION_TIMEOUT, 60);
import org.glyptodon.guacamole.environment.Environment;
@Inject
private Environment environment;
tokenSessionMap.put(authToken, new GuacamoleSession(environment, credentials, userContext));
import org.glyptodon.guacamole.environment.Environment;
@Inject
private Environment environment;
if (environment.getProperty(INTEGRATION_ENABLED, false)) {
for (Class<?> listenerClass : listenerClasses) {
Class<?> module = (Class<?>) GuacamoleClassLoader.getInstance().findClass(classname);
TunnelLoader loader = (TunnelLoader) module.getConstructor().newInstance();
Set<?> resourcePaths = servletContext.getResourcePaths(TRANSLATION_PATH);
for (Object resourcePathObject : resourcePaths) {
String resourcePath = (String) resourcePathObject;
package org.glyptodon.guacamole.net.basic.inject;
import com.google.inject.Inject;
public class AuthenticationModule extends AbstractModule {
private final Logger logger = LoggerFactory.getLogger(AuthenticationModule.class);
private final Environment environment;
private final TokenSessionMap tokenSessionMap;
public AuthenticationModule(Environment environment,
TokenSessionMap tokenSessionMap) {
this.environment = environment;
this.tokenSessionMap = tokenSessionMap;
bind(TokenSessionMap.class).toInstance(tokenSessionMap);
bind(AuthenticationService.class);
bind(AuthTokenGenerator.class).to(SecureRandomAuthTokenGenerator.class);
AuthenticationProvider authProvider = environment.getRequiredProperty(BasicGuacamoleProperties.AUTH_PROVIDER);
package org.glyptodon.guacamole.net.basic.inject;
import org.glyptodon.guacamole.environment.Environment;
public class EnvironmentModule extends AbstractModule {
private final Environment environment;
public EnvironmentModule(Environment environment) {
this.environment = environment;
}
bind(Environment.class).toInstance(environment);
package org.glyptodon.guacamole.net.basic.inject;
import org.glyptodon.guacamole.environment.Environment;
private final Environment environment;
public LogModule(Environment environment) {
this.environment = environment;
}
File guacamoleHome = environment.getGuacamoleHome();
package org.glyptodon.guacamole.net.basic.inject;
import com.google.inject.matcher.Matchers;
import org.glyptodon.guacamole.net.basic.rest.AuthProviderRESTExceptionWrapper;
import org.glyptodon.guacamole.net.basic.rest.AuthProviderRESTExposure;
import org.glyptodon.guacamole.net.basic.rest.ObjectRetrievalService;
public class RESTModule extends ServletModule {
bindInterceptor(
Matchers.any(),
Matchers.annotatedWith(AuthProviderRESTExposure.class),
new AuthProviderRESTExceptionWrapper()
);
bind(ObjectRetrievalService.class);
package org.glyptodon.guacamole.net.basic.inject;
import org.glyptodon.guacamole.net.basic.BasicGuacamoleTunnelServlet;
import org.glyptodon.guacamole.net.basic.GuacamoleClassLoader;
import org.glyptodon.guacamole.net.basic.TunnelLoader;
import org.glyptodon.guacamole.net.basic.TunnelRequestService;
package org.glyptodon.guacamole.net.basic.inject;
public BasicTokenSessionMap(Environment environment) {
Collection<ParameterModel> parameterModels = new ArrayList<ParameterModel>(parameters.size());
Collection<String> affectedIdentifiers = new HashSet<String>(permissions.size());
Enumeration<?> parameters = parameterAttribute.getStringValues();
String parameter = (String) parameters.nextElement();
package org.glyptodon.guacamole.net.basic;
import org.glyptodon.guacamole.net.basic.log.LogModule;
import org.glyptodon.guacamole.net.basic.rest.RESTAuthModule;
import org.glyptodon.guacamole.net.basic.rest.RESTServletModule;
return Guice.createInjector(Stage.PRODUCTION,
new RESTAuthModule(environment, sessionMap),
new RESTServletModule(),
package org.glyptodon.guacamole.net.basic;
package org.glyptodon.guacamole.net.basic;
package org.glyptodon.guacamole.net.basic.log;
package org.glyptodon.guacamole.net.basic.rest;
public class RESTAuthModule extends AbstractModule {
private final Logger logger = LoggerFactory.getLogger(RESTAuthModule.class);
public RESTAuthModule(Environment environment,
package org.glyptodon.guacamole.net.basic.rest;
public class RESTServletModule extends ServletModule {
import org.glyptodon.guacamole.net.SimpleGuacamoleTunnel;
GuacamoleTunnel tunnel = new SimpleGuacamoleTunnel(socket);
return Collections.<InternalType>emptyList();
return Collections.<String>emptyList();
Collection<ParameterModel> parameterModels = new ArrayList<ParameterModel>(parameters.size());
Collection<String> affectedIdentifiers = new HashSet<String>(permissions.size());
return Collections.<ModeledConnection>emptyList();
return Collections.<ModeledConnection>emptyList();
return Collections.<ActiveConnectionRecord>emptyList();
return Collections.<ActiveConnectionRecord>emptyList();
return Collections.<ActiveConnectionRecord>emptyList();
import org.glyptodon.guacamole.environment.Environment;
import org.glyptodon.guacamole.environment.LocalEnvironment;
private final Environment environment;
public LDAPAuthenticationProvider() throws GuacamoleException {
environment = new LocalEnvironment();
}
environment.getRequiredProperty(LDAPGuacamoleProperties.LDAP_HOSTNAME),
environment.getRequiredProperty(LDAPGuacamoleProperties.LDAP_PORT)
String username_attribute = environment.getRequiredProperty(
String user_base_dn = environment.getRequiredProperty(
String config_base_dn = environment.getRequiredProperty(
Enumeration<?> parameters = parameterAttribute.getStringValues();
String parameter = (String) parameters.nextElement();
import org.glyptodon.guacamole.environment.Environment;
import org.glyptodon.guacamole.environment.LocalEnvironment;
private final Environment environment;
public NoAuthenticationProvider() throws GuacamoleException {
environment = new LocalEnvironment();
}
return environment.getRequiredProperty(NOAUTH_CONFIG);
public static final CredentialsInfo EMPTY = new CredentialsInfo(Collections.<Parameter>emptyList());
return Collections.<ConnectionRecord>emptyList();
private Map<String, ObjectType> objects = Collections.<String, ObjectType>emptyMap();
private Set<ObjectPermission> permissions = Collections.<ObjectPermission>emptySet();
private Set<SystemPermission> permissions = Collections.<SystemPermission>emptySet();
connectionIdentifiers, Collections.<String>emptyList()
import org.glyptodon.guacamole.environment.Environment;
import org.glyptodon.guacamole.environment.LocalEnvironment;
private final Environment environment;
public BasicFileAuthenticationProvider() throws GuacamoleException {
environment = new LocalEnvironment();
}
environment.getRequiredProperty(BASIC_USER_MAPPING);
import com.google.inject.Stage;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.environment.Environment;
import org.glyptodon.guacamole.environment.LocalEnvironment;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
private final Logger logger = LoggerFactory.getLogger(BasicServletContextListener.class);
private Environment environment;
private TokenSessionMap sessionMap;
@Override
public void contextInitialized(ServletContextEvent servletContextEvent) {
try {
environment = new LocalEnvironment();
sessionMap = new BasicTokenSessionMap(environment);
}
catch (GuacamoleException e) {
logger.error("Unable to read guacamole.properties: {}", e.getMessage());
logger.debug("Error reading guacamole.properties.", e);
throw new RuntimeException(e);
}
super.contextInitialized(servletContextEvent);
}
return Guice.createInjector(Stage.PRODUCTION,
new EnvironmentModule(environment),
new LogModule(environment),
new RESTAuthModule(environment, sessionMap),
new RESTServletModule(),
if (sessionMap != null)
sessionMap.shutdown();
package org.glyptodon.guacamole.net.basic;
import org.glyptodon.guacamole.environment.Environment;
public class EnvironmentModule extends AbstractModule {
private final Environment environment;
public EnvironmentModule(Environment environment) {
this.environment = environment;
}
bind(Environment.class).toInstance(environment);
import org.glyptodon.guacamole.environment.Environment;
import org.glyptodon.guacamole.environment.LocalEnvironment;
Environment environment = new LocalEnvironment();
environment.getProperty(BasicGuacamoleProperties.LIB_DIRECTORY)
import org.glyptodon.guacamole.environment.Environment;
public GuacamoleSession(Environment environment, Credentials credentials,
UserContext userContext) throws GuacamoleException {
environment.getProperty(BasicGuacamoleProperties.EVENT_LISTENERS);
for (Class<?> listenerClass : listenerClasses) {
Class<?> module = (Class<?>) GuacamoleClassLoader.getInstance().findClass(classname);
TunnelLoader loader = (TunnelLoader) module.getConstructor().newInstance();
import org.glyptodon.guacamole.environment.Environment;
@Inject
private Environment environment;
if (environment.getProperty(ClipboardRESTService.INTEGRATION_ENABLED, false)) {
import org.glyptodon.guacamole.environment.Environment;
private final Environment environment;
public LogModule(Environment environment) {
this.environment = environment;
}
File guacamoleHome = environment.getGuacamoleHome();
import org.glyptodon.guacamole.environment.Environment;
private final Logger logger = LoggerFactory.getLogger(RESTAuthModule.class);
private final Environment environment;
private final TokenSessionMap tokenSessionMap;
public RESTAuthModule(Environment environment,
TokenSessionMap tokenSessionMap) {
this.environment = environment;
this.tokenSessionMap = tokenSessionMap;
bind(TokenSessionMap.class).toInstance(tokenSessionMap);
bind(AuthenticationService.class);
bind(AuthTokenGenerator.class).to(SecureRandomAuthTokenGenerator.class);
AuthenticationProvider authProvider = environment.getRequiredProperty(BasicGuacamoleProperties.AUTH_PROVIDER);
import com.google.inject.matcher.Matchers;
bindInterceptor(
Matchers.any(),
Matchers.annotatedWith(AuthProviderRESTExposure.class),
new AuthProviderRESTExceptionWrapper()
);
bind(ObjectRetrievalService.class);
import org.glyptodon.guacamole.environment.Environment;
public BasicTokenSessionMap(Environment environment) {
sessionTimeoutValue = environment.getProperty(BasicGuacamoleProperties.API_SESSION_TIMEOUT, 60);
import org.glyptodon.guacamole.environment.Environment;
@Inject
private Environment environment;
tokenSessionMap.put(authToken, new GuacamoleSession(environment, credentials, userContext));
import org.glyptodon.guacamole.environment.Environment;
@Inject
private Environment environment;
if (environment.getProperty(INTEGRATION_ENABLED, false)) {
return Collections.<ConnectionRecord>emptyList();
Set<?> resourcePaths = servletContext.getResourcePaths(TRANSLATION_PATH);
return Collections.<String, String>emptyMap();
for (Object resourcePathObject : resourcePaths) {
String resourcePath = (String) resourcePathObject;
import org.glyptodon.guacamole.net.basic.resource.ResourceServlet;
import org.glyptodon.guacamole.net.basic.resource.WebApplicationResource;
serve("/app.js").with(new ResourceServlet(new WebApplicationResource(getServletContext(), "/guacamole.min.js")));
serve("/app.css").with(new ResourceServlet(new WebApplicationResource(getServletContext(), "/guacamole.min.css")));
import org.glyptodon.guacamole.net.basic.extension.ExtensionModule;
new ExtensionModule(environment),
import java.util.ArrayList;
import java.util.Collection;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.basic.resource.Resource;
import org.glyptodon.guacamole.net.basic.resource.SequenceResource;
File[] extensionFiles = extensionsDir.listFiles(new FileFilter() {
Collection<Resource> javaScriptResources = new ArrayList<Resource>();
javaScriptResources.add(new WebApplicationResource(getServletContext(), "/guacamole.min.js"));
Collection<Resource> cssResources = new ArrayList<Resource>();
cssResources.add(new WebApplicationResource(getServletContext(), "/guacamole.min.css"));
for (File extensionFile : extensionFiles) {
logger.debug("Loading extension: \"{}\"", extensionFile.getName());
try {
Extension extension = new Extension(ExtensionModule.class.getClassLoader(), extensionFile);
javaScriptResources.addAll(extension.getJavaScriptResources());
cssResources.addAll(extension.getCSSResources());
logger.info("Extension \"{}\" loaded.", extension.getName());
}
catch (GuacamoleException e) {
logger.error("Extension \"{}\" could not be loaded: {}", extensionFile.getName(), e.getMessage());
logger.debug("Unable to load extension.", e);
}
serve("/app.js").with(new ResourceServlet(new SequenceResource(javaScriptResources)));
serve("/app.css").with(new ResourceServlet(new SequenceResource(cssResources)));
import org.glyptodon.guacamole.net.auth.AuthenticationProvider;
private final Collection<Resource> javaScriptResources;
private final Collection<Resource> cssResources;
private final Collection<Class<AuthenticationProvider>> authenticationProviderClasses;
private Collection<Resource> getClassPathResources(String mimetype, Collection<String> paths) {
if (paths == null)
return Collections.<Resource>emptyList();
Collection<Resource> resources = new ArrayList<Resource>(paths.size());
for (String path : paths)
resources.add(new ClassPathResource(classLoader, mimetype, path));
return Collections.unmodifiableCollection(resources);
}
private Class<AuthenticationProvider> getAuthenticationProviderClass(String name)
throws GuacamoleException {
try {
Class<?> authenticationProviderClass = classLoader.loadClass(name);
if (!AuthenticationProvider.class.isAssignableFrom(authenticationProviderClass))
throw new GuacamoleServerException("Authentication providers MUST extend the AuthenticationProvider class.");
return (Class<AuthenticationProvider>) authenticationProviderClass;
}
catch (ClassNotFoundException e) {
throw new GuacamoleException("Authentication provider class not found.", e);
}
}
private Collection<Class<AuthenticationProvider>> getAuthenticationProviderClasses(Collection<String> names)
throws GuacamoleException {
if (names == null)
return Collections.<Class<AuthenticationProvider>>emptyList();
Collection<Class<AuthenticationProvider>> classes = new ArrayList<Class<AuthenticationProvider>>(names.size());
for (String name : names)
classes.add(getAuthenticationProviderClass(name));
return Collections.unmodifiableCollection(classes);
}
cssResources = getClassPathResources("text/css", manifest.getCSSPaths());
javaScriptResources = getClassPathResources("text/javascript", manifest.getJavaScriptPaths());
authenticationProviderClasses = getAuthenticationProviderClasses(manifest.getAuthProviders());
return javaScriptResources;
return cssResources;
}
public Collection<Class<AuthenticationProvider>> getAuthenticationProviderClasses() {
return authenticationProviderClasses;
private Collection<String> authProviders;
public Collection<String> getAuthProviders() {
return authProviders;
}
public void setAuthProviders(Collection<String> authProviders) {
this.authProviders = authProviders;
}
import com.google.inject.Singleton;
import org.glyptodon.guacamole.net.auth.AuthenticationProvider;
Collection<Class<AuthenticationProvider>> authenticationProviders = extension.getAuthenticationProviderClasses();
for (Class<AuthenticationProvider> authenticationProvider : authenticationProviders) {
logger.debug("Binding AuthenticationProvider \"{}\".", authenticationProvider);
bind(AuthenticationProvider.class).to(authenticationProvider).in(Singleton.class);
}
AuthenticationProvider authProvider = environment.getProperty(BasicGuacamoleProperties.AUTH_PROVIDER);
if (authProvider != null) {
logger.warn("The \"auth-provider\" is now deprecated. Please use the \"extensions\" directory within GUACAMOLE_HOME instead.");
bind(AuthenticationProvider.class).toInstance(authProvider);
}
logger.warn("Value of deprecated \"auth-provider\" property within guacamole.properties is not valid: {}", e.getMessage());
Class<?> module = Class.forName(classname);
Class.forName("javax.websocket.Endpoint");
Class.forName("org.glyptodon.guacamole.net.basic.websocket.jetty8.BasicGuacamoleWebSocketTunnelServlet");
Class.forName("org.glyptodon.guacamole.net.basic.websocket.jetty9.BasicGuacamoleWebSocketTunnelServlet");
Class.forName("org.glyptodon.guacamole.net.basic.websocket.tomcat.BasicGuacamoleWebSocketTunnelServlet");
private static final String LIB_DIRECTORY = "lib";
private ClassLoader getParentClassLoader() throws GuacamoleException {
File libDir = new File(environment.getGuacamoleHome(), LIB_DIRECTORY);
if (!libDir.isDirectory())
return ExtensionModule.class.getClassLoader();
return DirectoryClassLoader.getInstance(libDir);
}
Extension extension = new Extension(getParentClassLoader(), extensionFile);
logger.warn("The \"auth-provider\" and \"lib-directory\" properties are now deprecated. Please use the \"extensions\" and \"lib\" directories within GUACAMOLE_HOME instead.");
new RESTAuthModule(sessionMap),
@Deprecated
import net.sourceforge.guacamole.net.basic.BasicFileAuthenticationProvider;
import org.glyptodon.guacamole.net.basic.properties.BasicGuacamoleProperties;
private Class<? extends AuthenticationProvider> boundAuthenticationProvider = null;
private Class<AuthenticationProvider> getAuthProviderProperty() {
try {
Class<AuthenticationProvider> authenticationProvider = environment.getProperty(BasicGuacamoleProperties.AUTH_PROVIDER);
if (authenticationProvider != null)
logger.warn("The \"auth-provider\" and \"lib-directory\" properties are now deprecated. Please use the \"extensions\" and \"lib\" directories within GUACAMOLE_HOME instead.");
return authenticationProvider;
}
catch (GuacamoleException e) {
logger.warn("Value of deprecated \"auth-provider\" property within guacamole.properties is not valid: {}", e.getMessage());
logger.debug("Error reading authentication provider from guacamole.properties.", e);
}
return null;
}
private void bindAuthenticationProvider(Class<? extends AuthenticationProvider> authenticationProvider) {
if (boundAuthenticationProvider != null)
boundAuthenticationProvider = authenticationProvider;
else {
logger.debug("Ignoring AuthenticationProvider \"{}\".", authenticationProvider);
logger.warn("Only one authentication extension may be used at a time. Please "
"make sure that only one authentication extension is present "
"directory, and that you are not also specifying the deprecated "
"\"auth-provider\" property within guacamole.properties.");
return;
}
logger.debug("Binding AuthenticationProvider \"{}\".", authenticationProvider);
bind(AuthenticationProvider.class).to(authenticationProvider).in(Singleton.class);
}
Class<AuthenticationProvider> authProviderProperty = getAuthProviderProperty();
if (authProviderProperty != null)
bindAuthenticationProvider(authProviderProperty);
for (Class<AuthenticationProvider> authenticationProvider : authenticationProviders)
bindAuthenticationProvider(authenticationProvider);
if (boundAuthenticationProvider == null) {
logger.info("Using default, \"basic\", XML-driven authentication.");
bindAuthenticationProvider(BasicFileAuthenticationProvider.class);
}
@Deprecated
public abstract class AuthenticationProviderProperty implements GuacamoleProperty<Class<AuthenticationProvider>> {
public Class<AuthenticationProvider> parseValue(String authProviderClassName) throws GuacamoleException {
Class<?> authProviderClass = GuacamoleClassLoader.getInstance().loadClass(authProviderClassName);
if (!AuthenticationProvider.class.isAssignableFrom(authProviderClass))
return (Class<AuthenticationProvider>) authProviderClass;
@Deprecated
@Deprecated
@SuppressWarnings("deprecation")
public RESTAuthModule(TokenSessionMap tokenSessionMap) {
Class<?> authProviderClass = org.glyptodon.guacamole.net.basic.GuacamoleClassLoader.getInstance().loadClass(authProviderClassName);
if (boundAuthenticationProvider == null)
public String getGuacamoleVersion() {
return manifest.getGuacamoleVersion();
}
private String guacamoleVersion;
public String getGuacamoleVersion() {
return guacamoleVersion;
}
public void setGuacamoleVersion(String guacamoleVersion) {
this.guacamoleVersion = guacamoleVersion;
}
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import org.glyptodon.guacamole.GuacamoleServerException;
private static final List<String> ALLOWED_GUACAMOLE_VERSIONS =
Collections.unmodifiableList(Arrays.asList(
"0.9.6"
));
private boolean isCompatible(String guacamoleVersion) {
return ALLOWED_GUACAMOLE_VERSIONS.contains(guacamoleVersion);
}
if (!isCompatible(extension.getGuacamoleVersion())) {
logger.debug("Declared Guacamole version \"{}\" of extension \"{}\" is not compatible with this version of Guacamole.",
extension.getGuacamoleVersion(), extensionFile.getName());
"compatible with this version of Guacamole.");
}
public static final String DEFAULT_USER_MAPPING = "user-mapping.xml";
File user_mapping_file = environment.getProperty(BASIC_USER_MAPPING);
if (user_mapping_file == null)
user_mapping_file = new File(environment.getGuacamoleHome(), DEFAULT_USER_MAPPING);
public static final String DEFAULT_NOAUTH_CONFIG = "noauth-config.xml";
File configFile = environment.getProperty(NOAUTH_CONFIG);
if (configFile == null)
configFile = new File(environment.getGuacamoleHome(), DEFAULT_NOAUTH_CONFIG);
return configFile;
private static final String DEFAULT_GUACD_HOSTNAME = "localhost";
private static final int DEFAULT_GUACD_PORT = 4822;
if (environment.getProperty(Environment.GUACD_SSL, false))
return new ManagedSSLGuacamoleSocket(
environment.getProperty(Environment.GUACD_HOSTNAME, DEFAULT_GUACD_HOSTNAME),
environment.getProperty(Environment.GUACD_PORT,     DEFAULT_GUACD_PORT),
environment.getProperty(Environment.GUACD_HOSTNAME, DEFAULT_GUACD_HOSTNAME),
environment.getProperty(Environment.GUACD_PORT,     DEFAULT_GUACD_PORT),
import org.glyptodon.guacamole.net.SSLGuacamoleSocket;
public class ManagedSSLGuacamoleSocket extends SSLGuacamoleSocket {
public ManagedSSLGuacamoleSocket(String hostname, int port,
private static final String DEFAULT_GUACD_HOSTNAME = "localhost";
private static final int DEFAULT_GUACD_PORT = 4822;
String hostname = env.getProperty(Environment.GUACD_HOSTNAME, DEFAULT_GUACD_HOSTNAME);
int port = env.getProperty(Environment.GUACD_PORT, DEFAULT_GUACD_PORT);
InputStream stream = null;
if (!guacHome.isDirectory())
else {
File propertiesFile = new File(guacHome, "guacamole.properties");
if (propertiesFile.exists())
stream = new FileInputStream(propertiesFile);
}
if (stream != null) {
try { properties.load(stream); }
finally { stream.close(); }
}
else
logger.info("No guacamole.properties file found within GUACAMOLE_HOME or the classpath. Using defaults.");
private static final String DEFAULT_GUACD_HOSTNAME = "localhost";
private static final int DEFAULT_GUACD_PORT = 4822;
if (environment.getProperty(Environment.GUACD_SSL, false))
return new ManagedSSLGuacamoleSocket(
environment.getProperty(Environment.GUACD_HOSTNAME, DEFAULT_GUACD_HOSTNAME),
environment.getProperty(Environment.GUACD_PORT,     DEFAULT_GUACD_PORT),
environment.getProperty(Environment.GUACD_HOSTNAME, DEFAULT_GUACD_HOSTNAME),
environment.getProperty(Environment.GUACD_PORT,     DEFAULT_GUACD_PORT),
public static final String DEFAULT_NOAUTH_CONFIG = "noauth-config.xml";
File configFile = environment.getProperty(NOAUTH_CONFIG);
if (configFile == null)
configFile = new File(environment.getGuacamoleHome(), DEFAULT_NOAUTH_CONFIG);
return configFile;
InputStream stream = null;
if (!guacHome.isDirectory())
else {
File propertiesFile = new File(guacHome, "guacamole.properties");
if (propertiesFile.exists())
stream = new FileInputStream(propertiesFile);
}
if (stream != null) {
try { properties.load(stream); }
finally { stream.close(); }
}
else
logger.info("No guacamole.properties file found within GUACAMOLE_HOME or the classpath. Using defaults.");
private static final String DEFAULT_GUACD_HOSTNAME = "localhost";
private static final int DEFAULT_GUACD_PORT = 4822;
String hostname = env.getProperty(Environment.GUACD_HOSTNAME, DEFAULT_GUACD_HOSTNAME);
int port = env.getProperty(Environment.GUACD_PORT, DEFAULT_GUACD_PORT);
public static final String DEFAULT_USER_MAPPING = "user-mapping.xml";
File user_mapping_file = environment.getProperty(BASIC_USER_MAPPING);
if (user_mapping_file == null)
user_mapping_file = new File(environment.getGuacamoleHome(), DEFAULT_USER_MAPPING);
import org.glyptodon.guacamole.net.basic.extension.ExtensionModule;
new ExtensionModule(environment),
new RESTAuthModule(sessionMap),
@Deprecated
Class<?> module = Class.forName(classname);
@Deprecated
public abstract class AuthenticationProviderProperty implements GuacamoleProperty<Class<AuthenticationProvider>> {
public Class<AuthenticationProvider> parseValue(String authProviderClassName) throws GuacamoleException {
Class<?> authProviderClass = org.glyptodon.guacamole.net.basic.GuacamoleClassLoader.getInstance().loadClass(authProviderClassName);
if (!AuthenticationProvider.class.isAssignableFrom(authProviderClass))
return (Class<AuthenticationProvider>) authProviderClass;
@Deprecated
@Deprecated
public RESTAuthModule(TokenSessionMap tokenSessionMap) {
Class.forName("javax.websocket.Endpoint");
Class.forName("org.glyptodon.guacamole.net.basic.websocket.jetty8.BasicGuacamoleWebSocketTunnelServlet");
Class.forName("org.glyptodon.guacamole.net.basic.websocket.jetty9.BasicGuacamoleWebSocketTunnelServlet");
Class.forName("org.glyptodon.guacamole.net.basic.websocket.tomcat.BasicGuacamoleWebSocketTunnelServlet");
if (canReadPermissions(user, targetUser)) {
if (canReadPermissions(user, targetUser)) {
private void loadExtensions(Collection<Resource> javaScriptResources,
Collection<Resource> cssResources) {
if (extensionFiles == null)
}
@Override
protected void configureServlets() {
Class<AuthenticationProvider> authProviderProperty = getAuthProviderProperty();
if (authProviderProperty != null)
bindAuthenticationProvider(authProviderProperty);
Collection<Resource> javaScriptResources = new ArrayList<Resource>();
javaScriptResources.add(new WebApplicationResource(getServletContext(), "/guacamole.min.js"));
Collection<Resource> cssResources = new ArrayList<Resource>();
cssResources.add(new WebApplicationResource(getServletContext(), "/guacamole.min.css"));
loadExtensions(javaScriptResources, cssResources);
if (manifest == null)
bind(AuthenticationProvider.class).toInstance(new AuthenticationProviderFacade(authenticationProvider));
import org.glyptodon.guacamole.net.auth.credentials.GuacamoleInvalidCredentialsException;
throw new GuacamoleInvalidCredentialsException("Permission denied.", CredentialsInfo.USERNAME_PASSWORD);
throw new GuacamoleInvalidCredentialsException("Permission denied.", CredentialsInfo.USERNAME_PASSWORD);
if (manifest == null)
bind(AuthenticationProvider.class).toInstance(new AuthenticationProviderFacade(authenticationProvider));
private void loadExtensions(Collection<Resource> javaScriptResources,
Collection<Resource> cssResources) {
if (extensionFiles == null)
}
@Override
protected void configureServlets() {
Class<AuthenticationProvider> authProviderProperty = getAuthProviderProperty();
if (authProviderProperty != null)
bindAuthenticationProvider(authProviderProperty);
Collection<Resource> javaScriptResources = new ArrayList<Resource>();
javaScriptResources.add(new WebApplicationResource(getServletContext(), "/guacamole.min.js"));
Collection<Resource> cssResources = new ArrayList<Resource>();
cssResources.add(new WebApplicationResource(getServletContext(), "/guacamole.min.css"));
loadExtensions(javaScriptResources, cssResources);
if (extensionFiles == null) {
return;
}
if (extensionFiles == null) {
return;
}
import java.util.HashMap;
import java.util.Map;
private final Map<String, Resource> javaScriptResources;
private final Map<String, Resource> cssResources;
private Map<String, Resource> getClassPathResources(String mimetype, Collection<String> paths) {
return Collections.<String, Resource>emptyMap();
Map<String, Resource> resources = new HashMap<String, Resource>(paths.size());
resources.put(path, new ClassPathResource(classLoader, mimetype, path));
return Collections.unmodifiableMap(resources);
public Map<String, Resource> getJavaScriptResources() {
public Map<String, Resource> getCSSResources() {
javaScriptResources.addAll(extension.getJavaScriptResources().values());
cssResources.addAll(extension.getCSSResources().values());
logger.warn("Authentication attempt denied because the authentication system could not be loaded. Please check for errors earlier in the logs.");
logger.warn("Reauthentication attempt denied because the authentication system could not be loaded. Please check for errors earlier in the logs.");
private final Map<String, Resource> translationResources;
private final Map<String, Resource> staticResources;
private Map<String, Resource> getClassPathResources(Map<String, String> resourceTypes) {
if (resourceTypes == null)
return Collections.<String, Resource>emptyMap();
Map<String, Resource> resources = new HashMap<String, Resource>(resourceTypes.size());
for (Map.Entry<String, String> resource : resourceTypes.entrySet()) {
String path = resource.getKey();
String mimetype = resource.getValue();
resources.put(path, new ClassPathResource(classLoader, mimetype, path));
}
return Collections.unmodifiableMap(resources);
}
translationResources = getClassPathResources("application/json", manifest.getTranslationPaths());
staticResources = getClassPathResources(manifest.getResourceTypes());
public Map<String, Resource> getTranslationResources() {
return translationResources;
}
public Map<String, Resource> getStaticResources() {
return staticResources;
}
import java.util.Map;
private Collection<String> translationPaths;
private Map<String, String> resourceTypes;
@JsonProperty("translations")
public Collection<String> getTranslationPaths() {
return translationPaths;
}
@JsonProperty("translations")
public void setTranslationPaths(Collection<String> translationPaths) {
this.translationPaths = translationPaths;
}
@JsonProperty("resources")
public Map<String, String> getResourceTypes() {
return resourceTypes;
}
@JsonProperty("resources")
public void setResourceTypes(Map<String, String> resourceTypes) {
this.resourceTypes = resourceTypes;
}
import java.util.Map;
for (Map.Entry<String, Resource> staticResource : extension.getStaticResources().entrySet()) {
String path = staticResource.getKey();
Resource resource = staticResource.getValue();
}
private final LanguageResourceService languageResourceService = new LanguageResourceService();
bind(LanguageResourceService.class).toInstance(languageResourceService);
languageResourceService.addLanguageResources(getServletContext());
import com.google.inject.Inject;
import org.glyptodon.guacamole.net.basic.extension.LanguageResourceService;
@Inject
private LanguageResourceService languageResourceService;
public Map<String, String> getLanguages() {
return languageResourceService.getLanguageNames();
}
for (Map.Entry<String, Resource> translationResource :
extension.getTranslationResources().entrySet()) {
String path = translationResource.getKey();
Resource resource = translationResource.getValue();
String languageKey = languageResourceService.getLanguageKey(path);
if (languageKey == null) {
logger.warn("Invalid language file name: \"{}\"", path);
continue;
}
languageResourceService.addLanguageResource(languageKey, resource);
}
for (Map.Entry<String, Resource> entry : languageResourceService.getLanguageResources().entrySet()) {
String languageKey = entry.getKey();
Resource resource = entry.getValue();
}
private void bindAuthenticationProviders(Collection<Class<AuthenticationProvider>> authProviders) {
for (Class<AuthenticationProvider> authenticationProvider : authProviders)
bindAuthenticationProvider(authenticationProvider);
}
private void serveLanguageResources(Map<String, Resource> resources) {
for (Map.Entry<String, Resource> translationResource : resources.entrySet()) {
String path = translationResource.getKey();
Resource resource = translationResource.getValue();
String languageKey = languageResourceService.getLanguageKey(path);
if (languageKey == null) {
logger.warn("Invalid language file name: \"{}\"", path);
continue;
}
languageResourceService.addLanguageResource(languageKey, resource);
}
}
private void serveStaticResources(String prefix, Map<String, Resource> resources) {
for (Map.Entry<String, Resource> staticResource : resources.entrySet()) {
String path = staticResource.getKey();
Resource resource = staticResource.getValue();
}
}
bindAuthenticationProviders(extension.getAuthenticationProviderClasses());
serveLanguageResources(extension.getTranslationResources());
serveStaticResources(staticResourcePrefix, extension.getStaticResources());
Resource existing = resources.get(key);
if (existing != null) {
logger.debug("Merged strings with existing language: \"{}\"", key);
}
else {
resources.put(key, resource);
logger.debug("Added language: \"{}\"", key);
}
import java.math.BigDecimal;
import java.util.Iterator;
import java.util.logging.Level;
import org.codehaus.jackson.node.JsonNodeFactory;
import org.codehaus.jackson.node.ObjectNode;
import org.codehaus.jackson.type.TypeReference;
import org.glyptodon.guacamole.net.basic.resource.ByteArrayResource;
*/
private JsonNode mergeTranslations(JsonNode original, JsonNode overlay) {
if (!overlay.isObject() || original == null)
return overlay;
ObjectNode newNode = JsonNodeFactory.instance.objectNode();
Iterator<String> fieldNames = original.getFieldNames();
while (fieldNames.hasNext()) {
String fieldName = fieldNames.next();
newNode.put(fieldName, original.get(fieldName));
}
fieldNames = overlay.getFieldNames();
while (fieldNames.hasNext()) {
String fieldName = fieldNames.next();
newNode.put(fieldName, mergeTranslations(original.get(fieldName), overlay.get(fieldName)));
}
return newNode;
}
try {
InputStream existingStream = existing.asStream();
InputStream resourceStream = resource.asStream();
if (existingStream == null || resourceStream == null) {
logger.warn("Language resource \"{}\" does not exist.", key);
return;
}
JsonNode existingTree = mapper.readTree(existingStream);
JsonNode resourceTree = mapper.readTree(resourceStream);
JsonNode mergedTree = mergeTranslations(existingTree, resourceTree);
resources.put(key, new ByteArrayResource("application/json", mapper.writeValueAsBytes(mergedTree)));
logger.debug("Merged strings with existing language: \"{}\"", key);
}
catch (IOException e) {
logger.error("Unable to merge language resource \"{}\": {}", key, e.getMessage());
logger.debug("Error merging language resource.", e);
}
import java.util.Iterator;
import org.codehaus.jackson.node.JsonNodeFactory;
import org.codehaus.jackson.node.ObjectNode;
import org.glyptodon.guacamole.net.basic.resource.ByteArrayResource;
*/
private JsonNode mergeTranslations(JsonNode original, JsonNode overlay) {
if (!overlay.isObject() || original == null)
return overlay;
ObjectNode newNode = JsonNodeFactory.instance.objectNode();
Iterator<String> fieldNames = original.getFieldNames();
while (fieldNames.hasNext()) {
String fieldName = fieldNames.next();
newNode.put(fieldName, original.get(fieldName));
}
fieldNames = overlay.getFieldNames();
while (fieldNames.hasNext()) {
String fieldName = fieldNames.next();
newNode.put(fieldName, mergeTranslations(original.get(fieldName), overlay.get(fieldName)));
}
return newNode;
}
try {
InputStream existingStream = existing.asStream();
InputStream resourceStream = resource.asStream();
if (existingStream == null || resourceStream == null) {
logger.warn("Language resource \"{}\" does not exist.", key);
return;
}
JsonNode existingTree = mapper.readTree(existingStream);
JsonNode resourceTree = mapper.readTree(resourceStream);
JsonNode mergedTree = mergeTranslations(existingTree, resourceTree);
resources.put(key, new ByteArrayResource("application/json", mapper.writeValueAsBytes(mergedTree)));
logger.debug("Merged strings with existing language: \"{}\"", key);
}
catch (IOException e) {
logger.error("Unable to merge language resource \"{}\": {}", key, e.getMessage());
logger.debug("Error merging language resource.", e);
}
"*",
"*",
*/
private JsonNode parseLanguageResource(Resource resource) throws IOException {
InputStream stream = resource.asStream();
if (stream == null)
return null;
try {
JsonNode tree = mapper.readTree(stream);
return tree;
}
finally {
stream.close();
}
}
JsonNode existingTree = parseLanguageResource(existing);
if (existingTree == null) {
logger.warn("Base language resource \"{}\" does not exist.", key);
JsonNode resourceTree = parseLanguageResource(resource);
if (resourceTree == null) {
logger.warn("Overlay language resource \"{}\" does not exist.", key);
return;
}
*/
private JsonNode parseLanguageResource(Resource resource) throws IOException {
InputStream stream = resource.asStream();
if (stream == null)
return null;
try {
JsonNode tree = mapper.readTree(stream);
return tree;
}
finally {
stream.close();
}
}
JsonNode existingTree = parseLanguageResource(existing);
if (existingTree == null) {
logger.warn("Base language resource \"{}\" does not exist.", key);
JsonNode resourceTree = parseLanguageResource(resource);
if (resourceTree == null) {
logger.warn("Overlay language resource \"{}\" does not exist.", key);
return;
}
import org.glyptodon.guacamole.net.auth.attribute.ObjectAttributeSet;
ObjectAttributeSet getAttributes() throws GuacamoleException;
import org.glyptodon.guacamole.net.auth.attribute.ObjectAttributeSet;
ObjectAttributeSet getAttributes() throws GuacamoleException;
import org.glyptodon.guacamole.net.auth.attribute.ObjectAttributeSet;
@Override
public ObjectAttributeSet getAttributes() throws GuacamoleException {
return new SimpleObjectAttributeSet();
}
import org.glyptodon.guacamole.net.auth.attribute.ObjectAttributeSet;
@Override
public ObjectAttributeSet getAttributes() throws GuacamoleException {
return new SimpleObjectAttributeSet();
}
import java.util.Map;
Map<String, String> getAttributes();
void setAttributes(Map<String, String> attributes);
import java.util.Map;
Map<String, String> getAttributes();
void setAttributes(Map<String, String> attributes);
import java.util.Map;
Map<String, String> getAttributes();
void setAttributes(Map<String, String> attributes);
import java.util.Collection;
import org.glyptodon.guacamole.net.auth.attribute.Attribute;
Collection<Attribute> getUserAttributes();
Collection<Attribute> getConnectionAttributes();
Collection<Attribute> getConnectionGroupAttributes();
public class Attribute implements Identifiable {
private String identifier;
private Type type;
@Override
public String getIdentifier() {
return identifier;
}
@Override
public void setIdentifier(String identifier) {
this.identifier = identifier;
}
public Type getType() {
return type;
}
void setType(Type type) {
this.type = type;
}
import java.util.Map;
public Map<String, String> getAttributes() {
return Collections.<String, String>emptyMap();
}
@Override
public void setAttributes(Map<String, String> attributes) {
}
@Override
import java.util.Collections;
import java.util.Map;
public Map<String, String> getAttributes() {
return Collections.<String, String>emptyMap();
}
@Override
public void setAttributes(Map<String, String> attributes) {
}
@Override
import java.util.Collections;
import java.util.Map;
import org.glyptodon.guacamole.GuacamoleSecurityException;
public Map<String, String> getAttributes() {
return Collections.<String, String>emptyMap();
}
@Override
public void setAttributes(Map<String, String> attributes) {
}
@Override
import org.glyptodon.guacamole.net.auth.attribute.Attribute;
@Override
public Collection<Attribute> getUserAttributes() {
return Collections.<Attribute>emptyList();
}
@Override
public Collection<Attribute> getConnectionAttributes() {
return Collections.<Attribute>emptyList();
}
@Override
public Collection<Attribute> getConnectionGroupAttributes() {
return Collections.<Attribute>emptyList();
}
import java.util.Collections;
import java.util.Map;
@Override
public Map<String, String> getAttributes() {
return Collections.<String, String>emptyMap();
}
@Override
public void setAttributes(Map<String, String> attributes) {
throw new UnsupportedOperationException("STUB");
}
import java.util.Collections;
import java.util.Map;
@Override
public Map<String, String> getAttributes() {
return Collections.<String, String>emptyMap();
}
@Override
public void setAttributes(Map<String, String> attributes) {
throw new UnsupportedOperationException("STUB");
}
import java.util.Collections;
import java.util.Map;
@Override
public Map<String, String> getAttributes() {
return Collections.<String, String>emptyMap();
}
@Override
public void setAttributes(Map<String, String> attributes) {
throw new UnsupportedOperationException("The root connection group cannot be modified.");
}
import java.util.Collections;
import java.util.Map;
@Override
public Map<String, String> getAttributes() {
return Collections.<String, String>emptyMap();
}
@Override
public void setAttributes(Map<String, String> attributes) {
throw new UnsupportedOperationException("STUB");
}
import java.util.Collection;
import java.util.Collections;
import org.glyptodon.guacamole.net.auth.attribute.Attribute;
@Override
public Collection<Attribute> getUserAttributes() {
return Collections.<Attribute>emptyList();
}
@Override
public Collection<Attribute> getConnectionAttributes() {
return Collections.<Attribute>emptyList();
}
@Override
public Collection<Attribute> getConnectionGroupAttributes() {
return Collections.<Attribute>emptyList();
}
import org.codehaus.jackson.map.annotate.JsonSerialize;
@JsonSerialize(include=JsonSerialize.Inclusion.NON_NULL)
private Map<String, String> attributes;
this.attributes = connection.getAttributes();
public Map<String, String> getAttributes() {
return attributes;
}
public void setAttributes(Map<String, String> attributes) {
this.attributes = attributes;
}
public Map<String, String> getAttributes() {
return apiConnection.getAttributes();
}
@Override
public void setAttributes(Map<String, String> attributes) {
apiConnection.setAttributes(attributes);
}
@Override
existingConnection.setAttributes(connection.getAttributes());
import java.util.Map;
import org.codehaus.jackson.map.annotate.JsonSerialize;
@JsonSerialize(include=JsonSerialize.Inclusion.NON_NULL)
private Map<String, String> attributes;
this.attributes = connectionGroup.getAttributes();
public Map<String, String> getAttributes() {
return attributes;
}
public void setAttributes(Map<String, String> attributes) {
this.attributes = attributes;
}
import java.util.Map;
public Map<String, String> getAttributes() {
return apiConnectionGroup.getAttributes();
}
@Override
public void setAttributes(Map<String, String> attributes) {
apiConnectionGroup.setAttributes(attributes);
}
@Override
existingConnectionGroup.setAttributes(connectionGroup.getAttributes());
import java.util.Map;
private Map<String, String> attributes;
this.attributes = user.getAttributes();
public Map<String, String> getAttributes() {
return attributes;
}
public void setAttributes(Map<String, String> attributes) {
this.attributes = attributes;
}
import java.util.Map;
public Map<String, String> getAttributes() {
return apiUser.getAttributes();
}
@Override
public void setAttributes(Map<String, String> attributes) {
apiUser.setAttributes(attributes);
}
@Override
existingUser.setAttributes(user.getAttributes());
import org.glyptodon.guacamole.form.Parameter;
public Collection<Parameter> getUserAttributes() {
return Collections.<Parameter>emptyList();
public Collection<Parameter> getConnectionAttributes() {
return Collections.<Parameter>emptyList();
public Collection<Parameter> getConnectionGroupAttributes() {
return Collections.<Parameter>emptyList();
import org.glyptodon.guacamole.form.Parameter;
Collection<Parameter> getUserAttributes();
Collection<Parameter> getConnectionAttributes();
Collection<Parameter> getConnectionGroupAttributes();
import org.glyptodon.guacamole.form.Parameter;
public Collection<Parameter> getUserAttributes() {
return Collections.<Parameter>emptyList();
public Collection<Parameter> getConnectionAttributes() {
return Collections.<Parameter>emptyList();
public Collection<Parameter> getConnectionGroupAttributes() {
return Collections.<Parameter>emptyList();
import org.glyptodon.guacamole.net.basic.rest.schema.SchemaRESTService;
bind(SchemaRESTService.class);
package org.glyptodon.guacamole.net.basic.rest.schema;
import java.util.Collections;
import java.util.Map;
@Override
public Map<String, String> getAttributes() {
return Collections.<String, String>emptyMap();
}
@Override
public void setAttributes(Map<String, String> attributes) {
}
import java.util.Collections;
import java.util.Map;
@Override
public Map<String, String> getAttributes() {
return Collections.<String, String>emptyMap();
}
@Override
public void setAttributes(Map<String, String> attributes) {
}
import java.util.Collections;
import java.util.Map;
@Override
public Map<String, String> getAttributes() {
return Collections.<String, String>emptyMap();
}
@Override
public void setAttributes(Map<String, String> attributes) {
throw new UnsupportedOperationException("The root connection group cannot be modified.");
}
import java.util.Collections;
import java.util.Map;
@Override
public Map<String, String> getAttributes() {
return Collections.<String, String>emptyMap();
}
@Override
public void setAttributes(Map<String, String> attributes) {
}
import java.util.Collection;
import java.util.Collections;
import org.glyptodon.guacamole.form.Parameter;
@Override
public Collection<Parameter> getUserAttributes() {
return Collections.<Parameter>emptyList();
}
@Override
public Collection<Parameter> getConnectionAttributes() {
return Collections.<Parameter>emptyList();
}
@Override
public Collection<Parameter> getConnectionGroupAttributes() {
return Collections.<Parameter>emptyList();
}
import java.util.Map;
Map<String, String> getAttributes();
void setAttributes(Map<String, String> attributes);
import java.util.Map;
Map<String, String> getAttributes();
void setAttributes(Map<String, String> attributes);
import java.util.Map;
Map<String, String> getAttributes();
void setAttributes(Map<String, String> attributes);
import java.util.Collection;
import org.glyptodon.guacamole.form.Parameter;
Collection<Parameter> getUserAttributes();
Collection<Parameter> getConnectionAttributes();
Collection<Parameter> getConnectionGroupAttributes();
import java.util.Map;
public Map<String, String> getAttributes() {
return Collections.<String, String>emptyMap();
}
@Override
public void setAttributes(Map<String, String> attributes) {
}
@Override
import java.util.Collections;
import java.util.Map;
public Map<String, String> getAttributes() {
return Collections.<String, String>emptyMap();
}
@Override
public void setAttributes(Map<String, String> attributes) {
}
@Override
import java.util.Collections;
import java.util.Map;
import org.glyptodon.guacamole.GuacamoleSecurityException;
public Map<String, String> getAttributes() {
return Collections.<String, String>emptyMap();
}
@Override
public void setAttributes(Map<String, String> attributes) {
}
@Override
import org.glyptodon.guacamole.form.Parameter;
@Override
public Collection<Parameter> getUserAttributes() {
return Collections.<Parameter>emptyList();
}
@Override
public Collection<Parameter> getConnectionAttributes() {
return Collections.<Parameter>emptyList();
}
@Override
public Collection<Parameter> getConnectionGroupAttributes() {
return Collections.<Parameter>emptyList();
}
import org.glyptodon.guacamole.net.basic.rest.schema.SchemaRESTService;
bind(SchemaRESTService.class);
import org.codehaus.jackson.map.annotate.JsonSerialize;
@JsonSerialize(include=JsonSerialize.Inclusion.NON_NULL)
private Map<String, String> attributes;
this.attributes = connection.getAttributes();
public Map<String, String> getAttributes() {
return attributes;
}
public void setAttributes(Map<String, String> attributes) {
this.attributes = attributes;
}
public Map<String, String> getAttributes() {
return apiConnection.getAttributes();
}
@Override
public void setAttributes(Map<String, String> attributes) {
apiConnection.setAttributes(attributes);
}
@Override
existingConnection.setAttributes(connection.getAttributes());
import java.util.Map;
import org.codehaus.jackson.map.annotate.JsonSerialize;
@JsonSerialize(include=JsonSerialize.Inclusion.NON_NULL)
private Map<String, String> attributes;
this.attributes = connectionGroup.getAttributes();
public Map<String, String> getAttributes() {
return attributes;
}
public void setAttributes(Map<String, String> attributes) {
this.attributes = attributes;
}
import java.util.Map;
public Map<String, String> getAttributes() {
return apiConnectionGroup.getAttributes();
}
@Override
public void setAttributes(Map<String, String> attributes) {
apiConnectionGroup.setAttributes(attributes);
}
@Override
existingConnectionGroup.setAttributes(connectionGroup.getAttributes());
package org.glyptodon.guacamole.net.basic.rest.schema;
import java.util.Map;
private Map<String, String> attributes;
this.attributes = user.getAttributes();
public Map<String, String> getAttributes() {
return attributes;
}
public void setAttributes(Map<String, String> attributes) {
this.attributes = attributes;
}
import java.util.Map;
public Map<String, String> getAttributes() {
return apiUser.getAttributes();
}
@Override
public void setAttributes(Map<String, String> attributes) {
apiUser.setAttributes(attributes);
}
@Override
existingUser.setAttributes(user.getAttributes());
import org.glyptodon.guacamole.form.Field;
public Collection<Field> getUserAttributes() {
return Collections.<Field>emptyList();
public Collection<Field> getConnectionAttributes() {
return Collections.<Field>emptyList();
public Collection<Field> getConnectionGroupAttributes() {
return Collections.<Field>emptyList();
import org.codehaus.jackson.map.ObjectMapper;
private static final ObjectMapper mapper = new ObjectMapper();
throws IOException {
return mapper.readValue(input, ProtocolInfo.class);
return string.endsWith(".json");
logger.debug("Error reading protocol JSON.", e);
if (stream != null) {
try {
protocols.put(protocol, readProtocol(stream));
}
catch (IOException e) {
logger.error("Unable to read pre-defined connection parameter information for protocol \"{}\": {}", protocol, e.getMessage());
logger.debug("Error reading pre-defined protocol JSON.", e);
}
}
import org.codehaus.jackson.map.annotate.JsonSerialize;
@JsonSerialize(include=JsonSerialize.Inclusion.NON_NULL)
public class FieldOption {
public FieldOption() {
public FieldOption(String value, String title) {
package org.glyptodon.guacamole.form;
import org.glyptodon.guacamole.form.Field;
Collection<Field> getUserAttributes();
Collection<Field> getConnectionAttributes();
Collection<Field> getConnectionGroupAttributes();
import org.glyptodon.guacamole.form.Field;
private final Collection<Field> fields;
public CredentialsInfo(Collection<Field> fields) {
this.fields = fields;
public Collection<Field> getFields() {
return Collections.unmodifiableCollection(fields);
public static final CredentialsInfo EMPTY = new CredentialsInfo(Collections.<Field>emptyList());
new Field("username", "username", Field.Type.USERNAME),
new Field("password", "password", Field.Type.PASSWORD)
import org.glyptodon.guacamole.form.Field;
public Collection<Field> getUserAttributes() {
return Collections.<Field>emptyList();
public Collection<Field> getConnectionAttributes() {
return Collections.<Field>emptyList();
public Collection<Field> getConnectionGroupAttributes() {
return Collections.<Field>emptyList();
import org.glyptodon.guacamole.form.Form;
private Collection<Form> forms;
this.forms = new ArrayList<Form>();
this.name  = name;
this.title = title;
this.forms = new ArrayList<Form>();
public ProtocolInfo(String name, String title, Collection<Form> forms) {
this.name  = name;
this.title = title;
this.forms = forms;
public Collection<Form> getForms() {
return forms;
public void setForms(Collection<Form> forms) {
this.forms = forms;
import org.glyptodon.guacamole.form.Field;
private final Collection<Field> expected;
public APIError(Type type, String message, Collection<Field> expected) {
public Collection<Field> getExpected() {
import org.glyptodon.guacamole.form.Field;
public APIException(APIError.Type type, String message, Collection<Field> expected) {
e.getCredentialsInfo().getFields()
e.getCredentialsInfo().getFields()
import org.glyptodon.guacamole.form.Field;
public Collection<Field> getUserAttributes(@QueryParam("token") String authToken) throws GuacamoleException {
public Collection<Field> getConnectionAttributes(@QueryParam("token") String authToken) throws GuacamoleException {
public Collection<Field> getConnectionGroupAttributes(@QueryParam("token") String authToken) throws GuacamoleException {
import org.glyptodon.guacamole.form.Field;
public Collection<Field> getUserAttributes() {
return Collections.<Field>emptyList();
public Collection<Field> getConnectionAttributes() {
return Collections.<Field>emptyList();
public Collection<Field> getConnectionGroupAttributes() {
return Collections.<Field>emptyList();
import org.codehaus.jackson.map.ObjectMapper;
private static final ObjectMapper mapper = new ObjectMapper();
throws IOException {
return mapper.readValue(input, ProtocolInfo.class);
return string.endsWith(".json");
logger.debug("Error reading protocol JSON.", e);
if (stream != null) {
try {
protocols.put(protocol, readProtocol(stream));
}
catch (IOException e) {
logger.error("Unable to read pre-defined connection parameter information for protocol \"{}\": {}", protocol, e.getMessage());
logger.debug("Error reading pre-defined protocol JSON.", e);
}
}
import org.codehaus.jackson.map.annotate.JsonSerialize;
@JsonSerialize(include=JsonSerialize.Inclusion.NON_NULL)
public class FieldOption {
public FieldOption() {
public FieldOption(String value, String title) {
package org.glyptodon.guacamole.form;
import org.glyptodon.guacamole.form.Field;
Collection<Field> getUserAttributes();
Collection<Field> getConnectionAttributes();
Collection<Field> getConnectionGroupAttributes();
import org.glyptodon.guacamole.form.Field;
private final Collection<Field> fields;
public CredentialsInfo(Collection<Field> fields) {
this.fields = fields;
public Collection<Field> getFields() {
return Collections.unmodifiableCollection(fields);
public static final CredentialsInfo EMPTY = new CredentialsInfo(Collections.<Field>emptyList());
new Field("username", "username", Field.Type.USERNAME),
new Field("password", "password", Field.Type.PASSWORD)
import org.glyptodon.guacamole.form.Field;
public Collection<Field> getUserAttributes() {
return Collections.<Field>emptyList();
public Collection<Field> getConnectionAttributes() {
return Collections.<Field>emptyList();
public Collection<Field> getConnectionGroupAttributes() {
return Collections.<Field>emptyList();
import org.glyptodon.guacamole.form.Form;
private Collection<Form> forms;
this.forms = new ArrayList<Form>();
this.name  = name;
this.title = title;
this.forms = new ArrayList<Form>();
public ProtocolInfo(String name, String title, Collection<Form> forms) {
this.name  = name;
this.title = title;
this.forms = forms;
public Collection<Form> getForms() {
return forms;
public void setForms(Collection<Form> forms) {
this.forms = forms;
import org.glyptodon.guacamole.form.Field;
private final Collection<Field> expected;
public APIError(Type type, String message, Collection<Field> expected) {
public Collection<Field> getExpected() {
import org.glyptodon.guacamole.form.Field;
public APIException(APIError.Type type, String message, Collection<Field> expected) {
e.getCredentialsInfo().getFields()
e.getCredentialsInfo().getFields()
import org.glyptodon.guacamole.form.Field;
public Collection<Field> getUserAttributes(@QueryParam("token") String authToken) throws GuacamoleException {
public Collection<Field> getConnectionAttributes(@QueryParam("token") String authToken) throws GuacamoleException {
public Collection<Field> getConnectionGroupAttributes(@QueryParam("token") String authToken) throws GuacamoleException {
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import org.glyptodon.guacamole.form.Field;
public static final String DISABLED_ATTRIBUTE_NAME = "disabled";
public static final Field DISABLED_ATTRIBUTE = new Field(DISABLED_ATTRIBUTE_NAME, "Disabled", "true");
public static final Collection<Field> ATTRIBUTES = Collections.unmodifiableCollection(Arrays.asList(
DISABLED_ATTRIBUTE
));
Map<String, String> attributes = new HashMap<String, String>();
attributes.put("disabled", getModel().isDisabled() ? "true" : null);
return attributes;
getModel().setDisabled("true".equals(attributes.get("disabled")));
return ModeledUser.ATTRIBUTES;
if (user != null && !user.getModel().isDisabled()) {
private boolean disabled;
public boolean isDisabled() {
return disabled;
}
public void setDisabled(boolean disabled) {
this.disabled = disabled;
}
this.name = name;
this.title = title;
import org.glyptodon.guacamole.form.Form;
public static final Form ACCOUNT_RESTRICTIONS = new Form("restrictions", "Account Restrictions", Arrays.asList(
new Field(DISABLED_ATTRIBUTE_NAME, "Disabled", "true")
));
public static final Collection<Form> ATTRIBUTES = Collections.unmodifiableCollection(Arrays.asList(
ACCOUNT_RESTRICTIONS
import org.glyptodon.guacamole.form.Form;
public Collection<Form> getUserAttributes() {
public Collection<Form> getConnectionAttributes() {
return Collections.<Form>emptyList();
public Collection<Form> getConnectionGroupAttributes() {
return Collections.<Form>emptyList();
import org.glyptodon.guacamole.form.Form;
Collection<Form> getUserAttributes();
Collection<Form> getConnectionAttributes();
Collection<Form> getConnectionGroupAttributes();
import org.glyptodon.guacamole.form.Form;
public Collection<Form> getUserAttributes() {
return Collections.<Form>emptyList();
public Collection<Form> getConnectionAttributes() {
return Collections.<Form>emptyList();
public Collection<Form> getConnectionGroupAttributes() {
return Collections.<Form>emptyList();
import org.glyptodon.guacamole.form.Form;
public Collection<Form> getUserAttributes(@QueryParam("token") String authToken) throws GuacamoleException {
public Collection<Form> getConnectionAttributes(@QueryParam("token") String authToken) throws GuacamoleException {
public Collection<Form> getConnectionGroupAttributes(@QueryParam("token") String authToken) throws GuacamoleException {
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import org.glyptodon.guacamole.form.Field;
import org.glyptodon.guacamole.form.Form;
public static final String DISABLED_ATTRIBUTE_NAME = "disabled";
public static final Form ACCOUNT_RESTRICTIONS = new Form("restrictions", "Account Restrictions", Arrays.asList(
new Field(DISABLED_ATTRIBUTE_NAME, "Disabled", "true")
));
public static final Collection<Form> ATTRIBUTES = Collections.unmodifiableCollection(Arrays.asList(
ACCOUNT_RESTRICTIONS
));
Map<String, String> attributes = new HashMap<String, String>();
attributes.put("disabled", getModel().isDisabled() ? "true" : null);
return attributes;
getModel().setDisabled("true".equals(attributes.get("disabled")));
import org.glyptodon.guacamole.form.Form;
public Collection<Form> getUserAttributes() {
return ModeledUser.ATTRIBUTES;
public Collection<Form> getConnectionAttributes() {
return Collections.<Form>emptyList();
public Collection<Form> getConnectionGroupAttributes() {
return Collections.<Form>emptyList();
if (user != null && !user.getModel().isDisabled()) {
private boolean disabled;
public boolean isDisabled() {
return disabled;
}
public void setDisabled(boolean disabled) {
this.disabled = disabled;
}
this.name = name;
this.title = title;
import org.glyptodon.guacamole.form.Form;
Collection<Form> getUserAttributes();
Collection<Form> getConnectionAttributes();
Collection<Form> getConnectionGroupAttributes();
import org.glyptodon.guacamole.form.Form;
public Collection<Form> getUserAttributes() {
return Collections.<Form>emptyList();
public Collection<Form> getConnectionAttributes() {
return Collections.<Form>emptyList();
public Collection<Form> getConnectionGroupAttributes() {
return Collections.<Form>emptyList();
import org.glyptodon.guacamole.form.Form;
public Collection<Form> getUserAttributes(@QueryParam("token") String authToken) throws GuacamoleException {
public Collection<Form> getConnectionAttributes(@QueryParam("token") String authToken) throws GuacamoleException {
public Collection<Form> getConnectionGroupAttributes(@QueryParam("token") String authToken) throws GuacamoleException {
public static class Type {
public static String TEXT = "TEXT";
public static String USERNAME = "USERNAME";
public static String PASSWORD = "PASSWORD";
public static String NUMERIC = "NUMERIC";
public static String BOOLEAN = "BOOLEAN";
public static String ENUM = "ENUM";
public static String MULTILINE = "MULTILINE";
private String type;
public Field(String name, String title, String type) {
public String getType() {
public void setType(String type) {
public static class Type {
public static String TEXT = "TEXT";
public static String USERNAME = "USERNAME";
public static String PASSWORD = "PASSWORD";
public static String NUMERIC = "NUMERIC";
public static String BOOLEAN = "BOOLEAN";
public static String ENUM = "ENUM";
public static String MULTILINE = "MULTILINE";
private String type;
public Field(String name, String title, String type) {
public String getType() {
public void setType(String type) {
public static final String EXPIRED_ATTRIBUTE_NAME = "expired";
new Field(DISABLED_ATTRIBUTE_NAME, "Disabled", "true"),
new Field(EXPIRED_ATTRIBUTE_NAME, "Password expired", "true")
attributes.put(DISABLED_ATTRIBUTE_NAME, getModel().isDisabled() ? "true" : null);
attributes.put(EXPIRED_ATTRIBUTE_NAME, getModel().isExpired() ? "true" : null);
getModel().setDisabled("true".equals(attributes.get(DISABLED_ATTRIBUTE_NAME)));
getModel().setExpired("true".equals(attributes.get(EXPIRED_ATTRIBUTE_NAME)));
private boolean expired;
public boolean isExpired() {
return expired;
}
public void setExpired(boolean expired) {
this.expired = expired;
}
public static final Field USERNAME = new Field("username", "username", Field.Type.USERNAME);
public static final Field PASSWORD = new Field("password", "password", Field.Type.PASSWORD);
USERNAME,
PASSWORD
import java.util.Arrays;
import javax.servlet.http.HttpServletRequest;
import org.glyptodon.guacamole.form.Field;
import org.glyptodon.guacamole.net.auth.credentials.CredentialsInfo;
import org.glyptodon.guacamole.net.auth.credentials.GuacamoleInsufficientCredentialsException;
import org.glyptodon.guacamole.net.auth.credentials.GuacamoleInvalidCredentialsException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
private static final Logger logger = LoggerFactory.getLogger(UserService.class);
private static final String NEW_PASSWORD_PARAMETER = "new-password";
private static final Field NEW_PASSWORD = new Field(NEW_PASSWORD_PARAMETER, "New password", Field.Type.PASSWORD);
private static final CredentialsInfo EXPIRED_PASSWORD = new CredentialsInfo(Arrays.asList(
CredentialsInfo.USERNAME,
CredentialsInfo.PASSWORD,
NEW_PASSWORD
));
if (user.getModel().isExpired()) {
HttpServletRequest request = credentials.getRequest();
String newPassword = request.getParameter(NEW_PASSWORD_PARAMETER);
if (newPassword == null) {
logger.info("The password of user \"{}\" has expired and must be reset.", user.getIdentifier());
throw new GuacamoleInsufficientCredentialsException("Password expired", EXPIRED_PASSWORD);
}
logger.info("Resetting expired password of user \"{}\".", user.getIdentifier());
}
throw new GuacamoleInvalidCredentialsException("Invalid login", CredentialsInfo.USERNAME_PASSWORD);
import org.glyptodon.guacamole.GuacamoleClientException;
if (newPassword.equals(credentials.getPassword()))
throw new GuacamoleClientException("The new password must be different from the expired password.");
if (newPassword.isEmpty())
throw new GuacamoleClientException("The new password may not be blank.");
throw new GuacamoleClientException("LOGIN.ERROR_PASSWORD_SAME");
throw new GuacamoleClientException("LOGIN.ERROR_PASSWORD_BLANK");
private static final String CONFIRM_NEW_PASSWORD_PARAMETER = "confirm-new-password";
private static final Field CONFIRM_NEW_PASSWORD = new Field(CONFIRM_NEW_PASSWORD_PARAMETER, "Confirm new password", Field.Type.PASSWORD);
NEW_PASSWORD,
CONFIRM_NEW_PASSWORD
String confirmNewPassword = request.getParameter(CONFIRM_NEW_PASSWORD_PARAMETER);
if (newPassword == null || confirmNewPassword == null) {
if (!newPassword.equals(confirmNewPassword))
throw new GuacamoleClientException("LOGIN.ERROR_PASSWORD_MISMATCH");
if (user != null) {
import javax.servlet.http.HttpServletRequest;
import org.glyptodon.guacamole.form.Field;
import org.glyptodon.guacamole.net.auth.credentials.CredentialsInfo;
import org.glyptodon.guacamole.net.auth.credentials.GuacamoleInsufficientCredentialsException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
private static final Logger logger = LoggerFactory.getLogger(UserService.class);
private static final String NEW_PASSWORD_PARAMETER = "new-password";
private static final Field NEW_PASSWORD = new Field(NEW_PASSWORD_PARAMETER, "New password", Field.Type.PASSWORD);
private static final String CONFIRM_NEW_PASSWORD_PARAMETER = "confirm-new-password";
private static final Field CONFIRM_NEW_PASSWORD = new Field(CONFIRM_NEW_PASSWORD_PARAMETER, "Confirm new password", Field.Type.PASSWORD);
private static final CredentialsInfo EXPIRED_PASSWORD = new CredentialsInfo(Arrays.asList(
CredentialsInfo.USERNAME,
CredentialsInfo.PASSWORD,
NEW_PASSWORD,
CONFIRM_NEW_PASSWORD
));
public ModeledUser retrieveUser(Credentials credentials)
throws GuacamoleException {
if (userModel.isDisabled())
return null;
byte[] hash = encryptionService.createPasswordHash(password, userModel.getPasswordSalt());
if (!Arrays.equals(hash, userModel.getPasswordHash()))
return null;
ModeledUser user = getObjectInstance(null, userModel);
user.setCurrentUser(new AuthenticatedUser(user, credentials));
if (userModel.isExpired()) {
HttpServletRequest request = credentials.getRequest();
String newPassword = request.getParameter(NEW_PASSWORD_PARAMETER);
String confirmNewPassword = request.getParameter(CONFIRM_NEW_PASSWORD_PARAMETER);
if (newPassword == null || confirmNewPassword == null) {
logger.info("The password of user \"{}\" has expired and must be reset.", username);
throw new GuacamoleInsufficientCredentialsException("LOGIN.INFO_PASSWORD_EXPIRED", EXPIRED_PASSWORD);
}
if (newPassword.equals(credentials.getPassword()))
throw new GuacamoleClientException("LOGIN.ERROR_PASSWORD_SAME");
if (newPassword.isEmpty())
throw new GuacamoleClientException("LOGIN.ERROR_PASSWORD_BLANK");
if (!newPassword.equals(confirmNewPassword))
throw new GuacamoleClientException("LOGIN.ERROR_PASSWORD_MISMATCH");
userModel.setExpired(false);
user.setPassword(newPassword);
userMapper.update(userModel);
logger.info("Expired password of user \"{}\" has been reset.", username);
return user;
import org.glyptodon.guacamole.form.BooleanField;
public static final Form ACCOUNT_RESTRICTIONS = new Form("restrictions", "Account Restrictions", Arrays.<Field>asList(
new BooleanField(DISABLED_ATTRIBUTE_NAME, "Disabled", "true"),
new BooleanField(EXPIRED_ATTRIBUTE_NAME, "Password expired", "true")
import org.glyptodon.guacamole.form.PasswordField;
private static final Field NEW_PASSWORD = new PasswordField(NEW_PASSWORD_PARAMETER, "New password");
private static final Field CONFIRM_NEW_PASSWORD = new PasswordField(CONFIRM_NEW_PASSWORD_PARAMETER, "Confirm new password");
this.name  = name;
this.title = title;
this.type  = type;
public Field(String name, String title, String type,
Collection<FieldOption> options) {
this.type    = type;
import org.glyptodon.guacamole.form.PasswordField;
import org.glyptodon.guacamole.form.UsernameField;
public static final Field USERNAME = new UsernameField("username", "username");
public static final Field PASSWORD = new PasswordField("password", "password");
public static final Form ACCOUNT_RESTRICTIONS = new Form("restrictions", Arrays.<Field>asList(
new BooleanField(DISABLED_ATTRIBUTE_NAME, "true"),
new BooleanField(EXPIRED_ATTRIBUTE_NAME, "true")
private static final Field NEW_PASSWORD = new PasswordField(NEW_PASSWORD_PARAMETER);
private static final Field CONFIRM_NEW_PASSWORD = new PasswordField(CONFIRM_NEW_PASSWORD_PARAMETER);
public BooleanField(String name, String truthValue) {
super(name, Field.Type.BOOLEAN, Collections.singletonList(truthValue));
public EnumField(String name, Collection<String> options) {
super(name, Field.Type.ENUM, options);
private Collection<String> options;
public Field(String name, String type) {
public Field(String name, String type, Collection<String> options) {
public Collection<String> getOptions() {
public void setOptions(Collection<String> options) {
public Form(String name, Collection<Field> fields) {
public MultilineField(String name) {
super(name, Field.Type.MULTILINE);
public NumericField(String name) {
super(name, Field.Type.NUMERIC);
public PasswordField(String name) {
super(name, Field.Type.PASSWORD);
public TextField(String name) {
super(name, Field.Type.TEXT);
public UsernameField(String name) {
super(name, Field.Type.USERNAME);
public static final Field USERNAME = new UsernameField("username");
public static final Field PASSWORD = new PasswordField("password");
public ProtocolInfo(String name) {
public ProtocolInfo(String name, Collection<Form> forms) {
import org.glyptodon.guacamole.form.BooleanField;
public static final String EXPIRED_ATTRIBUTE_NAME = "expired";
public static final Form ACCOUNT_RESTRICTIONS = new Form("restrictions", Arrays.<Field>asList(
new BooleanField(DISABLED_ATTRIBUTE_NAME, "true"),
new BooleanField(EXPIRED_ATTRIBUTE_NAME, "true")
attributes.put(DISABLED_ATTRIBUTE_NAME, getModel().isDisabled() ? "true" : null);
attributes.put(EXPIRED_ATTRIBUTE_NAME, getModel().isExpired() ? "true" : null);
getModel().setDisabled("true".equals(attributes.get(DISABLED_ATTRIBUTE_NAME)));
getModel().setExpired("true".equals(attributes.get(EXPIRED_ATTRIBUTE_NAME)));
import org.glyptodon.guacamole.net.auth.credentials.CredentialsInfo;
import org.glyptodon.guacamole.net.auth.credentials.GuacamoleInvalidCredentialsException;
if (user != null) {
throw new GuacamoleInvalidCredentialsException("Invalid login", CredentialsInfo.USERNAME_PASSWORD);
private boolean expired;
public boolean isExpired() {
return expired;
}
public void setExpired(boolean expired) {
this.expired = expired;
}
import javax.servlet.http.HttpServletRequest;
import org.glyptodon.guacamole.form.Field;
import org.glyptodon.guacamole.form.PasswordField;
import org.glyptodon.guacamole.net.auth.credentials.CredentialsInfo;
import org.glyptodon.guacamole.net.auth.credentials.GuacamoleInsufficientCredentialsException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
private static final Logger logger = LoggerFactory.getLogger(UserService.class);
private static final String NEW_PASSWORD_PARAMETER = "new-password";
private static final Field NEW_PASSWORD = new PasswordField(NEW_PASSWORD_PARAMETER);
private static final String CONFIRM_NEW_PASSWORD_PARAMETER = "confirm-new-password";
private static final Field CONFIRM_NEW_PASSWORD = new PasswordField(CONFIRM_NEW_PASSWORD_PARAMETER);
private static final CredentialsInfo EXPIRED_PASSWORD = new CredentialsInfo(Arrays.asList(
CredentialsInfo.USERNAME,
CredentialsInfo.PASSWORD,
NEW_PASSWORD,
CONFIRM_NEW_PASSWORD
));
public ModeledUser retrieveUser(Credentials credentials)
throws GuacamoleException {
if (userModel.isDisabled())
return null;
byte[] hash = encryptionService.createPasswordHash(password, userModel.getPasswordSalt());
if (!Arrays.equals(hash, userModel.getPasswordHash()))
return null;
ModeledUser user = getObjectInstance(null, userModel);
user.setCurrentUser(new AuthenticatedUser(user, credentials));
if (userModel.isExpired()) {
HttpServletRequest request = credentials.getRequest();
String newPassword = request.getParameter(NEW_PASSWORD_PARAMETER);
String confirmNewPassword = request.getParameter(CONFIRM_NEW_PASSWORD_PARAMETER);
if (newPassword == null || confirmNewPassword == null) {
logger.info("The password of user \"{}\" has expired and must be reset.", username);
throw new GuacamoleInsufficientCredentialsException("LOGIN.INFO_PASSWORD_EXPIRED", EXPIRED_PASSWORD);
}
if (newPassword.equals(credentials.getPassword()))
throw new GuacamoleClientException("LOGIN.ERROR_PASSWORD_SAME");
if (newPassword.isEmpty())
throw new GuacamoleClientException("LOGIN.ERROR_PASSWORD_BLANK");
if (!newPassword.equals(confirmNewPassword))
throw new GuacamoleClientException("LOGIN.ERROR_PASSWORD_MISMATCH");
userModel.setExpired(false);
user.setPassword(newPassword);
userMapper.update(userModel);
logger.info("Expired password of user \"{}\" has been reset.", username);
return user;
private Collection<String> options;
public Field(String name, String type) {
this.name  = name;
this.type  = type;
public Field(String name, String type, Collection<String> options) {
this.type    = type;
public Collection<String> getOptions() {
public void setOptions(Collection<String> options) {
public Form(String name, Collection<Field> fields) {
import org.glyptodon.guacamole.form.PasswordField;
import org.glyptodon.guacamole.form.UsernameField;
public static final Field USERNAME = new UsernameField("username");
public static final Field PASSWORD = new PasswordField("password");
USERNAME,
PASSWORD
public ProtocolInfo(String name) {
public ProtocolInfo(String name, Collection<Form> forms) {
"0.9.7"
"0.9.7"
private final Resource smallIcon;
private final Resource largeIcon;
if (manifest.getSmallIcon() != null)
smallIcon = new ClassPathResource(classLoader, "image/png", manifest.getSmallIcon());
else
smallIcon = null;
if (manifest.getLargeIcon() != null)
largeIcon = new ClassPathResource(classLoader, "image/png", manifest.getLargeIcon());
else
largeIcon = null;
public Resource getSmallIcon() {
return smallIcon;
}
public Resource getLargeIcon() {
return largeIcon;
}
private String smallIcon;
private String largeIcon;
public String getSmallIcon() {
return smallIcon;
}
public void setSmallIcon(String smallIcon) {
this.smallIcon = smallIcon;
}
public String getLargeIcon() {
return largeIcon;
}
public void setLargeIcon(String largeIcon) {
this.largeIcon = largeIcon;
}
if(extension.getSmallIcon() != null)
serve("/images/logo-64.png").with(new ResourceServlet(extension.getSmallIcon()));
if(extension.getLargeIcon()!= null)
serve("/images/logo-144.png").with(new ResourceServlet(extension.getLargeIcon()));
private final Resource smallIcon;
private final Resource largeIcon;
if (manifest.getSmallIcon() != null)
smallIcon = new ClassPathResource(classLoader, "image/png", manifest.getSmallIcon());
else
smallIcon = null;
if (manifest.getLargeIcon() != null)
largeIcon = new ClassPathResource(classLoader, "image/png", manifest.getLargeIcon());
else
largeIcon = null;
public Resource getSmallIcon() {
return smallIcon;
}
public Resource getLargeIcon() {
return largeIcon;
}
private String smallIcon;
private String largeIcon;
public String getSmallIcon() {
return smallIcon;
}
public void setSmallIcon(String smallIcon) {
this.smallIcon = smallIcon;
}
public String getLargeIcon() {
return largeIcon;
}
public void setLargeIcon(String largeIcon) {
this.largeIcon = largeIcon;
}
if(extension.getSmallIcon() != null)
serve("/images/logo-64.png").with(new ResourceServlet(extension.getSmallIcon()));
if(extension.getLargeIcon()!= null)
serve("/images/logo-144.png").with(new ResourceServlet(extension.getLargeIcon()));
protected GuacamoleTunnel createConnectedTunnel(UserContext context,
final TunnelRequest.IdentifierType idType, String id,
GuacamoleClientInformation info)
throws GuacamoleException {
GuacamoleTunnel tunnel = null;
switch (idType) {
logger.info("User \"{}\" connected to connection \"{}\".", context.self().getIdentifier(), id);
logger.info("User \"{}\" connected to group \"{}\".", context.self().getIdentifier(), id);
assert(false);
GuacamoleTunnel tunnel, final TunnelRequest.IdentifierType idType,
final String id) throws GuacamoleException {
private final long connectionStartTime = System.currentTimeMillis();
long connectionEndTime = System.currentTimeMillis();
long duration = connectionEndTime - connectionStartTime;
switch (idType) {
case CONNECTION:
logger.info("User \"{}\" disconnected from connection \"{}\". Duration: {} milliseconds",
session.getUserContext().self().getIdentifier(), id, duration);
break;
case CONNECTION_GROUP:
logger.info("User \"{}\" disconnected from connection group \"{}\". Duration: {} milliseconds",
session.getUserContext().self().getIdentifier(), id, duration);
break;
default:
assert(false);
}
session.removeTunnel(getUUID().toString());
String id = request.getParameter("id");
TunnelRequest.IdentifierType idType = TunnelRequest.IdentifierType.getType(id);
if (idType == null)
throw new GuacamoleClientException("Illegal identifier - unknown type.");
id = id.substring(idType.PREFIX.length());
final GuacamoleTunnel tunnel = createConnectedTunnel(session.getUserContext(), idType, id, info);
return createAssociatedTunnel(session, tunnel, idType, id);
protected GuacamoleTunnel createConnectedTunnel(UserContext context,
final TunnelRequest.IdentifierType idType, String id,
GuacamoleClientInformation info)
throws GuacamoleException {
GuacamoleTunnel tunnel = null;
switch (idType) {
logger.info("User \"{}\" connected to connection \"{}\".", context.self().getIdentifier(), id);
logger.info("User \"{}\" connected to group \"{}\".", context.self().getIdentifier(), id);
assert(false);
GuacamoleTunnel tunnel, final TunnelRequest.IdentifierType idType,
final String id) throws GuacamoleException {
private final long connectionStartTime = System.currentTimeMillis();
long connectionEndTime = System.currentTimeMillis();
long duration = connectionEndTime - connectionStartTime;
switch (idType) {
case CONNECTION:
logger.info("User \"{}\" disconnected from connection \"{}\". Duration: {} milliseconds",
session.getUserContext().self().getIdentifier(), id, duration);
break;
case CONNECTION_GROUP:
logger.info("User \"{}\" disconnected from connection group \"{}\". Duration: {} milliseconds",
session.getUserContext().self().getIdentifier(), id, duration);
break;
default:
assert(false);
}
session.removeTunnel(getUUID().toString());
String id = request.getParameter("id");
TunnelRequest.IdentifierType idType = TunnelRequest.IdentifierType.getType(id);
if (idType == null)
throw new GuacamoleClientException("Illegal identifier - unknown type.");
id = id.substring(idType.PREFIX.length());
final GuacamoleTunnel tunnel = createConnectedTunnel(session.getUserContext(), idType, id, info);
return createAssociatedTunnel(session, tunnel, idType, id);
import java.sql.Date;
import java.sql.Time;
private Time accessWindowStart;
private Time accessWindowEnd;
private Date validFrom;
private Date validUntil;
private String timeZone;
public Time getAccessWindowStart() {
return accessWindowStart;
}
public void setAccessWindowStart(Time accessWindowStart) {
this.accessWindowStart = accessWindowStart;
}
public Time getAccessWindowEnd() {
return accessWindowEnd;
}
public void setAccessWindowEnd(Time accessWindowEnd) {
this.accessWindowEnd = accessWindowEnd;
}
public Date getValidFrom() {
return validFrom;
}
public void setValidFrom(Date validFrom) {
this.validFrom = validFrom;
}
public Date getValidUntil() {
return validUntil;
}
public void setValidUntil(Date validUntil) {
this.validUntil = validUntil;
}
public String getTimeZone() {
return timeZone;
}
public void setTimeZone(String timeZone) {
this.timeZone = timeZone;
}
import java.sql.Date;
import java.sql.Time;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import org.glyptodon.guacamole.form.TextField;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
private static final Logger logger = LoggerFactory.getLogger(ModeledUser.class);
private static final String DATE_FORMAT = "yyyy-MM-dd";
private static final String TIME_FORMAT = "HH:mm:ss";
public static final String ACCESS_WINDOW_START_ATTRIBUTE_NAME = "access-window-start";
public static final String ACCESS_WINDOW_END_ATTRIBUTE_NAME = "access-window-end";
public static final String VALID_FROM_ATTRIBUTE_NAME = "valid-from";
public static final String VALID_UNTIL_ATTRIBUTE_NAME = "valid-until";
public static final String TIMEZONE_ATTRIBUTE_NAME = "timezone";
new BooleanField(EXPIRED_ATTRIBUTE_NAME, "true"),
new TextField(ACCESS_WINDOW_START_ATTRIBUTE_NAME),
new TextField(ACCESS_WINDOW_END_ATTRIBUTE_NAME),
new TextField(VALID_FROM_ATTRIBUTE_NAME),
new TextField(VALID_UNTIL_ATTRIBUTE_NAME),
new TextField(TIMEZONE_ATTRIBUTE_NAME)
private String formatDate(Date date) {
DateFormat dateFormat = new SimpleDateFormat(DATE_FORMAT);
return date == null ? null : dateFormat.format(date);
}
private String formatTime(Time time) {
DateFormat timeFormat = new SimpleDateFormat(TIME_FORMAT);
return time == null ? null : timeFormat.format(time);
}
private Date parseDate(String dateString)
throws ParseException {
if (dateString == null || dateString.isEmpty())
return null;
DateFormat dateFormat = new SimpleDateFormat(DATE_FORMAT);
return new Date(dateFormat.parse(dateString).getTime());
}
private Time parseTime(String timeString)
throws ParseException {
if (timeString == null || timeString.isEmpty())
return null;
DateFormat timeFormat = new SimpleDateFormat(TIME_FORMAT);
return new Time(timeFormat.parse(timeString).getTime());
}
private String parseTimeZone(String timeZone) {
if (timeZone == null || timeZone.isEmpty())
return null;
return timeZone;
}
attributes.put(ACCESS_WINDOW_START_ATTRIBUTE_NAME, formatTime(getModel().getAccessWindowStart()));
attributes.put(ACCESS_WINDOW_END_ATTRIBUTE_NAME, formatTime(getModel().getAccessWindowEnd()));
attributes.put(VALID_FROM_ATTRIBUTE_NAME, formatDate(getModel().getValidFrom()));
attributes.put(VALID_UNTIL_ATTRIBUTE_NAME, formatDate(getModel().getValidUntil()));
attributes.put(TIMEZONE_ATTRIBUTE_NAME, getModel().getTimeZone());
try { getModel().setAccessWindowStart(parseTime(attributes.get(ACCESS_WINDOW_START_ATTRIBUTE_NAME))); }
catch (ParseException e) {
logger.warn("Not setting start time of user access window - invalid time format.");
logger.debug("Unable to parse time attribute.", e);
}
try { getModel().setAccessWindowEnd(parseTime(attributes.get(ACCESS_WINDOW_END_ATTRIBUTE_NAME))); }
catch (ParseException e) {
logger.warn("Not setting end time of user access window - invalid time format.");
logger.debug("Unable to parse time attribute.", e);
}
try { getModel().setValidFrom(parseDate(attributes.get(VALID_FROM_ATTRIBUTE_NAME))); }
catch (ParseException e) {
logger.warn("Not setting user validity start date - invalid date format.");
logger.debug("Unable to parse date attribute.", e);
}
try { getModel().setValidUntil(parseDate(attributes.get(VALID_UNTIL_ATTRIBUTE_NAME))); }
catch (ParseException e) {
logger.warn("Not setting user validity end date - invalid date format.");
logger.debug("Unable to parse date attribute.", e);
}
getModel().setTimeZone(parseTimeZone(attributes.get(TIMEZONE_ATTRIBUTE_NAME)));
logger.warn("Not setting start time of user access window: {}", e.getMessage());
logger.warn("Not setting end time of user access window: {}", e.getMessage());
logger.warn("Not setting user validity start date: {}", e.getMessage());
logger.warn("Not setting user validity end date: {}", e.getMessage());
import java.util.Calendar;
import java.util.TimeZone;
private TimeZone getTimeZone() {
String timeZone = getModel().getTimeZone();
if (timeZone == null)
return TimeZone.getDefault();
return TimeZone.getTimeZone(timeZone);
}
private Calendar asCalendar(Calendar base, Time time) {
Calendar timeCalendar = Calendar.getInstance();
timeCalendar.setTime(time);
base.set(Calendar.HOUR_OF_DAY, timeCalendar.get(Calendar.HOUR_OF_DAY));
base.set(Calendar.MINUTE,      timeCalendar.get(Calendar.MINUTE));
base.set(Calendar.SECOND,      timeCalendar.get(Calendar.SECOND));
base.set(Calendar.MILLISECOND, timeCalendar.get(Calendar.MILLISECOND));
return base;
}
private Calendar getAccessWindowStart() {
Time start = getModel().getAccessWindowStart();
if (start == null)
return null;
return asCalendar(Calendar.getInstance(getTimeZone()), start);
}
private Calendar getAccessWindowEnd() {
Time end = getModel().getAccessWindowEnd();
if (end == null)
return null;
return asCalendar(Calendar.getInstance(getTimeZone()), end);
}
private Calendar getValidFrom() {
Date validFrom = getModel().getValidFrom();
if (validFrom == null)
return null;
Calendar validFromCalendar = Calendar.getInstance(getTimeZone());
validFromCalendar.setTime(validFrom);
validFromCalendar.set(Calendar.HOUR_OF_DAY, 0);
validFromCalendar.set(Calendar.MINUTE,      0);
validFromCalendar.set(Calendar.SECOND,      0);
validFromCalendar.set(Calendar.MILLISECOND, 0);
return validFromCalendar;
}
private Calendar getValidUntil() {
Date validUntil = getModel().getValidUntil();
if (validUntil == null)
return null;
Calendar validUntilCalendar = Calendar.getInstance(getTimeZone());
validUntilCalendar.setTime(validUntil);
validUntilCalendar.set(Calendar.HOUR_OF_DAY,  23);
validUntilCalendar.set(Calendar.MINUTE,       59);
validUntilCalendar.set(Calendar.SECOND,       59);
validUntilCalendar.set(Calendar.MILLISECOND, 999);
return validUntilCalendar;
}
private boolean isActive(Calendar activeStart, Calendar inactiveStart) {
if (inactiveStart != null && activeStart != null && inactiveStart.before(activeStart))
return !isActive(inactiveStart, activeStart);
Calendar current = Calendar.getInstance();
return !(activeStart != null && current.before(activeStart))
&& !(inactiveStart != null && current.after(inactiveStart));
}
public boolean isAccountValid() {
return isActive(getValidFrom(), getValidUntil());
}
public boolean isAccountAccessible() {
return isActive(getAccessWindowStart(), getAccessWindowEnd());
}
if (!user.isAccountValid())
throw new GuacamoleClientException("LOGIN.ERROR_NO_LONGER_VALID");
if (!user.isAccountAccessible())
throw new GuacamoleClientException("LOGIN.ERROR_NOT_WITHIN_ACCESS_WINDOW");
throw new GuacamoleClientException("LOGIN.ERROR_NOT_VALID");
throw new GuacamoleClientException("LOGIN.ERROR_NOT_ACCESSIBLE");
import java.sql.Date;
import java.sql.Time;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.TimeZone;
import org.glyptodon.guacamole.form.TextField;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
private static final Logger logger = LoggerFactory.getLogger(ModeledUser.class);
private static final String DATE_FORMAT = "yyyy-MM-dd";
private static final String TIME_FORMAT = "HH:mm:ss";
public static final String ACCESS_WINDOW_START_ATTRIBUTE_NAME = "access-window-start";
public static final String ACCESS_WINDOW_END_ATTRIBUTE_NAME = "access-window-end";
public static final String VALID_FROM_ATTRIBUTE_NAME = "valid-from";
public static final String VALID_UNTIL_ATTRIBUTE_NAME = "valid-until";
public static final String TIMEZONE_ATTRIBUTE_NAME = "timezone";
new BooleanField(EXPIRED_ATTRIBUTE_NAME, "true"),
new TextField(ACCESS_WINDOW_START_ATTRIBUTE_NAME),
new TextField(ACCESS_WINDOW_END_ATTRIBUTE_NAME),
new TextField(VALID_FROM_ATTRIBUTE_NAME),
new TextField(VALID_UNTIL_ATTRIBUTE_NAME),
new TextField(TIMEZONE_ATTRIBUTE_NAME)
private String formatDate(Date date) {
DateFormat dateFormat = new SimpleDateFormat(DATE_FORMAT);
return date == null ? null : dateFormat.format(date);
}
private String formatTime(Time time) {
DateFormat timeFormat = new SimpleDateFormat(TIME_FORMAT);
return time == null ? null : timeFormat.format(time);
}
private Date parseDate(String dateString)
throws ParseException {
if (dateString == null || dateString.isEmpty())
return null;
DateFormat dateFormat = new SimpleDateFormat(DATE_FORMAT);
return new Date(dateFormat.parse(dateString).getTime());
}
private Time parseTime(String timeString)
throws ParseException {
if (timeString == null || timeString.isEmpty())
return null;
DateFormat timeFormat = new SimpleDateFormat(TIME_FORMAT);
return new Time(timeFormat.parse(timeString).getTime());
}
private String parseTimeZone(String timeZone) {
if (timeZone == null || timeZone.isEmpty())
return null;
return timeZone;
}
attributes.put(ACCESS_WINDOW_START_ATTRIBUTE_NAME, formatTime(getModel().getAccessWindowStart()));
attributes.put(ACCESS_WINDOW_END_ATTRIBUTE_NAME, formatTime(getModel().getAccessWindowEnd()));
attributes.put(VALID_FROM_ATTRIBUTE_NAME, formatDate(getModel().getValidFrom()));
attributes.put(VALID_UNTIL_ATTRIBUTE_NAME, formatDate(getModel().getValidUntil()));
attributes.put(TIMEZONE_ATTRIBUTE_NAME, getModel().getTimeZone());
try { getModel().setAccessWindowStart(parseTime(attributes.get(ACCESS_WINDOW_START_ATTRIBUTE_NAME))); }
catch (ParseException e) {
logger.warn("Not setting start time of user access window: {}", e.getMessage());
logger.debug("Unable to parse time attribute.", e);
}
try { getModel().setAccessWindowEnd(parseTime(attributes.get(ACCESS_WINDOW_END_ATTRIBUTE_NAME))); }
catch (ParseException e) {
logger.warn("Not setting end time of user access window: {}", e.getMessage());
logger.debug("Unable to parse time attribute.", e);
}
try { getModel().setValidFrom(parseDate(attributes.get(VALID_FROM_ATTRIBUTE_NAME))); }
catch (ParseException e) {
logger.warn("Not setting user validity start date: {}", e.getMessage());
logger.debug("Unable to parse date attribute.", e);
}
try { getModel().setValidUntil(parseDate(attributes.get(VALID_UNTIL_ATTRIBUTE_NAME))); }
catch (ParseException e) {
logger.warn("Not setting user validity end date: {}", e.getMessage());
logger.debug("Unable to parse date attribute.", e);
}
getModel().setTimeZone(parseTimeZone(attributes.get(TIMEZONE_ATTRIBUTE_NAME)));
}
private TimeZone getTimeZone() {
String timeZone = getModel().getTimeZone();
if (timeZone == null)
return TimeZone.getDefault();
return TimeZone.getTimeZone(timeZone);
}
private Calendar asCalendar(Calendar base, Time time) {
Calendar timeCalendar = Calendar.getInstance();
timeCalendar.setTime(time);
base.set(Calendar.HOUR_OF_DAY, timeCalendar.get(Calendar.HOUR_OF_DAY));
base.set(Calendar.MINUTE,      timeCalendar.get(Calendar.MINUTE));
base.set(Calendar.SECOND,      timeCalendar.get(Calendar.SECOND));
base.set(Calendar.MILLISECOND, timeCalendar.get(Calendar.MILLISECOND));
return base;
}
private Calendar getAccessWindowStart() {
Time start = getModel().getAccessWindowStart();
if (start == null)
return null;
return asCalendar(Calendar.getInstance(getTimeZone()), start);
}
private Calendar getAccessWindowEnd() {
Time end = getModel().getAccessWindowEnd();
if (end == null)
return null;
return asCalendar(Calendar.getInstance(getTimeZone()), end);
}
private Calendar getValidFrom() {
Date validFrom = getModel().getValidFrom();
if (validFrom == null)
return null;
Calendar validFromCalendar = Calendar.getInstance(getTimeZone());
validFromCalendar.setTime(validFrom);
validFromCalendar.set(Calendar.HOUR_OF_DAY, 0);
validFromCalendar.set(Calendar.MINUTE,      0);
validFromCalendar.set(Calendar.SECOND,      0);
validFromCalendar.set(Calendar.MILLISECOND, 0);
return validFromCalendar;
}
private Calendar getValidUntil() {
Date validUntil = getModel().getValidUntil();
if (validUntil == null)
return null;
Calendar validUntilCalendar = Calendar.getInstance(getTimeZone());
validUntilCalendar.setTime(validUntil);
validUntilCalendar.set(Calendar.HOUR_OF_DAY,  23);
validUntilCalendar.set(Calendar.MINUTE,       59);
validUntilCalendar.set(Calendar.SECOND,       59);
validUntilCalendar.set(Calendar.MILLISECOND, 999);
return validUntilCalendar;
}
private boolean isActive(Calendar activeStart, Calendar inactiveStart) {
if (inactiveStart != null && activeStart != null && inactiveStart.before(activeStart))
return !isActive(inactiveStart, activeStart);
Calendar current = Calendar.getInstance();
return !(activeStart != null && current.before(activeStart))
&& !(inactiveStart != null && current.after(inactiveStart));
}
public boolean isAccountValid() {
return isActive(getValidFrom(), getValidUntil());
}
public boolean isAccountAccessible() {
return isActive(getAccessWindowStart(), getAccessWindowEnd());
import java.sql.Date;
import java.sql.Time;
private Time accessWindowStart;
private Time accessWindowEnd;
private Date validFrom;
private Date validUntil;
private String timeZone;
public Time getAccessWindowStart() {
return accessWindowStart;
}
public void setAccessWindowStart(Time accessWindowStart) {
this.accessWindowStart = accessWindowStart;
}
public Time getAccessWindowEnd() {
return accessWindowEnd;
}
public void setAccessWindowEnd(Time accessWindowEnd) {
this.accessWindowEnd = accessWindowEnd;
}
public Date getValidFrom() {
return validFrom;
}
public void setValidFrom(Date validFrom) {
this.validFrom = validFrom;
}
public Date getValidUntil() {
return validUntil;
}
public void setValidUntil(Date validUntil) {
this.validUntil = validUntil;
}
public String getTimeZone() {
return timeZone;
}
public void setTimeZone(String timeZone) {
this.timeZone = timeZone;
}
if (!user.isAccountValid())
throw new GuacamoleClientException("LOGIN.ERROR_NOT_VALID");
if (!user.isAccountAccessible())
throw new GuacamoleClientException("LOGIN.ERROR_NOT_ACCESSIBLE");
import org.glyptodon.guacamole.form.TimeZoneField;
new TimeZoneField(TIMEZONE_ATTRIBUTE_NAME)
public static String TIMEZONE = "TIMEZONE";
import org.glyptodon.guacamole.form.TimeZoneField;
new TimeZoneField(TIMEZONE_ATTRIBUTE_NAME)
public static String TIMEZONE = "TIMEZONE";
import org.glyptodon.guacamole.form.DateField;
import org.glyptodon.guacamole.form.TimeField;
new TimeField(ACCESS_WINDOW_START_ATTRIBUTE_NAME),
new TimeField(ACCESS_WINDOW_END_ATTRIBUTE_NAME),
new DateField(VALID_FROM_ATTRIBUTE_NAME),
new DateField(VALID_UNTIL_ATTRIBUTE_NAME),
DateFormat dateFormat = new SimpleDateFormat(DateField.FORMAT);
DateFormat timeFormat = new SimpleDateFormat(TimeField.FORMAT);
DateFormat dateFormat = new SimpleDateFormat(DateField.FORMAT);
DateFormat timeFormat = new SimpleDateFormat(TimeField.FORMAT);
public static String DATE = "DATE";
public static String TIME = "TIME";
import org.glyptodon.guacamole.form.DateField;
import org.glyptodon.guacamole.form.TimeField;
new TimeField(ACCESS_WINDOW_START_ATTRIBUTE_NAME),
new TimeField(ACCESS_WINDOW_END_ATTRIBUTE_NAME),
new DateField(VALID_FROM_ATTRIBUTE_NAME),
new DateField(VALID_UNTIL_ATTRIBUTE_NAME),
DateFormat dateFormat = new SimpleDateFormat(DateField.FORMAT);
DateFormat timeFormat = new SimpleDateFormat(TimeField.FORMAT);
DateFormat dateFormat = new SimpleDateFormat(DateField.FORMAT);
DateFormat timeFormat = new SimpleDateFormat(TimeField.FORMAT);
public static String DATE = "DATE";
public static String TIME = "TIME";
@Produces(MediaType.TEXT_PLAIN)
@Produces(MediaType.TEXT_PLAIN)
@Produces(MediaType.TEXT_PLAIN)
@Produces(MediaType.TEXT_PLAIN)
@Produces(MediaType.TEXT_PLAIN)
@Produces(MediaType.TEXT_PLAIN)
writer.writeInstruction(
new GuacamoleInstruction(
"image",
info.getImageMimetypes().toArray(new String[0])
));
private final List<String> imageMimetypes = new ArrayList<String>();
public List<String> getImageMimetypes() {
return imageMimetypes;
}
List<String> image_mimetypes = request.getParameterValues("image");
if (image_mimetypes != null)
info.getImageMimetypes().addAll(image_mimetypes);
private final GuacamoleTunnelService tunnelService;
GuacamoleTunnelService tunnelService) {
this.tunnelService = tunnelService;
bind(GuacamoleTunnelService.class).toInstance(tunnelService);
import org.glyptodon.guacamole.auth.jdbc.tunnel.ConfigurableGuacamoleTunnelService;
private GuacamoleTunnelService getTunnelService(Environment environment)
int connectionDefaultMaxConnections;
int connectionDefaultMaxConnectionsPerUser;
int connectionGroupDefaultMaxConnections;
int connectionGroupDefaultMaxConnectionsPerUser;
connectionGroupDefaultMaxConnections = 0;
if (disallowSimultaneous)
connectionDefaultMaxConnections = 1;
else
connectionDefaultMaxConnections = 0;
if (disallowDuplicate) {
connectionDefaultMaxConnectionsPerUser      = 1;
connectionGroupDefaultMaxConnectionsPerUser = 1;
connectionDefaultMaxConnectionsPerUser      = 0;
connectionGroupDefaultMaxConnectionsPerUser = 0;
return new ConfigurableGuacamoleTunnelService(
connectionDefaultMaxConnections,
connectionDefaultMaxConnectionsPerUser,
connectionGroupDefaultMaxConnections,
connectionGroupDefaultMaxConnectionsPerUser
);
new JDBCAuthenticationProviderModule(environment, getTunnelService(environment))
import org.glyptodon.guacamole.auth.jdbc.tunnel.ConfigurableGuacamoleTunnelService;
private GuacamoleTunnelService getTunnelService(Environment environment)
int connectionDefaultMaxConnections;
int connectionDefaultMaxConnectionsPerUser;
int connectionGroupDefaultMaxConnections;
int connectionGroupDefaultMaxConnectionsPerUser;
connectionGroupDefaultMaxConnections = 0;
if (disallowSimultaneous)
connectionDefaultMaxConnections = 1;
else
connectionDefaultMaxConnections = 0;
if (disallowDuplicate) {
connectionDefaultMaxConnectionsPerUser      = 1;
connectionGroupDefaultMaxConnectionsPerUser = 1;
connectionDefaultMaxConnectionsPerUser      = 0;
connectionGroupDefaultMaxConnectionsPerUser = 0;
return new ConfigurableGuacamoleTunnelService(
connectionDefaultMaxConnections,
connectionDefaultMaxConnectionsPerUser,
connectionGroupDefaultMaxConnections,
connectionGroupDefaultMaxConnectionsPerUser
);
new JDBCAuthenticationProviderModule(environment, getTunnelService(environment))
private final GuacamoleTunnelService tunnelService;
GuacamoleTunnelService tunnelService) {
this.tunnelService = tunnelService;
bind(GuacamoleTunnelService.class).toInstance(tunnelService);
import org.glyptodon.guacamole.auth.jdbc.tunnel.ConfigurableGuacamoleTunnelService;
private GuacamoleTunnelService getTunnelService(Environment environment)
int connectionDefaultMaxConnections;
int connectionDefaultMaxConnectionsPerUser;
int connectionGroupDefaultMaxConnections;
int connectionGroupDefaultMaxConnectionsPerUser;
connectionGroupDefaultMaxConnections = 0;
if (disallowSimultaneous)
connectionDefaultMaxConnections = 1;
else
connectionDefaultMaxConnections = 0;
if (disallowDuplicate) {
connectionDefaultMaxConnectionsPerUser      = 1;
connectionGroupDefaultMaxConnectionsPerUser = 1;
connectionDefaultMaxConnectionsPerUser      = 0;
connectionGroupDefaultMaxConnectionsPerUser = 0;
return new ConfigurableGuacamoleTunnelService(
connectionDefaultMaxConnections,
connectionDefaultMaxConnectionsPerUser,
connectionGroupDefaultMaxConnections,
connectionGroupDefaultMaxConnectionsPerUser
);
new JDBCAuthenticationProviderModule(environment, getTunnelService(environment))
import org.glyptodon.guacamole.auth.jdbc.tunnel.ConfigurableGuacamoleTunnelService;
private GuacamoleTunnelService getTunnelService(Environment environment)
int connectionDefaultMaxConnections;
int connectionDefaultMaxConnectionsPerUser;
int connectionGroupDefaultMaxConnections;
int connectionGroupDefaultMaxConnectionsPerUser;
connectionGroupDefaultMaxConnections = 0;
if (disallowSimultaneous)
connectionDefaultMaxConnections = 1;
else
connectionDefaultMaxConnections = 0;
if (disallowDuplicate) {
connectionDefaultMaxConnectionsPerUser      = 1;
connectionGroupDefaultMaxConnectionsPerUser = 1;
connectionDefaultMaxConnectionsPerUser      = 0;
connectionGroupDefaultMaxConnectionsPerUser = 0;
return new ConfigurableGuacamoleTunnelService(
connectionDefaultMaxConnections,
connectionDefaultMaxConnectionsPerUser,
connectionGroupDefaultMaxConnections,
connectionGroupDefaultMaxConnectionsPerUser
);
new JDBCAuthenticationProviderModule(environment, getTunnelService(environment))
private Integer maxConnections;
private Integer maxConnectionsPerUser;
public Integer getMaxConnections() {
return maxConnections;
}
public void setMaxConnections(Integer maxConnections) {
this.maxConnections = maxConnections;
}
public Integer getMaxConnectionsPerUser() {
return maxConnectionsPerUser;
}
public void setMaxConnectionsPerUser(Integer maxConnectionsPerUser) {
this.maxConnectionsPerUser = maxConnectionsPerUser;
}
private Integer maxConnections;
private Integer maxConnectionsPerUser;
public Integer getMaxConnections() {
return maxConnections;
}
public void setMaxConnections(Integer maxConnections) {
this.maxConnections = maxConnections;
}
public Integer getMaxConnectionsPerUser() {
return maxConnectionsPerUser;
}
public void setMaxConnectionsPerUser(Integer maxConnectionsPerUser) {
this.maxConnectionsPerUser = maxConnectionsPerUser;
}
Integer connectionMaxConnectionsPerUser = connection.getModel().getMaxConnectionsPerUser();
if (connectionMaxConnectionsPerUser == null)
connectionMaxConnectionsPerUser = connectionDefaultMaxConnectionsPerUser;
Integer connectionMaxConnections = connection.getModel().getMaxConnections();
if (connectionMaxConnections == null)
connectionMaxConnections = connectionDefaultMaxConnections;
if (tryAdd(activeSeats, seat, connectionMaxConnectionsPerUser)) {
connectionMaxConnections))
Integer connectionGroupMaxConnectionsPerUser = connectionGroup.getModel().getMaxConnectionsPerUser();
if (connectionGroupMaxConnectionsPerUser == null)
connectionGroupMaxConnectionsPerUser = connectionGroupDefaultMaxConnectionsPerUser;
Integer connectionGroupMaxConnections = connectionGroup.getModel().getMaxConnections();
if (connectionGroupMaxConnections == null)
connectionGroupMaxConnections = connectionGroupDefaultMaxConnections;
connectionGroupMaxConnectionsPerUser)) {
connectionGroupMaxConnections))
@Override
public Map<String, String> getAttributes() {
Map<String, String> attributes = new HashMap<String, String>();
attributes.put(DISABLED_ATTRIBUTE_NAME, getModel().isDisabled() ? "true" : null);
attributes.put(EXPIRED_ATTRIBUTE_NAME, getModel().isExpired() ? "true" : null);
attributes.put(ACCESS_WINDOW_START_ATTRIBUTE_NAME, TimeField.format(getModel().getAccessWindowStart()));
attributes.put(ACCESS_WINDOW_END_ATTRIBUTE_NAME, TimeField.format(getModel().getAccessWindowEnd()));
attributes.put(VALID_FROM_ATTRIBUTE_NAME, DateField.format(getModel().getValidFrom()));
attributes.put(VALID_UNTIL_ATTRIBUTE_NAME, DateField.format(getModel().getValidUntil()));
attributes.put(TIMEZONE_ATTRIBUTE_NAME, getModel().getTimeZone());
return attributes;
java.util.Date parsedDate = DateField.parse(dateString);
if (parsedDate == null)
return new Date(parsedDate.getTime());
java.util.Date parsedDate = TimeField.parse(timeString);
if (parsedDate == null)
return new Time(parsedDate.getTime());
getModel().setTimeZone(TimeZoneField.parse(attributes.get(TIMEZONE_ATTRIBUTE_NAME)));
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
public static String format(Date date) {
DateFormat dateFormat = new SimpleDateFormat(DateField.FORMAT);
return date == null ? null : dateFormat.format(date);
}
public static Date parse(String dateString)
throws ParseException {
if (dateString == null || dateString.isEmpty())
return null;
DateFormat dateFormat = new SimpleDateFormat(DateField.FORMAT);
return dateFormat.parse(dateString);
}
public static String format(Integer i) {
if (i == null)
return null;
return i.toString();
}
public static Integer parse(String str) throws NumberFormatException {
if (str == null || str.isEmpty())
return null;
return new Integer(str);
}
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
public static Date parse(String timeString)
throws ParseException {
if (timeString == null || timeString.isEmpty())
return null;
DateFormat timeFormat = new SimpleDateFormat(TimeField.FORMAT);
return timeFormat.parse(timeString);
}
public static String format(Date time) {
DateFormat timeFormat = new SimpleDateFormat(TimeField.FORMAT);
return time == null ? null : timeFormat.format(time);
}
public static String parse(String timeZone) {
if (timeZone == null || timeZone.isEmpty())
return null;
return timeZone;
}
throw new GuacamoleClientTooManyException("Cannot connect. Connection already in use by this user.");
if (count >= max && max != 0)
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import org.glyptodon.guacamole.form.Field;
import org.glyptodon.guacamole.form.Form;
import org.glyptodon.guacamole.form.NumericField;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
private static final Logger logger = LoggerFactory.getLogger(ModeledConnection.class);
public static final String MAX_CONNECTIONS_NAME = "max-connections";
public static final String MAX_CONNECTIONS_PER_USER_NAME = "max-connections-per-user";
public static final Form CONCURRENCY_LIMITS = new Form("concurrency", Arrays.<Field>asList(
new NumericField(MAX_CONNECTIONS_NAME),
new NumericField(MAX_CONNECTIONS_PER_USER_NAME)
));
public static final Collection<Form> ATTRIBUTES = Collections.unmodifiableCollection(Arrays.asList(
CONCURRENCY_LIMITS
));
Map<String, String> attributes = new HashMap<String, String>();
attributes.put(MAX_CONNECTIONS_NAME, NumericField.format(getModel().getMaxConnections()));
attributes.put(MAX_CONNECTIONS_PER_USER_NAME, NumericField.format(getModel().getMaxConnectionsPerUser()));
return attributes;
try { getModel().setMaxConnections(NumericField.parse(attributes.get(MAX_CONNECTIONS_NAME))); }
catch (NumberFormatException e) {
logger.warn("Not setting maximum connections: {}", e.getMessage());
logger.debug("Unable to parse numeric attribute.", e);
}
try { getModel().setMaxConnectionsPerUser(NumericField.parse(attributes.get(MAX_CONNECTIONS_PER_USER_NAME))); }
catch (NumberFormatException e) {
logger.warn("Not setting maximum connections per user: {}", e.getMessage());
logger.debug("Unable to parse numeric attribute.", e);
}
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import org.glyptodon.guacamole.form.Field;
import org.glyptodon.guacamole.form.Form;
import org.glyptodon.guacamole.form.NumericField;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
private static final Logger logger = LoggerFactory.getLogger(ModeledConnectionGroup.class);
public static final String MAX_CONNECTIONS_NAME = "max-connections";
public static final String MAX_CONNECTIONS_PER_USER_NAME = "max-connections-per-user";
public static final Form CONCURRENCY_LIMITS = new Form("concurrency", Arrays.<Field>asList(
new NumericField(MAX_CONNECTIONS_NAME),
new NumericField(MAX_CONNECTIONS_PER_USER_NAME)
));
public static final Collection<Form> ATTRIBUTES = Collections.unmodifiableCollection(Arrays.asList(
CONCURRENCY_LIMITS
));
Map<String, String> attributes = new HashMap<String, String>();
attributes.put(MAX_CONNECTIONS_NAME, NumericField.format(getModel().getMaxConnections()));
attributes.put(MAX_CONNECTIONS_PER_USER_NAME, NumericField.format(getModel().getMaxConnectionsPerUser()));
return attributes;
try { getModel().setMaxConnections(NumericField.parse(attributes.get(MAX_CONNECTIONS_NAME))); }
catch (NumberFormatException e) {
logger.warn("Not setting maximum connections: {}", e.getMessage());
logger.debug("Unable to parse numeric attribute.", e);
}
try { getModel().setMaxConnectionsPerUser(NumericField.parse(attributes.get(MAX_CONNECTIONS_PER_USER_NAME))); }
catch (NumberFormatException e) {
logger.warn("Not setting maximum connections per user: {}", e.getMessage());
logger.debug("Unable to parse numeric attribute.", e);
}
import org.glyptodon.guacamole.auth.jdbc.connection.ModeledConnection;
import org.glyptodon.guacamole.auth.jdbc.connectiongroup.ModeledConnectionGroup;
return ModeledConnection.ATTRIBUTES;
return ModeledConnectionGroup.ATTRIBUTES;
private Integer maxConnections;
private Integer maxConnectionsPerUser;
public Integer getMaxConnections() {
return maxConnections;
}
public void setMaxConnections(Integer maxConnections) {
this.maxConnections = maxConnections;
}
public Integer getMaxConnectionsPerUser() {
return maxConnectionsPerUser;
}
public void setMaxConnectionsPerUser(Integer maxConnectionsPerUser) {
this.maxConnectionsPerUser = maxConnectionsPerUser;
}
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import org.glyptodon.guacamole.form.Field;
import org.glyptodon.guacamole.form.Form;
import org.glyptodon.guacamole.form.NumericField;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
private static final Logger logger = LoggerFactory.getLogger(ModeledConnection.class);
public static final String MAX_CONNECTIONS_NAME = "max-connections";
public static final String MAX_CONNECTIONS_PER_USER_NAME = "max-connections-per-user";
public static final Form CONCURRENCY_LIMITS = new Form("concurrency", Arrays.<Field>asList(
new NumericField(MAX_CONNECTIONS_NAME),
new NumericField(MAX_CONNECTIONS_PER_USER_NAME)
));
public static final Collection<Form> ATTRIBUTES = Collections.unmodifiableCollection(Arrays.asList(
CONCURRENCY_LIMITS
));
Map<String, String> attributes = new HashMap<String, String>();
attributes.put(MAX_CONNECTIONS_NAME, NumericField.format(getModel().getMaxConnections()));
attributes.put(MAX_CONNECTIONS_PER_USER_NAME, NumericField.format(getModel().getMaxConnectionsPerUser()));
return attributes;
try { getModel().setMaxConnections(NumericField.parse(attributes.get(MAX_CONNECTIONS_NAME))); }
catch (NumberFormatException e) {
logger.warn("Not setting maximum connections: {}", e.getMessage());
logger.debug("Unable to parse numeric attribute.", e);
}
try { getModel().setMaxConnectionsPerUser(NumericField.parse(attributes.get(MAX_CONNECTIONS_PER_USER_NAME))); }
catch (NumberFormatException e) {
logger.warn("Not setting maximum connections per user: {}", e.getMessage());
logger.debug("Unable to parse numeric attribute.", e);
}
private Integer maxConnections;
private Integer maxConnectionsPerUser;
public Integer getMaxConnections() {
return maxConnections;
}
public void setMaxConnections(Integer maxConnections) {
this.maxConnections = maxConnections;
}
public Integer getMaxConnectionsPerUser() {
return maxConnectionsPerUser;
}
public void setMaxConnectionsPerUser(Integer maxConnectionsPerUser) {
this.maxConnectionsPerUser = maxConnectionsPerUser;
}
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import org.glyptodon.guacamole.form.Field;
import org.glyptodon.guacamole.form.Form;
import org.glyptodon.guacamole.form.NumericField;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
private static final Logger logger = LoggerFactory.getLogger(ModeledConnectionGroup.class);
public static final String MAX_CONNECTIONS_NAME = "max-connections";
public static final String MAX_CONNECTIONS_PER_USER_NAME = "max-connections-per-user";
public static final Form CONCURRENCY_LIMITS = new Form("concurrency", Arrays.<Field>asList(
new NumericField(MAX_CONNECTIONS_NAME),
new NumericField(MAX_CONNECTIONS_PER_USER_NAME)
));
public static final Collection<Form> ATTRIBUTES = Collections.unmodifiableCollection(Arrays.asList(
CONCURRENCY_LIMITS
));
Map<String, String> attributes = new HashMap<String, String>();
attributes.put(MAX_CONNECTIONS_NAME, NumericField.format(getModel().getMaxConnections()));
attributes.put(MAX_CONNECTIONS_PER_USER_NAME, NumericField.format(getModel().getMaxConnectionsPerUser()));
return attributes;
try { getModel().setMaxConnections(NumericField.parse(attributes.get(MAX_CONNECTIONS_NAME))); }
catch (NumberFormatException e) {
logger.warn("Not setting maximum connections: {}", e.getMessage());
logger.debug("Unable to parse numeric attribute.", e);
}
try { getModel().setMaxConnectionsPerUser(NumericField.parse(attributes.get(MAX_CONNECTIONS_PER_USER_NAME))); }
catch (NumberFormatException e) {
logger.warn("Not setting maximum connections per user: {}", e.getMessage());
logger.debug("Unable to parse numeric attribute.", e);
}
if (count >= max && max != 0)
Integer connectionMaxConnectionsPerUser = connection.getModel().getMaxConnectionsPerUser();
if (connectionMaxConnectionsPerUser == null)
connectionMaxConnectionsPerUser = connectionDefaultMaxConnectionsPerUser;
Integer connectionMaxConnections = connection.getModel().getMaxConnections();
if (connectionMaxConnections == null)
connectionMaxConnections = connectionDefaultMaxConnections;
if (tryAdd(activeSeats, seat, connectionMaxConnectionsPerUser)) {
connectionMaxConnections))
throw new GuacamoleClientTooManyException("Cannot connect. Connection already in use by this user.");
Integer connectionGroupMaxConnectionsPerUser = connectionGroup.getModel().getMaxConnectionsPerUser();
if (connectionGroupMaxConnectionsPerUser == null)
connectionGroupMaxConnectionsPerUser = connectionGroupDefaultMaxConnectionsPerUser;
Integer connectionGroupMaxConnections = connectionGroup.getModel().getMaxConnections();
if (connectionGroupMaxConnections == null)
connectionGroupMaxConnections = connectionGroupDefaultMaxConnections;
connectionGroupMaxConnectionsPerUser)) {
connectionGroupMaxConnections))
@Override
public Map<String, String> getAttributes() {
Map<String, String> attributes = new HashMap<String, String>();
attributes.put(DISABLED_ATTRIBUTE_NAME, getModel().isDisabled() ? "true" : null);
attributes.put(EXPIRED_ATTRIBUTE_NAME, getModel().isExpired() ? "true" : null);
attributes.put(ACCESS_WINDOW_START_ATTRIBUTE_NAME, TimeField.format(getModel().getAccessWindowStart()));
attributes.put(ACCESS_WINDOW_END_ATTRIBUTE_NAME, TimeField.format(getModel().getAccessWindowEnd()));
attributes.put(VALID_FROM_ATTRIBUTE_NAME, DateField.format(getModel().getValidFrom()));
attributes.put(VALID_UNTIL_ATTRIBUTE_NAME, DateField.format(getModel().getValidUntil()));
attributes.put(TIMEZONE_ATTRIBUTE_NAME, getModel().getTimeZone());
return attributes;
java.util.Date parsedDate = DateField.parse(dateString);
if (parsedDate == null)
return new Date(parsedDate.getTime());
java.util.Date parsedDate = TimeField.parse(timeString);
if (parsedDate == null)
return new Time(parsedDate.getTime());
getModel().setTimeZone(TimeZoneField.parse(attributes.get(TIMEZONE_ATTRIBUTE_NAME)));
import org.glyptodon.guacamole.auth.jdbc.connection.ModeledConnection;
import org.glyptodon.guacamole.auth.jdbc.connectiongroup.ModeledConnectionGroup;
return ModeledConnection.ATTRIBUTES;
return ModeledConnectionGroup.ATTRIBUTES;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
public static String format(Date date) {
DateFormat dateFormat = new SimpleDateFormat(DateField.FORMAT);
return date == null ? null : dateFormat.format(date);
}
public static Date parse(String dateString)
throws ParseException {
if (dateString == null || dateString.isEmpty())
return null;
DateFormat dateFormat = new SimpleDateFormat(DateField.FORMAT);
return dateFormat.parse(dateString);
}
public static String format(Integer i) {
if (i == null)
return null;
return i.toString();
}
public static Integer parse(String str) throws NumberFormatException {
if (str == null || str.isEmpty())
return null;
return new Integer(str);
}
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
public static Date parse(String timeString)
throws ParseException {
if (timeString == null || timeString.isEmpty())
return null;
DateFormat timeFormat = new SimpleDateFormat(TimeField.FORMAT);
return timeFormat.parse(timeString);
}
public static String format(Date time) {
DateFormat timeFormat = new SimpleDateFormat(TimeField.FORMAT);
return time == null ? null : timeFormat.format(time);
}
public static String parse(String timeZone) {
if (timeZone == null || timeZone.isEmpty())
return null;
return timeZone;
}
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
private static final Logger logger = LoggerFactory.getLogger(MySQLAuthenticationProvider.class);
Boolean disallowSimultaneous = environment.getProperty(MySQLGuacamoleProperties.MYSQL_DISALLOW_SIMULTANEOUS_CONNECTIONS);
Boolean disallowDuplicate    = environment.getProperty(MySQLGuacamoleProperties.MYSQL_DISALLOW_DUPLICATE_CONNECTIONS);
if (disallowSimultaneous != null) {
if (disallowSimultaneous) {
connectionDefaultMaxConnections = 1;
connectionGroupDefaultMaxConnections = 0;
}
else {
connectionDefaultMaxConnections = 0;
connectionGroupDefaultMaxConnections = 0;
}
logger.warn("The \"{}\" property is deprecated. Use \"{}\" and \"{}\" instead.",
MySQLGuacamoleProperties.MYSQL_DISALLOW_SIMULTANEOUS_CONNECTIONS.getName(),
MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_CONNECTIONS.getName(),
MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_GROUP_CONNECTIONS.getName());
logger.info("To achieve the same result of setting \"{}\" to \"{}\", set \"{}\" to \"{}\" and \"{}\" to \"{}\".",
MySQLGuacamoleProperties.MYSQL_DISALLOW_SIMULTANEOUS_CONNECTIONS.getName(), disallowSimultaneous,
MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_CONNECTIONS.getName(),           connectionDefaultMaxConnections,
MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_GROUP_CONNECTIONS.getName(),     connectionGroupDefaultMaxConnections);
}
else {
connectionDefaultMaxConnections      = environment.getProperty(MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_CONNECTIONS, 0);
connectionGroupDefaultMaxConnections = environment.getProperty(MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_GROUP_CONNECTIONS, 0);
}
if (disallowDuplicate != null) {
if (disallowDuplicate) {
connectionDefaultMaxConnectionsPerUser      = 1;
connectionGroupDefaultMaxConnectionsPerUser = 1;
}
else {
connectionDefaultMaxConnectionsPerUser      = 0;
connectionGroupDefaultMaxConnectionsPerUser = 0;
}
logger.warn("The \"{}\" property is deprecated. Use \"{}\" and \"{}\" instead.",
MySQLGuacamoleProperties.MYSQL_DISALLOW_DUPLICATE_CONNECTIONS.getName(),
MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_CONNECTIONS_PER_USER.getName(),
MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_GROUP_CONNECTIONS.getName());
logger.info("To achieve the same result of setting \"{}\" to \"{}\", set \"{}\" to \"{}\" and \"{}\" to \"{}\".",
MySQLGuacamoleProperties.MYSQL_DISALLOW_DUPLICATE_CONNECTIONS.getName(),         disallowDuplicate,
MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_CONNECTIONS_PER_USER.getName(),       connectionDefaultMaxConnectionsPerUser,
MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_GROUP_CONNECTIONS_PER_USER.getName(), connectionGroupDefaultMaxConnectionsPerUser);
connectionDefaultMaxConnectionsPerUser      = environment.getProperty(MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_CONNECTIONS_PER_USER, 1);
connectionGroupDefaultMaxConnectionsPerUser = environment.getProperty(MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_GROUP_CONNECTIONS_PER_USER, 1);
public static final IntegerGuacamoleProperty
MYSQL_DEFAULT_MAX_CONNECTIONS =
new IntegerGuacamoleProperty() {
@Override
public String getName() { return "mysql-default-max-connections"; }
};
public static final IntegerGuacamoleProperty
MYSQL_DEFAULT_MAX_GROUP_CONNECTIONS =
new IntegerGuacamoleProperty() {
@Override
public String getName() { return "mysql-default-max-group-connections"; }
};
public static final IntegerGuacamoleProperty
MYSQL_DEFAULT_MAX_CONNECTIONS_PER_USER =
new IntegerGuacamoleProperty() {
@Override
public String getName() { return "mysql-default-max-connections-per-user"; }
};
public static final IntegerGuacamoleProperty
MYSQL_DEFAULT_MAX_GROUP_CONNECTIONS_PER_USER =
new IntegerGuacamoleProperty() {
@Override
public String getName() { return "mysql-default-max-group-connections-per-user"; }
};
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
private static final Logger logger = LoggerFactory.getLogger(PostgreSQLAuthenticationProvider.class);
Boolean disallowSimultaneous = environment.getProperty(PostgreSQLGuacamoleProperties.POSTGRESQL_DISALLOW_SIMULTANEOUS_CONNECTIONS);
Boolean disallowDuplicate    = environment.getProperty(PostgreSQLGuacamoleProperties.POSTGRESQL_DISALLOW_DUPLICATE_CONNECTIONS);
if (disallowSimultaneous != null) {
if (disallowSimultaneous) {
connectionDefaultMaxConnections = 1;
connectionGroupDefaultMaxConnections = 0;
}
else {
connectionDefaultMaxConnections = 0;
connectionGroupDefaultMaxConnections = 0;
}
logger.warn("The \"{}\" property is deprecated. Use \"{}\" and \"{}\" instead.",
PostgreSQLGuacamoleProperties.POSTGRESQL_DISALLOW_SIMULTANEOUS_CONNECTIONS.getName(),
PostgreSQLGuacamoleProperties.POSTGRESQL_DEFAULT_MAX_CONNECTIONS.getName(),
PostgreSQLGuacamoleProperties.POSTGRESQL_DEFAULT_MAX_GROUP_CONNECTIONS.getName());
logger.info("To achieve the same result of setting \"{}\" to \"{}\", set \"{}\" to \"{}\" and \"{}\" to \"{}\".",
PostgreSQLGuacamoleProperties.POSTGRESQL_DISALLOW_SIMULTANEOUS_CONNECTIONS.getName(), disallowSimultaneous,
PostgreSQLGuacamoleProperties.POSTGRESQL_DEFAULT_MAX_CONNECTIONS.getName(),           connectionDefaultMaxConnections,
PostgreSQLGuacamoleProperties.POSTGRESQL_DEFAULT_MAX_GROUP_CONNECTIONS.getName(),     connectionGroupDefaultMaxConnections);
}
else {
connectionDefaultMaxConnections      = environment.getProperty(PostgreSQLGuacamoleProperties.POSTGRESQL_DEFAULT_MAX_CONNECTIONS, 0);
connectionGroupDefaultMaxConnections = environment.getProperty(PostgreSQLGuacamoleProperties.POSTGRESQL_DEFAULT_MAX_GROUP_CONNECTIONS, 0);
}
if (disallowDuplicate != null) {
if (disallowDuplicate) {
connectionDefaultMaxConnectionsPerUser      = 1;
connectionGroupDefaultMaxConnectionsPerUser = 1;
}
else {
connectionDefaultMaxConnectionsPerUser      = 0;
connectionGroupDefaultMaxConnectionsPerUser = 0;
}
logger.warn("The \"{}\" property is deprecated. Use \"{}\" and \"{}\" instead.",
PostgreSQLGuacamoleProperties.POSTGRESQL_DISALLOW_DUPLICATE_CONNECTIONS.getName(),
PostgreSQLGuacamoleProperties.POSTGRESQL_DEFAULT_MAX_CONNECTIONS_PER_USER.getName(),
PostgreSQLGuacamoleProperties.POSTGRESQL_DEFAULT_MAX_GROUP_CONNECTIONS.getName());
logger.info("To achieve the same result of setting \"{}\" to \"{}\", set \"{}\" to \"{}\" and \"{}\" to \"{}\".",
PostgreSQLGuacamoleProperties.POSTGRESQL_DISALLOW_DUPLICATE_CONNECTIONS.getName(),         disallowDuplicate,
PostgreSQLGuacamoleProperties.POSTGRESQL_DEFAULT_MAX_CONNECTIONS_PER_USER.getName(),       connectionDefaultMaxConnectionsPerUser,
PostgreSQLGuacamoleProperties.POSTGRESQL_DEFAULT_MAX_GROUP_CONNECTIONS_PER_USER.getName(), connectionGroupDefaultMaxConnectionsPerUser);
connectionDefaultMaxConnectionsPerUser      = environment.getProperty(PostgreSQLGuacamoleProperties.POSTGRESQL_DEFAULT_MAX_CONNECTIONS_PER_USER, 1);
connectionGroupDefaultMaxConnectionsPerUser = environment.getProperty(PostgreSQLGuacamoleProperties.POSTGRESQL_DEFAULT_MAX_GROUP_CONNECTIONS_PER_USER, 1);
public static final IntegerGuacamoleProperty
POSTGRESQL_DEFAULT_MAX_CONNECTIONS =
new IntegerGuacamoleProperty() {
@Override
public String getName() { return "postgresql-default-max-connections"; }
};
public static final IntegerGuacamoleProperty
POSTGRESQL_DEFAULT_MAX_GROUP_CONNECTIONS =
new IntegerGuacamoleProperty() {
@Override
public String getName() { return "postgresql-default-max-group-connections"; }
};
public static final IntegerGuacamoleProperty
POSTGRESQL_DEFAULT_MAX_CONNECTIONS_PER_USER =
new IntegerGuacamoleProperty() {
@Override
public String getName() { return "postgresql-default-max-connections-per-user"; }
};
public static final IntegerGuacamoleProperty
POSTGRESQL_DEFAULT_MAX_GROUP_CONNECTIONS_PER_USER =
new IntegerGuacamoleProperty() {
@Override
public String getName() { return "postgresql-default-max-group-connections-per-user"; }
};
connectionDefaultMaxConnections      = 1;
connectionDefaultMaxConnections      = 0;
connectionDefaultMaxConnections      = 1;
connectionDefaultMaxConnections      = 0;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
private static final Logger logger = LoggerFactory.getLogger(MySQLAuthenticationProvider.class);
Boolean disallowSimultaneous = environment.getProperty(MySQLGuacamoleProperties.MYSQL_DISALLOW_SIMULTANEOUS_CONNECTIONS);
Boolean disallowDuplicate    = environment.getProperty(MySQLGuacamoleProperties.MYSQL_DISALLOW_DUPLICATE_CONNECTIONS);
if (disallowSimultaneous != null) {
if (disallowSimultaneous) {
connectionDefaultMaxConnections      = 1;
connectionGroupDefaultMaxConnections = 0;
}
else {
connectionDefaultMaxConnections      = 0;
connectionGroupDefaultMaxConnections = 0;
}
logger.warn("The \"{}\" property is deprecated. Use \"{}\" and \"{}\" instead.",
MySQLGuacamoleProperties.MYSQL_DISALLOW_SIMULTANEOUS_CONNECTIONS.getName(),
MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_CONNECTIONS.getName(),
MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_GROUP_CONNECTIONS.getName());
logger.info("To achieve the same result of setting \"{}\" to \"{}\", set \"{}\" to \"{}\" and \"{}\" to \"{}\".",
MySQLGuacamoleProperties.MYSQL_DISALLOW_SIMULTANEOUS_CONNECTIONS.getName(), disallowSimultaneous,
MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_CONNECTIONS.getName(),           connectionDefaultMaxConnections,
MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_GROUP_CONNECTIONS.getName(),     connectionGroupDefaultMaxConnections);
}
else {
connectionDefaultMaxConnections      = environment.getProperty(MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_CONNECTIONS, 0);
connectionGroupDefaultMaxConnections = environment.getProperty(MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_GROUP_CONNECTIONS, 0);
}
if (disallowDuplicate != null) {
if (disallowDuplicate) {
connectionDefaultMaxConnectionsPerUser      = 1;
connectionGroupDefaultMaxConnectionsPerUser = 1;
}
else {
connectionDefaultMaxConnectionsPerUser      = 0;
connectionGroupDefaultMaxConnectionsPerUser = 0;
}
logger.warn("The \"{}\" property is deprecated. Use \"{}\" and \"{}\" instead.",
MySQLGuacamoleProperties.MYSQL_DISALLOW_DUPLICATE_CONNECTIONS.getName(),
MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_CONNECTIONS_PER_USER.getName(),
MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_GROUP_CONNECTIONS.getName());
logger.info("To achieve the same result of setting \"{}\" to \"{}\", set \"{}\" to \"{}\" and \"{}\" to \"{}\".",
MySQLGuacamoleProperties.MYSQL_DISALLOW_DUPLICATE_CONNECTIONS.getName(),         disallowDuplicate,
MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_CONNECTIONS_PER_USER.getName(),       connectionDefaultMaxConnectionsPerUser,
MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_GROUP_CONNECTIONS_PER_USER.getName(), connectionGroupDefaultMaxConnectionsPerUser);
connectionDefaultMaxConnectionsPerUser      = environment.getProperty(MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_CONNECTIONS_PER_USER, 1);
connectionGroupDefaultMaxConnectionsPerUser = environment.getProperty(MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_GROUP_CONNECTIONS_PER_USER, 1);
public static final IntegerGuacamoleProperty
MYSQL_DEFAULT_MAX_CONNECTIONS =
new IntegerGuacamoleProperty() {
@Override
public String getName() { return "mysql-default-max-connections"; }
};
public static final IntegerGuacamoleProperty
MYSQL_DEFAULT_MAX_GROUP_CONNECTIONS =
new IntegerGuacamoleProperty() {
@Override
public String getName() { return "mysql-default-max-group-connections"; }
};
public static final IntegerGuacamoleProperty
MYSQL_DEFAULT_MAX_CONNECTIONS_PER_USER =
new IntegerGuacamoleProperty() {
@Override
public String getName() { return "mysql-default-max-connections-per-user"; }
};
public static final IntegerGuacamoleProperty
MYSQL_DEFAULT_MAX_GROUP_CONNECTIONS_PER_USER =
new IntegerGuacamoleProperty() {
@Override
public String getName() { return "mysql-default-max-group-connections-per-user"; }
};
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
private static final Logger logger = LoggerFactory.getLogger(PostgreSQLAuthenticationProvider.class);
Boolean disallowSimultaneous = environment.getProperty(PostgreSQLGuacamoleProperties.POSTGRESQL_DISALLOW_SIMULTANEOUS_CONNECTIONS);
Boolean disallowDuplicate    = environment.getProperty(PostgreSQLGuacamoleProperties.POSTGRESQL_DISALLOW_DUPLICATE_CONNECTIONS);
if (disallowSimultaneous != null) {
if (disallowSimultaneous) {
connectionDefaultMaxConnections      = 1;
connectionGroupDefaultMaxConnections = 0;
}
else {
connectionDefaultMaxConnections      = 0;
connectionGroupDefaultMaxConnections = 0;
}
logger.warn("The \"{}\" property is deprecated. Use \"{}\" and \"{}\" instead.",
PostgreSQLGuacamoleProperties.POSTGRESQL_DISALLOW_SIMULTANEOUS_CONNECTIONS.getName(),
PostgreSQLGuacamoleProperties.POSTGRESQL_DEFAULT_MAX_CONNECTIONS.getName(),
PostgreSQLGuacamoleProperties.POSTGRESQL_DEFAULT_MAX_GROUP_CONNECTIONS.getName());
logger.info("To achieve the same result of setting \"{}\" to \"{}\", set \"{}\" to \"{}\" and \"{}\" to \"{}\".",
PostgreSQLGuacamoleProperties.POSTGRESQL_DISALLOW_SIMULTANEOUS_CONNECTIONS.getName(), disallowSimultaneous,
PostgreSQLGuacamoleProperties.POSTGRESQL_DEFAULT_MAX_CONNECTIONS.getName(),           connectionDefaultMaxConnections,
PostgreSQLGuacamoleProperties.POSTGRESQL_DEFAULT_MAX_GROUP_CONNECTIONS.getName(),     connectionGroupDefaultMaxConnections);
}
else {
connectionDefaultMaxConnections      = environment.getProperty(PostgreSQLGuacamoleProperties.POSTGRESQL_DEFAULT_MAX_CONNECTIONS, 0);
connectionGroupDefaultMaxConnections = environment.getProperty(PostgreSQLGuacamoleProperties.POSTGRESQL_DEFAULT_MAX_GROUP_CONNECTIONS, 0);
}
if (disallowDuplicate != null) {
if (disallowDuplicate) {
connectionDefaultMaxConnectionsPerUser      = 1;
connectionGroupDefaultMaxConnectionsPerUser = 1;
}
else {
connectionDefaultMaxConnectionsPerUser      = 0;
connectionGroupDefaultMaxConnectionsPerUser = 0;
}
logger.warn("The \"{}\" property is deprecated. Use \"{}\" and \"{}\" instead.",
PostgreSQLGuacamoleProperties.POSTGRESQL_DISALLOW_DUPLICATE_CONNECTIONS.getName(),
PostgreSQLGuacamoleProperties.POSTGRESQL_DEFAULT_MAX_CONNECTIONS_PER_USER.getName(),
PostgreSQLGuacamoleProperties.POSTGRESQL_DEFAULT_MAX_GROUP_CONNECTIONS.getName());
logger.info("To achieve the same result of setting \"{}\" to \"{}\", set \"{}\" to \"{}\" and \"{}\" to \"{}\".",
PostgreSQLGuacamoleProperties.POSTGRESQL_DISALLOW_DUPLICATE_CONNECTIONS.getName(),         disallowDuplicate,
PostgreSQLGuacamoleProperties.POSTGRESQL_DEFAULT_MAX_CONNECTIONS_PER_USER.getName(),       connectionDefaultMaxConnectionsPerUser,
PostgreSQLGuacamoleProperties.POSTGRESQL_DEFAULT_MAX_GROUP_CONNECTIONS_PER_USER.getName(), connectionGroupDefaultMaxConnectionsPerUser);
connectionDefaultMaxConnectionsPerUser      = environment.getProperty(PostgreSQLGuacamoleProperties.POSTGRESQL_DEFAULT_MAX_CONNECTIONS_PER_USER, 1);
connectionGroupDefaultMaxConnectionsPerUser = environment.getProperty(PostgreSQLGuacamoleProperties.POSTGRESQL_DEFAULT_MAX_GROUP_CONNECTIONS_PER_USER, 1);
public static final IntegerGuacamoleProperty
POSTGRESQL_DEFAULT_MAX_CONNECTIONS =
new IntegerGuacamoleProperty() {
@Override
public String getName() { return "postgresql-default-max-connections"; }
};
public static final IntegerGuacamoleProperty
POSTGRESQL_DEFAULT_MAX_GROUP_CONNECTIONS =
new IntegerGuacamoleProperty() {
@Override
public String getName() { return "postgresql-default-max-group-connections"; }
};
public static final IntegerGuacamoleProperty
POSTGRESQL_DEFAULT_MAX_CONNECTIONS_PER_USER =
new IntegerGuacamoleProperty() {
@Override
public String getName() { return "postgresql-default-max-connections-per-user"; }
};
public static final IntegerGuacamoleProperty
POSTGRESQL_DEFAULT_MAX_GROUP_CONNECTIONS_PER_USER =
new IntegerGuacamoleProperty() {
@Override
public String getName() { return "postgresql-default-max-group-connections-per-user"; }
};
AuthenticatedUser authenticateUser(Credentials credentials)
AuthenticatedUser updateAuthenticatedUser(AuthenticatedUser authenticatedUser,
Credentials credentials) throws GuacamoleException;
UserContext getUserContext(AuthenticatedUser authenticatedUser)
UserContext updateUserContext(UserContext context,
AuthenticatedUser authenticatedUser) throws GuacamoleException;
import java.util.UUID;
import org.glyptodon.guacamole.net.auth.AbstractAuthenticatedUser;
import org.glyptodon.guacamole.net.auth.AuthenticatedUser;
private class SimpleAuthenticatedUser extends AbstractAuthenticatedUser {
private final Credentials credentials;
private final Map<String, GuacamoleConfiguration> configs;
public SimpleAuthenticatedUser(Credentials credentials, Map<String, GuacamoleConfiguration> configs) {
this.credentials = credentials;
this.configs = configs;
String username = credentials.getUsername();
if (username != null && !username.isEmpty())
setIdentifier(username);
else
setIdentifier(UUID.randomUUID().toString());
}
public Map<String, GuacamoleConfiguration> getAuthorizedConfigurations() {
return configs;
}
@Override
public AuthenticationProvider getAuthenticationProvider() {
return SimpleAuthenticationProvider.this;
}
@Override
public Credentials getCredentials() {
return credentials;
}
}
private Map<String, GuacamoleConfiguration>
getFilteredAuthorizedConfigurations(Credentials credentials)
throws GuacamoleException {
return configs;
}
private Map<String, GuacamoleConfiguration>
getFilteredAuthorizedConfigurations(AuthenticatedUser authenticatedUser)
throws GuacamoleException {
if (authenticatedUser instanceof SimpleAuthenticatedUser)
return ((SimpleAuthenticatedUser) authenticatedUser).getAuthorizedConfigurations();
return getFilteredAuthorizedConfigurations(authenticatedUser.getCredentials());
}
@Override
public AuthenticatedUser authenticateUser(final Credentials credentials)
throws GuacamoleException {
Map<String, GuacamoleConfiguration> configs =
getFilteredAuthorizedConfigurations(credentials);
if (configs == null)
return null;
return new SimpleAuthenticatedUser(credentials, configs);
}
@Override
public UserContext getUserContext(AuthenticatedUser authenticatedUser)
throws GuacamoleException {
Map<String, GuacamoleConfiguration> configs =
getFilteredAuthorizedConfigurations(authenticatedUser);
if (configs == null)
return null;
return new SimpleUserContext(authenticatedUser.getIdentifier(), configs);
}
@Override
public AuthenticatedUser updateAuthenticatedUser(AuthenticatedUser authenticatedUser,
Credentials credentials) throws GuacamoleException {
return authenticatedUser;
AuthenticatedUser authorizedUser) throws GuacamoleException {
import org.glyptodon.guacamole.net.auth.AuthenticatedUser;
private AuthenticatedUser authenticatedUser;
public GuacamoleSession(Environment environment,
AuthenticatedUser authenticatedUser, UserContext userContext)
throws GuacamoleException {
this.authenticatedUser = authenticatedUser;
public AuthenticatedUser getAuthenticatedUser() {
return authenticatedUser;
public void setAuthenticatedUser(AuthenticatedUser authenticatedUser) {
this.authenticatedUser = authenticatedUser;
import org.glyptodon.guacamole.net.auth.AuthenticatedUser;
public AuthenticatedUser authenticateUser(Credentials credentials)
return authProvider.authenticateUser(credentials);
public AuthenticatedUser updateAuthenticatedUser(AuthenticatedUser authenticatedUser,
Credentials credentials) throws GuacamoleException {
return authProvider.updateAuthenticatedUser(authenticatedUser, credentials);
}
@Override
public UserContext getUserContext(AuthenticatedUser authenticatedUser)
throws GuacamoleException {
if (authProvider == null) {
logger.warn("User data retrieval attempt denied because the authentication system could not be loaded. Please check for errors earlier in the logs.");
return null;
}
return authProvider.getUserContext(authenticatedUser);
}
@Override
public UserContext updateUserContext(UserContext context,
AuthenticatedUser authenticatedUser)
throws GuacamoleException {
if (authProvider == null) {
logger.warn("User data refresh attempt denied because the authentication system could not be loaded. Please check for errors earlier in the logs.");
return null;
}
return authProvider.updateUserContext(context, authenticatedUser);
import org.glyptodon.guacamole.net.auth.AuthenticatedUser;
AuthenticatedUser authenticatedUser;
authenticatedUser = authProvider.updateAuthenticatedUser(existingSession.getAuthenticatedUser(), credentials);
authenticatedUser = authProvider.authenticateUser(credentials);
if (authenticatedUser != null && logger.isInfoEnabled())
authenticatedUser.getIdentifier(), getLoggableAddress(request));
if (authenticatedUser == null)
UserContext userContext;
if (existingSession != null)
userContext = authProvider.updateUserContext(existingSession.getUserContext(), authenticatedUser);
else
userContext = authProvider.getUserContext(authenticatedUser);
if (userContext == null)
throw new GuacamoleInvalidCredentialsException("Permission Denied.",
CredentialsInfo.USERNAME_PASSWORD);
existingSession.setAuthenticatedUser(authenticatedUser);
tokenSessionMap.put(authToken, new GuacamoleSession(environment, authenticatedUser, userContext));
logger.debug("Login was successful for user \"{}\".", authenticatedUser.getIdentifier());
return new APIAuthToken(authToken, authenticatedUser.getIdentifier());
import org.glyptodon.guacamole.net.auth.credentials.GuacamoleCredentialsException;
try {
if (authProvider.authenticateUser(credentials) == null) {
throw new APIException(APIError.Type.PERMISSION_DENIED,
"Permission denied.");
}
}
catch (GuacamoleCredentialsException e) {
import org.glyptodon.guacamole.net.auth.AuthenticationProvider;
public class AuthenticatedUser implements org.glyptodon.guacamole.net.auth.AuthenticatedUser {
private final AuthenticationProvider authenticationProvider;
public AuthenticatedUser(AuthenticationProvider authenticationProvider,
ModeledUser user, Credentials credentials) {
this.authenticationProvider = authenticationProvider;
@Override
@Override
public AuthenticationProvider getAuthenticationProvider() {
return authenticationProvider;
}
@Override
public String getIdentifier() {
return user.getIdentifier();
}
@Override
public void setIdentifier(String identifier) {
user.setIdentifier(identifier);
}
import org.glyptodon.guacamole.net.auth.AuthenticationProvider;
public AuthenticatedUser retrieveAuthenticatedUser(AuthenticationProvider authenticationProvider,
Credentials credentials) throws GuacamoleException {
user.setCurrentUser(new AuthenticatedUser(authenticationProvider, user, credentials));
return user.getCurrentUser();
}
public ModeledUser retrieveUser(org.glyptodon.guacamole.net.auth.AuthenticatedUser authenticatedUser) {
if (authenticatedUser instanceof AuthenticatedUser)
return ((AuthenticatedUser) authenticatedUser).getUser();
String username = authenticatedUser.getIdentifier();
UserModel userModel = userMapper.selectOne(username);
if (userModel == null)
return null;
ModeledUser user = getObjectInstance(null, userModel);
user.setCurrentUser(new AuthenticatedUser(authenticatedUser.getAuthenticationProvider(), user, authenticatedUser.getCredentials()));
import org.glyptodon.guacamole.auth.jdbc.user.AuthenticationProviderService;
import org.glyptodon.guacamole.net.auth.AuthenticatedUser;
public AuthenticatedUser authenticateUser(Credentials credentials)
throws GuacamoleException {
AuthenticationProviderService authProviderService = injector.getInstance(AuthenticationProviderService.class);
return authProviderService.authenticateUser(this, credentials);
}
@Override
public AuthenticatedUser updateAuthenticatedUser(AuthenticatedUser authenticatedUser,
Credentials credentials) throws GuacamoleException {
return authenticatedUser;
}
@Override
public UserContext getUserContext(AuthenticatedUser authenticatedUser)
AuthenticationProviderService authProviderService = injector.getInstance(AuthenticationProviderService.class);
return authProviderService.getUserContext(authenticatedUser);
AuthenticatedUser authenticatedUser) throws GuacamoleException {
import org.glyptodon.guacamole.auth.jdbc.user.AuthenticationProviderService;
import org.glyptodon.guacamole.net.auth.AuthenticatedUser;
public AuthenticatedUser authenticateUser(Credentials credentials)
throws GuacamoleException {
AuthenticationProviderService authProviderService = injector.getInstance(AuthenticationProviderService.class);
return authProviderService.authenticateUser(this, credentials);
}
@Override
public AuthenticatedUser updateAuthenticatedUser(AuthenticatedUser authenticatedUser,
Credentials credentials) throws GuacamoleException {
return authenticatedUser;
}
@Override
public UserContext getUserContext(AuthenticatedUser authenticatedUser)
AuthenticationProviderService authProviderService = injector.getInstance(AuthenticationProviderService.class);
return authProviderService.getUserContext(authenticatedUser);
AuthenticatedUser authenticatedUser) throws GuacamoleException {
import org.glyptodon.guacamole.net.auth.AuthenticationProvider;
private final AuthenticationProvider authProvider;
public JDBCAuthenticationProviderModule(AuthenticationProvider authProvider,
Environment environment,
this.authProvider = authProvider;
bind(AuthenticationProvider.class).toInstance(authProvider);
import org.glyptodon.guacamole.net.auth.AuthenticationProvider;
@Inject
private AuthenticationProvider authProvider;
public AuthenticationProvider getAuthenticationProvider() {
return authProvider;
}
@Override
new JDBCAuthenticationProviderModule(this, environment,
getTunnelService(environment))
new JDBCAuthenticationProviderModule(this, environment,
getTunnelService(environment))
AuthenticationProvider getAuthenticationProvider();
return new SimpleUserContext(this, authenticatedUser.getIdentifier(), configs);
import org.glyptodon.guacamole.net.auth.AuthenticationProvider;
private final AuthenticationProvider authProvider;
public SimpleUserContext(AuthenticationProvider authProvider,
Map<String, GuacamoleConfiguration> configs) {
this(authProvider, UUID.randomUUID().toString(), configs);
public SimpleUserContext(AuthenticationProvider authProvider,
String username, Map<String, GuacamoleConfiguration> configs) {
this.authProvider = authProvider;
public AuthenticationProvider getAuthenticationProvider() {
return authProvider;
}
@Override
import java.util.Collections;
import java.util.List;
private List<UserContext> userContexts;
AuthenticatedUser authenticatedUser,
List<UserContext> userContexts)
this.userContexts = userContexts;
logger.debug(
"\n****************************************************************"
"\n"
"\n       !!!!  PLEASE DO NOT USE getUserContext() !!!!"
"\n"
"\n getUserContext() has been replaced by getUserContexts(), which"
"\n properly handles multiple authentication providers. All use of"
"\n the old getUserContext() must be removed before GUAC-586 can"
"\n be considered complete."
"\n"
"\n****************************************************************"
);
String authProviderIdentifier = authenticatedUser.getAuthenticationProvider().getIdentifier();
for (UserContext userContext : userContexts) {
if (userContext.getAuthenticationProvider().getIdentifier().equals(authProviderIdentifier))
return userContext;
}
return null;
public List<UserContext> getUserContexts() {
return Collections.unmodifiableList(userContexts);
}
public void setUserContexts(List<UserContext> userContexts) {
this.userContexts = userContexts;
session.getAuthenticatedUser().getIdentifier(), id, duration);
session.getAuthenticatedUser().getIdentifier(), id, duration);
import com.google.inject.Provides;
private final List<AuthenticationProvider> boundAuthenticationProviders =
new ArrayList<AuthenticationProvider>();
logger.debug("[{}] Binding AuthenticationProvider \"{}\".",
boundAuthenticationProviders.size(), authenticationProvider.getName());
boundAuthenticationProviders.add(new AuthenticationProviderFacade(authenticationProvider));
@Provides
public List<AuthenticationProvider> getAuthenticationProviders() {
return Collections.unmodifiableList(boundAuthenticationProviders);
}
bindAuthenticationProvider(BasicFileAuthenticationProvider.class);
import java.util.List;
import org.glyptodon.guacamole.net.basic.GuacamoleSession;
public UserContext retrieveUserContext(GuacamoleSession session,
int id) throws GuacamoleException {
List<UserContext> userContexts = session.getUserContexts();
if (id < 0 || id >= userContexts.size())
return userContexts.get(id);
}
import java.util.List;
public List<UserContext> getUserContexts(String authToken)
throws GuacamoleException {
return getGuacamoleSession(authToken).getUserContexts();
}
import java.util.ArrayList;
import java.util.List;
private List<AuthenticationProvider> authProviders;
AuthenticatedUser authenticatedUser = null;
if (existingSession != null) {
authenticatedUser = existingSession.getAuthenticatedUser();
authenticatedUser = authenticatedUser.getAuthenticationProvider().updateAuthenticatedUser(authenticatedUser, credentials);
}
for (AuthenticationProvider authProvider : authProviders) {
authenticatedUser = authProvider.authenticateUser(credentials);
if (authenticatedUser != null && logger.isInfoEnabled()) {
logger.info("User \"{}\" successfully authenticated from {}.",
authenticatedUser.getIdentifier(), getLoggableAddress(request));
break;
}
}
List<UserContext> userContexts = new ArrayList<UserContext>(authProviders.size());
for (AuthenticationProvider authProvider : authProviders) {
UserContext userContext;
if (existingSession != null)
userContext = authProvider.updateUserContext(existingSession.getUserContext(), authenticatedUser);
else
userContext = authProvider.getUserContext(authenticatedUser);
if (userContext != null)
userContexts.add(userContext);
}
existingSession.setUserContexts(userContexts);
tokenSessionMap.put(authToken, new GuacamoleSession(environment, authenticatedUser, userContexts));
if (userContext.getAuthenticationProvider().authenticateUser(credentials) == null) {
import org.glyptodon.guacamole.GuacamoleSecurityException;
import org.glyptodon.guacamole.net.auth.credentials.GuacamoleCredentialsException;
private Credentials getCredentials(HttpServletRequest request,
String username, String password) {
if (username == null && password == null) {
String authorization = request.getHeader("Authorization");
if (authorization != null && authorization.startsWith("Basic ")) {
try {
String basicBase64 = authorization.substring(6);
String basicCredentials = new String(DatatypeConverter.parseBase64Binary(basicBase64), "UTF-8");
int colon = basicCredentials.indexOf(':');
if (colon != -1) {
username = basicCredentials.substring(0, colon);
}
else
logger.debug("Invalid HTTP Basic \"Authorization\" header received.");
}
catch (UnsupportedEncodingException e) {
throw new UnsupportedOperationException("Unexpected lack of UTF-8 support.", e);
}
}
Credentials credentials = new Credentials();
credentials.setUsername(username);
credentials.setPassword(password);
credentials.setRequest(request);
credentials.setSession(request.getSession(true));
return credentials;
}
private AuthenticatedUser authenticateUser(Credentials credentials)
throws GuacamoleException {
GuacamoleCredentialsException authFailure = null;
for (AuthenticationProvider authProvider : authProviders) {
try {
AuthenticatedUser authenticatedUser = authProvider.authenticateUser(credentials);
if (authenticatedUser != null)
return authenticatedUser;
}
catch (GuacamoleCredentialsException e) {
if (authFailure == null)
authFailure = e;
}
}
if (authFailure != null)
throw authFailure;
throw new GuacamoleInvalidCredentialsException(
"Permission Denied.",
CredentialsInfo.USERNAME_PASSWORD
);
}
private AuthenticatedUser updateAuthenticatedUser(AuthenticatedUser authenticatedUser,
Credentials credentials) throws GuacamoleException {
AuthenticationProvider authProvider = authenticatedUser.getAuthenticationProvider();
authenticatedUser = authProvider.updateAuthenticatedUser(authenticatedUser, credentials);
if (authenticatedUser == null)
throw new GuacamoleSecurityException("User re-authentication failed.");
return authenticatedUser;
}
private AuthenticatedUser getAuthenticatedUser(GuacamoleSession existingSession,
Credentials credentials) throws GuacamoleException {
try {
if (existingSession != null)
return updateAuthenticatedUser(existingSession.getAuthenticatedUser(), credentials);
AuthenticatedUser authenticatedUser = authenticateUser(credentials);
if (logger.isInfoEnabled())
logger.info("User \"{}\" successfully authenticated from {}.",
authenticatedUser.getIdentifier(),
getLoggableAddress(credentials.getRequest()));
return authenticatedUser;
}
catch (GuacamoleException e) {
HttpServletRequest request = credentials.getRequest();
String username = credentials.getUsername();
if (username != null) {
if (logger.isWarnEnabled())
logger.warn("Authentication attempt from {} for user \"{}\" failed.",
getLoggableAddress(request), username);
}
else if (logger.isDebugEnabled())
logger.debug("Anonymous authentication attempt from {} failed.",
getLoggableAddress(request));
throw e;
}
}
private List<UserContext> getUserContexts(GuacamoleSession existingSession,
AuthenticatedUser authenticatedUser) throws GuacamoleException {
List<UserContext> userContexts = new ArrayList<UserContext>(authProviders.size());
if (existingSession != null) {
List<UserContext> oldUserContexts = existingSession.getUserContexts();
for (UserContext oldUserContext : oldUserContexts) {
AuthenticationProvider authProvider = oldUserContext.getAuthenticationProvider();
UserContext userContext = authProvider.updateUserContext(oldUserContext, authenticatedUser);
if (userContext != null)
userContexts.add(userContext);
else
logger.debug("AuthenticationProvider \"{}\" retroactively destroyed its UserContext.",
authProvider.getClass().getName());
}
}
else {
for (AuthenticationProvider authProvider : authProviders) {
UserContext userContext = authProvider.getUserContext(authenticatedUser);
if (userContext != null)
userContexts.add(userContext);
}
}
return userContexts;
}
Credentials credentials = getCredentials(request, username, password);
AuthenticatedUser authenticatedUser = getAuthenticatedUser(existingSession, credentials);
List<UserContext> userContexts = getUserContexts(existingSession, authenticatedUser);
logger.debug("Login was successful for user \"{}\".", authenticatedUser.getIdentifier());
import org.glyptodon.guacamole.net.basic.xml.usermapping.UserMappingTagHandler;
private final Logger logger = LoggerFactory.getLogger(BasicFileAuthenticationProvider.class);
private long lastModified = Long.MIN_VALUE;
private UserMapping cachedUserMapping;
private UserMapping getUserMapping() {
File userMappingFile;
try {
userMappingFile = environment.getProperty(BASIC_USER_MAPPING);
if (userMappingFile == null)
userMappingFile = new File(environment.getGuacamoleHome(), DEFAULT_USER_MAPPING);
}
catch (GuacamoleException e) {
logger.warn("Unable to read user mapping filename from properties: {}", e.getMessage());
logger.debug("Error parsing user mapping property.", e);
return null;
}
if (!userMappingFile.exists()) {
logger.debug("User mapping file \"{}\" does not exist and will not be read.", userMappingFile);
return null;
}
if (lastModified < userMappingFile.lastModified()) {
logger.debug("Reading user mapping file: \"{}\"", userMappingFile);
InputStream input = new BufferedInputStream(new FileInputStream(userMappingFile));
lastModified = userMappingFile.lastModified();
cachedUserMapping = userMappingHandler.asUserMapping();
logger.warn("Unable to read user mapping file \"{}\": {}", userMappingFile, e.getMessage());
logger.debug("Error reading user mapping file.", e);
return null;
logger.warn("User mapping file \"{}\" is not valid: {}", userMappingFile, e.getMessage());
logger.debug("Error parsing user mapping file.", e);
return null;
return cachedUserMapping;
UserMapping userMapping = getUserMapping();
if (userMapping == null)
return null;
package org.glyptodon.guacamole.net.basic.xml.usermapping;
package org.glyptodon.guacamole.net.basic.xml.usermapping;
package org.glyptodon.guacamole.net.basic.xml.usermapping;
package org.glyptodon.guacamole.net.basic.xml.usermapping;
package org.glyptodon.guacamole.net.basic.xml.usermapping;
package org.glyptodon.guacamole.net.basic.xml.usermapping;
public String getIdentifier() {
return "mysql";
}
@Override
public String getIdentifier() {
return "postgresql";
}
@Override
@Override
public String getIdentifier() {
return "ldap";
}
@Override
public String getIdentifier() {
return "noauth";
}
String getIdentifier();
@Override
public String getIdentifier() {
return "default";
}
import java.util.UUID;
private final String facadeIdentifier = UUID.randomUUID().toString();
public String getIdentifier() {
if (authProvider == null) {
logger.warn("The authentication system could not be loaded. Please check for errors earlier in the logs.");
return facadeIdentifier;
}
return authProvider.getIdentifier();
}
@Override
String identifier) throws GuacamoleException {
for (UserContext userContext : userContexts) {
if (userContext.getAuthenticationProvider().getIdentifier().equals(identifier))
return userContext;
}
public APIAuthenticationResult createToken(@FormParam("username") String username,
List<String> authProviderIdentifiers = new ArrayList<String>(userContexts.size());
for (UserContext userContext : userContexts)
authProviderIdentifiers.add(userContext.getAuthenticationProvider().getIdentifier());
return new APIAuthenticationResult(
authToken,
authenticatedUser.getIdentifier(),
authenticatedUser.getAuthenticationProvider().getIdentifier(),
authProviderIdentifiers
);
logger.warn("The guacamole.properties file within GUACAMOLE_HOME cannot be read: {}", e.getMessage());
logger.debug("Error reading guacamole.properties.", e);
private Map<String, ProtocolInfo> readProtocols() {
import org.glyptodon.guacamole.net.auth.AuthenticationProvider;
private final AuthenticationProvider authProvider;
public JDBCAuthenticationProviderModule(AuthenticationProvider authProvider,
Environment environment,
this.authProvider = authProvider;
bind(AuthenticationProvider.class).toInstance(authProvider);
import org.glyptodon.guacamole.net.auth.AuthenticationProvider;
public class AuthenticatedUser implements org.glyptodon.guacamole.net.auth.AuthenticatedUser {
private final AuthenticationProvider authenticationProvider;
public AuthenticatedUser(AuthenticationProvider authenticationProvider,
ModeledUser user, Credentials credentials) {
this.authenticationProvider = authenticationProvider;
@Override
@Override
public AuthenticationProvider getAuthenticationProvider() {
return authenticationProvider;
}
@Override
public String getIdentifier() {
return user.getIdentifier();
}
@Override
public void setIdentifier(String identifier) {
user.setIdentifier(identifier);
}
import org.glyptodon.guacamole.net.auth.AuthenticationProvider;
@Inject
private AuthenticationProvider authProvider;
public AuthenticationProvider getAuthenticationProvider() {
return authProvider;
}
@Override
import org.glyptodon.guacamole.net.auth.AuthenticationProvider;
public AuthenticatedUser retrieveAuthenticatedUser(AuthenticationProvider authenticationProvider,
Credentials credentials) throws GuacamoleException {
user.setCurrentUser(new AuthenticatedUser(authenticationProvider, user, credentials));
return user.getCurrentUser();
}
public ModeledUser retrieveUser(org.glyptodon.guacamole.net.auth.AuthenticatedUser authenticatedUser) {
if (authenticatedUser instanceof AuthenticatedUser)
return ((AuthenticatedUser) authenticatedUser).getUser();
String username = authenticatedUser.getIdentifier();
UserModel userModel = userMapper.selectOne(username);
if (userModel == null)
return null;
ModeledUser user = getObjectInstance(null, userModel);
user.setCurrentUser(new AuthenticatedUser(authenticatedUser.getAuthenticationProvider(), user, authenticatedUser.getCredentials()));
import org.glyptodon.guacamole.auth.jdbc.user.AuthenticationProviderService;
import org.glyptodon.guacamole.net.auth.AuthenticatedUser;
new JDBCAuthenticationProviderModule(this, environment,
getTunnelService(environment))
public String getIdentifier() {
return "mysql";
}
@Override
public AuthenticatedUser authenticateUser(Credentials credentials)
throws GuacamoleException {
AuthenticationProviderService authProviderService = injector.getInstance(AuthenticationProviderService.class);
return authProviderService.authenticateUser(this, credentials);
}
@Override
public AuthenticatedUser updateAuthenticatedUser(AuthenticatedUser authenticatedUser,
Credentials credentials) throws GuacamoleException {
return authenticatedUser;
}
@Override
public UserContext getUserContext(AuthenticatedUser authenticatedUser)
AuthenticationProviderService authProviderService = injector.getInstance(AuthenticationProviderService.class);
return authProviderService.getUserContext(authenticatedUser);
AuthenticatedUser authenticatedUser) throws GuacamoleException {
import org.glyptodon.guacamole.auth.jdbc.user.AuthenticationProviderService;
import org.glyptodon.guacamole.net.auth.AuthenticatedUser;
new JDBCAuthenticationProviderModule(this, environment,
getTunnelService(environment))
public String getIdentifier() {
return "postgresql";
}
@Override
public AuthenticatedUser authenticateUser(Credentials credentials)
throws GuacamoleException {
AuthenticationProviderService authProviderService = injector.getInstance(AuthenticationProviderService.class);
return authProviderService.authenticateUser(this, credentials);
}
@Override
public AuthenticatedUser updateAuthenticatedUser(AuthenticatedUser authenticatedUser,
Credentials credentials) throws GuacamoleException {
return authenticatedUser;
}
@Override
public UserContext getUserContext(AuthenticatedUser authenticatedUser)
AuthenticationProviderService authProviderService = injector.getInstance(AuthenticationProviderService.class);
return authProviderService.getUserContext(authenticatedUser);
AuthenticatedUser authenticatedUser) throws GuacamoleException {
@Override
public String getIdentifier() {
return "ldap";
}
@Override
public String getIdentifier() {
return "noauth";
}
logger.warn("The guacamole.properties file within GUACAMOLE_HOME cannot be read: {}", e.getMessage());
logger.debug("Error reading guacamole.properties.", e);
private Map<String, ProtocolInfo> readProtocols() {
String getIdentifier();
AuthenticatedUser authenticateUser(Credentials credentials)
AuthenticatedUser updateAuthenticatedUser(AuthenticatedUser authenticatedUser,
Credentials credentials) throws GuacamoleException;
UserContext getUserContext(AuthenticatedUser authenticatedUser)
UserContext updateUserContext(UserContext context,
AuthenticatedUser authenticatedUser) throws GuacamoleException;
AuthenticationProvider getAuthenticationProvider();
import java.util.UUID;
import org.glyptodon.guacamole.net.auth.AbstractAuthenticatedUser;
import org.glyptodon.guacamole.net.auth.AuthenticatedUser;
private class SimpleAuthenticatedUser extends AbstractAuthenticatedUser {
private final Credentials credentials;
private final Map<String, GuacamoleConfiguration> configs;
public SimpleAuthenticatedUser(Credentials credentials, Map<String, GuacamoleConfiguration> configs) {
this.credentials = credentials;
this.configs = configs;
String username = credentials.getUsername();
if (username != null && !username.isEmpty())
setIdentifier(username);
else
setIdentifier(UUID.randomUUID().toString());
}
public Map<String, GuacamoleConfiguration> getAuthorizedConfigurations() {
return configs;
}
@Override
public AuthenticationProvider getAuthenticationProvider() {
return SimpleAuthenticationProvider.this;
}
@Override
public Credentials getCredentials() {
return credentials;
}
}
private Map<String, GuacamoleConfiguration>
getFilteredAuthorizedConfigurations(Credentials credentials)
throws GuacamoleException {
return configs;
}
private Map<String, GuacamoleConfiguration>
getFilteredAuthorizedConfigurations(AuthenticatedUser authenticatedUser)
throws GuacamoleException {
if (authenticatedUser instanceof SimpleAuthenticatedUser)
return ((SimpleAuthenticatedUser) authenticatedUser).getAuthorizedConfigurations();
return getFilteredAuthorizedConfigurations(authenticatedUser.getCredentials());
}
@Override
public AuthenticatedUser authenticateUser(final Credentials credentials)
throws GuacamoleException {
Map<String, GuacamoleConfiguration> configs =
getFilteredAuthorizedConfigurations(credentials);
if (configs == null)
return null;
return new SimpleAuthenticatedUser(credentials, configs);
}
@Override
public UserContext getUserContext(AuthenticatedUser authenticatedUser)
throws GuacamoleException {
Map<String, GuacamoleConfiguration> configs =
getFilteredAuthorizedConfigurations(authenticatedUser);
if (configs == null)
return null;
return new SimpleUserContext(this, authenticatedUser.getIdentifier(), configs);
}
@Override
public AuthenticatedUser updateAuthenticatedUser(AuthenticatedUser authenticatedUser,
Credentials credentials) throws GuacamoleException {
return authenticatedUser;
AuthenticatedUser authorizedUser) throws GuacamoleException {
import org.glyptodon.guacamole.net.auth.AuthenticationProvider;
private final AuthenticationProvider authProvider;
public SimpleUserContext(AuthenticationProvider authProvider,
Map<String, GuacamoleConfiguration> configs) {
this(authProvider, UUID.randomUUID().toString(), configs);
public SimpleUserContext(AuthenticationProvider authProvider,
String username, Map<String, GuacamoleConfiguration> configs) {
this.authProvider = authProvider;
public AuthenticationProvider getAuthenticationProvider() {
return authProvider;
}
@Override
import org.glyptodon.guacamole.net.basic.xml.usermapping.UserMappingTagHandler;
private final Logger logger = LoggerFactory.getLogger(BasicFileAuthenticationProvider.class);
private long lastModified = Long.MIN_VALUE;
private UserMapping cachedUserMapping;
@Override
public String getIdentifier() {
return "default";
}
private UserMapping getUserMapping() {
File userMappingFile;
try {
userMappingFile = environment.getProperty(BASIC_USER_MAPPING);
if (userMappingFile == null)
userMappingFile = new File(environment.getGuacamoleHome(), DEFAULT_USER_MAPPING);
}
catch (GuacamoleException e) {
logger.warn("Unable to read user mapping filename from properties: {}", e.getMessage());
logger.debug("Error parsing user mapping property.", e);
return null;
}
if (!userMappingFile.exists()) {
logger.debug("User mapping file \"{}\" does not exist and will not be read.", userMappingFile);
return null;
}
if (lastModified < userMappingFile.lastModified()) {
logger.debug("Reading user mapping file: \"{}\"", userMappingFile);
InputStream input = new BufferedInputStream(new FileInputStream(userMappingFile));
lastModified = userMappingFile.lastModified();
cachedUserMapping = userMappingHandler.asUserMapping();
logger.warn("Unable to read user mapping file \"{}\": {}", userMappingFile, e.getMessage());
logger.debug("Error reading user mapping file.", e);
return null;
logger.warn("User mapping file \"{}\" is not valid: {}", userMappingFile, e.getMessage());
logger.debug("Error parsing user mapping file.", e);
return null;
return cachedUserMapping;
UserMapping userMapping = getUserMapping();
if (userMapping == null)
return null;
import java.util.List;
import org.glyptodon.guacamole.net.auth.AuthenticatedUser;
private AuthenticatedUser authenticatedUser;
private List<UserContext> userContexts;
public GuacamoleSession(Environment environment,
AuthenticatedUser authenticatedUser,
List<UserContext> userContexts)
throws GuacamoleException {
this.authenticatedUser = authenticatedUser;
this.userContexts = userContexts;
public AuthenticatedUser getAuthenticatedUser() {
return authenticatedUser;
public void setAuthenticatedUser(AuthenticatedUser authenticatedUser) {
this.authenticatedUser = authenticatedUser;
logger.debug(
"\n****************************************************************"
"\n"
"\n       !!!!  PLEASE DO NOT USE getUserContext() !!!!"
"\n"
"\n getUserContext() has been replaced by getUserContexts(), which"
"\n properly handles multiple authentication providers. All use of"
"\n the old getUserContext() must be removed before GUAC-586 can"
"\n be considered complete."
"\n"
"\n****************************************************************"
);
String authProviderIdentifier = authenticatedUser.getAuthenticationProvider().getIdentifier();
for (UserContext userContext : userContexts) {
if (userContext.getAuthenticationProvider().getIdentifier().equals(authProviderIdentifier))
return userContext;
}
return null;
public List<UserContext> getUserContexts() {
return Collections.unmodifiableList(userContexts);
}
public void setUserContexts(List<UserContext> userContexts) {
this.userContexts = userContexts;
session.getAuthenticatedUser().getIdentifier(), id, duration);
session.getAuthenticatedUser().getIdentifier(), id, duration);
import java.util.UUID;
import org.glyptodon.guacamole.net.auth.AuthenticatedUser;
private final String facadeIdentifier = UUID.randomUUID().toString();
public String getIdentifier() {
if (authProvider == null) {
logger.warn("The authentication system could not be loaded. Please check for errors earlier in the logs.");
return facadeIdentifier;
}
return authProvider.getIdentifier();
}
@Override
public AuthenticatedUser authenticateUser(Credentials credentials)
return authProvider.authenticateUser(credentials);
public AuthenticatedUser updateAuthenticatedUser(AuthenticatedUser authenticatedUser,
Credentials credentials) throws GuacamoleException {
return authProvider.updateAuthenticatedUser(authenticatedUser, credentials);
}
@Override
public UserContext getUserContext(AuthenticatedUser authenticatedUser)
throws GuacamoleException {
if (authProvider == null) {
logger.warn("User data retrieval attempt denied because the authentication system could not be loaded. Please check for errors earlier in the logs.");
return null;
}
return authProvider.getUserContext(authenticatedUser);
}
@Override
public UserContext updateUserContext(UserContext context,
AuthenticatedUser authenticatedUser)
throws GuacamoleException {
if (authProvider == null) {
logger.warn("User data refresh attempt denied because the authentication system could not be loaded. Please check for errors earlier in the logs.");
return null;
}
return authProvider.updateUserContext(context, authenticatedUser);
import com.google.inject.Provides;
private final List<AuthenticationProvider> boundAuthenticationProviders =
new ArrayList<AuthenticationProvider>();
logger.debug("[{}] Binding AuthenticationProvider \"{}\".",
boundAuthenticationProviders.size(), authenticationProvider.getName());
boundAuthenticationProviders.add(new AuthenticationProviderFacade(authenticationProvider));
@Provides
public List<AuthenticationProvider> getAuthenticationProviders() {
return Collections.unmodifiableList(boundAuthenticationProviders);
}
bindAuthenticationProvider(BasicFileAuthenticationProvider.class);
import java.util.List;
import org.glyptodon.guacamole.net.basic.GuacamoleSession;
public UserContext retrieveUserContext(GuacamoleSession session,
String identifier) throws GuacamoleException {
List<UserContext> userContexts = session.getUserContexts();
for (UserContext userContext : userContexts) {
if (userContext.getAuthenticationProvider().getIdentifier().equals(identifier))
return userContext;
}
}
import java.util.List;
public List<UserContext> getUserContexts(String authToken)
throws GuacamoleException {
return getGuacamoleSession(authToken).getUserContexts();
}
import java.util.ArrayList;
import java.util.List;
import org.glyptodon.guacamole.GuacamoleSecurityException;
import org.glyptodon.guacamole.net.auth.AuthenticatedUser;
import org.glyptodon.guacamole.net.auth.credentials.GuacamoleCredentialsException;
private List<AuthenticationProvider> authProviders;
private Credentials getCredentials(HttpServletRequest request,
String username, String password) {
return credentials;
}
private AuthenticatedUser authenticateUser(Credentials credentials)
throws GuacamoleException {
GuacamoleCredentialsException authFailure = null;
for (AuthenticationProvider authProvider : authProviders) {
try {
AuthenticatedUser authenticatedUser = authProvider.authenticateUser(credentials);
if (authenticatedUser != null)
return authenticatedUser;
catch (GuacamoleCredentialsException e) {
if (authFailure == null)
authFailure = e;
}
if (authFailure != null)
throw authFailure;
throw new GuacamoleInvalidCredentialsException(
"Permission Denied.",
CredentialsInfo.USERNAME_PASSWORD
);
}
private AuthenticatedUser updateAuthenticatedUser(AuthenticatedUser authenticatedUser,
Credentials credentials) throws GuacamoleException {
AuthenticationProvider authProvider = authenticatedUser.getAuthenticationProvider();
authenticatedUser = authProvider.updateAuthenticatedUser(authenticatedUser, credentials);
if (authenticatedUser == null)
throw new GuacamoleSecurityException("User re-authentication failed.");
return authenticatedUser;
}
private AuthenticatedUser getAuthenticatedUser(GuacamoleSession existingSession,
Credentials credentials) throws GuacamoleException {
try {
if (existingSession != null)
return updateAuthenticatedUser(existingSession.getAuthenticatedUser(), credentials);
AuthenticatedUser authenticatedUser = authenticateUser(credentials);
if (logger.isInfoEnabled())
logger.info("User \"{}\" successfully authenticated from {}.",
authenticatedUser.getIdentifier(),
getLoggableAddress(credentials.getRequest()));
return authenticatedUser;
}
HttpServletRequest request = credentials.getRequest();
String username = credentials.getUsername();
getLoggableAddress(request));
}
private List<UserContext> getUserContexts(GuacamoleSession existingSession,
AuthenticatedUser authenticatedUser) throws GuacamoleException {
List<UserContext> userContexts = new ArrayList<UserContext>(authProviders.size());
if (existingSession != null) {
List<UserContext> oldUserContexts = existingSession.getUserContexts();
for (UserContext oldUserContext : oldUserContexts) {
AuthenticationProvider authProvider = oldUserContext.getAuthenticationProvider();
UserContext userContext = authProvider.updateUserContext(oldUserContext, authenticatedUser);
if (userContext != null)
userContexts.add(userContext);
else
logger.debug("AuthenticationProvider \"{}\" retroactively destroyed its UserContext.",
authProvider.getClass().getName());
}
}
else {
for (AuthenticationProvider authProvider : authProviders) {
UserContext userContext = authProvider.getUserContext(authenticatedUser);
if (userContext != null)
userContexts.add(userContext);
}
}
return userContexts;
}
@POST
@AuthProviderRESTExposure
public APIAuthenticationResult createToken(@FormParam("username") String username,
@FormParam("password") String password,
@FormParam("token") String token,
@Context HttpServletRequest consumedRequest,
MultivaluedMap<String, String> parameters)
throws GuacamoleException {
HttpServletRequest request = new APIRequest(consumedRequest, parameters);
GuacamoleSession existingSession;
if (token != null)
existingSession = tokenSessionMap.get(token);
else
existingSession = null;
Credentials credentials = getCredentials(request, username, password);
AuthenticatedUser authenticatedUser = getAuthenticatedUser(existingSession, credentials);
List<UserContext> userContexts = getUserContexts(existingSession, authenticatedUser);
existingSession.setAuthenticatedUser(authenticatedUser);
existingSession.setUserContexts(userContexts);
tokenSessionMap.put(authToken, new GuacamoleSession(environment, authenticatedUser, userContexts));
logger.debug("Login was successful for user \"{}\".", authenticatedUser.getIdentifier());
List<String> authProviderIdentifiers = new ArrayList<String>(userContexts.size());
for (UserContext userContext : userContexts)
authProviderIdentifiers.add(userContext.getAuthenticationProvider().getIdentifier());
return new APIAuthenticationResult(
authToken,
authenticatedUser.getIdentifier(),
authenticatedUser.getAuthenticationProvider().getIdentifier(),
authProviderIdentifiers
);
import org.glyptodon.guacamole.net.auth.credentials.GuacamoleCredentialsException;
try {
if (userContext.getAuthenticationProvider().authenticateUser(credentials) == null) {
throw new APIException(APIError.Type.PERMISSION_DENIED,
"Permission denied.");
}
}
catch (GuacamoleCredentialsException e) {
package org.glyptodon.guacamole.net.basic.xml.usermapping;
package org.glyptodon.guacamole.net.basic.xml.usermapping;
package org.glyptodon.guacamole.net.basic.xml.usermapping;
package org.glyptodon.guacamole.net.basic.xml.usermapping;
package org.glyptodon.guacamole.net.basic.xml.usermapping;
package org.glyptodon.guacamole.net.basic.xml.usermapping;
import org.glyptodon.guacamole.auth.ldap.AuthenticationProviderService;
import org.glyptodon.guacamole.auth.ldap.LDAPAuthenticationProviderModule;
import com.google.inject.Guice;
import com.google.inject.Injector;
import org.glyptodon.guacamole.net.auth.AuthenticatedUser;
import org.glyptodon.guacamole.net.auth.AuthenticationProvider;
import org.glyptodon.guacamole.net.auth.UserContext;
public class LDAPAuthenticationProvider implements AuthenticationProvider {
private final Injector injector;
injector = Guice.createInjector(
new LDAPAuthenticationProviderModule(this)
);
@Override
public AuthenticatedUser authenticateUser(Credentials credentials) throws GuacamoleException {
AuthenticationProviderService authProviderService = injector.getInstance(AuthenticationProviderService.class);
return authProviderService.authenticateUser(credentials);
@Override
public AuthenticatedUser updateAuthenticatedUser(AuthenticatedUser authenticatedUser,
Credentials credentials) throws GuacamoleException {
return authenticatedUser;
}
public UserContext getUserContext(AuthenticatedUser authenticatedUser)
throws GuacamoleException {
AuthenticationProviderService authProviderService = injector.getInstance(AuthenticationProviderService.class);
return authProviderService.getUserContext(authenticatedUser);
}
@Override
public UserContext updateUserContext(UserContext context,
AuthenticatedUser authenticatedUser) throws GuacamoleException {
return context;
package org.glyptodon.guacamole.auth.ldap;
private final Set<ObjectPermission> userPermissions =
new HashSet<ObjectPermission>();
public SimpleUser(String username) {
setIdentifier(username);
}
this(username);
public SimpleUser(String username,
Collection<String> userIdentifiers,
Collection<String> connectionIdentifiers,
Collection<String> connectionGroupIdentifiers) {
this(username);
addReadPermissions(userPermissions,            userIdentifiers);
addReadPermissions(connectionPermissions,      connectionIdentifiers);
addReadPermissions(connectionGroupPermissions, connectionGroupIdentifiers);
}
return new SimpleObjectPermissionSet(userPermissions);
public static final String ROOT_CONNECTION_GROUP = "ROOT";
import net.sourceforge.guacamole.net.auth.ldap.LDAPAuthenticationProvider;
Connection connection = new SimpleConnection(name, name, config);
connection.setParentIdentifier(LDAPAuthenticationProvider.ROOT_CONNECTION_GROUP);
connections.put(name, connection);
import net.sourceforge.guacamole.net.auth.ldap.LDAPAuthenticationProvider;
LDAPAuthenticationProvider.ROOT_CONNECTION_GROUP,
LDAPAuthenticationProvider.ROOT_CONNECTION_GROUP,
import org.glyptodon.guacamole.auth.ldap.AuthenticationProviderService;
import org.glyptodon.guacamole.auth.ldap.LDAPAuthenticationProviderModule;
import com.google.inject.Guice;
import com.google.inject.Injector;
import org.glyptodon.guacamole.net.auth.AuthenticatedUser;
import org.glyptodon.guacamole.net.auth.AuthenticationProvider;
import org.glyptodon.guacamole.net.auth.UserContext;
public class LDAPAuthenticationProvider implements AuthenticationProvider {
public static final String ROOT_CONNECTION_GROUP = "ROOT";
private final Injector injector;
injector = Guice.createInjector(
new LDAPAuthenticationProviderModule(this)
);
@Override
public AuthenticatedUser authenticateUser(Credentials credentials) throws GuacamoleException {
AuthenticationProviderService authProviderService = injector.getInstance(AuthenticationProviderService.class);
return authProviderService.authenticateUser(credentials);
@Override
public AuthenticatedUser updateAuthenticatedUser(AuthenticatedUser authenticatedUser,
Credentials credentials) throws GuacamoleException {
return authenticatedUser;
}
public UserContext getUserContext(AuthenticatedUser authenticatedUser)
throws GuacamoleException {
AuthenticationProviderService authProviderService = injector.getInstance(AuthenticationProviderService.class);
return authProviderService.getUserContext(authenticatedUser);
}
@Override
public UserContext updateUserContext(UserContext context,
AuthenticatedUser authenticatedUser) throws GuacamoleException {
return context;
package org.glyptodon.guacamole.auth.ldap;
private final Set<ObjectPermission> userPermissions =
new HashSet<ObjectPermission>();
public SimpleUser(String username) {
setIdentifier(username);
}
this(username);
public SimpleUser(String username,
Collection<String> userIdentifiers,
Collection<String> connectionIdentifiers,
Collection<String> connectionGroupIdentifiers) {
this(username);
addReadPermissions(userPermissions,            userIdentifiers);
addReadPermissions(connectionPermissions,      connectionIdentifiers);
addReadPermissions(connectionGroupPermissions, connectionGroupIdentifiers);
}
return new SimpleObjectPermissionSet(userPermissions);
import org.glyptodon.guacamole.net.auth.AuthenticationProvider;
String authProviderIdentifier) throws GuacamoleException {
AuthenticationProvider authProvider = userContext.getAuthenticationProvider();
if (authProvider.getIdentifier().equals(authProviderIdentifier))
public User retrieveUser(GuacamoleSession session, String authProviderIdentifier,
String identifier) throws GuacamoleException {
UserContext userContext = retrieveUserContext(session, authProviderIdentifier);
return retrieveUser(userContext, identifier);
}
public Connection retrieveConnection(GuacamoleSession session,
String authProviderIdentifier, String identifier)
throws GuacamoleException {
UserContext userContext = retrieveUserContext(session, authProviderIdentifier);
return retrieveConnection(userContext, identifier);
}
public ConnectionGroup retrieveConnectionGroup(GuacamoleSession session,
String authProviderIdentifier, String identifier) throws GuacamoleException {
UserContext userContext = retrieveUserContext(session, authProviderIdentifier);
return retrieveConnectionGroup(userContext, identifier);
}
import org.glyptodon.guacamole.net.auth.AuthenticationProvider;
import org.glyptodon.guacamole.net.basic.GuacamoleSession;
@Path("/data/{dataSource}/users")
@PathParam("dataSource") String authProviderIdentifier,
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
User self = userContext.self();
public APIUser getUser(@QueryParam("token") String authToken,
@PathParam("dataSource") String authProviderIdentifier,
@PathParam("username") String username)
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
User user = retrievalService.retrieveUser(session, authProviderIdentifier, username);
public String createUser(@QueryParam("token") String authToken,
@PathParam("dataSource") String authProviderIdentifier, APIUser user)
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
@PathParam("dataSource") String authProviderIdentifier,
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
@PathParam("dataSource") String authProviderIdentifier,
@PathParam("username") String username,
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
AuthenticationProvider authProvider = userContext.getAuthenticationProvider();
if (authProvider.authenticateUser(credentials) == null) {
@PathParam("dataSource") String authProviderIdentifier,
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
@PathParam("dataSource") String authProviderIdentifier,
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
@PathParam("dataSource") String authProviderIdentifier,
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
connection.setAttributes(object.getAttributes());
connectionGroup.setAttributes(object.getAttributes());
user.setAttributes(object.getAttributes());
if (authenticatedUser instanceof SimpleAuthenticatedUser && authenticatedUser.getAuthenticationProvider() == this)
Arrays.sort(extensionFiles);
import javax.ws.rs.PathParam;
import org.glyptodon.guacamole.net.basic.GuacamoleSession;
import org.glyptodon.guacamole.net.basic.rest.ObjectRetrievalService;
@Path("/schema/{dataSource}")
@Inject
private ObjectRetrievalService retrievalService;
public Collection<Form> getUserAttributes(@QueryParam("token") String authToken,
@PathParam("dataSource") String authProviderIdentifier)
throws GuacamoleException {
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
public Collection<Form> getConnectionAttributes(@QueryParam("token") String authToken,
@PathParam("dataSource") String authProviderIdentifier)
throws GuacamoleException {
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
public Collection<Form> getConnectionGroupAttributes(@QueryParam("token") String authToken,
@PathParam("dataSource") String authProviderIdentifier)
throws GuacamoleException {
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
public Map<String, ProtocolInfo> getProtocols(@QueryParam("token") String authToken,
@PathParam("dataSource") String authProviderIdentifier)
throws GuacamoleException {
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
retrievalService.retrieveUserContext(session, authProviderIdentifier);
import org.glyptodon.guacamole.net.basic.GuacamoleSession;
@Path("/data/{dataSource}/connections")
@PathParam("dataSource") String authProviderIdentifier,
@PathParam("connectionID") String connectionID)
throws GuacamoleException {
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
return new APIConnection(retrievalService.retrieveConnection(session, authProviderIdentifier, connectionID));
@PathParam("dataSource") String authProviderIdentifier,
@PathParam("connectionID") String connectionID)
throws GuacamoleException {
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
@PathParam("dataSource") String authProviderIdentifier,
@PathParam("connectionID") String connectionID)
throws GuacamoleException {
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
Connection connection = retrievalService.retrieveConnection(session, authProviderIdentifier, connectionID);
public void deleteConnection(@QueryParam("token") String authToken,
@PathParam("dataSource") String authProviderIdentifier,
@PathParam("connectionID") String connectionID)
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
@PathParam("dataSource") String authProviderIdentifier,
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
@PathParam("dataSource") String authProviderIdentifier,
@PathParam("connectionID") String connectionID,
APIConnection connection) throws GuacamoleException {
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
import org.glyptodon.guacamole.net.basic.GuacamoleSession;
@Path("/data/{dataSource}/connectionGroups")
public APIConnectionGroup getConnectionGroup(@QueryParam("token") String authToken,
@PathParam("dataSource") String authProviderIdentifier,
@PathParam("connectionGroupID") String connectionGroupID)
throws GuacamoleException {
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
return new APIConnectionGroup(retrievalService.retrieveConnectionGroup(session, authProviderIdentifier, connectionGroupID));
@PathParam("dataSource") String authProviderIdentifier,
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
@PathParam("dataSource") String authProviderIdentifier,
@PathParam("connectionGroupID") String connectionGroupID)
throws GuacamoleException {
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
@PathParam("dataSource") String authProviderIdentifier,
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
@PathParam("dataSource") String authProviderIdentifier,
@PathParam("connectionGroupID") String connectionGroupID,
APIConnectionGroup connectionGroup)
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
import javax.ws.rs.PathParam;
import org.glyptodon.guacamole.net.basic.GuacamoleSession;
import org.glyptodon.guacamole.net.basic.rest.ObjectRetrievalService;
@Path("/data/{dataSource}/activeConnections")
@Inject
private ObjectRetrievalService retrievalService;
@PathParam("dataSource") String authProviderIdentifier,
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
@PathParam("dataSource") String authProviderIdentifier,
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
if (!isAdmin && permissions != null && !permissions.isEmpty()) {
public class HTTPTunnelRequest extends TunnelRequest {
import org.glyptodon.guacamole.GuacamoleClientException;
import org.glyptodon.guacamole.GuacamoleException;
public abstract class TunnelRequest {
public static final String AUTH_TOKEN_PARAMETER = "token";
public static final String AUTH_PROVIDER_IDENTIFIER_PARAMETER = "GUAC_DATA_SOURCE";
public static final String TYPE_PARAMETER = "GUAC_TYPE";
public static final String IDENTIFIER_PARAMETER = "GUAC_ID";
public static final String WIDTH_PARAMETER = "GUAC_WIDTH";
public static final String HEIGHT_PARAMETER = "GUAC_HEIGHT";
public static final String DPI_PARAMETER = "GUAC_DPI";
public static final String AUDIO_PARAMETER = "GUAC_AUDIO";
public static final String VIDEO_PARAMETER = "GUAC_VIDEO";
public static enum Type {
CONNECTION("c"),
CONNECTION_GROUP("g");
final String PARAMETER_VALUE;
Type(String value) {
PARAMETER_VALUE = value;
public abstract String getParameter(String name);
public abstract List<String> getParameterValues(String name);
public String getRequiredParameter(String name) throws GuacamoleException {
String value = getParameter(name);
if (value == null)
return value;
}
public Integer getIntegerParameter(String name) throws GuacamoleException {
String value = getParameter(name);
if (value == null)
return null;
try {
return Integer.parseInt(value);
}
catch (NumberFormatException e) {
}
}
public String getAuthenticationToken() {
return getParameter(AUTH_TOKEN_PARAMETER);
}
public String getAuthenticationProviderIdentifier()
throws GuacamoleException {
return getRequiredParameter(AUTH_PROVIDER_IDENTIFIER_PARAMETER);
}
public Type getType() throws GuacamoleException {
String type = getRequiredParameter(TYPE_PARAMETER);
for (Type possibleType : Type.values()) {
if (type.equals(possibleType.PARAMETER_VALUE))
return possibleType;
}
throw new GuacamoleClientException("Illegal identifier - unknown type.");
}
public String getIdentifier() throws GuacamoleException {
return getRequiredParameter(IDENTIFIER_PARAMETER);
}
public Integer getWidth() throws GuacamoleException {
return getIntegerParameter(WIDTH_PARAMETER);
}
public Integer getHeight() throws GuacamoleException {
return getIntegerParameter(HEIGHT_PARAMETER);
}
public Integer getDPI() throws GuacamoleException {
return getIntegerParameter(DPI_PARAMETER);
}
public List<String> getAudioMimetypes() {
return getParameterValues(AUDIO_PARAMETER);
}
public List<String> getVideoMimetypes() {
return getParameterValues(VIDEO_PARAMETER);
}
import org.glyptodon.guacamole.net.basic.rest.ObjectRetrievalService;
@Inject
private ObjectRetrievalService retrievalService;
protected GuacamoleClientInformation getClientInformation(TunnelRequest request)
throws GuacamoleException {
Integer width = request.getWidth();
info.setOptimalScreenWidth(width);
Integer height = request.getHeight();
info.setOptimalScreenHeight(height);
Integer dpi = request.getDPI();
info.setOptimalResolution(dpi);
List<String> audioMimetypes = request.getAudioMimetypes();
if (audioMimetypes != null)
info.getAudioMimetypes().addAll(audioMimetypes);
List<String> videoMimetypes = request.getVideoMimetypes();
if (videoMimetypes != null)
info.getVideoMimetypes().addAll(videoMimetypes);
final TunnelRequest.Type type, String id,
switch (type) {
GuacamoleTunnel tunnel, final TunnelRequest.Type type,
switch (type) {
String authToken                = request.getAuthenticationToken();
String id                       = request.getIdentifier();
TunnelRequest.Type type         = request.getType();
String authProviderIdentifier   = request.getAuthenticationProviderIdentifier();
GuacamoleClientInformation info = getClientInformation(request);
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
GuacamoleTunnel tunnel = createConnectedTunnel(userContext, type, id, info);
return createAssociatedTunnel(session, tunnel, type, id);
public class WebSocketTunnelRequest extends TunnelRequest {
public class WebSocketTunnelRequest extends TunnelRequest {
connection.setAttributes(object.getAttributes());
connectionGroup.setAttributes(object.getAttributes());
user.setAttributes(object.getAttributes());
if (authenticatedUser instanceof SimpleAuthenticatedUser && authenticatedUser.getAuthenticationProvider() == this)
public class HTTPTunnelRequest extends TunnelRequest {
import org.glyptodon.guacamole.GuacamoleClientException;
import org.glyptodon.guacamole.GuacamoleException;
public abstract class TunnelRequest {
public static final String AUTH_TOKEN_PARAMETER = "token";
public static final String AUTH_PROVIDER_IDENTIFIER_PARAMETER = "GUAC_DATA_SOURCE";
public static final String TYPE_PARAMETER = "GUAC_TYPE";
public static final String IDENTIFIER_PARAMETER = "GUAC_ID";
public static final String WIDTH_PARAMETER = "GUAC_WIDTH";
public static final String HEIGHT_PARAMETER = "GUAC_HEIGHT";
public static final String DPI_PARAMETER = "GUAC_DPI";
public static final String AUDIO_PARAMETER = "GUAC_AUDIO";
public static final String VIDEO_PARAMETER = "GUAC_VIDEO";
public static enum Type {
CONNECTION("c"),
CONNECTION_GROUP("g");
final String PARAMETER_VALUE;
Type(String value) {
PARAMETER_VALUE = value;
public abstract String getParameter(String name);
public abstract List<String> getParameterValues(String name);
public String getRequiredParameter(String name) throws GuacamoleException {
String value = getParameter(name);
if (value == null)
return value;
}
public Integer getIntegerParameter(String name) throws GuacamoleException {
String value = getParameter(name);
if (value == null)
return null;
try {
return Integer.parseInt(value);
}
catch (NumberFormatException e) {
}
}
public String getAuthenticationToken() {
return getParameter(AUTH_TOKEN_PARAMETER);
}
public String getAuthenticationProviderIdentifier()
throws GuacamoleException {
return getRequiredParameter(AUTH_PROVIDER_IDENTIFIER_PARAMETER);
}
public Type getType() throws GuacamoleException {
String type = getRequiredParameter(TYPE_PARAMETER);
for (Type possibleType : Type.values()) {
if (type.equals(possibleType.PARAMETER_VALUE))
return possibleType;
}
throw new GuacamoleClientException("Illegal identifier - unknown type.");
}
public String getIdentifier() throws GuacamoleException {
return getRequiredParameter(IDENTIFIER_PARAMETER);
}
public Integer getWidth() throws GuacamoleException {
return getIntegerParameter(WIDTH_PARAMETER);
}
public Integer getHeight() throws GuacamoleException {
return getIntegerParameter(HEIGHT_PARAMETER);
}
public Integer getDPI() throws GuacamoleException {
return getIntegerParameter(DPI_PARAMETER);
}
public List<String> getAudioMimetypes() {
return getParameterValues(AUDIO_PARAMETER);
}
public List<String> getVideoMimetypes() {
return getParameterValues(VIDEO_PARAMETER);
}
import org.glyptodon.guacamole.net.basic.rest.ObjectRetrievalService;
@Inject
private ObjectRetrievalService retrievalService;
protected GuacamoleClientInformation getClientInformation(TunnelRequest request)
throws GuacamoleException {
Integer width = request.getWidth();
info.setOptimalScreenWidth(width);
Integer height = request.getHeight();
info.setOptimalScreenHeight(height);
Integer dpi = request.getDPI();
info.setOptimalResolution(dpi);
List<String> audioMimetypes = request.getAudioMimetypes();
if (audioMimetypes != null)
info.getAudioMimetypes().addAll(audioMimetypes);
List<String> videoMimetypes = request.getVideoMimetypes();
if (videoMimetypes != null)
info.getVideoMimetypes().addAll(videoMimetypes);
final TunnelRequest.Type type, String id,
switch (type) {
GuacamoleTunnel tunnel, final TunnelRequest.Type type,
switch (type) {
String authToken                = request.getAuthenticationToken();
String id                       = request.getIdentifier();
TunnelRequest.Type type         = request.getType();
String authProviderIdentifier   = request.getAuthenticationProviderIdentifier();
GuacamoleClientInformation info = getClientInformation(request);
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
GuacamoleTunnel tunnel = createConnectedTunnel(userContext, type, id, info);
return createAssociatedTunnel(session, tunnel, type, id);
Arrays.sort(extensionFiles);
import org.glyptodon.guacamole.net.auth.AuthenticationProvider;
String authProviderIdentifier) throws GuacamoleException {
AuthenticationProvider authProvider = userContext.getAuthenticationProvider();
if (authProvider.getIdentifier().equals(authProviderIdentifier))
public User retrieveUser(GuacamoleSession session, String authProviderIdentifier,
String identifier) throws GuacamoleException {
UserContext userContext = retrieveUserContext(session, authProviderIdentifier);
return retrieveUser(userContext, identifier);
}
public Connection retrieveConnection(GuacamoleSession session,
String authProviderIdentifier, String identifier)
throws GuacamoleException {
UserContext userContext = retrieveUserContext(session, authProviderIdentifier);
return retrieveConnection(userContext, identifier);
}
public ConnectionGroup retrieveConnectionGroup(GuacamoleSession session,
String authProviderIdentifier, String identifier) throws GuacamoleException {
UserContext userContext = retrieveUserContext(session, authProviderIdentifier);
return retrieveConnectionGroup(userContext, identifier);
}
import javax.ws.rs.PathParam;
import org.glyptodon.guacamole.net.basic.GuacamoleSession;
import org.glyptodon.guacamole.net.basic.rest.ObjectRetrievalService;
@Path("/data/{dataSource}/activeConnections")
@Inject
private ObjectRetrievalService retrievalService;
@PathParam("dataSource") String authProviderIdentifier,
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
@PathParam("dataSource") String authProviderIdentifier,
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
import org.glyptodon.guacamole.net.basic.GuacamoleSession;
@Path("/data/{dataSource}/connections")
@PathParam("dataSource") String authProviderIdentifier,
@PathParam("connectionID") String connectionID)
throws GuacamoleException {
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
return new APIConnection(retrievalService.retrieveConnection(session, authProviderIdentifier, connectionID));
@PathParam("dataSource") String authProviderIdentifier,
@PathParam("connectionID") String connectionID)
throws GuacamoleException {
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
@PathParam("dataSource") String authProviderIdentifier,
@PathParam("connectionID") String connectionID)
throws GuacamoleException {
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
Connection connection = retrievalService.retrieveConnection(session, authProviderIdentifier, connectionID);
public void deleteConnection(@QueryParam("token") String authToken,
@PathParam("dataSource") String authProviderIdentifier,
@PathParam("connectionID") String connectionID)
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
@PathParam("dataSource") String authProviderIdentifier,
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
@PathParam("dataSource") String authProviderIdentifier,
@PathParam("connectionID") String connectionID,
APIConnection connection) throws GuacamoleException {
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
import org.glyptodon.guacamole.net.basic.GuacamoleSession;
@Path("/data/{dataSource}/connectionGroups")
public APIConnectionGroup getConnectionGroup(@QueryParam("token") String authToken,
@PathParam("dataSource") String authProviderIdentifier,
@PathParam("connectionGroupID") String connectionGroupID)
throws GuacamoleException {
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
return new APIConnectionGroup(retrievalService.retrieveConnectionGroup(session, authProviderIdentifier, connectionGroupID));
@PathParam("dataSource") String authProviderIdentifier,
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
@PathParam("dataSource") String authProviderIdentifier,
@PathParam("connectionGroupID") String connectionGroupID)
throws GuacamoleException {
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
@PathParam("dataSource") String authProviderIdentifier,
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
@PathParam("dataSource") String authProviderIdentifier,
@PathParam("connectionGroupID") String connectionGroupID,
APIConnectionGroup connectionGroup)
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
import javax.ws.rs.PathParam;
import org.glyptodon.guacamole.net.basic.GuacamoleSession;
import org.glyptodon.guacamole.net.basic.rest.ObjectRetrievalService;
@Path("/schema/{dataSource}")
@Inject
private ObjectRetrievalService retrievalService;
public Collection<Form> getUserAttributes(@QueryParam("token") String authToken,
@PathParam("dataSource") String authProviderIdentifier)
throws GuacamoleException {
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
public Collection<Form> getConnectionAttributes(@QueryParam("token") String authToken,
@PathParam("dataSource") String authProviderIdentifier)
throws GuacamoleException {
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
public Collection<Form> getConnectionGroupAttributes(@QueryParam("token") String authToken,
@PathParam("dataSource") String authProviderIdentifier)
throws GuacamoleException {
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
public Map<String, ProtocolInfo> getProtocols(@QueryParam("token") String authToken,
@PathParam("dataSource") String authProviderIdentifier)
throws GuacamoleException {
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
retrievalService.retrieveUserContext(session, authProviderIdentifier);
import org.glyptodon.guacamole.net.auth.AuthenticationProvider;
import org.glyptodon.guacamole.net.basic.GuacamoleSession;
@Path("/data/{dataSource}/users")
@PathParam("dataSource") String authProviderIdentifier,
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
User self = userContext.self();
if (!isAdmin && permissions != null && !permissions.isEmpty()) {
public APIUser getUser(@QueryParam("token") String authToken,
@PathParam("dataSource") String authProviderIdentifier,
@PathParam("username") String username)
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
User user = retrievalService.retrieveUser(session, authProviderIdentifier, username);
public String createUser(@QueryParam("token") String authToken,
@PathParam("dataSource") String authProviderIdentifier, APIUser user)
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
@PathParam("dataSource") String authProviderIdentifier,
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
@PathParam("dataSource") String authProviderIdentifier,
@PathParam("username") String username,
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
AuthenticationProvider authProvider = userContext.getAuthenticationProvider();
if (authProvider.authenticateUser(credentials) == null) {
@PathParam("dataSource") String authProviderIdentifier,
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
@PathParam("dataSource") String authProviderIdentifier,
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
@PathParam("dataSource") String authProviderIdentifier,
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
public class WebSocketTunnelRequest extends TunnelRequest {
public class WebSocketTunnelRequest extends TunnelRequest {
ObjectPermission.Type.READ
import org.glyptodon.guacamole.GuacamoleSecurityException;
assert(userDN != null);
Authorization auth = userMapping.getAuthorization(credentials.getUsername());
ObjectPermission.Type.READ
assert(userDN != null);
Authorization auth = userMapping.getAuthorization(credentials.getUsername());
"0.9.8"
"0.9.8"
ModeledConnection connection;
try {
connection = acquire(user, connections);
}
finally {
release(user, connectionGroup);
}
ModeledConnection connection;
try {
connection = acquire(user, connections);
}
finally {
release(user, connectionGroup);
}
catch (GuacamoleException e) {
throw e;
catch (GuacamoleException e) {
throw e;
import org.glyptodon.guacamole.net.auth.credentials.GuacamoleInvalidCredentialsException;
throw new GuacamoleInvalidCredentialsException("Permission denied.", CredentialsInfo.USERNAME_PASSWORD);
import org.glyptodon.guacamole.net.auth.credentials.GuacamoleInvalidCredentialsException;
throw new GuacamoleInvalidCredentialsException("Permission denied.", CredentialsInfo.USERNAME_PASSWORD);
writer.writeInstruction(
new GuacamoleInstruction(
"image",
info.getImageMimetypes().toArray(new String[0])
));
private final List<String> imageMimetypes = new ArrayList<String>();
public List<String> getImageMimetypes() {
return imageMimetypes;
}
public static final String IMAGE_PARAMETER = "GUAC_IMAGE";
public List<String> getImageMimetypes() {
return getParameterValues(IMAGE_PARAMETER);
}
List<String> imageMimetypes = request.getImageMimetypes();
if (imageMimetypes != null)
info.getImageMimetypes().addAll(imageMimetypes);
writer.writeInstruction(
new GuacamoleInstruction(
"image",
info.getImageMimetypes().toArray(new String[0])
));
private final List<String> imageMimetypes = new ArrayList<String>();
public List<String> getImageMimetypes() {
return imageMimetypes;
}
public static final String IMAGE_PARAMETER = "GUAC_IMAGE";
public List<String> getImageMimetypes() {
return getParameterValues(IMAGE_PARAMETER);
}
List<String> imageMimetypes = request.getImageMimetypes();
if (imageMimetypes != null)
info.getImageMimetypes().addAll(imageMimetypes);
import org.glyptodon.guacamole.net.auth.ConnectionRecordSet;
import org.glyptodon.guacamole.net.auth.simple.SimpleConnectionRecordSet;
public ConnectionRecordSet getConnectionHistory()
throws GuacamoleException {
return new SimpleConnectionRecordSet();
}
@Override
import org.glyptodon.guacamole.net.auth.ConnectionRecordSet;
import org.glyptodon.guacamole.net.auth.simple.SimpleConnectionRecordSet;
public ConnectionRecordSet getConnectionHistory()
throws GuacamoleException {
return new SimpleConnectionRecordSet();
}
@Override
ConnectionRecordSet getConnectionHistory() throws GuacamoleException;
import org.glyptodon.guacamole.net.auth.ConnectionRecordSet;
public ConnectionRecordSet getConnectionHistory()
throws GuacamoleException {
return new SimpleConnectionRecordSet();
}
@Override
import org.glyptodon.guacamole.net.basic.rest.history.HistoryRESTService;
bind(HistoryRESTService.class);
import org.glyptodon.guacamole.net.basic.rest.history.APIConnectionRecord;
package org.glyptodon.guacamole.net.basic.rest.history;
public String getConnectionIdentifier() {
return model.getConnectionIdentifier();
}
@Override
public String getConnectionIdentifier() {
return connection.getIdentifier();
}
@Override
public String getConnectionIdentifier();
private final String connectionIdentifier;
this.connectionIdentifier = record.getConnectionIdentifier();
public String getConnectionIdentifier() {
return connectionIdentifier;
}
for (String required : requiredContents) {
if (!required.isEmpty())
history = history.contains(required);
}
import java.util.Set;
List<ConnectionRecordModel> search(@Param("terms") Set<ConnectionRecordSearchTerm> terms,
@Param("sortPredicates") List<ConnectionRecordSortPredicate> sortPredicates,
@Param("limit") int limit);
import org.glyptodon.guacamole.auth.jdbc.connection.ConnectionRecordSet;
@Inject
private Provider<ConnectionRecordSet> connectionRecordSetProvider;
ConnectionRecordSet connectionRecordSet = connectionRecordSetProvider.get();
connectionRecordSet.init(getCurrentUser());
return connectionRecordSet;
import java.util.Collection;
import org.glyptodon.guacamole.auth.jdbc.user.UserModel;
List<ConnectionRecordModel> search(@Param("terms") Collection<ConnectionRecordSearchTerm> terms,
List<ConnectionRecordModel> searchReadable(@Param("user") UserModel user,
@Param("terms") Collection<ConnectionRecordSearchTerm> terms,
@Param("sortPredicates") List<ConnectionRecordSortPredicate> sortPredicates,
@Param("limit") int limit);
private ConnectionService connectionService;
return connectionService.retrieveHistory(getCurrentUser(),
requiredContents, connectionRecordSortPredicates, limit);
protected ConnectionRecord getObjectInstance(ConnectionRecordModel model) {
return new ModeledConnectionRecord(model);
}
protected List<ConnectionRecord> getObjectInstances(List<ConnectionRecordModel> models) {
List<ConnectionRecord> objects = new ArrayList<ConnectionRecord>(models.size());
for (ConnectionRecordModel model : models)
objects.add(getObjectInstance(model));
return objects;
}
records.add(getObjectInstance(model));
public List<ConnectionRecord> retrieveHistory(AuthenticatedUser user,
Collection<ConnectionRecordSearchTerm> requiredContents,
List<ConnectionRecordSortPredicate> sortPredicates, int limit)
throws GuacamoleException {
List<ConnectionRecordModel> searchResults;
if (user.getUser().isAdministrator())
searchResults = connectionRecordMapper.search(requiredContents,
sortPredicates, limit);
else
searchResults = connectionRecordMapper.searchReadable(user.getUser().getModel(),
requiredContents, sortPredicates, limit);
return getObjectInstances(searchResults);
}
private final LanguageResourceService languageResourceService;
this.languageResourceService = new LanguageResourceService(environment);
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.environment.Environment;
import org.glyptodon.guacamole.net.basic.properties.BasicGuacamoleProperties;
*/
private final Set<String> allowedLanguages;
*/
public LanguageResourceService(Environment environment) {
Set<String> parsedAllowedLanguages;
try {
parsedAllowedLanguages = environment.getProperty(BasicGuacamoleProperties.ALLOWED_LANGUAGES);
logger.debug("Available languages will be restricted to: {}", parsedAllowedLanguages);
}
catch (GuacamoleException e) {
parsedAllowedLanguages = null;
logger.error("Unable to parse list of allowed languages: {}", e.getMessage());
logger.debug("Error parsing list of allowed languages.", e);
}
this.allowedLanguages = parsedAllowedLanguages;
}
*/
private boolean isLanguageAllowed(String languageKey) {
if (allowedLanguages == null)
return true;
return allowedLanguages.contains(languageKey);
}
if (!isLanguageAllowed(key)) {
logger.debug("OMITTING language: \"{}\"", key);
return;
}
import org.glyptodon.guacamole.properties.StringGuacamoleProperty;
public static final StringSetProperty ALLOWED_LANGUAGES = new StringSetProperty() {
@Override
public String getName() { return "allowed-languages"; }
};
private final LanguageResourceService languageResourceService;
this.languageResourceService = new LanguageResourceService(environment);
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.environment.Environment;
import org.glyptodon.guacamole.net.basic.properties.BasicGuacamoleProperties;
*/
private final Set<String> allowedLanguages;
*/
public LanguageResourceService(Environment environment) {
Set<String> parsedAllowedLanguages;
try {
parsedAllowedLanguages = environment.getProperty(BasicGuacamoleProperties.ALLOWED_LANGUAGES);
logger.debug("Available languages will be restricted to: {}", parsedAllowedLanguages);
}
catch (GuacamoleException e) {
parsedAllowedLanguages = null;
logger.error("Unable to parse list of allowed languages: {}", e.getMessage());
logger.debug("Error parsing list of allowed languages.", e);
}
this.allowedLanguages = parsedAllowedLanguages;
}
*/
private boolean isLanguageAllowed(String languageKey) {
if (allowedLanguages == null)
return true;
return allowedLanguages.contains(languageKey);
}
if (!isLanguageAllowed(key)) {
logger.debug("OMITTING language: \"{}\"", key);
return;
}
import org.glyptodon.guacamole.properties.StringGuacamoleProperty;
public static final StringSetProperty ALLOWED_LANGUAGES = new StringSetProperty() {
@Override
public String getName() { return "allowed-languages"; }
};
private String connectionName;
public String getConnectionName() {
return connectionName;
}
public void setConnectionName(String connectionName) {
this.connectionName = connectionName;
}
public String getConnectionName() {
return model.getConnectionName();
}
@Override
public String getConnectionName() {
return connection.getName();
}
@Override
public String getConnectionName();
private final String connectionName;
this.connectionName       = record.getConnectionName();
this.startDate            = record.getStartDate();
this.endDate              = record.getEndDate();
this.remoteHost           = record.getRemoteHost();
this.username             = record.getUsername();
this.active               = record.isActive();
public String getConnectionName() {
return connectionName;
}
parseInt(month, 1) - 1,
connectionName(ConnectionRecordSet.SortableProperty.CONNECTION_NAME),
public class RESTExceptionWrapper implements MethodInterceptor {
new RESTMethodMatcher(),
new RESTExceptionWrapper()
import org.glyptodon.guacamole.GuacamoleResourceNotFoundException;
public void invalidateToken(@PathParam("token") String authToken)
throws GuacamoleException {
throw new GuacamoleResourceNotFoundException("No such token.");
import org.glyptodon.guacamole.GuacamoleClientException;
import org.glyptodon.guacamole.GuacamoleSecurityException;
throw new GuacamoleClientException("Username in path does not match username provided JSON data.");
if (userContext.self().getIdentifier().equals(user.getUsername()))
throw new GuacamoleSecurityException("Permission denied.");
if (authProvider.authenticateUser(credentials) == null)
throw new GuacamoleSecurityException("Permission denied.");
throw new GuacamoleSecurityException("Permission denied.");
PermissionType permission) throws GuacamoleException {
public class RESTExceptionWrapper implements MethodInterceptor {
new RESTMethodMatcher(),
new RESTExceptionWrapper()
import org.glyptodon.guacamole.GuacamoleResourceNotFoundException;
public void invalidateToken(@PathParam("token") String authToken)
throws GuacamoleException {
throw new GuacamoleResourceNotFoundException("No such token.");
import org.glyptodon.guacamole.GuacamoleClientException;
import org.glyptodon.guacamole.GuacamoleSecurityException;
throw new GuacamoleClientException("Username in path does not match username provided JSON data.");
if (userContext.self().getIdentifier().equals(user.getUsername()))
throw new GuacamoleSecurityException("Permission denied.");
if (authProvider.authenticateUser(credentials) == null)
throw new GuacamoleSecurityException("Permission denied.");
throw new GuacamoleSecurityException("Permission denied.");
PermissionType permission) throws GuacamoleException {
private final LanguageResourceService languageResourceService;
this.languageResourceService = new LanguageResourceService(environment);
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.environment.Environment;
import org.glyptodon.guacamole.net.basic.properties.BasicGuacamoleProperties;
*/
private final Set<String> allowedLanguages;
*/
public LanguageResourceService(Environment environment) {
Set<String> parsedAllowedLanguages;
try {
parsedAllowedLanguages = environment.getProperty(BasicGuacamoleProperties.ALLOWED_LANGUAGES);
logger.debug("Available languages will be restricted to: {}", parsedAllowedLanguages);
}
catch (GuacamoleException e) {
parsedAllowedLanguages = null;
logger.error("Unable to parse list of allowed languages: {}", e.getMessage());
logger.debug("Error parsing list of allowed languages.", e);
}
this.allowedLanguages = parsedAllowedLanguages;
}
*/
private boolean isLanguageAllowed(String languageKey) {
if (allowedLanguages == null)
return true;
return allowedLanguages.contains(languageKey);
}
if (!isLanguageAllowed(key)) {
logger.debug("OMITTING language: \"{}\"", key);
return;
}
import org.glyptodon.guacamole.properties.StringGuacamoleProperty;
public static final StringSetProperty ALLOWED_LANGUAGES = new StringSetProperty() {
@Override
public String getName() { return "allowed-languages"; }
};
public class RESTExceptionWrapper implements MethodInterceptor {
new RESTMethodMatcher(),
new RESTExceptionWrapper()
import org.glyptodon.guacamole.GuacamoleResourceNotFoundException;
public void invalidateToken(@PathParam("token") String authToken)
throws GuacamoleException {
throw new GuacamoleResourceNotFoundException("No such token.");
import org.glyptodon.guacamole.GuacamoleClientException;
import org.glyptodon.guacamole.GuacamoleSecurityException;
throw new GuacamoleClientException("Username in path does not match username provided JSON data.");
if (userContext.self().getIdentifier().equals(user.getUsername()))
throw new GuacamoleSecurityException("Permission denied.");
if (authProvider.authenticateUser(credentials) == null)
throw new GuacamoleSecurityException("Permission denied.");
throw new GuacamoleSecurityException("Permission denied.");
PermissionType permission) throws GuacamoleException {
import java.util.Collection;
import org.glyptodon.guacamole.auth.jdbc.user.UserModel;
List<ConnectionRecordModel> search(@Param("terms") Collection<ConnectionRecordSearchTerm> terms,
@Param("sortPredicates") List<ConnectionRecordSortPredicate> sortPredicates,
@Param("limit") int limit);
List<ConnectionRecordModel> searchReadable(@Param("user") UserModel user,
@Param("terms") Collection<ConnectionRecordSearchTerm> terms,
@Param("sortPredicates") List<ConnectionRecordSortPredicate> sortPredicates,
@Param("limit") int limit);
private String connectionName;
public String getConnectionName() {
return connectionName;
}
public void setConnectionName(String connectionName) {
this.connectionName = connectionName;
}
protected ConnectionRecord getObjectInstance(ConnectionRecordModel model) {
return new ModeledConnectionRecord(model);
}
protected List<ConnectionRecord> getObjectInstances(List<ConnectionRecordModel> models) {
List<ConnectionRecord> objects = new ArrayList<ConnectionRecord>(models.size());
for (ConnectionRecordModel model : models)
objects.add(getObjectInstance(model));
return objects;
}
records.add(getObjectInstance(model));
public List<ConnectionRecord> retrieveHistory(AuthenticatedUser user,
Collection<ConnectionRecordSearchTerm> requiredContents,
List<ConnectionRecordSortPredicate> sortPredicates, int limit)
throws GuacamoleException {
List<ConnectionRecordModel> searchResults;
if (user.getUser().isAdministrator())
searchResults = connectionRecordMapper.search(requiredContents,
sortPredicates, limit);
else
searchResults = connectionRecordMapper.searchReadable(user.getUser().getModel(),
requiredContents, sortPredicates, limit);
return getObjectInstances(searchResults);
}
public String getConnectionIdentifier() {
return model.getConnectionIdentifier();
}
@Override
public String getConnectionName() {
return model.getConnectionName();
}
@Override
public String getConnectionIdentifier() {
return connection.getIdentifier();
}
@Override
public String getConnectionName() {
return connection.getName();
}
@Override
import org.glyptodon.guacamole.auth.jdbc.connection.ConnectionRecordSet;
@Inject
private Provider<ConnectionRecordSet> connectionRecordSetProvider;
public ConnectionRecordSet getConnectionHistory()
throws GuacamoleException {
ConnectionRecordSet connectionRecordSet = connectionRecordSetProvider.get();
connectionRecordSet.init(getCurrentUser());
return connectionRecordSet;
}
@Override
import org.glyptodon.guacamole.net.auth.ConnectionRecordSet;
import org.glyptodon.guacamole.net.auth.simple.SimpleConnectionRecordSet;
public ConnectionRecordSet getConnectionHistory()
throws GuacamoleException {
return new SimpleConnectionRecordSet();
}
@Override
public String getConnectionIdentifier();
public String getConnectionName();
ConnectionRecordSet getConnectionHistory() throws GuacamoleException;
import org.glyptodon.guacamole.net.auth.ConnectionRecordSet;
public ConnectionRecordSet getConnectionHistory()
throws GuacamoleException {
return new SimpleConnectionRecordSet();
}
@Override
import org.glyptodon.guacamole.net.basic.rest.history.HistoryRESTService;
bind(HistoryRESTService.class);
import org.glyptodon.guacamole.net.basic.rest.history.APIConnectionRecord;
package org.glyptodon.guacamole.net.basic.rest.history;
private final String connectionIdentifier;
private final String connectionName;
this.connectionIdentifier = record.getConnectionIdentifier();
this.connectionName       = record.getConnectionName();
this.startDate            = record.getStartDate();
this.endDate              = record.getEndDate();
this.remoteHost           = record.getRemoteHost();
this.username             = record.getUsername();
this.active               = record.isActive();
}
public String getConnectionIdentifier() {
return connectionIdentifier;
}
public String getConnectionName() {
return connectionName;
import org.glyptodon.guacamole.GuacamoleUnauthorizedException;
public class GuacamoleCredentialsException extends GuacamoleUnauthorizedException {
import java.lang.reflect.Method;
import java.lang.reflect.Parameter;
import javax.ws.rs.FormParam;
import javax.ws.rs.QueryParam;
import org.glyptodon.guacamole.GuacamoleUnauthorizedException;
private final Logger logger = LoggerFactory.getLogger(RESTExceptionWrapper.class);
private boolean isRequestParameter(Parameter parameter, String name) {
QueryParam queryParam = parameter.getAnnotation(QueryParam.class);
if (queryParam != null && name.equals(queryParam.value()))
return true;
FormParam formParam = parameter.getAnnotation(FormParam.class);
return formParam != null && name.equals(formParam.value());
}
private String getAuthenticationToken(MethodInvocation invocation) {
Method method = invocation.getMethod();
Parameter[] parameters = method.getParameters();
Parameter parameter = parameters[i];
if (parameter.getType() != String.class)
continue;
if (!isRequestParameter(parameter, "token"))
continue;
Object[] args = invocation.getArguments();
return (String) args[i];
}
return null;
}
try {
return invocation.proceed();
}
catch (GuacamoleUnauthorizedException e) {
String token = getAuthenticationToken(invocation);
if (token != null) {
logger.debug("Implicitly invalidating token \"{}\" due to GuacamoleUnauthorizedException.", token);
}
throw e;
}
import java.lang.annotation.Annotation;
private boolean isRequestParameter(Annotation[] annotations, String name) {
for (Annotation annotation : annotations) {
if (annotation instanceof QueryParam && name.equals(((QueryParam) annotation).value()))
return true;
if (annotation instanceof FormParam && name.equals(((FormParam) annotation).value()))
return true;
}
return false;
Annotation[][] parameterAnnotations = method.getParameterAnnotations();
Class<?>[] parameterTypes = method.getParameterTypes();
assert(parameterAnnotations.length == parameterTypes.length);
Class<?> parameterType = parameterTypes[i];
if (parameterType != String.class)
Annotation[] annotations = parameterAnnotations[i];
if (!isRequestParameter(annotations, "token"))
import org.glyptodon.guacamole.net.basic.rest.RESTServiceModule;
new RESTServiceModule(sessionMap),
import org.glyptodon.guacamole.net.basic.rest.auth.TokenSessionMap;
private final TokenSessionMap tokenSessionMap;
public RESTExceptionWrapper(TokenSessionMap tokenSessionMap) {
this.tokenSessionMap = tokenSessionMap;
}
if (token != null && tokenSessionMap.remove(token) != null)
logger.debug("Implicitly invalidated token \"{}\" due to GuacamoleUnauthorizedException.", token);
import org.glyptodon.guacamole.net.basic.rest.auth.AuthTokenGenerator;
import org.glyptodon.guacamole.net.basic.rest.auth.AuthenticationService;
import org.glyptodon.guacamole.net.basic.rest.auth.SecureRandomAuthTokenGenerator;
import org.glyptodon.guacamole.net.basic.rest.auth.TokenSessionMap;
public class RESTServiceModule extends ServletModule {
private final TokenSessionMap tokenSessionMap;
public RESTServiceModule(TokenSessionMap tokenSessionMap) {
this.tokenSessionMap = tokenSessionMap;
}
bind(TokenSessionMap.class).toInstance(tokenSessionMap);
bind(AuthenticationService.class);
bind(AuthTokenGenerator.class).to(SecureRandomAuthTokenGenerator.class);
new RESTExceptionWrapper(tokenSessionMap)
import org.glyptodon.guacamole.net.basic.GuacamoleSession;
GuacamoleSession session = tokenSessionMap.remove(token);
if (session != null) {
session.invalidate();
logger.debug("Implicitly invalidated session for token \"{}\".", token);
}
import com.google.inject.Inject;
import org.glyptodon.guacamole.net.basic.rest.auth.AuthenticationService;
@Inject
private AuthenticationService authenticationService;
if (authenticationService.destroyGuacamoleSession(token))
import org.aopalliance.intercept.MethodInterceptor;
MethodInterceptor interceptor = new RESTExceptionWrapper();
requestInjection(interceptor);
bindInterceptor(Matchers.any(), new RESTMethodMatcher(), interceptor);
import java.util.ArrayList;
import java.util.regex.Pattern;
import javax.servlet.http.HttpServletRequest;
import org.glyptodon.guacamole.GuacamoleSecurityException;
import org.glyptodon.guacamole.environment.Environment;
import org.glyptodon.guacamole.net.auth.AuthenticatedUser;
import org.glyptodon.guacamole.net.auth.AuthenticationProvider;
import org.glyptodon.guacamole.net.auth.Credentials;
import org.glyptodon.guacamole.net.auth.credentials.CredentialsInfo;
import org.glyptodon.guacamole.net.auth.credentials.GuacamoleCredentialsException;
import org.glyptodon.guacamole.net.auth.credentials.GuacamoleInvalidCredentialsException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
private static final Logger logger = LoggerFactory.getLogger(AuthenticationService.class);
@Inject
private Environment environment;
@Inject
private List<AuthenticationProvider> authProviders;
@Inject
private AuthTokenGenerator authTokenGenerator;
private static final String IPV4_ADDRESS_REGEX = "([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})";
private static final String IPV6_ADDRESS_REGEX = "([0-9a-fA-F]*(:[0-9a-fA-F]*){0,7})";
private String getLoggableAddress(HttpServletRequest request) {
String header = request.getHeader("X-Forwarded-For");
if (header != null && X_FORWARDED_FOR.matcher(header).matches())
return request.getRemoteAddr();
}
private AuthenticatedUser authenticateUser(Credentials credentials)
throws GuacamoleException {
GuacamoleCredentialsException authFailure = null;
for (AuthenticationProvider authProvider : authProviders) {
try {
AuthenticatedUser authenticatedUser = authProvider.authenticateUser(credentials);
if (authenticatedUser != null)
return authenticatedUser;
}
catch (GuacamoleCredentialsException e) {
if (authFailure == null)
authFailure = e;
}
}
if (authFailure != null)
throw authFailure;
throw new GuacamoleInvalidCredentialsException(
"Permission Denied.",
CredentialsInfo.USERNAME_PASSWORD
);
}
private AuthenticatedUser updateAuthenticatedUser(AuthenticatedUser authenticatedUser,
Credentials credentials) throws GuacamoleException {
AuthenticationProvider authProvider = authenticatedUser.getAuthenticationProvider();
authenticatedUser = authProvider.updateAuthenticatedUser(authenticatedUser, credentials);
if (authenticatedUser == null)
throw new GuacamoleSecurityException("User re-authentication failed.");
return authenticatedUser;
}
private AuthenticatedUser getAuthenticatedUser(GuacamoleSession existingSession,
Credentials credentials) throws GuacamoleException {
try {
if (existingSession != null)
return updateAuthenticatedUser(existingSession.getAuthenticatedUser(), credentials);
AuthenticatedUser authenticatedUser = AuthenticationService.this.authenticateUser(credentials);
if (logger.isInfoEnabled())
logger.info("User \"{}\" successfully authenticated from {}.",
authenticatedUser.getIdentifier(),
getLoggableAddress(credentials.getRequest()));
return authenticatedUser;
}
catch (GuacamoleException e) {
HttpServletRequest request = credentials.getRequest();
String username = credentials.getUsername();
if (username != null) {
if (logger.isWarnEnabled())
logger.warn("Authentication attempt from {} for user \"{}\" failed.",
getLoggableAddress(request), username);
}
else if (logger.isDebugEnabled())
logger.debug("Anonymous authentication attempt from {} failed.",
getLoggableAddress(request));
throw e;
}
}
private List<UserContext> getUserContexts(GuacamoleSession existingSession,
AuthenticatedUser authenticatedUser) throws GuacamoleException {
List<UserContext> userContexts = new ArrayList<UserContext>(authProviders.size());
if (existingSession != null) {
List<UserContext> oldUserContexts = existingSession.getUserContexts();
for (UserContext oldUserContext : oldUserContexts) {
AuthenticationProvider authProvider = oldUserContext.getAuthenticationProvider();
UserContext userContext = authProvider.updateUserContext(oldUserContext, authenticatedUser);
if (userContext != null)
userContexts.add(userContext);
else
logger.debug("AuthenticationProvider \"{}\" retroactively destroyed its UserContext.",
authProvider.getClass().getName());
}
}
else {
for (AuthenticationProvider authProvider : authProviders) {
UserContext userContext = authProvider.getUserContext(authenticatedUser);
if (userContext != null)
userContexts.add(userContext);
}
}
return userContexts;
}
public String authenticate(Credentials credentials, String token)
throws GuacamoleException {
GuacamoleSession existingSession;
if (token != null)
existingSession = tokenSessionMap.get(token);
else
existingSession = null;
AuthenticatedUser authenticatedUser = getAuthenticatedUser(existingSession, credentials);
List<UserContext> userContexts = getUserContexts(existingSession, authenticatedUser);
String authToken;
if (existingSession != null) {
authToken = token;
existingSession.setAuthenticatedUser(authenticatedUser);
existingSession.setUserContexts(userContexts);
}
else {
authToken = authTokenGenerator.getToken();
tokenSessionMap.put(authToken, new GuacamoleSession(environment, authenticatedUser, userContexts));
logger.debug("Login was successful for user \"{}\".", authenticatedUser.getIdentifier());
}
return authToken;
}
public boolean destroyGuacamoleSession(String authToken) {
GuacamoleSession session = tokenSessionMap.remove(authToken);
if (session == null)
return false;
session.invalidate();
return true;
}
@Inject
private AuthenticationService authenticationService;
token = authenticationService.authenticate(credentials, token);
GuacamoleSession session = authenticationService.getGuacamoleSession(token);
if (session == null)
throw new GuacamoleResourceNotFoundException("No such token.");
List<UserContext> userContexts = session.getUserContexts();
AuthenticatedUser authenticatedUser = session.getAuthenticatedUser();
token,
if (!authenticationService.destroyGuacamoleSession(authToken))
throw new GuacamoleResourceNotFoundException("No such token.");
import org.glyptodon.guacamole.GuacamoleUnauthorizedException;
protected GuacamoleTunnel createAssociatedTunnel(GuacamoleTunnel tunnel,
final GuacamoleSession session, final TunnelRequest.Type type,
try {
GuacamoleTunnel tunnel = createConnectedTunnel(userContext, type, id, info);
return createAssociatedTunnel(tunnel, session, type, id);
}
catch (GuacamoleUnauthorizedException e) {
if (authenticationService.destroyGuacamoleSession(authToken))
logger.debug("Implicitly invalidated session for token \"{}\".", authToken);
throw e;
}
final String authToken,  final GuacamoleSession session,
final TunnelRequest.Type type, final String id)
throws GuacamoleException {
try {
session.removeTunnel(getUUID().toString());
super.close();
}
catch (GuacamoleUnauthorizedException e) {
if (authenticationService.destroyGuacamoleSession(authToken))
logger.debug("Implicitly invalidated session for token \"{}\".", authToken);
throw e;
}
return createAssociatedTunnel(tunnel, authToken, session, type, id);
import org.glyptodon.guacamole.GuacamoleUnauthorizedException;
public class GuacamoleCredentialsException extends GuacamoleUnauthorizedException {
import org.glyptodon.guacamole.net.basic.rest.RESTServiceModule;
new RESTServiceModule(sessionMap),
import org.glyptodon.guacamole.GuacamoleUnauthorizedException;
protected GuacamoleTunnel createAssociatedTunnel(GuacamoleTunnel tunnel,
final String authToken,  final GuacamoleSession session,
final TunnelRequest.Type type, final String id)
throws GuacamoleException {
try {
session.removeTunnel(getUUID().toString());
super.close();
}
catch (GuacamoleUnauthorizedException e) {
if (authenticationService.destroyGuacamoleSession(authToken))
logger.debug("Implicitly invalidated session for token \"{}\".", authToken);
throw e;
}
try {
GuacamoleTunnel tunnel = createConnectedTunnel(userContext, type, id, info);
return createAssociatedTunnel(tunnel, authToken, session, type, id);
}
catch (GuacamoleUnauthorizedException e) {
if (authenticationService.destroyGuacamoleSession(authToken))
logger.debug("Implicitly invalidated session for token \"{}\".", authToken);
throw e;
}
import com.google.inject.Inject;
import java.lang.annotation.Annotation;
import java.lang.reflect.Method;
import javax.ws.rs.FormParam;
import javax.ws.rs.QueryParam;
import org.glyptodon.guacamole.GuacamoleUnauthorizedException;
import org.glyptodon.guacamole.net.basic.rest.auth.AuthenticationService;
private final Logger logger = LoggerFactory.getLogger(RESTExceptionWrapper.class);
@Inject
private AuthenticationService authenticationService;
private boolean isRequestParameter(Annotation[] annotations, String name) {
for (Annotation annotation : annotations) {
if (annotation instanceof QueryParam && name.equals(((QueryParam) annotation).value()))
return true;
if (annotation instanceof FormParam && name.equals(((FormParam) annotation).value()))
return true;
}
return false;
}
private String getAuthenticationToken(MethodInvocation invocation) {
Method method = invocation.getMethod();
Annotation[][] parameterAnnotations = method.getParameterAnnotations();
Class<?>[] parameterTypes = method.getParameterTypes();
assert(parameterAnnotations.length == parameterTypes.length);
Class<?> parameterType = parameterTypes[i];
if (parameterType != String.class)
continue;
Annotation[] annotations = parameterAnnotations[i];
if (!isRequestParameter(annotations, "token"))
continue;
Object[] args = invocation.getArguments();
return (String) args[i];
}
return null;
}
try {
return invocation.proceed();
}
catch (GuacamoleUnauthorizedException e) {
String token = getAuthenticationToken(invocation);
if (authenticationService.destroyGuacamoleSession(token))
logger.debug("Implicitly invalidated session for token \"{}\".", token);
throw e;
}
import org.aopalliance.intercept.MethodInterceptor;
import org.glyptodon.guacamole.net.basic.rest.auth.AuthTokenGenerator;
import org.glyptodon.guacamole.net.basic.rest.auth.AuthenticationService;
import org.glyptodon.guacamole.net.basic.rest.auth.SecureRandomAuthTokenGenerator;
import org.glyptodon.guacamole.net.basic.rest.auth.TokenSessionMap;
public class RESTServiceModule extends ServletModule {
private final TokenSessionMap tokenSessionMap;
public RESTServiceModule(TokenSessionMap tokenSessionMap) {
this.tokenSessionMap = tokenSessionMap;
}
bind(TokenSessionMap.class).toInstance(tokenSessionMap);
bind(AuthenticationService.class);
bind(AuthTokenGenerator.class).to(SecureRandomAuthTokenGenerator.class);
MethodInterceptor interceptor = new RESTExceptionWrapper();
requestInjection(interceptor);
bindInterceptor(Matchers.any(), new RESTMethodMatcher(), interceptor);
import java.util.ArrayList;
import java.util.regex.Pattern;
import javax.servlet.http.HttpServletRequest;
import org.glyptodon.guacamole.GuacamoleSecurityException;
import org.glyptodon.guacamole.environment.Environment;
import org.glyptodon.guacamole.net.auth.AuthenticatedUser;
import org.glyptodon.guacamole.net.auth.AuthenticationProvider;
import org.glyptodon.guacamole.net.auth.Credentials;
import org.glyptodon.guacamole.net.auth.credentials.CredentialsInfo;
import org.glyptodon.guacamole.net.auth.credentials.GuacamoleCredentialsException;
import org.glyptodon.guacamole.net.auth.credentials.GuacamoleInvalidCredentialsException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
private static final Logger logger = LoggerFactory.getLogger(AuthenticationService.class);
@Inject
private Environment environment;
@Inject
private List<AuthenticationProvider> authProviders;
@Inject
private AuthTokenGenerator authTokenGenerator;
private static final String IPV4_ADDRESS_REGEX = "([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})";
private static final String IPV6_ADDRESS_REGEX = "([0-9a-fA-F]*(:[0-9a-fA-F]*){0,7})";
private String getLoggableAddress(HttpServletRequest request) {
String header = request.getHeader("X-Forwarded-For");
if (header != null && X_FORWARDED_FOR.matcher(header).matches())
return request.getRemoteAddr();
}
private AuthenticatedUser authenticateUser(Credentials credentials)
throws GuacamoleException {
GuacamoleCredentialsException authFailure = null;
for (AuthenticationProvider authProvider : authProviders) {
try {
AuthenticatedUser authenticatedUser = authProvider.authenticateUser(credentials);
if (authenticatedUser != null)
return authenticatedUser;
}
catch (GuacamoleCredentialsException e) {
if (authFailure == null)
authFailure = e;
}
}
if (authFailure != null)
throw authFailure;
throw new GuacamoleInvalidCredentialsException(
"Permission Denied.",
CredentialsInfo.USERNAME_PASSWORD
);
}
private AuthenticatedUser updateAuthenticatedUser(AuthenticatedUser authenticatedUser,
Credentials credentials) throws GuacamoleException {
AuthenticationProvider authProvider = authenticatedUser.getAuthenticationProvider();
authenticatedUser = authProvider.updateAuthenticatedUser(authenticatedUser, credentials);
if (authenticatedUser == null)
throw new GuacamoleSecurityException("User re-authentication failed.");
return authenticatedUser;
}
private AuthenticatedUser getAuthenticatedUser(GuacamoleSession existingSession,
Credentials credentials) throws GuacamoleException {
try {
if (existingSession != null)
return updateAuthenticatedUser(existingSession.getAuthenticatedUser(), credentials);
AuthenticatedUser authenticatedUser = AuthenticationService.this.authenticateUser(credentials);
if (logger.isInfoEnabled())
logger.info("User \"{}\" successfully authenticated from {}.",
authenticatedUser.getIdentifier(),
getLoggableAddress(credentials.getRequest()));
return authenticatedUser;
}
catch (GuacamoleException e) {
HttpServletRequest request = credentials.getRequest();
String username = credentials.getUsername();
if (username != null) {
if (logger.isWarnEnabled())
logger.warn("Authentication attempt from {} for user \"{}\" failed.",
getLoggableAddress(request), username);
}
else if (logger.isDebugEnabled())
logger.debug("Anonymous authentication attempt from {} failed.",
getLoggableAddress(request));
throw e;
}
}
private List<UserContext> getUserContexts(GuacamoleSession existingSession,
AuthenticatedUser authenticatedUser) throws GuacamoleException {
List<UserContext> userContexts = new ArrayList<UserContext>(authProviders.size());
if (existingSession != null) {
List<UserContext> oldUserContexts = existingSession.getUserContexts();
for (UserContext oldUserContext : oldUserContexts) {
AuthenticationProvider authProvider = oldUserContext.getAuthenticationProvider();
UserContext userContext = authProvider.updateUserContext(oldUserContext, authenticatedUser);
if (userContext != null)
userContexts.add(userContext);
else
logger.debug("AuthenticationProvider \"{}\" retroactively destroyed its UserContext.",
authProvider.getClass().getName());
}
}
else {
for (AuthenticationProvider authProvider : authProviders) {
UserContext userContext = authProvider.getUserContext(authenticatedUser);
if (userContext != null)
userContexts.add(userContext);
}
}
return userContexts;
}
public String authenticate(Credentials credentials, String token)
throws GuacamoleException {
GuacamoleSession existingSession;
if (token != null)
existingSession = tokenSessionMap.get(token);
else
existingSession = null;
AuthenticatedUser authenticatedUser = getAuthenticatedUser(existingSession, credentials);
List<UserContext> userContexts = getUserContexts(existingSession, authenticatedUser);
String authToken;
if (existingSession != null) {
authToken = token;
existingSession.setAuthenticatedUser(authenticatedUser);
existingSession.setUserContexts(userContexts);
}
else {
authToken = authTokenGenerator.getToken();
tokenSessionMap.put(authToken, new GuacamoleSession(environment, authenticatedUser, userContexts));
logger.debug("Login was successful for user \"{}\".", authenticatedUser.getIdentifier());
}
return authToken;
}
public boolean destroyGuacamoleSession(String authToken) {
GuacamoleSession session = tokenSessionMap.remove(authToken);
if (session == null)
return false;
session.invalidate();
return true;
}
@Inject
private AuthenticationService authenticationService;
token = authenticationService.authenticate(credentials, token);
GuacamoleSession session = authenticationService.getGuacamoleSession(token);
if (session == null)
throw new GuacamoleResourceNotFoundException("No such token.");
List<UserContext> userContexts = session.getUserContexts();
AuthenticatedUser authenticatedUser = session.getAuthenticatedUser();
token,
if (!authenticationService.destroyGuacamoleSession(authToken))
throw new GuacamoleResourceNotFoundException("No such token.");
import java.util.List;
private String getUserBindDN(String username)
throws GuacamoleException {
List<String> usernameAttributes = confService.getUsernameAttributes();
if (usernameAttributes.isEmpty())
return null;
if (usernameAttributes.size() != 1)
return null;
return
escapingService.escapeDN(usernameAttributes.get(0))
}
String username = credentials.getUsername();
String password = credentials.getPassword();
if (username == null || username.isEmpty()) {
if (password == null || password.isEmpty()) {
String userDN = getUserBindDN(username);
if (userDN == null) {
logger.error("Unable to determine DN for user \"{}\".", username);
return null;
}
password.getBytes("UTF-8"));
LDAPConnection ldapConnection;
try {
ldapConnection = bindAs(credentials);
}
catch (GuacamoleException e) {
logger.error("Cannot bind with LDAP server: {}", e.getMessage());
logger.debug("Error binding with LDAP server.", e);
ldapConnection = null;
}
import java.util.Collections;
import java.util.List;
public List<String> getUsernameAttributes() throws GuacamoleException {
Collections.singletonList("uid")
public static final StringListProperty LDAP_USERNAME_ATTRIBUTE = new StringListProperty() {
private void putAllUsers(Map<String, User> users, LDAPConnection ldapConnection,
String usernameAttribute) throws GuacamoleException {
try {
LDAPSearchResults results = ldapConnection.search(
confService.getUserBaseDN(),
LDAPConnection.SCOPE_SUB,
null,
false
);
while (results.hasMore()) {
LDAPEntry entry = results.next();
LDAPAttribute username = entry.getAttribute(usernameAttribute);
if (username == null) {
logger.warn("Queried user is missing the username attribute \"{}\".", usernameAttribute);
continue;
}
String identifier = username.getStringValue();
if (users.put(identifier, new SimpleUser(identifier)) != null)
logger.warn("Possibly ambiguous user account: \"{}\".", identifier);
}
}
catch (LDAPException e) {
throw new GuacamoleServerException("Error while querying users.", e);
}
}
Map<String, User> users = new HashMap<String, User>();
for (String usernameAttribute : confService.getUsernameAttributes())
putAllUsers(users, ldapConnection, usernameAttribute);
return users;
for (String usernameAttribute : confService.getUsernameAttributes()) {
try {
putAllUsers(users, ldapConnection, usernameAttribute);
}
catch (GuacamoleException e) {
logger.warn("Could not query list of all users for attribute \"{}\": {}",
usernameAttribute, e.getMessage());
logger.debug("Error querying list of all users.", e);
}
}
public static final StringGuacamoleProperty LDAP_SEARCH_BIND_DN = new StringGuacamoleProperty() {
@Override
public String getName() { return "ldap-search-bind-dn"; }
};
public static final StringGuacamoleProperty LDAP_SEARCH_BIND_PASSWORD = new StringGuacamoleProperty() {
@Override
public String getName() { return "ldap-search-bind-password"; }
};
List<String> stringValues = Arrays.asList(DELIMITER_PATTERN.split(values));
if (stringValues.isEmpty())
return null;
return stringValues;
if (usernameAttributes.size() != 1) {
logger.warn("Cannot directly derive user DN when multiple username attributes are specified");
}
private LDAPConnection bindAs(String userDN, String password)
throws GuacamoleException {
}
private LDAPConnection bindAs(Credentials credentials)
throws GuacamoleException {
String username = credentials.getUsername();
String password = credentials.getPassword();
if (username == null || username.isEmpty()) {
logger.debug("Anonymous bind is not currently allowed by the LDAP authentication provider.");
return null;
}
if (password == null || password.isEmpty()) {
logger.debug("Anonymous bind is not currently allowed by the LDAP authentication provider.");
return null;
}
String userDN = getUserBindDN(username);
if (userDN == null) {
logger.error("Unable to determine DN for user \"{}\".", username);
return null;
}
return bindAs(userDN, password);
import java.util.ArrayList;
import java.util.List;
private String generateLDAPQuery(String username)
throws GuacamoleException {
List<String> usernameAttributes = confService.getUsernameAttributes();
StringBuilder ldapQuery = new StringBuilder("(&(objectClass=*)");
if (usernameAttributes.size() > 1)
ldapQuery.append("(|");
for (String usernameAttribute : usernameAttributes) {
ldapQuery.append("(");
ldapQuery.append(escapingService.escapeLDAPSearchFilter(usernameAttribute));
ldapQuery.append("=");
ldapQuery.append(escapingService.escapeLDAPSearchFilter(username));
ldapQuery.append(")");
}
if (usernameAttributes.size() > 1)
ldapQuery.append(")");
return ldapQuery.toString();
}
public List<String> getUserDNs(LDAPConnection ldapConnection,
String username) throws GuacamoleException {
try {
List<String> userDNs = new ArrayList<String>();
LDAPSearchResults results = ldapConnection.search(
confService.getUserBaseDN(),
LDAPConnection.SCOPE_SUB,
generateLDAPQuery(username),
null,
false
);
while (results.hasMore()) {
LDAPEntry entry = results.next();
userDNs.add(entry.getDN());
}
return userDNs;
}
catch (LDAPException e) {
throw new GuacamoleServerException("Error while query user DNs.", e);
}
}
import org.glyptodon.guacamole.auth.ldap.user.UserService;
@Inject
private UserService userService;
return userService.deriveUserDN(username);
public String deriveUserDN(String username)
throws GuacamoleException {
List<String> usernameAttributes = confService.getUsernameAttributes();
if (usernameAttributes.size() != 1) {
logger.warn("Cannot directly derive user DN when multiple username attributes are specified");
return null;
}
return
escapingService.escapeDN(usernameAttributes.get(0))
}
public String getSearchBindDN() throws GuacamoleException {
return environment.getProperty(
LDAPGuacamoleProperties.LDAP_SEARCH_BIND_DN
);
}
public String getSearchBindPassword() throws GuacamoleException {
return environment.getProperty(
LDAPGuacamoleProperties.LDAP_SEARCH_BIND_PASSWORD
);
}
import java.util.List;
private void disconnect(LDAPConnection ldapConnection) {
try {
ldapConnection.disconnect();
}
catch (LDAPException e) {
logger.warn("Unable to disconnect from LDAP server: {}", e.getMessage());
logger.debug("LDAP disconnect failed.", e);
}
}
String searchBindDN = confService.getSearchBindDN();
if (searchBindDN != null) {
LDAPConnection searchConnection = bindAs(
searchBindDN,
confService.getSearchBindPassword()
);
try {
List<String> userDNs = userService.getUserDNs(searchConnection, username);
if (userDNs.isEmpty())
return null;
if (userDNs.size() != 1) {
logger.warn("Multiple DNs possible for user \"{}\": {}", username, userDNs);
return null;
}
return userDNs.get(0);
}
finally {
disconnect(searchConnection);
}
}
byte[] passwordBytes;
if (password != null)
passwordBytes = password.getBytes("UTF-8");
else
passwordBytes = null;
ldapConnection.bind(LDAPConnection.LDAP_V3, userDN, passwordBytes);
disconnect(ldapConnection);
logger.debug("Unable to determine DN for user \"{}\".", username);
disconnect(ldapConnection);
disconnect(ldapConnection);
ldapQuery.append(")");
disconnect(ldapConnection);
@Inject
private LDAPConnectionService ldapService;
LDAPConnection searchConnection = ldapService.bindAs(
ldapService.disconnect(searchConnection);
return ldapService.bindAs(userDN, password);
ldapService.disconnect(ldapConnection);
ldapService.disconnect(ldapConnection);
bind(LDAPConnectionService.class);
if (searchConnection == null) {
logger.error("Unable to bind using search DN \"{}\"", searchBindDN);
return null;
}
return environment.getProperty(
import java.util.Collections;
String configurationBaseDN = confService.getConfigurationBaseDN();
if (configurationBaseDN == null)
return Collections.<String, Connection>emptyMap();
configurationBaseDN,
import java.util.List;
import org.glyptodon.guacamole.auth.ldap.user.UserService;
private LDAPConnectionService ldapService;
@Inject
private UserService userService;
private String getUserBindDN(String username)
throws GuacamoleException {
String searchBindDN = confService.getSearchBindDN();
if (searchBindDN != null) {
LDAPConnection searchConnection = ldapService.bindAs(
searchBindDN,
confService.getSearchBindPassword()
);
if (searchConnection == null) {
logger.error("Unable to bind using search DN \"{}\"", searchBindDN);
return null;
}
try {
List<String> userDNs = userService.getUserDNs(searchConnection, username);
if (userDNs.isEmpty())
return null;
if (userDNs.size() != 1) {
logger.warn("Multiple DNs possible for user \"{}\": {}", username, userDNs);
return null;
}
return userDNs.get(0);
}
finally {
ldapService.disconnect(searchConnection);
}
}
return userService.deriveUserDN(username);
}
String username = credentials.getUsername();
String password = credentials.getPassword();
if (username == null || username.isEmpty()) {
if (password == null || password.isEmpty()) {
String userDN = getUserBindDN(username);
if (userDN == null) {
logger.debug("Unable to determine DN for user \"{}\".", username);
return ldapService.bindAs(userDN, password);
LDAPConnection ldapConnection;
try {
ldapConnection = bindAs(credentials);
}
catch (GuacamoleException e) {
logger.error("Cannot bind with LDAP server: {}", e.getMessage());
logger.debug("Error binding with LDAP server.", e);
ldapConnection = null;
}
ldapService.disconnect(ldapConnection);
ldapService.disconnect(ldapConnection);
import java.util.Collections;
import java.util.List;
public List<String> getUsernameAttributes() throws GuacamoleException {
Collections.singletonList("uid")
return environment.getProperty(
public String getSearchBindDN() throws GuacamoleException {
return environment.getProperty(
LDAPGuacamoleProperties.LDAP_SEARCH_BIND_DN
);
}
public String getSearchBindPassword() throws GuacamoleException {
return environment.getProperty(
LDAPGuacamoleProperties.LDAP_SEARCH_BIND_PASSWORD
);
}
bind(LDAPConnectionService.class);
public static final StringListProperty LDAP_USERNAME_ATTRIBUTE = new StringListProperty() {
public static final StringGuacamoleProperty LDAP_SEARCH_BIND_DN = new StringGuacamoleProperty() {
@Override
public String getName() { return "ldap-search-bind-dn"; }
};
public static final StringGuacamoleProperty LDAP_SEARCH_BIND_PASSWORD = new StringGuacamoleProperty() {
@Override
public String getName() { return "ldap-search-bind-password"; }
};
import java.util.Collections;
String configurationBaseDN = confService.getConfigurationBaseDN();
if (configurationBaseDN == null)
return Collections.<String, Connection>emptyMap();
configurationBaseDN,
import java.util.ArrayList;
import java.util.List;
private void putAllUsers(Map<String, User> users, LDAPConnection ldapConnection,
String usernameAttribute) throws GuacamoleException {
try {
LDAPSearchResults results = ldapConnection.search(
confService.getUserBaseDN(),
LDAPConnection.SCOPE_SUB,
null,
false
);
while (results.hasMore()) {
LDAPEntry entry = results.next();
LDAPAttribute username = entry.getAttribute(usernameAttribute);
if (username == null) {
logger.warn("Queried user is missing the username attribute \"{}\".", usernameAttribute);
continue;
}
String identifier = username.getStringValue();
if (users.put(identifier, new SimpleUser(identifier)) != null)
logger.warn("Possibly ambiguous user account: \"{}\".", identifier);
}
}
catch (LDAPException e) {
throw new GuacamoleServerException("Error while querying users.", e);
}
}
Map<String, User> users = new HashMap<String, User>();
for (String usernameAttribute : confService.getUsernameAttributes()) {
try {
putAllUsers(users, ldapConnection, usernameAttribute);
}
catch (GuacamoleException e) {
logger.warn("Could not query list of all users for attribute \"{}\": {}",
usernameAttribute, e.getMessage());
logger.debug("Error querying list of all users.", e);
}
}
return users;
}
private String generateLDAPQuery(String username)
throws GuacamoleException {
List<String> usernameAttributes = confService.getUsernameAttributes();
StringBuilder ldapQuery = new StringBuilder("(&(objectClass=*)");
if (usernameAttributes.size() > 1)
ldapQuery.append("(|");
for (String usernameAttribute : usernameAttributes) {
ldapQuery.append("(");
ldapQuery.append(escapingService.escapeLDAPSearchFilter(usernameAttribute));
ldapQuery.append("=");
ldapQuery.append(escapingService.escapeLDAPSearchFilter(username));
ldapQuery.append(")");
}
if (usernameAttributes.size() > 1)
ldapQuery.append(")");
ldapQuery.append(")");
return ldapQuery.toString();
}
public List<String> getUserDNs(LDAPConnection ldapConnection,
String username) throws GuacamoleException {
List<String> userDNs = new ArrayList<String>();
LDAPConnection.SCOPE_SUB,
generateLDAPQuery(username),
userDNs.add(entry.getDN());
return userDNs;
throw new GuacamoleServerException("Error while query user DNs.", e);
public String deriveUserDN(String username)
throws GuacamoleException {
List<String> usernameAttributes = confService.getUsernameAttributes();
if (usernameAttributes.size() != 1) {
logger.warn("Cannot directly derive user DN when multiple username attributes are specified");
return null;
}
return
escapingService.escapeDN(usernameAttributes.get(0))
}
import org.glyptodon.guacamole.net.auth.AuthenticatedUser;
import org.glyptodon.guacamole.token.StandardTokens;
import org.glyptodon.guacamole.token.TokenFilter;
public Map<String, Connection> getConnections(AuthenticatedUser user,
LDAPConnection ldapConnection) throws GuacamoleException {
TokenFilter tokenFilter = new TokenFilter();
StandardTokens.addStandardTokens(tokenFilter, user.getCredentials());
tokenFilter.filterValues(config.getParameters());
connectionService.getConnections(user, ldapConnection)
import org.glyptodon.guacamole.auth.ldap.LDAPGuacamoleProperties;
logger.warn(String.format("Cannot directly derive user DN when "
"multiple username attributes are specified. Please "
"define an LDAP search DN using the \"%s\" property "
"in your \"guacamole.properties\".",
LDAPGuacamoleProperties.LDAP_SEARCH_BIND_DN.getName()));
import org.glyptodon.guacamole.net.auth.AuthenticatedUser;
import org.glyptodon.guacamole.token.StandardTokens;
import org.glyptodon.guacamole.token.TokenFilter;
public Map<String, Connection> getConnections(AuthenticatedUser user,
LDAPConnection ldapConnection) throws GuacamoleException {
TokenFilter tokenFilter = new TokenFilter();
StandardTokens.addStandardTokens(tokenFilter, user.getCredentials());
tokenFilter.filterValues(config.getParameters());
connectionService.getConnections(user, ldapConnection)
import org.glyptodon.guacamole.auth.ldap.LDAPGuacamoleProperties;
logger.warn(String.format("Cannot directly derive user DN when "
"multiple username attributes are specified. Please "
"define an LDAP search DN using the \"%s\" property "
"in your \"guacamole.properties\".",
LDAPGuacamoleProperties.LDAP_SEARCH_BIND_DN.getName()));
private final JDBCEnvironment environment;
JDBCEnvironment environment) {
bind(JDBCEnvironment.class).toInstance(environment);
import org.glyptodon.guacamole.auth.jdbc.JDBCEnvironment;
private JDBCEnvironment environment;
import com.google.inject.Inject;
import org.glyptodon.guacamole.auth.jdbc.JDBCEnvironment;
@Inject JDBCEnvironment jdbcEnvironment;
connectionMaxConnectionsPerUser = jdbcEnvironment.getDefaultMaxConnectionsPerUser();
connectionMaxConnections = jdbcEnvironment.getDefaultMaxConnections();
connectionGroupMaxConnectionsPerUser = jdbcEnvironment.getDefaultMaxGroupConnectionsPerUser();
connectionGroupMaxConnections = jdbcEnvironment.getDefaultMaxGroupConnections();
MySQLEnvironment environment = new MySQLEnvironment();
new JDBCAuthenticationProviderModule(this, environment)
public MySQLAuthenticationProviderModule(MySQLEnvironment environment)
myBatisProperties.setProperty("JDBC.host", environment.getMySQLHostname());
myBatisProperties.setProperty("JDBC.port", String.valueOf(environment.getMySQLPort()));
myBatisProperties.setProperty("JDBC.schema", environment.getMySQLDatabase());
myBatisProperties.setProperty("JDBC.username", environment.getMySQLUsername());
myBatisProperties.setProperty("JDBC.password", environment.getMySQLPassword());
private static final String DEFAULT_HOSTNAME = "localhost";
private static final int DEFAULT_PORT = 3306;
return getProperty(
MySQLGuacamoleProperties.MYSQL_HOSTNAME,
DEFAULT_HOSTNAME
);
return getProperty(MySQLGuacamoleProperties.MYSQL_PORT, DEFAULT_PORT);
private int DEFAULT_MAX_CONNECTIONS_PER_USER = 1;
private int DEFAULT_MAX_GROUP_CONNECTIONS_PER_USER = 1;
private int DEFAULT_MAX_CONNECTIONS = 0;
private int DEFAULT_MAX_GROUP_CONNECTIONS = 0;
Boolean disallowDuplicate    = getProperty(MySQLGuacamoleProperties.MYSQL_DISALLOW_DUPLICATE_CONNECTIONS);
DEFAULT_MAX_CONNECTIONS       = 1;
DEFAULT_MAX_GROUP_CONNECTIONS = 0;
DEFAULT_MAX_CONNECTIONS       = 0;
DEFAULT_MAX_GROUP_CONNECTIONS = 0;
logger.warn("The \"{}\" property is deprecated. Use \"{}\" and \"{}\" instead.",
MySQLGuacamoleProperties.MYSQL_DISALLOW_SIMULTANEOUS_CONNECTIONS.getName(),
MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_CONNECTIONS.getName(),
MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_GROUP_CONNECTIONS.getName());
logger.info("To achieve the same result of setting \"{}\" to \"{}\", set \"{}\" to \"{}\" and \"{}\" to \"{}\".",
MySQLGuacamoleProperties.MYSQL_DISALLOW_SIMULTANEOUS_CONNECTIONS.getName(), disallowSimultaneous,
MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_CONNECTIONS.getName(),           DEFAULT_MAX_CONNECTIONS,
MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_GROUP_CONNECTIONS.getName(),     DEFAULT_MAX_GROUP_CONNECTIONS);
if (disallowDuplicate != null) {
if (disallowDuplicate) {
DEFAULT_MAX_CONNECTIONS_PER_USER       = 1;
DEFAULT_MAX_GROUP_CONNECTIONS_PER_USER = 1;
}
else {
DEFAULT_MAX_CONNECTIONS_PER_USER       = 0;
DEFAULT_MAX_GROUP_CONNECTIONS_PER_USER = 0;
}
logger.warn("The \"{}\" property is deprecated. Use \"{}\" and \"{}\" instead.",
MySQLGuacamoleProperties.MYSQL_DISALLOW_DUPLICATE_CONNECTIONS.getName(),
MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_CONNECTIONS_PER_USER.getName(),
MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_GROUP_CONNECTIONS.getName());
logger.info("To achieve the same result of setting \"{}\" to \"{}\", set \"{}\" to \"{}\" and \"{}\" to \"{}\".",
MySQLGuacamoleProperties.MYSQL_DISALLOW_DUPLICATE_CONNECTIONS.getName(),         disallowDuplicate,
MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_CONNECTIONS_PER_USER.getName(),       DEFAULT_MAX_CONNECTIONS_PER_USER,
MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_GROUP_CONNECTIONS_PER_USER.getName(), DEFAULT_MAX_GROUP_CONNECTIONS_PER_USER);
}
@Override
public int getDefaultMaxConnections() throws GuacamoleException {
return getProperty(
MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_CONNECTIONS,
DEFAULT_MAX_CONNECTIONS
);
return getProperty(
MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_GROUP_CONNECTIONS,
DEFAULT_MAX_GROUP_CONNECTIONS
);
return getProperty(
MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_CONNECTIONS_PER_USER,
DEFAULT_MAX_CONNECTIONS_PER_USER
);
return getProperty(
MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_GROUP_CONNECTIONS_PER_USER,
DEFAULT_MAX_GROUP_CONNECTIONS_PER_USER
);
import org.glyptodon.guacamole.auth.jdbc.JDBCEnvironment;
PostgreSQLEnvironment environment = new PostgreSQLEnvironment();
new JDBCAuthenticationProviderModule(this, environment)
public PostgreSQLAuthenticationProviderModule(PostgreSQLEnvironment environment)
myBatisProperties.setProperty("JDBC.host", environment.getPostgreSQLHostname());
myBatisProperties.setProperty("JDBC.port", String.valueOf(environment.getPostgreSQLPort()));
myBatisProperties.setProperty("JDBC.schema", environment.getPostgreSQLDatabase());
myBatisProperties.setProperty("JDBC.username", environment.getPostgreSQLUsername());
myBatisProperties.setProperty("JDBC.password", environment.getPostgreSQLPassword());
import org.glyptodon.guacamole.auth.jdbc.tunnel.ConfigurableGuacamoleTunnelService;
bind(GuacamoleTunnelService.class).to(ConfigurableGuacamoleTunnelService.class);
@Inject
private JDBCEnvironment environment;
connectionMaxConnectionsPerUser = environment.getDefaultMaxConnectionsPerUser();
connectionMaxConnections = environment.getDefaultMaxConnections();
connectionGroupMaxConnectionsPerUser = environment.getDefaultMaxGroupConnectionsPerUser();
connectionGroupMaxConnections = environment.getDefaultMaxGroupConnections();
import org.glyptodon.guacamole.auth.jdbc.tunnel.RestrictedGuacamoleTunnelService;
bind(GuacamoleTunnelService.class).to(RestrictedGuacamoleTunnelService.class);
import org.glyptodon.guacamole.auth.jdbc.JDBCEnvironment;
@Inject
private JDBCEnvironment environment;
public int getMaxConnections() throws GuacamoleException {
Integer value = getModel().getMaxConnections();
if (value == null)
return environment.getDefaultMaxConnections();
return value;
}
public int getMaxConnectionsPerUser() throws GuacamoleException {
Integer value = getModel().getMaxConnectionsPerUser();
if (value == null)
return environment.getDefaultMaxConnectionsPerUser();
return value;
}
import org.glyptodon.guacamole.auth.jdbc.JDBCEnvironment;
@Inject
private JDBCEnvironment environment;
public int getMaxConnections() throws GuacamoleException {
Integer value = getModel().getMaxConnections();
if (value == null)
return environment.getDefaultMaxGroupConnections();
return value;
}
public int getMaxConnectionsPerUser() throws GuacamoleException {
Integer value = getModel().getMaxConnectionsPerUser();
if (value == null)
return environment.getDefaultMaxGroupConnectionsPerUser();
return value;
}
public class RestrictedGuacamoleTunnelService
if (tryAdd(activeSeats, seat,
connection.getMaxConnectionsPerUser())) {
connection.getMaxConnections()))
connectionGroup.getMaxConnectionsPerUser())) {
connectionGroup.getMaxConnections()))
import org.glyptodon.guacamole.auth.jdbc.tunnel.RestrictedGuacamoleTunnelService;
private final JDBCEnvironment environment;
JDBCEnvironment environment) {
bind(JDBCEnvironment.class).toInstance(environment);
bind(GuacamoleTunnelService.class).to(RestrictedGuacamoleTunnelService.class);
import org.glyptodon.guacamole.auth.jdbc.JDBCEnvironment;
@Inject
private JDBCEnvironment environment;
public int getMaxConnections() throws GuacamoleException {
Integer value = getModel().getMaxConnections();
if (value == null)
return environment.getDefaultMaxConnections();
return value;
}
public int getMaxConnectionsPerUser() throws GuacamoleException {
Integer value = getModel().getMaxConnectionsPerUser();
if (value == null)
return environment.getDefaultMaxConnectionsPerUser();
return value;
}
import org.glyptodon.guacamole.auth.jdbc.JDBCEnvironment;
@Inject
private JDBCEnvironment environment;
public int getMaxConnections() throws GuacamoleException {
Integer value = getModel().getMaxConnections();
if (value == null)
return environment.getDefaultMaxGroupConnections();
return value;
}
public int getMaxConnectionsPerUser() throws GuacamoleException {
Integer value = getModel().getMaxConnectionsPerUser();
if (value == null)
return environment.getDefaultMaxGroupConnectionsPerUser();
return value;
}
import org.glyptodon.guacamole.auth.jdbc.JDBCEnvironment;
private JDBCEnvironment environment;
public class RestrictedGuacamoleTunnelService
if (tryAdd(activeSeats, seat,
connection.getMaxConnectionsPerUser())) {
connection.getMaxConnections()))
connectionGroup.getMaxConnectionsPerUser())) {
connectionGroup.getMaxConnections()))
MySQLEnvironment environment = new MySQLEnvironment();
new JDBCAuthenticationProviderModule(this, environment)
public MySQLAuthenticationProviderModule(MySQLEnvironment environment)
myBatisProperties.setProperty("JDBC.host", environment.getMySQLHostname());
myBatisProperties.setProperty("JDBC.port", String.valueOf(environment.getMySQLPort()));
myBatisProperties.setProperty("JDBC.schema", environment.getMySQLDatabase());
myBatisProperties.setProperty("JDBC.username", environment.getMySQLUsername());
myBatisProperties.setProperty("JDBC.password", environment.getMySQLPassword());
import org.glyptodon.guacamole.auth.jdbc.JDBCEnvironment;
PostgreSQLEnvironment environment = new PostgreSQLEnvironment();
new JDBCAuthenticationProviderModule(this, environment)
public PostgreSQLAuthenticationProviderModule(PostgreSQLEnvironment environment)
myBatisProperties.setProperty("JDBC.host", environment.getPostgreSQLHostname());
myBatisProperties.setProperty("JDBC.port", String.valueOf(environment.getPostgreSQLPort()));
myBatisProperties.setProperty("JDBC.schema", environment.getPostgreSQLDatabase());
myBatisProperties.setProperty("JDBC.username", environment.getPostgreSQLUsername());
myBatisProperties.setProperty("JDBC.password", environment.getPostgreSQLPassword());
START_DATE
startDate(ConnectionRecordSet.SortableProperty.START_DATE);
private static final int MAXIMUM_HISTORY_SIZE = 1000;
START_DATE
startDate(ConnectionRecordSet.SortableProperty.START_DATE);
private static final int MAXIMUM_HISTORY_SIZE = 1000;
if (user.getUser().isAdministrator())
return records;
if (user.getUser().isAdministrator())
return records;
getEncryptionMethod().DEFAULT_PORT
public EncryptionMethod getEncryptionMethod() throws GuacamoleException {
return environment.getProperty(
LDAPGuacamoleProperties.LDAP_ENCRYPTION_METHOD,
EncryptionMethod.NONE
);
}
public static final EncryptionMethodProperty LDAP_ENCRYPTION_METHOD = new EncryptionMethodProperty() {
@Override
public String getName() { return "ldap-encryption-method"; }
};
import com.novell.ldap.LDAPJSSESecureSocketFactory;
import com.novell.ldap.LDAPJSSEStartTLSFactory;
import org.glyptodon.guacamole.GuacamoleUnsupportedException;
private LDAPConnection createLDAPConnection() throws GuacamoleException {
EncryptionMethod encryptionMethod = confService.getEncryptionMethod();
switch (encryptionMethod) {
case NONE:
logger.debug("Connection to LDAP server without encryption.");
return new LDAPConnection();
case SSL:
logger.debug("Connecting to LDAP server using SSL/TLS.");
return new LDAPConnection(new LDAPJSSESecureSocketFactory());
case STARTTLS:
logger.debug("Connecting to LDAP server using STARTTLS.");
return new LDAPConnection(new LDAPJSSEStartTLSFactory());
default:
}
}
LDAPConnection ldapConnection = createLDAPConnection();
if (confService.getEncryptionMethod() == EncryptionMethod.STARTTLS)
ldapConnection.startTLS();
getEncryptionMethod().DEFAULT_PORT
public EncryptionMethod getEncryptionMethod() throws GuacamoleException {
return environment.getProperty(
LDAPGuacamoleProperties.LDAP_ENCRYPTION_METHOD,
EncryptionMethod.NONE
);
}
import com.novell.ldap.LDAPJSSESecureSocketFactory;
import com.novell.ldap.LDAPJSSEStartTLSFactory;
import org.glyptodon.guacamole.GuacamoleUnsupportedException;
private LDAPConnection createLDAPConnection() throws GuacamoleException {
EncryptionMethod encryptionMethod = confService.getEncryptionMethod();
switch (encryptionMethod) {
case NONE:
logger.debug("Connection to LDAP server without encryption.");
return new LDAPConnection();
case SSL:
logger.debug("Connecting to LDAP server using SSL/TLS.");
return new LDAPConnection(new LDAPJSSESecureSocketFactory());
case STARTTLS:
logger.debug("Connecting to LDAP server using STARTTLS.");
return new LDAPConnection(new LDAPJSSEStartTLSFactory());
default:
}
}
LDAPConnection ldapConnection = createLDAPConnection();
if (confService.getEncryptionMethod() == EncryptionMethod.STARTTLS)
ldapConnection.startTLS();
public static final EncryptionMethodProperty LDAP_ENCRYPTION_METHOD = new EncryptionMethodProperty() {
@Override
public String getName() { return "ldap-encryption-method"; }
};
public APIConnection createConnection(@QueryParam("token") String authToken,
return connection;
public APIConnectionGroup createConnectionGroup(
@QueryParam("token") String authToken,
return connectionGroup;
public APIUser createUser(@QueryParam("token") String authToken,
return user;
import org.glyptodon.guacamole.net.auth.Identifiable;
ExternalType extends Identifiable, ModelType extends ObjectModel>
object.setIdentifier(model.getIdentifier());
import org.glyptodon.guacamole.net.auth.Identifiable;
ExternalType extends Identifiable, ModelType extends GroupedObjectModel>
public interface Directory<ObjectType extends Identifiable> {
import org.glyptodon.guacamole.net.auth.Identifiable;
public class SimpleDirectory<ObjectType extends Identifiable>
implements Directory<ObjectType> {
import org.glyptodon.guacamole.net.auth.Identifiable;
ExternalType extends Identifiable, ModelType extends ObjectModel>
object.setIdentifier(model.getIdentifier());
import org.glyptodon.guacamole.net.auth.Identifiable;
ExternalType extends Identifiable, ModelType extends GroupedObjectModel>
public interface Directory<ObjectType extends Identifiable> {
import org.glyptodon.guacamole.net.auth.Identifiable;
public class SimpleDirectory<ObjectType extends Identifiable>
implements Directory<ObjectType> {
public APIConnection createConnection(@QueryParam("token") String authToken,
return connection;
public APIConnectionGroup createConnectionGroup(
@QueryParam("token") String authToken,
return connectionGroup;
public APIUser createUser(@QueryParam("token") String authToken,
return user;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
private final Logger logger = LoggerFactory.getLogger(GuacamoleHTTPTunnelServlet.class);
private final ConcurrentMap<String, GuacamoleTunnel> tunnels =
new ConcurrentHashMap<String, GuacamoleTunnel>();
protected void registerTunnel(GuacamoleTunnel tunnel) {
tunnels.put(tunnel.getUUID().toString(), tunnel);
logger.debug("Registered tunnel \"{}\".", tunnel.getUUID());
}
protected void deregisterTunnel(GuacamoleTunnel tunnel) {
tunnels.remove(tunnel.getUUID().toString());
logger.debug("Deregistered tunnel \"{}\".", tunnel.getUUID());
}
protected GuacamoleTunnel getTunnel(String tunnelUUID)
throws GuacamoleException {
GuacamoleTunnel tunnel = tunnels.get(tunnelUUID);
if (tunnel == null)
throw new GuacamoleResourceNotFoundException("No such tunnel.");
return tunnel;
}
protected void sendError(HttpServletResponse response,
GuacamoleStatus guacStatus, String message)
response.addHeader("Guacamole-Status-Code", Integer.toString(guacStatus.getGuacamoleStatusCode()));
response.sendError(guacStatus.getHttpStatusCode());
protected void handleTunnelRequest(HttpServletRequest request,
HttpServletResponse response) throws ServletException {
registerTunnel(tunnel);
protected abstract GuacamoleTunnel doConnect(HttpServletRequest request)
throws GuacamoleException;
protected void doRead(HttpServletRequest request,
HttpServletResponse response, String tunnelUUID)
throws GuacamoleException {
GuacamoleTunnel tunnel = getTunnel(tunnelUUID);
deregisterTunnel(tunnel);
deregisterTunnel(tunnel);
deregisterTunnel(tunnel);
deregisterTunnel(tunnel);
protected void doWrite(HttpServletRequest request,
HttpServletResponse response, String tunnelUUID)
throws GuacamoleException {
GuacamoleTunnel tunnel = getTunnel(tunnelUUID);
deregisterTunnel(tunnel);
@Deprecated
private final Logger logger = LoggerFactory.getLogger(GuacamoleSession.class);
public GuacamoleSession(HttpSession session) {
logger.warn("GuacamoleSession is deprecated. It is no longer "
"necessary and its use will have no effect.");
return null;
private final GuacamoleHTTPTunnelMap tunnels = new GuacamoleHTTPTunnelMap();
@Override
public void destroy() {
tunnels.shutdown();
}
private final Logger logger = LoggerFactory.getLogger(GuacamoleHTTPTunnelServlet.class);
private final GuacamoleHTTPTunnelMap tunnels = new GuacamoleHTTPTunnelMap();
protected void registerTunnel(GuacamoleTunnel tunnel) {
tunnels.put(tunnel.getUUID().toString(), tunnel);
logger.debug("Registered tunnel \"{}\".", tunnel.getUUID());
}
protected void deregisterTunnel(GuacamoleTunnel tunnel) {
tunnels.remove(tunnel.getUUID().toString());
logger.debug("Deregistered tunnel \"{}\".", tunnel.getUUID());
}
protected GuacamoleTunnel getTunnel(String tunnelUUID)
throws GuacamoleException {
GuacamoleTunnel tunnel = tunnels.get(tunnelUUID);
if (tunnel == null)
throw new GuacamoleResourceNotFoundException("No such tunnel.");
return tunnel;
}
protected void sendError(HttpServletResponse response,
GuacamoleStatus guacStatus, String message)
response.addHeader("Guacamole-Status-Code", Integer.toString(guacStatus.getGuacamoleStatusCode()));
response.sendError(guacStatus.getHttpStatusCode());
protected void handleTunnelRequest(HttpServletRequest request,
HttpServletResponse response) throws ServletException {
registerTunnel(tunnel);
protected abstract GuacamoleTunnel doConnect(HttpServletRequest request)
throws GuacamoleException;
protected void doRead(HttpServletRequest request,
HttpServletResponse response, String tunnelUUID)
throws GuacamoleException {
GuacamoleTunnel tunnel = getTunnel(tunnelUUID);
deregisterTunnel(tunnel);
deregisterTunnel(tunnel);
deregisterTunnel(tunnel);
deregisterTunnel(tunnel);
protected void doWrite(HttpServletRequest request,
HttpServletResponse response, String tunnelUUID)
throws GuacamoleException {
GuacamoleTunnel tunnel = getTunnel(tunnelUUID);
deregisterTunnel(tunnel);
@Override
public void destroy() {
tunnels.shutdown();
}
@Deprecated
private final Logger logger = LoggerFactory.getLogger(GuacamoleSession.class);
public GuacamoleSession(HttpSession session) {
logger.warn("GuacamoleSession is deprecated. It is no longer "
"necessary and its use will have no effect.");
return null;
if (tunnel == null)
return;
import org.glyptodon.guacamole.net.basic.TunnelRequest;
private static final String TUNNEL_REQUEST_PROPERTY = "WS_GUAC_TUNNEL_REQUEST";
private static final String TUNNEL_REQUEST_SERVICE_PROPERTY = "WS_GUAC_TUNNEL_REQUEST_SERVICE";
public void modifyHandshake(ServerEndpointConfig config,
HandshakeRequest request, HandshakeResponse response) {
userProperties.put(TUNNEL_REQUEST_PROPERTY, new WebSocketTunnelRequest(request));
userProperties.put(TUNNEL_REQUEST_SERVICE_PROPERTY, tunnelRequestServiceProvider.get());
protected GuacamoleTunnel createTunnel(Session session,
EndpointConfig config) throws GuacamoleException {
TunnelRequest tunnelRequest = (TunnelRequest) userProperties.get(TUNNEL_REQUEST_PROPERTY);
if (tunnelRequest == null)
return null;
TunnelRequestService tunnelRequestService = (TunnelRequestService) userProperties.get(TUNNEL_REQUEST_SERVICE_PROPERTY);
if (tunnelRequestService == null)
return null;
return tunnelRequestService.createTunnel(tunnelRequest);
public WebSocket doWebSocketConnect(final HttpServletRequest request, String protocol) {
private GuacamoleTunnel tunnel = null;
if (tunnel == null)
return;
try {
tunnel = doConnect(request);
}
catch (GuacamoleException e) {
logger.error("Creation of WebSocket tunnel to guacd failed: {}", e.getMessage());
logger.debug("Error connecting WebSocket tunnel.", e);
closeConnection(connection, e.getStatus());
return;
}
if (tunnel == null)
return;
public StreamInbound createWebSocketInbound(String protocol,
final HttpServletRequest request) {
private GuacamoleTunnel tunnel = null;
if (tunnel == null)
return;
try {
tunnel = doConnect(request);
}
catch (GuacamoleException e) {
logger.error("Creation of WebSocket tunnel to guacd failed: {}", e.getMessage());
logger.debug("Error connecting WebSocket tunnel.", e);
closeConnection(outbound, e.getStatus());
return;
}
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
private final Map<String, List<String>> parameterMap =
new HashMap<String, List<String>>();
for (Map.Entry<String, String[]> mapEntry : ((Map<String, String[]>)
request.getParameterMap()).entrySet()) {
String parameterName = mapEntry.getKey();
List<String> parameterValues = Arrays.asList(mapEntry.getValue());
parameterMap.put(
parameterName,
new ArrayList<String>(parameterValues)
);
}
List<String> values = getParameterValues(name);
if (values != null && !values.isEmpty())
return values.get(0);
return null;
return parameterMap.get(name);
import org.glyptodon.guacamole.net.basic.TunnelRequest;
protected GuacamoleTunnel doConnect(TunnelRequest request)
return tunnelRequestService.createTunnel(request);
import org.glyptodon.guacamole.net.basic.HTTPTunnelRequest;
import org.glyptodon.guacamole.net.basic.TunnelRequest;
public WebSocket doWebSocketConnect(HttpServletRequest request, String protocol) {
final TunnelRequest tunnelRequest = new HTTPTunnelRequest(request);
tunnel = doConnect(tunnelRequest);
protected abstract GuacamoleTunnel doConnect(TunnelRequest request)
import org.glyptodon.guacamole.net.basic.TunnelRequest;
protected GuacamoleTunnel doConnect(TunnelRequest request)
return tunnelRequestService.createTunnel(request);
import org.glyptodon.guacamole.net.basic.HTTPTunnelRequest;
import org.glyptodon.guacamole.net.basic.TunnelRequest;
HttpServletRequest request) {
final TunnelRequest tunnelRequest = new HTTPTunnelRequest(request);
tunnel = doConnect(tunnelRequest);
protected abstract GuacamoleTunnel doConnect(TunnelRequest request)
throws GuacamoleException;
if (tunnel == null)
return;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
private final Map<String, List<String>> parameterMap =
new HashMap<String, List<String>>();
for (Map.Entry<String, String[]> mapEntry : ((Map<String, String[]>)
request.getParameterMap()).entrySet()) {
String parameterName = mapEntry.getKey();
List<String> parameterValues = Arrays.asList(mapEntry.getValue());
parameterMap.put(
parameterName,
new ArrayList<String>(parameterValues)
);
}
List<String> values = getParameterValues(name);
if (values != null && !values.isEmpty())
return values.get(0);
return null;
return parameterMap.get(name);
import org.glyptodon.guacamole.net.basic.TunnelRequest;
private static final String TUNNEL_REQUEST_PROPERTY = "WS_GUAC_TUNNEL_REQUEST";
private static final String TUNNEL_REQUEST_SERVICE_PROPERTY = "WS_GUAC_TUNNEL_REQUEST_SERVICE";
public void modifyHandshake(ServerEndpointConfig config,
HandshakeRequest request, HandshakeResponse response) {
userProperties.put(TUNNEL_REQUEST_PROPERTY, new WebSocketTunnelRequest(request));
userProperties.put(TUNNEL_REQUEST_SERVICE_PROPERTY, tunnelRequestServiceProvider.get());
protected GuacamoleTunnel createTunnel(Session session,
EndpointConfig config) throws GuacamoleException {
TunnelRequest tunnelRequest = (TunnelRequest) userProperties.get(TUNNEL_REQUEST_PROPERTY);
if (tunnelRequest == null)
return null;
TunnelRequestService tunnelRequestService = (TunnelRequestService) userProperties.get(TUNNEL_REQUEST_SERVICE_PROPERTY);
if (tunnelRequestService == null)
return null;
return tunnelRequestService.createTunnel(tunnelRequest);
import org.glyptodon.guacamole.net.basic.TunnelRequest;
protected GuacamoleTunnel doConnect(TunnelRequest request)
return tunnelRequestService.createTunnel(request);
import org.glyptodon.guacamole.net.basic.HTTPTunnelRequest;
import org.glyptodon.guacamole.net.basic.TunnelRequest;
final TunnelRequest tunnelRequest = new HTTPTunnelRequest(request);
private GuacamoleTunnel tunnel = null;
if (tunnel == null)
return;
try {
tunnel = doConnect(tunnelRequest);
}
catch (GuacamoleException e) {
logger.error("Creation of WebSocket tunnel to guacd failed: {}", e.getMessage());
logger.debug("Error connecting WebSocket tunnel.", e);
closeConnection(connection, e.getStatus());
return;
}
protected abstract GuacamoleTunnel doConnect(TunnelRequest request)
if (tunnel == null)
return;
import org.glyptodon.guacamole.net.basic.TunnelRequest;
protected GuacamoleTunnel doConnect(TunnelRequest request)
return tunnelRequestService.createTunnel(request);
import org.glyptodon.guacamole.net.basic.HTTPTunnelRequest;
import org.glyptodon.guacamole.net.basic.TunnelRequest;
public StreamInbound createWebSocketInbound(String protocol,
HttpServletRequest request) {
final TunnelRequest tunnelRequest = new HTTPTunnelRequest(request);
private GuacamoleTunnel tunnel = null;
if (tunnel == null)
return;
try {
tunnel = doConnect(tunnelRequest);
}
catch (GuacamoleException e) {
logger.error("Creation of WebSocket tunnel to guacd failed: {}", e.getMessage());
logger.debug("Error connecting WebSocket tunnel.", e);
closeConnection(outbound, e.getStatus());
return;
}
protected abstract GuacamoleTunnel doConnect(TunnelRequest request)
throws GuacamoleException;
"0.9.9"
"0.9.9"
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
private final ConcurrentMap<String, GuacamoleHTTPTunnel> tunnelMap =
new ConcurrentHashMap<String, GuacamoleHTTPTunnel>();
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
private final ConcurrentMap<String, GuacamoleSession> sessionMap =
new ConcurrentHashMap<String, GuacamoleSession>();
long sessionCheckStart = System.currentTimeMillis();
long age = sessionCheckStart - session.getLastAccessedTime();
logger.debug("Session check completed in {} ms.",
System.currentTimeMillis() - sessionCheckStart);
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
private final ConcurrentMap<String, GuacamoleHTTPTunnel> tunnelMap =
new ConcurrentHashMap<String, GuacamoleHTTPTunnel>();
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
private final ConcurrentMap<String, GuacamoleSession> sessionMap =
new ConcurrentHashMap<String, GuacamoleSession>();
long sessionCheckStart = System.currentTimeMillis();
long age = sessionCheckStart - session.getLastAccessedTime();
logger.debug("Session check completed in {} ms.",
System.currentTimeMillis() - sessionCheckStart);
if (authToken == null)
return null;
if (authToken == null)
return null;
if (authToken == null)
return null;
if (authToken == null)
return null;
public String getGroupBaseDN() throws GuacamoleException {
return environment.getProperty(
LDAPGuacamoleProperties.LDAP_GROUP_BASE_DN
);
}
public static final StringGuacamoleProperty LDAP_GROUP_BASE_DN = new StringGuacamoleProperty() {
@Override
public String getName() { return "ldap-group-base-dn"; }
};
if (configurationBaseDN == null) {
}
String connectionSearchFilter = getConnectionSearchFilter(userDN, ldapConnection);
connectionSearchFilter,
} catch (LDAPException e) {
private String getConnectionSearchFilter(String userDN, LDAPConnection ldapConnection) throws LDAPException, GuacamoleException {
StringBuilder connectionSearchFilter = new StringBuilder();
connectionSearchFilter.append("(&(objectClass=guacConfigGroup)(|(member=");
connectionSearchFilter.append(escapingService.escapeLDAPSearchFilter(userDN));
connectionSearchFilter.append(")");
String groupBaseDN = confService.getGroupBaseDN();
if (groupBaseDN != null) {
LDAPSearchResults userRoleGroupResults = ldapConnection.search(
groupBaseDN,
LDAPConnection.SCOPE_SUB,
null,
false
);
while (userRoleGroupResults.hasMore()) {
LDAPEntry entry = userRoleGroupResults.next();
connectionSearchFilter.append("(seeAlso=").append(escapingService.escapeLDAPSearchFilter(entry.getDN())).append(")");
}
}
connectionSearchFilter.append("))");
return connectionSearchFilter.toString();
}
public String getGroupBaseDN() throws GuacamoleException {
return environment.getProperty(
LDAPGuacamoleProperties.LDAP_GROUP_BASE_DN
);
}
public static final StringGuacamoleProperty LDAP_GROUP_BASE_DN = new StringGuacamoleProperty() {
@Override
public String getName() { return "ldap-group-base-dn"; }
};
if (configurationBaseDN == null) {
}
String connectionSearchFilter = getConnectionSearchFilter(userDN, ldapConnection);
connectionSearchFilter,
} catch (LDAPException e) {
private String getConnectionSearchFilter(String userDN, LDAPConnection ldapConnection) throws LDAPException, GuacamoleException {
StringBuilder connectionSearchFilter = new StringBuilder();
connectionSearchFilter.append("(&(objectClass=guacConfigGroup)(|(member=");
connectionSearchFilter.append(escapingService.escapeLDAPSearchFilter(userDN));
connectionSearchFilter.append(")");
String groupBaseDN = confService.getGroupBaseDN();
if (groupBaseDN != null) {
LDAPSearchResults userRoleGroupResults = ldapConnection.search(
groupBaseDN,
LDAPConnection.SCOPE_SUB,
null,
false
);
while (userRoleGroupResults.hasMore()) {
LDAPEntry entry = userRoleGroupResults.next();
connectionSearchFilter.append("(seeAlso=").append(escapingService.escapeLDAPSearchFilter(entry.getDN())).append(")");
}
}
connectionSearchFilter.append("))");
return connectionSearchFilter.toString();
}
if (configurationBaseDN == null)
}
catch (LDAPException e) {
private String getConnectionSearchFilter(String userDN,
LDAPConnection ldapConnection)
throws LDAPException, GuacamoleException {
connectionSearchFilter.append("))");
public String getGroupBaseDN() throws GuacamoleException {
return environment.getProperty(
LDAPGuacamoleProperties.LDAP_GROUP_BASE_DN
);
}
public static final StringGuacamoleProperty LDAP_GROUP_BASE_DN = new StringGuacamoleProperty() {
@Override
public String getName() { return "ldap-group-base-dn"; }
};
String connectionSearchFilter = getConnectionSearchFilter(userDN, ldapConnection);
connectionSearchFilter,
private String getConnectionSearchFilter(String userDN,
LDAPConnection ldapConnection)
throws LDAPException, GuacamoleException {
StringBuilder connectionSearchFilter = new StringBuilder();
connectionSearchFilter.append("(&(objectClass=guacConfigGroup)(|(member=");
connectionSearchFilter.append(escapingService.escapeLDAPSearchFilter(userDN));
connectionSearchFilter.append(")");
String groupBaseDN = confService.getGroupBaseDN();
if (groupBaseDN != null) {
LDAPSearchResults userRoleGroupResults = ldapConnection.search(
groupBaseDN,
LDAPConnection.SCOPE_SUB,
null,
false
);
while (userRoleGroupResults.hasMore()) {
LDAPEntry entry = userRoleGroupResults.next();
connectionSearchFilter.append("(seeAlso=").append(escapingService.escapeLDAPSearchFilter(entry.getDN())).append(")");
}
}
connectionSearchFilter.append("))");
return connectionSearchFilter.toString();
}
import java.text.SimpleDateFormat;
import java.util.Date;
private static final String DATE_TOKEN = "GUAC_DATE";
private static final String TIME_TOKEN = "GUAC_TIME";
private static final String DATE_FORMAT = "yyyyMMdd";
private static final String TIME_FORMAT = "HHmmss";
Date currentTime = new Date();
filter.setToken(DATE_TOKEN, new SimpleDateFormat(DATE_FORMAT).format(currentTime));
filter.setToken(TIME_TOKEN, new SimpleDateFormat(TIME_FORMAT).format(currentTime));
public static void addStandardTokens(TokenFilter filter) {
Date currentTime = new Date();
filter.setToken(DATE_TOKEN, new SimpleDateFormat(DATE_FORMAT).format(currentTime));
filter.setToken(TIME_TOKEN, new SimpleDateFormat(TIME_FORMAT).format(currentTime));
}
addStandardTokens(filter);
public static final String USERNAME_TOKEN = "GUAC_USERNAME";
public static final String PASSWORD_TOKEN = "GUAC_PASSWORD";
public static final String DATE_TOKEN = "GUAC_DATE";
public static final String TIME_TOKEN = "GUAC_TIME";
import java.text.SimpleDateFormat;
import java.util.Date;
public static final String USERNAME_TOKEN = "GUAC_USERNAME";
public static final String PASSWORD_TOKEN = "GUAC_PASSWORD";
public static final String DATE_TOKEN = "GUAC_DATE";
public static final String TIME_TOKEN = "GUAC_TIME";
private static final String DATE_FORMAT = "yyyyMMdd";
private static final String TIME_FORMAT = "HHmmss";
public static void addStandardTokens(TokenFilter filter) {
Date currentTime = new Date();
filter.setToken(DATE_TOKEN, new SimpleDateFormat(DATE_FORMAT).format(currentTime));
filter.setToken(TIME_TOKEN, new SimpleDateFormat(TIME_FORMAT).format(currentTime));
}
addStandardTokens(filter);
private final Map<String, Resource> htmlResources;
htmlResources = getClassPathResources("text/html", manifest.getHTMLPaths());
public Map<String, Resource> getHTMLResources() {
return htmlResources;
}
private Collection<String> htmlPaths;
@JsonProperty("html")
public Collection<String> getHTMLPaths() {
return htmlPaths;
}
@JsonProperty("html")
public void setHTMLPaths(Collection<String> htmlPatchPaths) {
this.htmlPaths = htmlPatchPaths;
}
private final PatchResourceService patchResourceService;
this.patchResourceService = new PatchResourceService();
patchResourceService.addPatchResources(extension.getHTMLResources().values());
bind(PatchResourceService.class).toInstance(patchResourceService);
import org.glyptodon.guacamole.net.basic.rest.patch.PatchRESTService;
bind(PatchRESTService.class);
private final Map<String, Resource> htmlResources;
htmlResources = getClassPathResources("text/html", manifest.getHTMLPaths());
public Map<String, Resource> getHTMLResources() {
return htmlResources;
}
private Collection<String> htmlPaths;
@JsonProperty("html")
public Collection<String> getHTMLPaths() {
return htmlPaths;
}
@JsonProperty("html")
public void setHTMLPaths(Collection<String> htmlPatchPaths) {
this.htmlPaths = htmlPatchPaths;
}
private final PatchResourceService patchResourceService;
this.patchResourceService = new PatchResourceService();
patchResourceService.addPatchResources(extension.getHTMLResources().values());
bind(PatchResourceService.class).toInstance(patchResourceService);
import org.glyptodon.guacamole.net.basic.rest.patch.PatchRESTService;
bind(PatchRESTService.class);
try {
char buffer[] = new char[8192];
int length;
while ((length = reader.read(buffer)) != -1) {
contents.append(buffer, 0, length);
}
}
finally {
reader.close();
try {
char buffer[] = new char[8192];
int length;
while ((length = reader.read(buffer)) != -1) {
contents.append(buffer, 0, length);
}
}
finally {
reader.close();
public abstract int getAbsoluteMaxConnections() throws GuacamoleException;
import com.google.inject.Inject;
import java.util.concurrent.atomic.AtomicInteger;
import org.glyptodon.guacamole.auth.jdbc.JDBCEnvironment;
@Inject
private JDBCEnvironment environment;
private final AtomicInteger totalActiveConnections = new AtomicInteger(0);
private boolean tryIncrement(AtomicInteger counter, int max) {
while (true) {
int count = counter.get();
if (count >= max && max != 0)
return false;
return true;
}
}
if (!tryIncrement(totalActiveConnections, environment.getAbsoluteMaxConnections()))
throw new GuacamoleResourceConflictException("Cannot connect. Overall maximum connections reached.");
totalActiveConnections.decrementAndGet();
totalActiveConnections.decrementAndGet();
private final int ABSOLUTE_MAX_CONNECTIONS = 0;
public int getAbsoluteMaxConnections() throws GuacamoleException {
return getProperty(MySQLGuacamoleProperties.MYSQL_ABSOLUTE_MAX_CONNECTIONS,
ABSOLUTE_MAX_CONNECTIONS
);
}
@Override
public static final IntegerGuacamoleProperty
MYSQL_ABSOLUTE_MAX_CONNECTIONS =
new IntegerGuacamoleProperty() {
@Override
public String getName() { return "mysql-absolute-max-connections"; }
};
private final int ABSOLUTE_MAX_CONNECTIONS = 0;
public int getAbsoluteMaxConnections() throws GuacamoleException {
return getProperty(PostgreSQLGuacamoleProperties.POSTGRESQL_ABSOLUTE_MAX_CONNECTIONS,
ABSOLUTE_MAX_CONNECTIONS
);
}
@Override
public static final IntegerGuacamoleProperty
POSTGRESQL_ABSOLUTE_MAX_CONNECTIONS =
new IntegerGuacamoleProperty() {
@Override
public String getName() { return "postgresql-absolute-max-connections"; }
};
private final int DEFAULT_ABSOLUTE_MAX_CONNECTIONS = 0;
DEFAULT_ABSOLUTE_MAX_CONNECTIONS
private final int DEFAULT_ABSOLUTE_MAX_CONNECTIONS = 0;
DEFAULT_ABSOLUTE_MAX_CONNECTIONS
public abstract int getAbsoluteMaxConnections() throws GuacamoleException;
import com.google.inject.Inject;
import java.util.concurrent.atomic.AtomicInteger;
import org.glyptodon.guacamole.auth.jdbc.JDBCEnvironment;
@Inject
private JDBCEnvironment environment;
private final AtomicInteger totalActiveConnections = new AtomicInteger(0);
private boolean tryIncrement(AtomicInteger counter, int max) {
while (true) {
int count = counter.get();
if (count >= max && max != 0)
return false;
return true;
}
}
if (!tryIncrement(totalActiveConnections, environment.getAbsoluteMaxConnections()))
throw new GuacamoleResourceConflictException("Cannot connect. Overall maximum connections reached.");
totalActiveConnections.decrementAndGet();
totalActiveConnections.decrementAndGet();
private final int DEFAULT_ABSOLUTE_MAX_CONNECTIONS = 0;
public int getAbsoluteMaxConnections() throws GuacamoleException {
return getProperty(MySQLGuacamoleProperties.MYSQL_ABSOLUTE_MAX_CONNECTIONS,
DEFAULT_ABSOLUTE_MAX_CONNECTIONS
);
}
@Override
public static final IntegerGuacamoleProperty
MYSQL_ABSOLUTE_MAX_CONNECTIONS =
new IntegerGuacamoleProperty() {
@Override
public String getName() { return "mysql-absolute-max-connections"; }
};
private final int DEFAULT_ABSOLUTE_MAX_CONNECTIONS = 0;
public int getAbsoluteMaxConnections() throws GuacamoleException {
return getProperty(PostgreSQLGuacamoleProperties.POSTGRESQL_ABSOLUTE_MAX_CONNECTIONS,
DEFAULT_ABSOLUTE_MAX_CONNECTIONS
);
}
@Override
public static final IntegerGuacamoleProperty
POSTGRESQL_ABSOLUTE_MAX_CONNECTIONS =
new IntegerGuacamoleProperty() {
@Override
public String getName() { return "postgresql-absolute-max-connections"; }
};
package org.apache.guacamole.net.example;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.GuacamoleSocket;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.net.InetGuacamoleSocket;
import org.apache.guacamole.net.SimpleGuacamoleTunnel;
import org.apache.guacamole.protocol.ConfiguredGuacamoleSocket;
import org.apache.guacamole.protocol.GuacamoleConfiguration;
import org.apache.guacamole.servlet.GuacamoleHTTPTunnelServlet;
package org.apache.guacamole.auth.jdbc;
import org.apache.guacamole.auth.jdbc.user.UserContext;
import org.apache.guacamole.auth.jdbc.connectiongroup.RootConnectionGroup;
import org.apache.guacamole.auth.jdbc.connectiongroup.ModeledConnectionGroup;
import org.apache.guacamole.auth.jdbc.connectiongroup.ConnectionGroupDirectory;
import org.apache.guacamole.auth.jdbc.connection.ConnectionDirectory;
import org.apache.guacamole.auth.jdbc.connection.ModeledGuacamoleConfiguration;
import org.apache.guacamole.auth.jdbc.connection.ModeledConnection;
import org.apache.guacamole.auth.jdbc.permission.SystemPermissionSet;
import org.apache.guacamole.auth.jdbc.user.ModeledUser;
import org.apache.guacamole.auth.jdbc.user.UserDirectory;
import org.apache.guacamole.auth.jdbc.connectiongroup.ConnectionGroupMapper;
import org.apache.guacamole.auth.jdbc.connection.ConnectionMapper;
import org.apache.guacamole.auth.jdbc.connection.ConnectionRecordMapper;
import org.apache.guacamole.auth.jdbc.connection.ParameterMapper;
import org.apache.guacamole.auth.jdbc.permission.SystemPermissionMapper;
import org.apache.guacamole.auth.jdbc.user.UserMapper;
import org.apache.guacamole.auth.jdbc.connectiongroup.ConnectionGroupService;
import org.apache.guacamole.auth.jdbc.connection.ConnectionService;
import org.apache.guacamole.auth.jdbc.tunnel.GuacamoleTunnelService;
import org.apache.guacamole.auth.jdbc.security.PasswordEncryptionService;
import org.apache.guacamole.auth.jdbc.security.SHA256PasswordEncryptionService;
import org.apache.guacamole.auth.jdbc.security.SaltService;
import org.apache.guacamole.auth.jdbc.security.SecureRandomSaltService;
import org.apache.guacamole.auth.jdbc.permission.SystemPermissionService;
import org.apache.guacamole.auth.jdbc.user.UserService;
import org.apache.guacamole.auth.jdbc.permission.ConnectionGroupPermissionMapper;
import org.apache.guacamole.auth.jdbc.permission.ConnectionGroupPermissionService;
import org.apache.guacamole.auth.jdbc.permission.ConnectionGroupPermissionSet;
import org.apache.guacamole.auth.jdbc.permission.ConnectionPermissionMapper;
import org.apache.guacamole.auth.jdbc.permission.ConnectionPermissionService;
import org.apache.guacamole.auth.jdbc.permission.ConnectionPermissionSet;
import org.apache.guacamole.auth.jdbc.permission.UserPermissionMapper;
import org.apache.guacamole.auth.jdbc.permission.UserPermissionService;
import org.apache.guacamole.auth.jdbc.permission.UserPermissionSet;
import org.apache.guacamole.auth.jdbc.activeconnection.ActiveConnectionDirectory;
import org.apache.guacamole.auth.jdbc.activeconnection.ActiveConnectionPermissionService;
import org.apache.guacamole.auth.jdbc.activeconnection.ActiveConnectionPermissionSet;
import org.apache.guacamole.auth.jdbc.activeconnection.ActiveConnectionService;
import org.apache.guacamole.auth.jdbc.activeconnection.TrackedActiveConnection;
import org.apache.guacamole.auth.jdbc.tunnel.RestrictedGuacamoleTunnelService;
import org.apache.guacamole.net.auth.AuthenticationProvider;
package org.apache.guacamole.auth.jdbc;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.environment.LocalEnvironment;
package org.apache.guacamole.auth.jdbc.activeconnection;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.auth.jdbc.base.RestrictedObject;
import org.apache.guacamole.net.auth.ActiveConnection;
import org.apache.guacamole.net.auth.Directory;
package org.apache.guacamole.auth.jdbc.activeconnection;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleSecurityException;
import org.apache.guacamole.auth.jdbc.permission.AbstractPermissionService;
import org.apache.guacamole.auth.jdbc.permission.ObjectPermissionService;
import org.apache.guacamole.auth.jdbc.tunnel.ActiveConnectionRecord;
import org.apache.guacamole.auth.jdbc.tunnel.GuacamoleTunnelService;
import org.apache.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.apache.guacamole.auth.jdbc.user.ModeledUser;
import org.apache.guacamole.net.auth.permission.ObjectPermission;
import org.apache.guacamole.net.auth.permission.ObjectPermissionSet;
package org.apache.guacamole.auth.jdbc.activeconnection;
import org.apache.guacamole.auth.jdbc.permission.ObjectPermissionService;
import org.apache.guacamole.auth.jdbc.permission.ObjectPermissionSet;
package org.apache.guacamole.auth.jdbc.activeconnection;
import org.apache.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleSecurityException;
import org.apache.guacamole.auth.jdbc.base.DirectoryObjectService;
import org.apache.guacamole.auth.jdbc.tunnel.ActiveConnectionRecord;
import org.apache.guacamole.auth.jdbc.tunnel.GuacamoleTunnelService;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.net.auth.ActiveConnection;
package org.apache.guacamole.auth.jdbc.activeconnection;
import org.apache.guacamole.auth.jdbc.base.RestrictedObject;
import org.apache.guacamole.auth.jdbc.tunnel.ActiveConnectionRecord;
import org.apache.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.net.auth.ActiveConnection;
package org.apache.guacamole.auth.jdbc.activeconnection;
package org.apache.guacamole.auth.jdbc.base;
import org.apache.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.apache.guacamole.GuacamoleException;
package org.apache.guacamole.auth.jdbc.base;
package org.apache.guacamole.auth.jdbc.base;
import org.apache.guacamole.net.auth.Identifiable;
package org.apache.guacamole.auth.jdbc.base;
import org.apache.guacamole.auth.jdbc.user.UserModel;
package org.apache.guacamole.auth.jdbc.base;
import org.apache.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleSecurityException;
import org.apache.guacamole.auth.jdbc.permission.ObjectPermissionMapper;
import org.apache.guacamole.auth.jdbc.permission.ObjectPermissionModel;
import org.apache.guacamole.auth.jdbc.user.UserModel;
import org.apache.guacamole.net.auth.Identifiable;
import org.apache.guacamole.net.auth.permission.ObjectPermission;
import org.apache.guacamole.net.auth.permission.ObjectPermissionSet;
package org.apache.guacamole.auth.jdbc.base;
import org.apache.guacamole.auth.jdbc.connectiongroup.RootConnectionGroup;
package org.apache.guacamole.auth.jdbc.base;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleSecurityException;
import org.apache.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.apache.guacamole.net.auth.Identifiable;
import org.apache.guacamole.net.auth.permission.ObjectPermission;
import org.apache.guacamole.net.auth.permission.ObjectPermissionSet;
package org.apache.guacamole.auth.jdbc.base;
import org.apache.guacamole.auth.jdbc.user.AuthenticatedUser;
package org.apache.guacamole.auth.jdbc.base;
package org.apache.guacamole.auth.jdbc.base;
import org.apache.guacamole.auth.jdbc.user.AuthenticatedUser;
package org.apache.guacamole.auth.jdbc.base;
package org.apache.guacamole.auth.jdbc.connection;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.auth.jdbc.base.RestrictedObject;
import org.apache.guacamole.net.auth.Connection;
import org.apache.guacamole.net.auth.Directory;
package org.apache.guacamole.auth.jdbc.connection;
import org.apache.guacamole.auth.jdbc.base.ModeledDirectoryObjectMapper;
import org.apache.guacamole.auth.jdbc.user.UserModel;
package org.apache.guacamole.auth.jdbc.connection;
import org.apache.guacamole.auth.jdbc.base.GroupedObjectModel;
package org.apache.guacamole.auth.jdbc.connection;
import org.apache.guacamole.auth.jdbc.user.UserModel;
package org.apache.guacamole.auth.jdbc.connection;
package org.apache.guacamole.auth.jdbc.connection;
package org.apache.guacamole.auth.jdbc.connection;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.auth.jdbc.base.RestrictedObject;
import org.apache.guacamole.net.auth.ConnectionRecord;
implements org.apache.guacamole.net.auth.ConnectionRecordSet {
package org.apache.guacamole.auth.jdbc.connection;
import org.apache.guacamole.net.auth.ConnectionRecordSet;
package org.apache.guacamole.auth.jdbc.connection;
import org.apache.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.apache.guacamole.auth.jdbc.base.ModeledDirectoryObjectMapper;
import org.apache.guacamole.auth.jdbc.tunnel.GuacamoleTunnelService;
import org.apache.guacamole.GuacamoleClientException;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleSecurityException;
import org.apache.guacamole.auth.jdbc.base.ModeledGroupedDirectoryObjectService;
import org.apache.guacamole.auth.jdbc.permission.ConnectionPermissionMapper;
import org.apache.guacamole.auth.jdbc.permission.ObjectPermissionMapper;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.net.auth.Connection;
import org.apache.guacamole.net.auth.ConnectionRecord;
import org.apache.guacamole.net.auth.permission.ObjectPermission;
import org.apache.guacamole.net.auth.permission.ObjectPermissionSet;
import org.apache.guacamole.net.auth.permission.SystemPermission;
import org.apache.guacamole.net.auth.permission.SystemPermissionSet;
import org.apache.guacamole.protocol.GuacamoleClientInformation;
package org.apache.guacamole.auth.jdbc.connection;
import org.apache.guacamole.auth.jdbc.tunnel.GuacamoleTunnelService;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.auth.jdbc.JDBCEnvironment;
import org.apache.guacamole.auth.jdbc.base.ModeledGroupedDirectoryObject;
import org.apache.guacamole.form.Field;
import org.apache.guacamole.form.Form;
import org.apache.guacamole.form.NumericField;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.net.auth.Connection;
import org.apache.guacamole.net.auth.ConnectionRecord;
import org.apache.guacamole.protocol.GuacamoleClientInformation;
import org.apache.guacamole.protocol.GuacamoleConfiguration;
package org.apache.guacamole.auth.jdbc.connection;
import org.apache.guacamole.net.auth.ConnectionRecord;
package org.apache.guacamole.auth.jdbc.connection;
import org.apache.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.apache.guacamole.protocol.GuacamoleConfiguration;
package org.apache.guacamole.auth.jdbc.connection;
package org.apache.guacamole.auth.jdbc.connection;
package org.apache.guacamole.auth.jdbc.connection;
package org.apache.guacamole.auth.jdbc.connectiongroup;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.auth.jdbc.base.RestrictedObject;
import org.apache.guacamole.net.auth.ConnectionGroup;
import org.apache.guacamole.net.auth.Directory;
package org.apache.guacamole.auth.jdbc.connectiongroup;
import org.apache.guacamole.auth.jdbc.base.ModeledDirectoryObjectMapper;
import org.apache.guacamole.auth.jdbc.user.UserModel;
package org.apache.guacamole.auth.jdbc.connectiongroup;
import org.apache.guacamole.auth.jdbc.base.GroupedObjectModel;
import org.apache.guacamole.net.auth.ConnectionGroup;
package org.apache.guacamole.auth.jdbc.connectiongroup;
import org.apache.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.apache.guacamole.auth.jdbc.base.ModeledDirectoryObjectMapper;
import org.apache.guacamole.auth.jdbc.tunnel.GuacamoleTunnelService;
import org.apache.guacamole.GuacamoleClientException;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleSecurityException;
import org.apache.guacamole.GuacamoleUnsupportedException;
import org.apache.guacamole.auth.jdbc.base.ModeledGroupedDirectoryObjectService;
import org.apache.guacamole.auth.jdbc.permission.ConnectionGroupPermissionMapper;
import org.apache.guacamole.auth.jdbc.permission.ObjectPermissionMapper;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.net.auth.ConnectionGroup;
import org.apache.guacamole.net.auth.permission.ObjectPermission;
import org.apache.guacamole.net.auth.permission.ObjectPermissionSet;
import org.apache.guacamole.net.auth.permission.SystemPermission;
import org.apache.guacamole.net.auth.permission.SystemPermissionSet;
import org.apache.guacamole.protocol.GuacamoleClientInformation;
package org.apache.guacamole.auth.jdbc.connectiongroup;
import org.apache.guacamole.auth.jdbc.connection.ConnectionService;
import org.apache.guacamole.auth.jdbc.tunnel.GuacamoleTunnelService;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.auth.jdbc.JDBCEnvironment;
import org.apache.guacamole.auth.jdbc.base.ModeledGroupedDirectoryObject;
import org.apache.guacamole.form.Field;
import org.apache.guacamole.form.Form;
import org.apache.guacamole.form.NumericField;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.net.auth.ConnectionGroup;
import org.apache.guacamole.protocol.GuacamoleClientInformation;
package org.apache.guacamole.auth.jdbc.connectiongroup;
import org.apache.guacamole.auth.jdbc.connection.ConnectionService;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleSecurityException;
import org.apache.guacamole.auth.jdbc.base.RestrictedObject;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.net.auth.ConnectionGroup;
import org.apache.guacamole.protocol.GuacamoleClientInformation;
package org.apache.guacamole.auth.jdbc.connectiongroup;
package org.apache.guacamole.auth.jdbc;
package org.apache.guacamole.auth.jdbc.permission;
import org.apache.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.apache.guacamole.auth.jdbc.user.ModeledUser;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.auth.permission.ObjectPermission;
import org.apache.guacamole.net.auth.permission.ObjectPermissionSet;
import org.apache.guacamole.net.auth.permission.Permission;
import org.apache.guacamole.net.auth.permission.PermissionSet;
package org.apache.guacamole.auth.jdbc.permission;
package org.apache.guacamole.auth.jdbc.permission;
import org.apache.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.auth.jdbc.user.ModeledUser;
package org.apache.guacamole.auth.jdbc.permission;
package org.apache.guacamole.auth.jdbc.permission;
package org.apache.guacamole.auth.jdbc.permission;
import org.apache.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.auth.jdbc.user.ModeledUser;
package org.apache.guacamole.auth.jdbc.permission;
package org.apache.guacamole.auth.jdbc.permission;
import org.apache.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.apache.guacamole.auth.jdbc.user.ModeledUser;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleSecurityException;
import org.apache.guacamole.net.auth.permission.ObjectPermission;
import org.apache.guacamole.net.auth.permission.ObjectPermissionSet;
package org.apache.guacamole.auth.jdbc.permission;
import org.apache.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.apache.guacamole.auth.jdbc.user.ModeledUser;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleSecurityException;
import org.apache.guacamole.net.auth.permission.Permission;
import org.apache.guacamole.net.auth.permission.PermissionSet;
package org.apache.guacamole.auth.jdbc.permission;
import org.apache.guacamole.auth.jdbc.user.UserModel;
import org.apache.guacamole.net.auth.permission.ObjectPermission;
package org.apache.guacamole.auth.jdbc.permission;
import org.apache.guacamole.net.auth.permission.ObjectPermission;
package org.apache.guacamole.auth.jdbc.permission;
import org.apache.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.apache.guacamole.auth.jdbc.user.ModeledUser;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.auth.permission.ObjectPermission;
import org.apache.guacamole.net.auth.permission.ObjectPermissionSet;
package org.apache.guacamole.auth.jdbc.permission;
import org.apache.guacamole.auth.jdbc.user.ModeledUser;
import org.apache.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.auth.jdbc.base.RestrictedObject;
import org.apache.guacamole.net.auth.permission.ObjectPermission;
implements org.apache.guacamole.net.auth.permission.ObjectPermissionSet {
package org.apache.guacamole.auth.jdbc.permission;
import org.apache.guacamole.auth.jdbc.user.UserModel;
package org.apache.guacamole.auth.jdbc.permission;
package org.apache.guacamole.auth.jdbc.permission;
import org.apache.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.apache.guacamole.auth.jdbc.user.ModeledUser;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleSecurityException;
import org.apache.guacamole.net.auth.permission.ObjectPermission;
import org.apache.guacamole.net.auth.permission.ObjectPermissionSet;
import org.apache.guacamole.net.auth.permission.Permission;
import org.apache.guacamole.net.auth.permission.PermissionSet;
package org.apache.guacamole.auth.jdbc.permission;
import org.apache.guacamole.auth.jdbc.user.UserModel;
import org.apache.guacamole.net.auth.permission.SystemPermission;
package org.apache.guacamole.auth.jdbc.permission;
import org.apache.guacamole.net.auth.permission.SystemPermission;
package org.apache.guacamole.auth.jdbc.permission;
import org.apache.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.apache.guacamole.auth.jdbc.user.ModeledUser;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleSecurityException;
import org.apache.guacamole.GuacamoleUnsupportedException;
import org.apache.guacamole.net.auth.permission.SystemPermission;
package org.apache.guacamole.auth.jdbc.permission;
import org.apache.guacamole.auth.jdbc.user.ModeledUser;
import org.apache.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.auth.jdbc.base.RestrictedObject;
import org.apache.guacamole.net.auth.permission.SystemPermission;
implements org.apache.guacamole.net.auth.permission.SystemPermissionSet {
package org.apache.guacamole.auth.jdbc.permission;
package org.apache.guacamole.auth.jdbc.permission;
import org.apache.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.auth.jdbc.user.ModeledUser;
package org.apache.guacamole.auth.jdbc.permission;
package org.apache.guacamole.auth.jdbc.permission;
package org.apache.guacamole.auth.jdbc.security;
package org.apache.guacamole.auth.jdbc.security;
package org.apache.guacamole.auth.jdbc.security;
package org.apache.guacamole.auth.jdbc.security;
package org.apache.guacamole.auth.jdbc.security;
package org.apache.guacamole.auth.jdbc.tunnel;
import org.apache.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.apache.guacamole.auth.jdbc.connection.ModeledConnection;
import org.apache.guacamole.auth.jdbc.connectiongroup.ModeledConnectionGroup;
import org.apache.guacamole.auth.jdbc.connection.ConnectionRecordMapper;
import org.apache.guacamole.auth.jdbc.connection.ParameterMapper;
import org.apache.guacamole.auth.jdbc.connection.ConnectionModel;
import org.apache.guacamole.auth.jdbc.connection.ConnectionRecordModel;
import org.apache.guacamole.auth.jdbc.connection.ParameterModel;
import org.apache.guacamole.auth.jdbc.user.UserModel;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleSecurityException;
import org.apache.guacamole.auth.jdbc.JDBCEnvironment;
import org.apache.guacamole.auth.jdbc.connection.ConnectionMapper;
import org.apache.guacamole.environment.Environment;
import org.apache.guacamole.net.GuacamoleSocket;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.net.auth.Connection;
import org.apache.guacamole.net.auth.ConnectionGroup;
import org.apache.guacamole.protocol.ConfiguredGuacamoleSocket;
import org.apache.guacamole.protocol.GuacamoleClientInformation;
import org.apache.guacamole.protocol.GuacamoleConfiguration;
import org.apache.guacamole.token.StandardTokens;
import org.apache.guacamole.token.TokenFilter;
package org.apache.guacamole.auth.jdbc.tunnel;
package org.apache.guacamole.auth.jdbc.tunnel;
import org.apache.guacamole.auth.jdbc.connection.ModeledConnection;
import org.apache.guacamole.auth.jdbc.connectiongroup.ModeledConnectionGroup;
import org.apache.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.apache.guacamole.net.AbstractGuacamoleTunnel;
import org.apache.guacamole.net.GuacamoleSocket;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.net.auth.ConnectionRecord;
package org.apache.guacamole.auth.jdbc.tunnel;
import org.apache.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.apache.guacamole.auth.jdbc.connection.ModeledConnection;
import org.apache.guacamole.auth.jdbc.connectiongroup.ModeledConnectionGroup;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.net.auth.Connection;
import org.apache.guacamole.net.auth.ConnectionGroup;
import org.apache.guacamole.protocol.GuacamoleClientInformation;
package org.apache.guacamole.auth.jdbc.tunnel;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.InetGuacamoleSocket;
package org.apache.guacamole.auth.jdbc.tunnel;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.SSLGuacamoleSocket;
package org.apache.guacamole.auth.jdbc.tunnel;
import org.apache.guacamole.GuacamoleClientTooManyException;
import org.apache.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.apache.guacamole.auth.jdbc.connection.ModeledConnection;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleResourceConflictException;
import org.apache.guacamole.auth.jdbc.JDBCEnvironment;
import org.apache.guacamole.auth.jdbc.connectiongroup.ModeledConnectionGroup;
package org.apache.guacamole.auth.jdbc.tunnel;
package org.apache.guacamole.auth.jdbc.tunnel;
package org.apache.guacamole.auth.jdbc.user;
import org.apache.guacamole.net.auth.AuthenticationProvider;
import org.apache.guacamole.net.auth.Credentials;
public class AuthenticatedUser implements org.apache.guacamole.net.auth.AuthenticatedUser {
package org.apache.guacamole.auth.jdbc.user;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.auth.AuthenticationProvider;
import org.apache.guacamole.net.auth.Credentials;
import org.apache.guacamole.net.auth.credentials.CredentialsInfo;
import org.apache.guacamole.net.auth.credentials.GuacamoleInvalidCredentialsException;
public UserContext getUserContext(org.apache.guacamole.net.auth.AuthenticatedUser authenticatedUser)
package org.apache.guacamole.auth.jdbc.user;
import org.apache.guacamole.auth.jdbc.base.ModeledDirectoryObject;
import org.apache.guacamole.auth.jdbc.security.PasswordEncryptionService;
import org.apache.guacamole.auth.jdbc.security.SaltService;
import org.apache.guacamole.auth.jdbc.permission.SystemPermissionService;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.auth.jdbc.activeconnection.ActiveConnectionPermissionService;
import org.apache.guacamole.auth.jdbc.permission.ConnectionGroupPermissionService;
import org.apache.guacamole.auth.jdbc.permission.ConnectionPermissionService;
import org.apache.guacamole.auth.jdbc.permission.UserPermissionService;
import org.apache.guacamole.form.BooleanField;
import org.apache.guacamole.form.DateField;
import org.apache.guacamole.form.Field;
import org.apache.guacamole.form.Form;
import org.apache.guacamole.form.TimeField;
import org.apache.guacamole.form.TimeZoneField;
import org.apache.guacamole.net.auth.User;
import org.apache.guacamole.net.auth.permission.ObjectPermissionSet;
import org.apache.guacamole.net.auth.permission.SystemPermission;
import org.apache.guacamole.net.auth.permission.SystemPermissionSet;
package org.apache.guacamole.auth.jdbc.user;
import org.apache.guacamole.auth.jdbc.connectiongroup.RootConnectionGroup;
import org.apache.guacamole.auth.jdbc.connectiongroup.ConnectionGroupDirectory;
import org.apache.guacamole.auth.jdbc.connection.ConnectionDirectory;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.auth.jdbc.base.RestrictedObject;
import org.apache.guacamole.auth.jdbc.activeconnection.ActiveConnectionDirectory;
import org.apache.guacamole.auth.jdbc.connection.ConnectionRecordSet;
import org.apache.guacamole.auth.jdbc.connection.ModeledConnection;
import org.apache.guacamole.auth.jdbc.connectiongroup.ModeledConnectionGroup;
import org.apache.guacamole.form.Form;
import org.apache.guacamole.net.auth.ActiveConnection;
import org.apache.guacamole.net.auth.AuthenticationProvider;
import org.apache.guacamole.net.auth.Connection;
import org.apache.guacamole.net.auth.ConnectionGroup;
import org.apache.guacamole.net.auth.Directory;
import org.apache.guacamole.net.auth.User;
implements org.apache.guacamole.net.auth.UserContext {
package org.apache.guacamole.auth.jdbc.user;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.auth.jdbc.base.RestrictedObject;
import org.apache.guacamole.net.auth.Directory;
import org.apache.guacamole.net.auth.User;
package org.apache.guacamole.auth.jdbc.user;
import org.apache.guacamole.auth.jdbc.base.ModeledDirectoryObjectMapper;
package org.apache.guacamole.auth.jdbc.user;
import org.apache.guacamole.auth.jdbc.base.ObjectModel;
package org.apache.guacamole.auth.jdbc.user;
import org.apache.guacamole.net.auth.Credentials;
import org.apache.guacamole.auth.jdbc.base.ModeledDirectoryObjectMapper;
import org.apache.guacamole.auth.jdbc.base.ModeledDirectoryObjectService;
import org.apache.guacamole.GuacamoleClientException;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleUnsupportedException;
import org.apache.guacamole.auth.jdbc.permission.ObjectPermissionMapper;
import org.apache.guacamole.auth.jdbc.permission.ObjectPermissionModel;
import org.apache.guacamole.auth.jdbc.permission.UserPermissionMapper;
import org.apache.guacamole.auth.jdbc.security.PasswordEncryptionService;
import org.apache.guacamole.form.Field;
import org.apache.guacamole.form.PasswordField;
import org.apache.guacamole.net.auth.AuthenticationProvider;
import org.apache.guacamole.net.auth.User;
import org.apache.guacamole.net.auth.credentials.CredentialsInfo;
import org.apache.guacamole.net.auth.credentials.GuacamoleInsufficientCredentialsException;
import org.apache.guacamole.net.auth.permission.ObjectPermission;
import org.apache.guacamole.net.auth.permission.ObjectPermissionSet;
import org.apache.guacamole.net.auth.permission.SystemPermission;
import org.apache.guacamole.net.auth.permission.SystemPermissionSet;
public ModeledUser retrieveUser(org.apache.guacamole.net.auth.AuthenticatedUser authenticatedUser) {
package org.apache.guacamole.auth.jdbc.user;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.auth.AuthenticationProvider;
import org.apache.guacamole.net.auth.Credentials;
import org.apache.guacamole.net.auth.UserContext;
import org.apache.guacamole.auth.jdbc.JDBCAuthenticationProviderModule;
import org.apache.guacamole.auth.jdbc.user.AuthenticationProviderService;
import org.apache.guacamole.net.auth.AuthenticatedUser;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.auth.jdbc.JDBCEnvironment;
import org.apache.guacamole.properties.BooleanGuacamoleProperty;
import org.apache.guacamole.properties.IntegerGuacamoleProperty;
import org.apache.guacamole.properties.StringGuacamoleProperty;
package org.apache.guacamole.auth.postgresql;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.auth.AuthenticationProvider;
import org.apache.guacamole.net.auth.Credentials;
import org.apache.guacamole.net.auth.UserContext;
import org.apache.guacamole.auth.jdbc.JDBCAuthenticationProviderModule;
import org.apache.guacamole.auth.jdbc.JDBCEnvironment;
import org.apache.guacamole.auth.jdbc.user.AuthenticationProviderService;
import org.apache.guacamole.net.auth.AuthenticatedUser;
package org.apache.guacamole.auth.postgresql;
import org.apache.guacamole.GuacamoleException;
package org.apache.guacamole.auth.postgresql;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.auth.jdbc.JDBCEnvironment;
package org.apache.guacamole.auth.postgresql;
import org.apache.guacamole.properties.BooleanGuacamoleProperty;
import org.apache.guacamole.properties.IntegerGuacamoleProperty;
import org.apache.guacamole.properties.StringGuacamoleProperty;
package org.apache.guacamole.auth.postgresql;
import org.apache.guacamole.auth.ldap.AuthenticationProviderService;
import org.apache.guacamole.auth.ldap.LDAPAuthenticationProviderModule;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.auth.AuthenticatedUser;
import org.apache.guacamole.net.auth.AuthenticationProvider;
import org.apache.guacamole.net.auth.Credentials;
import org.apache.guacamole.net.auth.UserContext;
package org.apache.guacamole.auth.ldap;
import org.apache.guacamole.auth.ldap.user.AuthenticatedUser;
import org.apache.guacamole.auth.ldap.user.UserContext;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.auth.ldap.user.UserService;
import org.apache.guacamole.net.auth.Credentials;
import org.apache.guacamole.net.auth.credentials.CredentialsInfo;
import org.apache.guacamole.net.auth.credentials.GuacamoleInvalidCredentialsException;
public UserContext getUserContext(org.apache.guacamole.net.auth.AuthenticatedUser authenticatedUser)
package org.apache.guacamole.auth.ldap;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.environment.Environment;
package org.apache.guacamole.auth.ldap;
package org.apache.guacamole.auth.ldap;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleServerException;
import org.apache.guacamole.properties.GuacamoleProperty;
package org.apache.guacamole.auth.ldap;
package org.apache.guacamole.auth.ldap;
import org.apache.guacamole.auth.ldap.connection.ConnectionService;
import org.apache.guacamole.auth.ldap.user.UserService;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.environment.Environment;
import org.apache.guacamole.environment.LocalEnvironment;
import org.apache.guacamole.net.auth.AuthenticationProvider;
package org.apache.guacamole.auth.ldap;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleUnsupportedException;
package org.apache.guacamole.auth.ldap;
import org.apache.guacamole.properties.IntegerGuacamoleProperty;
import org.apache.guacamole.properties.StringGuacamoleProperty;
package org.apache.guacamole.auth.ldap;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.properties.GuacamoleProperty;
package org.apache.guacamole.auth.ldap.connection;
import org.apache.guacamole.auth.ldap.ConfigurationService;
import org.apache.guacamole.auth.ldap.EscapingService;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleServerException;
import org.apache.guacamole.net.auth.AuthenticatedUser;
import org.apache.guacamole.net.auth.Connection;
import org.apache.guacamole.net.auth.simple.SimpleConnection;
import org.apache.guacamole.protocol.GuacamoleConfiguration;
import org.apache.guacamole.token.StandardTokens;
import org.apache.guacamole.token.TokenFilter;
package org.apache.guacamole.auth.ldap.user;
import org.apache.guacamole.net.auth.AbstractAuthenticatedUser;
import org.apache.guacamole.net.auth.AuthenticationProvider;
import org.apache.guacamole.net.auth.Credentials;
package org.apache.guacamole.auth.ldap.user;
import org.apache.guacamole.auth.ldap.connection.ConnectionService;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.form.Form;
import org.apache.guacamole.net.auth.ActiveConnection;
import org.apache.guacamole.net.auth.AuthenticatedUser;
import org.apache.guacamole.net.auth.AuthenticationProvider;
import org.apache.guacamole.net.auth.Connection;
import org.apache.guacamole.net.auth.ConnectionGroup;
import org.apache.guacamole.net.auth.ConnectionRecordSet;
import org.apache.guacamole.net.auth.Directory;
import org.apache.guacamole.net.auth.User;
import org.apache.guacamole.net.auth.simple.SimpleConnectionGroup;
import org.apache.guacamole.net.auth.simple.SimpleConnectionGroupDirectory;
import org.apache.guacamole.net.auth.simple.SimpleConnectionRecordSet;
import org.apache.guacamole.net.auth.simple.SimpleDirectory;
import org.apache.guacamole.net.auth.simple.SimpleUser;
public class UserContext implements org.apache.guacamole.net.auth.UserContext {
package org.apache.guacamole.auth.ldap.user;
import org.apache.guacamole.auth.ldap.ConfigurationService;
import org.apache.guacamole.auth.ldap.EscapingService;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleServerException;
import org.apache.guacamole.auth.ldap.LDAPGuacamoleProperties;
import org.apache.guacamole.net.auth.User;
import org.apache.guacamole.net.auth.simple.SimpleUser;
import org.apache.guacamole.protocol.GuacamoleConfiguration;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleServerException;
import org.apache.guacamole.environment.Environment;
import org.apache.guacamole.environment.LocalEnvironment;
import org.apache.guacamole.net.auth.simple.SimpleAuthenticationProvider;
import org.apache.guacamole.net.auth.Credentials;
import org.apache.guacamole.properties.FileGuacamoleProperty;
import org.apache.guacamole.protocol.GuacamoleConfiguration;
package org.apache.guacamole;
import org.apache.guacamole.protocol.GuacamoleStatus;
package org.apache.guacamole;
import org.apache.guacamole.protocol.GuacamoleStatus;
package org.apache.guacamole;
import org.apache.guacamole.protocol.GuacamoleStatus;
package org.apache.guacamole;
import org.apache.guacamole.protocol.GuacamoleStatus;
package org.apache.guacamole;
import org.apache.guacamole.protocol.GuacamoleStatus;
package org.apache.guacamole;
import org.apache.guacamole.protocol.GuacamoleStatus;
package org.apache.guacamole;
import org.apache.guacamole.protocol.GuacamoleStatus;
package org.apache.guacamole;
import org.apache.guacamole.protocol.GuacamoleStatus;
package org.apache.guacamole;
import org.apache.guacamole.protocol.GuacamoleStatus;
package org.apache.guacamole;
import org.apache.guacamole.protocol.GuacamoleStatus;
package org.apache.guacamole;
import org.apache.guacamole.protocol.GuacamoleStatus;
package org.apache.guacamole;
import org.apache.guacamole.protocol.GuacamoleStatus;
package org.apache.guacamole;
import org.apache.guacamole.protocol.GuacamoleStatus;
package org.apache.guacamole;
import org.apache.guacamole.protocol.GuacamoleStatus;
package org.apache.guacamole;
import org.apache.guacamole.protocol.GuacamoleStatus;
package org.apache.guacamole;
import org.apache.guacamole.protocol.GuacamoleStatus;
package org.apache.guacamole.io;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.protocol.GuacamoleInstruction;
package org.apache.guacamole.io;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.protocol.GuacamoleInstruction;
package org.apache.guacamole.io;
import org.apache.guacamole.GuacamoleConnectionClosedException;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleServerException;
import org.apache.guacamole.GuacamoleUpstreamTimeoutException;
import org.apache.guacamole.protocol.GuacamoleInstruction;
package org.apache.guacamole.io;
import org.apache.guacamole.GuacamoleConnectionClosedException;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleServerException;
import org.apache.guacamole.GuacamoleUpstreamTimeoutException;
import org.apache.guacamole.protocol.GuacamoleInstruction;
package org.apache.guacamole.io;
package org.apache.guacamole.net;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.io.GuacamoleReader;
import org.apache.guacamole.io.GuacamoleWriter;
package org.apache.guacamole.net;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.io.GuacamoleReader;
import org.apache.guacamole.io.GuacamoleWriter;
package org.apache.guacamole.net;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.io.GuacamoleReader;
import org.apache.guacamole.io.GuacamoleWriter;
package org.apache.guacamole.net;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.io.GuacamoleReader;
import org.apache.guacamole.io.GuacamoleWriter;
package org.apache.guacamole.net;
import org.apache.guacamole.io.GuacamoleReader;
import org.apache.guacamole.io.ReaderGuacamoleReader;
import org.apache.guacamole.io.WriterGuacamoleWriter;
import org.apache.guacamole.io.GuacamoleWriter;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleServerException;
import org.apache.guacamole.GuacamoleUpstreamTimeoutException;
package org.apache.guacamole.net;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleServerException;
import org.apache.guacamole.io.GuacamoleReader;
import org.apache.guacamole.io.GuacamoleWriter;
import org.apache.guacamole.io.ReaderGuacamoleReader;
import org.apache.guacamole.io.WriterGuacamoleWriter;
package org.apache.guacamole.net;
package org.apache.guacamole.net;
package org.apache.guacamole;
package org.apache.guacamole.protocol;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleServerException;
import org.apache.guacamole.io.GuacamoleReader;
import org.apache.guacamole.io.GuacamoleWriter;
import org.apache.guacamole.net.GuacamoleSocket;
package org.apache.guacamole.protocol;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.io.GuacamoleReader;
package org.apache.guacamole.protocol;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.io.GuacamoleReader;
import org.apache.guacamole.io.GuacamoleWriter;
import org.apache.guacamole.net.GuacamoleSocket;
package org.apache.guacamole.protocol;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleServerException;
import org.apache.guacamole.io.GuacamoleWriter;
package org.apache.guacamole.protocol;
package org.apache.guacamole.protocol;
package org.apache.guacamole.protocol;
import org.apache.guacamole.GuacamoleException;
package org.apache.guacamole.protocol;
package org.apache.guacamole.protocol;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleServerException;
package org.apache.guacamole.protocol;
package org.apache.guacamole.protocol;
package org.apache.guacamole.servlet;
import org.apache.guacamole.net.DelegatingGuacamoleTunnel;
import org.apache.guacamole.net.GuacamoleTunnel;
package org.apache.guacamole.servlet;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.GuacamoleTunnel;
package org.apache.guacamole.servlet;
import org.apache.guacamole.GuacamoleClientException;
import org.apache.guacamole.GuacamoleConnectionClosedException;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleResourceNotFoundException;
import org.apache.guacamole.GuacamoleServerException;
import org.apache.guacamole.io.GuacamoleReader;
import org.apache.guacamole.io.GuacamoleWriter;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.protocol.GuacamoleStatus;
package org.apache.guacamole.servlet;
import org.apache.guacamole.net.GuacamoleTunnel;
package org.apache.guacamole.servlet;
package org.apache.guacamole.websocket;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.io.GuacamoleReader;
import org.apache.guacamole.io.GuacamoleWriter;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.GuacamoleClientException;
import org.apache.guacamole.GuacamoleConnectionClosedException;
import org.apache.guacamole.protocol.GuacamoleStatus;
package org.apache.guacamole.environment;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.properties.BooleanGuacamoleProperty;
import org.apache.guacamole.properties.GuacamoleProperty;
import org.apache.guacamole.properties.IntegerGuacamoleProperty;
import org.apache.guacamole.properties.StringGuacamoleProperty;
import org.apache.guacamole.protocols.ProtocolInfo;
package org.apache.guacamole.environment;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleServerException;
import org.apache.guacamole.properties.GuacamoleProperty;
import org.apache.guacamole.protocols.ProtocolInfo;
"/org/apache/guacamole/protocols/"
package org.apache.guacamole.form;
package org.apache.guacamole.form;
package org.apache.guacamole.form;
package org.apache.guacamole.form;
package org.apache.guacamole.form;
package org.apache.guacamole.form;
package org.apache.guacamole.form;
package org.apache.guacamole.form;
package org.apache.guacamole.form;
package org.apache.guacamole.form;
package org.apache.guacamole.form;
package org.apache.guacamole.form;
package org.apache.guacamole.form;
package org.apache.guacamole.form;
package org.apache.guacamole.net.auth;
import org.apache.guacamole.net.GuacamoleTunnel;
package org.apache.guacamole.net.auth;
package org.apache.guacamole.net.auth;
import org.apache.guacamole.protocol.GuacamoleConfiguration;
package org.apache.guacamole.net.auth;
package org.apache.guacamole.net.auth;
package org.apache.guacamole.net.auth;
import org.apache.guacamole.net.GuacamoleTunnel;
package org.apache.guacamole.net.auth;
package org.apache.guacamole.net.auth;
import org.apache.guacamole.GuacamoleException;
package org.apache.guacamole.net.auth;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.protocol.GuacamoleClientInformation;
package org.apache.guacamole.net.auth;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.protocol.GuacamoleConfiguration;
package org.apache.guacamole.net.auth;
import org.apache.guacamole.GuacamoleException;
package org.apache.guacamole.net.auth;
package org.apache.guacamole.net.auth;
import org.apache.guacamole.GuacamoleException;
package org.apache.guacamole.net.auth;
package org.apache.guacamole.net.auth;
import org.apache.guacamole.GuacamoleException;
package org.apache.guacamole.net.auth;
package org.apache.guacamole.net.auth;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.auth.permission.ObjectPermissionSet;
import org.apache.guacamole.net.auth.permission.SystemPermissionSet;
package org.apache.guacamole.net.auth;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.form.Form;
package org.apache.guacamole.net.auth.credentials;
import org.apache.guacamole.form.Field;
import org.apache.guacamole.form.PasswordField;
import org.apache.guacamole.form.UsernameField;
package org.apache.guacamole.net.auth.credentials;
import org.apache.guacamole.GuacamoleUnauthorizedException;
package org.apache.guacamole.net.auth.credentials;
package org.apache.guacamole.net.auth.credentials;
package org.apache.guacamole.net.auth;
package org.apache.guacamole.net.auth.permission;
package org.apache.guacamole.net.auth.permission;
import org.apache.guacamole.GuacamoleException;
package org.apache.guacamole.net.auth.permission;
package org.apache.guacamole.net.auth.permission;
import org.apache.guacamole.GuacamoleException;
package org.apache.guacamole.net.auth.permission;
package org.apache.guacamole.net.auth.permission;
import org.apache.guacamole.GuacamoleException;
package org.apache.guacamole.net.auth.permission;
package org.apache.guacamole.net.auth.simple;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.auth.AbstractAuthenticatedUser;
import org.apache.guacamole.net.auth.AuthenticationProvider;
import org.apache.guacamole.net.auth.AuthenticatedUser;
import org.apache.guacamole.net.auth.Credentials;
import org.apache.guacamole.net.auth.UserContext;
import org.apache.guacamole.protocol.GuacamoleConfiguration;
import org.apache.guacamole.token.StandardTokens;
import org.apache.guacamole.token.TokenFilter;
package org.apache.guacamole.net.auth.simple;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.environment.Environment;
import org.apache.guacamole.environment.LocalEnvironment;
import org.apache.guacamole.net.GuacamoleSocket;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.net.InetGuacamoleSocket;
import org.apache.guacamole.net.SSLGuacamoleSocket;
import org.apache.guacamole.net.SimpleGuacamoleTunnel;
import org.apache.guacamole.net.auth.AbstractConnection;
import org.apache.guacamole.net.auth.ConnectionRecord;
import org.apache.guacamole.protocol.ConfiguredGuacamoleSocket;
import org.apache.guacamole.protocol.GuacamoleClientInformation;
import org.apache.guacamole.protocol.GuacamoleConfiguration;
package org.apache.guacamole.net.auth.simple;
import org.apache.guacamole.net.auth.Connection;
package org.apache.guacamole.net.auth.simple;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleSecurityException;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.net.auth.AbstractConnectionGroup;
import org.apache.guacamole.net.auth.ConnectionGroup;
import org.apache.guacamole.protocol.GuacamoleClientInformation;
package org.apache.guacamole.net.auth.simple;
import org.apache.guacamole.net.auth.ConnectionGroup;
package org.apache.guacamole.net.auth.simple;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.auth.ConnectionRecord;
import org.apache.guacamole.net.auth.ConnectionRecordSet;
package org.apache.guacamole.net.auth.simple;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleSecurityException;
import org.apache.guacamole.net.auth.Directory;
import org.apache.guacamole.net.auth.Identifiable;
package org.apache.guacamole.net.auth.simple;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleSecurityException;
import org.apache.guacamole.net.auth.permission.ObjectPermission;
import org.apache.guacamole.net.auth.permission.ObjectPermissionSet;
package org.apache.guacamole.net.auth.simple;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleSecurityException;
import org.apache.guacamole.net.auth.permission.SystemPermission;
import org.apache.guacamole.net.auth.permission.SystemPermissionSet;
package org.apache.guacamole.net.auth.simple;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.auth.AbstractUser;
import org.apache.guacamole.net.auth.permission.ObjectPermission;
import org.apache.guacamole.net.auth.permission.ObjectPermissionSet;
import org.apache.guacamole.net.auth.permission.SystemPermissionSet;
package org.apache.guacamole.net.auth.simple;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.form.Form;
import org.apache.guacamole.net.auth.ActiveConnection;
import org.apache.guacamole.net.auth.AuthenticationProvider;
import org.apache.guacamole.net.auth.Connection;
import org.apache.guacamole.net.auth.ConnectionGroup;
import org.apache.guacamole.net.auth.ConnectionRecordSet;
import org.apache.guacamole.net.auth.Directory;
import org.apache.guacamole.net.auth.User;
import org.apache.guacamole.net.auth.UserContext;
import org.apache.guacamole.protocol.GuacamoleConfiguration;
package org.apache.guacamole.net.auth.simple;
import org.apache.guacamole.net.auth.User;
package org.apache.guacamole.net.auth.simple;
package org.apache.guacamole.net.event;
import org.apache.guacamole.net.auth.Credentials;
package org.apache.guacamole.net.event;
import org.apache.guacamole.net.auth.Credentials;
import org.apache.guacamole.net.auth.UserContext;
package org.apache.guacamole.net.event;
import org.apache.guacamole.net.auth.Credentials;
package org.apache.guacamole.net.event;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.net.auth.Credentials;
import org.apache.guacamole.net.auth.UserContext;
package org.apache.guacamole.net.event;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.net.auth.Credentials;
import org.apache.guacamole.net.auth.UserContext;
package org.apache.guacamole.net.event;
import org.apache.guacamole.net.GuacamoleTunnel;
package org.apache.guacamole.net.event;
import org.apache.guacamole.net.auth.UserContext;
package org.apache.guacamole.net.event.listener;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.event.AuthenticationFailureEvent;
package org.apache.guacamole.net.event.listener;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.event.AuthenticationSuccessEvent;
package org.apache.guacamole.net.event.listener;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.event.TunnelCloseEvent;
package org.apache.guacamole.net.event.listener;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.event.TunnelConnectEvent;
package org.apache.guacamole.net.event.listener;
package org.apache.guacamole.net.event;
package org.apache.guacamole.properties;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleServerException;
package org.apache.guacamole.properties;
import org.apache.guacamole.GuacamoleException;
package org.apache.guacamole.properties;
package org.apache.guacamole.properties;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleServerException;
package org.apache.guacamole.properties;
import org.apache.guacamole.GuacamoleException;
package org.apache.guacamole.properties;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleServerException;
package org.apache.guacamole.properties;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleServerException;
package org.apache.guacamole.properties;
import org.apache.guacamole.GuacamoleException;
package org.apache.guacamole.properties;
package org.apache.guacamole.protocols;
import org.apache.guacamole.form.Form;
package org.apache.guacamole.token;
import org.apache.guacamole.net.auth.Credentials;
package org.apache.guacamole.token;
package org.apache.guacamole.xml;
package org.apache.guacamole.xml;
package org.apache.guacamole.xml;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.environment.Environment;
import org.apache.guacamole.environment.LocalEnvironment;
import org.apache.guacamole.net.auth.Credentials;
import org.apache.guacamole.net.auth.simple.SimpleAuthenticationProvider;
import org.apache.guacamole.net.basic.auth.Authorization;
import org.apache.guacamole.net.basic.auth.UserMapping;
import org.apache.guacamole.xml.DocumentHandler;
import org.apache.guacamole.net.basic.xml.usermapping.UserMappingTagHandler;
import org.apache.guacamole.properties.FileGuacamoleProperty;
import org.apache.guacamole.protocol.GuacamoleConfiguration;
package org.apache.guacamole.net.basic;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.servlet.GuacamoleHTTPTunnelServlet;
package org.apache.guacamole.net.basic;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.environment.Environment;
import org.apache.guacamole.environment.LocalEnvironment;
import org.apache.guacamole.net.basic.extension.ExtensionModule;
import org.apache.guacamole.net.basic.log.LogModule;
import org.apache.guacamole.net.basic.rest.RESTServiceModule;
import org.apache.guacamole.net.basic.rest.auth.BasicTokenSessionMap;
import org.apache.guacamole.net.basic.rest.auth.TokenSessionMap;
package org.apache.guacamole.net.basic;
package org.apache.guacamole.net.basic;
import org.apache.guacamole.environment.Environment;
package org.apache.guacamole.net.basic;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.environment.Environment;
import org.apache.guacamole.environment.LocalEnvironment;
import org.apache.guacamole.net.basic.properties.BasicGuacamoleProperties;
package org.apache.guacamole.net.basic;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.environment.Environment;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.net.auth.AuthenticatedUser;
import org.apache.guacamole.net.auth.UserContext;
package org.apache.guacamole.net.basic;
package org.apache.guacamole.net.basic;
package org.apache.guacamole.net.basic;
"org.apache.guacamole.net.basic.websocket.WebSocketTunnelModule",
"org.apache.guacamole.net.basic.websocket.jetty8.WebSocketTunnelModule",
"org.apache.guacamole.net.basic.websocket.jetty9.WebSocketTunnelModule",
"org.apache.guacamole.net.basic.websocket.tomcat.WebSocketTunnelModule"
package org.apache.guacamole.net.basic;
import org.apache.guacamole.GuacamoleClientException;
import org.apache.guacamole.GuacamoleException;
package org.apache.guacamole.net.basic;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleSecurityException;
import org.apache.guacamole.GuacamoleUnauthorizedException;
import org.apache.guacamole.net.DelegatingGuacamoleTunnel;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.net.auth.Connection;
import org.apache.guacamole.net.auth.ConnectionGroup;
import org.apache.guacamole.net.auth.Directory;
import org.apache.guacamole.net.auth.UserContext;
import org.apache.guacamole.net.basic.rest.ObjectRetrievalService;
import org.apache.guacamole.net.basic.rest.auth.AuthenticationService;
import org.apache.guacamole.protocol.GuacamoleClientInformation;
package org.apache.guacamole.net.basic.auth;
import org.apache.guacamole.protocol.GuacamoleConfiguration;
package org.apache.guacamole.net.basic.auth;
package org.apache.guacamole.net.basic.auth;
package org.apache.guacamole.net.basic.extension;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.auth.AuthenticatedUser;
import org.apache.guacamole.net.auth.AuthenticationProvider;
import org.apache.guacamole.net.auth.Credentials;
import org.apache.guacamole.net.auth.UserContext;
import org.apache.guacamole.net.auth.credentials.CredentialsInfo;
import org.apache.guacamole.net.auth.credentials.GuacamoleInvalidCredentialsException;
package org.apache.guacamole.net.basic.extension;
import org.apache.guacamole.GuacamoleException;
package org.apache.guacamole.net.basic.extension;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleServerException;
import org.apache.guacamole.net.auth.AuthenticationProvider;
import org.apache.guacamole.net.basic.resource.ClassPathResource;
import org.apache.guacamole.net.basic.resource.Resource;
package org.apache.guacamole.net.basic.extension;
package org.apache.guacamole.net.basic.extension;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleServerException;
import org.apache.guacamole.environment.Environment;
import org.apache.guacamole.net.auth.AuthenticationProvider;
import org.apache.guacamole.net.basic.properties.BasicGuacamoleProperties;
import org.apache.guacamole.net.basic.resource.Resource;
import org.apache.guacamole.net.basic.resource.ResourceServlet;
import org.apache.guacamole.net.basic.resource.SequenceResource;
import org.apache.guacamole.net.basic.resource.WebApplicationResource;
package org.apache.guacamole.net.basic.extension;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.environment.Environment;
import org.apache.guacamole.net.basic.properties.BasicGuacamoleProperties;
import org.apache.guacamole.net.basic.resource.ByteArrayResource;
import org.apache.guacamole.net.basic.resource.Resource;
import org.apache.guacamole.net.basic.resource.WebApplicationResource;
package org.apache.guacamole.net.basic.extension;
import org.apache.guacamole.net.basic.resource.Resource;
package org.apache.guacamole.net.basic.extension;
package org.apache.guacamole.net.basic.log;
import org.apache.guacamole.environment.Environment;
package org.apache.guacamole.net.basic;
package org.apache.guacamole.net.basic.properties;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.auth.AuthenticationProvider;
import org.apache.guacamole.properties.GuacamoleProperty;
Class<?> authProviderClass = org.apache.guacamole.net.basic.GuacamoleClassLoader.getInstance().loadClass(authProviderClassName);
package org.apache.guacamole.net.basic.properties;
import org.apache.guacamole.properties.FileGuacamoleProperty;
import org.apache.guacamole.properties.IntegerGuacamoleProperty;
import org.apache.guacamole.properties.StringGuacamoleProperty;
package org.apache.guacamole.net.basic.properties;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.properties.GuacamoleProperty;
package org.apache.guacamole.net.basic.properties;
package org.apache.guacamole.net.basic.resource;
package org.apache.guacamole.net.basic.resource;
package org.apache.guacamole.net.basic.resource;
package org.apache.guacamole.net.basic.resource;
package org.apache.guacamole.net.basic.resource;
package org.apache.guacamole.net.basic.resource;
package org.apache.guacamole.net.basic.resource;
package org.apache.guacamole.net.basic.resource;
package org.apache.guacamole.net.basic.rest;
import org.apache.guacamole.form.Field;
package org.apache.guacamole.net.basic.rest;
import org.apache.guacamole.form.Field;
package org.apache.guacamole.net.basic.rest;
package org.apache.guacamole.net.basic.rest;
package org.apache.guacamole.net.basic.rest;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleResourceNotFoundException;
import org.apache.guacamole.net.auth.AuthenticationProvider;
import org.apache.guacamole.net.auth.Connection;
import org.apache.guacamole.net.auth.ConnectionGroup;
import org.apache.guacamole.net.auth.Directory;
import org.apache.guacamole.net.auth.User;
import org.apache.guacamole.net.auth.UserContext;
import org.apache.guacamole.net.basic.GuacamoleSession;
import org.apache.guacamole.net.basic.rest.connectiongroup.APIConnectionGroup;
package org.apache.guacamole.net.basic.rest;
package org.apache.guacamole.net.basic.rest;
import org.apache.guacamole.GuacamoleClientException;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleResourceNotFoundException;
import org.apache.guacamole.GuacamoleSecurityException;
import org.apache.guacamole.GuacamoleUnauthorizedException;
import org.apache.guacamole.net.auth.credentials.GuacamoleInsufficientCredentialsException;
import org.apache.guacamole.net.auth.credentials.GuacamoleInvalidCredentialsException;
import org.apache.guacamole.net.basic.rest.auth.AuthenticationService;
package org.apache.guacamole.net.basic.rest;
import org.apache.guacamole.GuacamoleException;
package org.apache.guacamole.net.basic.rest;
import org.apache.guacamole.net.basic.rest.auth.TokenRESTService;
import org.apache.guacamole.net.basic.rest.connection.ConnectionRESTService;
import org.apache.guacamole.net.basic.rest.connectiongroup.ConnectionGroupRESTService;
import org.apache.guacamole.net.basic.rest.activeconnection.ActiveConnectionRESTService;
import org.apache.guacamole.net.basic.rest.auth.AuthTokenGenerator;
import org.apache.guacamole.net.basic.rest.auth.AuthenticationService;
import org.apache.guacamole.net.basic.rest.auth.SecureRandomAuthTokenGenerator;
import org.apache.guacamole.net.basic.rest.auth.TokenSessionMap;
import org.apache.guacamole.net.basic.rest.history.HistoryRESTService;
import org.apache.guacamole.net.basic.rest.language.LanguageRESTService;
import org.apache.guacamole.net.basic.rest.patch.PatchRESTService;
import org.apache.guacamole.net.basic.rest.schema.SchemaRESTService;
import org.apache.guacamole.net.basic.rest.user.UserRESTService;
package org.apache.guacamole.net.basic.rest.activeconnection;
import org.apache.guacamole.net.auth.ActiveConnection;
package org.apache.guacamole.net.basic.rest.activeconnection;
import org.apache.guacamole.GuacamoleClientException;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleUnsupportedException;
import org.apache.guacamole.net.auth.ActiveConnection;
import org.apache.guacamole.net.auth.Directory;
import org.apache.guacamole.net.auth.User;
import org.apache.guacamole.net.auth.UserContext;
import org.apache.guacamole.net.auth.permission.ObjectPermission;
import org.apache.guacamole.net.auth.permission.ObjectPermissionSet;
import org.apache.guacamole.net.auth.permission.SystemPermission;
import org.apache.guacamole.net.auth.permission.SystemPermissionSet;
import org.apache.guacamole.net.basic.GuacamoleSession;
import org.apache.guacamole.net.basic.rest.APIPatch;
import org.apache.guacamole.net.basic.rest.ObjectRetrievalService;
import org.apache.guacamole.net.basic.rest.PATCH;
import org.apache.guacamole.net.basic.rest.auth.AuthenticationService;
package org.apache.guacamole.net.basic.rest.auth;
package org.apache.guacamole.net.basic.rest.auth;
package org.apache.guacamole.net.basic.rest.auth;
package org.apache.guacamole.net.basic.rest.auth;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleSecurityException;
import org.apache.guacamole.GuacamoleUnauthorizedException;
import org.apache.guacamole.environment.Environment;
import org.apache.guacamole.net.auth.AuthenticatedUser;
import org.apache.guacamole.net.auth.AuthenticationProvider;
import org.apache.guacamole.net.auth.Credentials;
import org.apache.guacamole.net.auth.UserContext;
import org.apache.guacamole.net.auth.credentials.CredentialsInfo;
import org.apache.guacamole.net.auth.credentials.GuacamoleCredentialsException;
import org.apache.guacamole.net.auth.credentials.GuacamoleInvalidCredentialsException;
import org.apache.guacamole.net.basic.GuacamoleSession;
package org.apache.guacamole.net.basic.rest.auth;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.environment.Environment;
import org.apache.guacamole.net.basic.GuacamoleSession;
import org.apache.guacamole.net.basic.properties.BasicGuacamoleProperties;
package org.apache.guacamole.net.basic.rest.auth;
package org.apache.guacamole.net.basic.rest.auth;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleResourceNotFoundException;
import org.apache.guacamole.net.auth.AuthenticatedUser;
import org.apache.guacamole.net.auth.Credentials;
import org.apache.guacamole.net.auth.UserContext;
import org.apache.guacamole.net.basic.GuacamoleSession;
import org.apache.guacamole.net.basic.rest.APIRequest;
package org.apache.guacamole.net.basic.rest.auth;
import org.apache.guacamole.net.basic.GuacamoleSession;
package org.apache.guacamole.net.basic.rest.auth;
package org.apache.guacamole.net.basic.rest.connection;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.auth.Connection;
import org.apache.guacamole.protocol.GuacamoleConfiguration;
package org.apache.guacamole.net.basic.rest.connection;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.net.auth.Connection;
import org.apache.guacamole.net.auth.ConnectionRecord;
import org.apache.guacamole.protocol.GuacamoleClientInformation;
import org.apache.guacamole.protocol.GuacamoleConfiguration;
package org.apache.guacamole.net.basic.rest.connection;
import org.apache.guacamole.GuacamoleClientException;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleSecurityException;
import org.apache.guacamole.net.auth.Connection;
import org.apache.guacamole.net.auth.ConnectionRecord;
import org.apache.guacamole.net.auth.Directory;
import org.apache.guacamole.net.auth.User;
import org.apache.guacamole.net.auth.UserContext;
import org.apache.guacamole.net.auth.permission.ObjectPermission;
import org.apache.guacamole.net.auth.permission.ObjectPermissionSet;
import org.apache.guacamole.net.auth.permission.SystemPermission;
import org.apache.guacamole.net.auth.permission.SystemPermissionSet;
import org.apache.guacamole.net.basic.GuacamoleSession;
import org.apache.guacamole.net.basic.rest.ObjectRetrievalService;
import org.apache.guacamole.net.basic.rest.auth.AuthenticationService;
import org.apache.guacamole.net.basic.rest.history.APIConnectionRecord;
import org.apache.guacamole.protocol.GuacamoleConfiguration;
package org.apache.guacamole.net.basic.rest.connection;
package org.apache.guacamole.net.basic.rest.connectiongroup;
import org.apache.guacamole.net.auth.ConnectionGroup;
import org.apache.guacamole.net.auth.ConnectionGroup.Type;
import org.apache.guacamole.net.basic.rest.connection.APIConnection;
package org.apache.guacamole.net.basic.rest.connectiongroup;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.net.auth.ConnectionGroup;
import org.apache.guacamole.protocol.GuacamoleClientInformation;
package org.apache.guacamole.net.basic.rest.connectiongroup;
import org.apache.guacamole.GuacamoleClientException;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.auth.ConnectionGroup;
import org.apache.guacamole.net.auth.Directory;
import org.apache.guacamole.net.auth.UserContext;
import org.apache.guacamole.net.auth.permission.ObjectPermission;
import org.apache.guacamole.net.basic.GuacamoleSession;
import org.apache.guacamole.net.basic.rest.ObjectRetrievalService;
import org.apache.guacamole.net.basic.rest.auth.AuthenticationService;
package org.apache.guacamole.net.basic.rest.connectiongroup;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.auth.Connection;
import org.apache.guacamole.net.auth.ConnectionGroup;
import org.apache.guacamole.net.auth.UserContext;
import org.apache.guacamole.net.auth.permission.ObjectPermission;
import org.apache.guacamole.net.auth.permission.ObjectPermissionSet;
import org.apache.guacamole.net.basic.rest.connection.APIConnection;
package org.apache.guacamole.net.basic.rest.connectiongroup;
package org.apache.guacamole.net.basic.rest.history;
import org.apache.guacamole.net.auth.ConnectionRecord;
package org.apache.guacamole.net.basic.rest.history;
import org.apache.guacamole.net.auth.ConnectionRecordSet;
import org.apache.guacamole.net.basic.rest.APIError;
import org.apache.guacamole.net.basic.rest.APIException;
package org.apache.guacamole.net.basic.rest.history;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.auth.ConnectionRecord;
import org.apache.guacamole.net.auth.ConnectionRecordSet;
import org.apache.guacamole.net.auth.UserContext;
import org.apache.guacamole.net.basic.GuacamoleSession;
import org.apache.guacamole.net.basic.rest.ObjectRetrievalService;
import org.apache.guacamole.net.basic.rest.auth.AuthenticationService;
package org.apache.guacamole.net.basic.rest.history;
package org.apache.guacamole.net.basic.rest.language;
import org.apache.guacamole.net.basic.extension.LanguageResourceService;
package org.apache.guacamole.net.basic.rest.language;
package org.apache.guacamole.net.basic.rest;
package org.apache.guacamole.net.basic.rest.patch;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleServerException;
import org.apache.guacamole.net.basic.extension.PatchResourceService;
import org.apache.guacamole.net.basic.resource.Resource;
package org.apache.guacamole.net.basic.rest.patch;
package org.apache.guacamole.net.basic.rest.permission;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.auth.User;
import org.apache.guacamole.net.auth.permission.ObjectPermission;
import org.apache.guacamole.net.auth.permission.ObjectPermissionSet;
import org.apache.guacamole.net.auth.permission.SystemPermission;
import org.apache.guacamole.net.auth.permission.SystemPermissionSet;
package org.apache.guacamole.net.basic.rest.permission;
package org.apache.guacamole.net.basic.rest.schema;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.environment.Environment;
import org.apache.guacamole.environment.LocalEnvironment;
import org.apache.guacamole.form.Form;
import org.apache.guacamole.net.auth.UserContext;
import org.apache.guacamole.net.basic.GuacamoleSession;
import org.apache.guacamole.net.basic.rest.ObjectRetrievalService;
import org.apache.guacamole.net.basic.rest.auth.AuthenticationService;
import org.apache.guacamole.protocols.ProtocolInfo;
package org.apache.guacamole.net.basic.rest.schema;
package org.apache.guacamole.net.basic.rest.user;
import org.apache.guacamole.net.auth.User;
package org.apache.guacamole.net.basic.rest.user;
package org.apache.guacamole.net.basic.rest.user;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleUnsupportedException;
import org.apache.guacamole.net.auth.User;
import org.apache.guacamole.net.auth.permission.ObjectPermissionSet;
import org.apache.guacamole.net.auth.permission.SystemPermissionSet;
package org.apache.guacamole.net.basic.rest.user;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.auth.permission.Permission;
import org.apache.guacamole.net.auth.permission.PermissionSet;
package org.apache.guacamole.net.basic.rest.user;
import org.apache.guacamole.GuacamoleClientException;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleResourceNotFoundException;
import org.apache.guacamole.GuacamoleSecurityException;
import org.apache.guacamole.net.auth.AuthenticationProvider;
import org.apache.guacamole.net.auth.Credentials;
import org.apache.guacamole.net.auth.Directory;
import org.apache.guacamole.net.auth.User;
import org.apache.guacamole.net.auth.UserContext;
import org.apache.guacamole.net.auth.credentials.GuacamoleCredentialsException;
import org.apache.guacamole.net.auth.permission.ObjectPermission;
import org.apache.guacamole.net.auth.permission.ObjectPermissionSet;
import org.apache.guacamole.net.auth.permission.Permission;
import org.apache.guacamole.net.auth.permission.SystemPermission;
import org.apache.guacamole.net.auth.permission.SystemPermissionSet;
import org.apache.guacamole.net.basic.GuacamoleSession;
import org.apache.guacamole.net.basic.rest.APIPatch;
import static org.apache.guacamole.net.basic.rest.APIPatch.Operation.add;
import static org.apache.guacamole.net.basic.rest.APIPatch.Operation.remove;
import org.apache.guacamole.net.basic.rest.ObjectRetrievalService;
import org.apache.guacamole.net.basic.rest.PATCH;
import org.apache.guacamole.net.basic.rest.auth.AuthenticationService;
import org.apache.guacamole.net.basic.rest.permission.APIPermissionSet;
package org.apache.guacamole.net.basic.rest.user;
package org.apache.guacamole.net.basic.websocket;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.net.basic.TunnelRequest;
import org.apache.guacamole.net.basic.TunnelRequestService;
import org.apache.guacamole.websocket.GuacamoleWebSocketTunnelEndpoint;
package org.apache.guacamole.net.basic.websocket;
import org.apache.guacamole.net.basic.TunnelLoader;
import org.apache.guacamole.net.basic.TunnelRequestService;
package org.apache.guacamole.net.basic.websocket;
import org.apache.guacamole.net.basic.TunnelRequest;
package org.apache.guacamole.net.basic.websocket.jetty8;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.net.basic.TunnelRequestService;
import org.apache.guacamole.net.basic.TunnelRequest;
package org.apache.guacamole.net.basic.websocket.jetty8;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.io.GuacamoleReader;
import org.apache.guacamole.io.GuacamoleWriter;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.GuacamoleClientException;
import org.apache.guacamole.GuacamoleConnectionClosedException;
import org.apache.guacamole.net.basic.HTTPTunnelRequest;
import org.apache.guacamole.net.basic.TunnelRequest;
import org.apache.guacamole.protocol.GuacamoleStatus;
package org.apache.guacamole.net.basic.websocket.jetty8;
import org.apache.guacamole.net.basic.TunnelLoader;
Class.forName("org.apache.guacamole.net.basic.websocket.jetty8.BasicGuacamoleWebSocketTunnelServlet");
package org.apache.guacamole.net.basic.websocket.jetty8;
package org.apache.guacamole.net.basic.websocket.jetty9;
import org.apache.guacamole.net.basic.TunnelRequestService;
package org.apache.guacamole.net.basic.websocket.jetty9;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.net.basic.TunnelRequestService;
package org.apache.guacamole.net.basic.websocket.jetty9;
import org.apache.guacamole.net.basic.TunnelRequestService;
package org.apache.guacamole.net.basic.websocket.jetty9;
import org.apache.guacamole.GuacamoleClientException;
import org.apache.guacamole.GuacamoleConnectionClosedException;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.io.GuacamoleReader;
import org.apache.guacamole.io.GuacamoleWriter;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.protocol.GuacamoleStatus;
package org.apache.guacamole.net.basic.websocket.jetty9;
import org.apache.guacamole.net.basic.TunnelLoader;
Class.forName("org.apache.guacamole.net.basic.websocket.jetty9.BasicGuacamoleWebSocketTunnelServlet");
package org.apache.guacamole.net.basic.websocket.jetty9;
import org.apache.guacamole.net.basic.TunnelRequest;
package org.apache.guacamole.net.basic.websocket.jetty9;
package org.apache.guacamole.net.basic.websocket;
package org.apache.guacamole.net.basic.websocket.tomcat;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.net.basic.TunnelRequestService;
import org.apache.guacamole.net.basic.TunnelRequest;
package org.apache.guacamole.net.basic.websocket.tomcat;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.io.GuacamoleReader;
import org.apache.guacamole.io.GuacamoleWriter;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.GuacamoleClientException;
import org.apache.guacamole.GuacamoleConnectionClosedException;
import org.apache.guacamole.net.basic.HTTPTunnelRequest;
import org.apache.guacamole.net.basic.TunnelRequest;
import org.apache.guacamole.protocol.GuacamoleStatus;
package org.apache.guacamole.net.basic.websocket.tomcat;
import org.apache.guacamole.net.basic.TunnelLoader;
Class.forName("org.apache.guacamole.net.basic.websocket.tomcat.BasicGuacamoleWebSocketTunnelServlet");
package org.apache.guacamole.net.basic.websocket.tomcat;
package org.apache.guacamole.net.basic.xml.usermapping;
import org.apache.guacamole.net.basic.auth.Authorization;
import org.apache.guacamole.net.basic.auth.UserMapping;
import org.apache.guacamole.xml.TagHandler;
import org.apache.guacamole.protocol.GuacamoleConfiguration;
package org.apache.guacamole.net.basic.xml.usermapping;
import org.apache.guacamole.net.basic.auth.Authorization;
import org.apache.guacamole.xml.TagHandler;
import org.apache.guacamole.protocol.GuacamoleConfiguration;
package org.apache.guacamole.net.basic.xml.usermapping;
import org.apache.guacamole.xml.TagHandler;
import org.apache.guacamole.protocol.GuacamoleConfiguration;
package org.apache.guacamole.net.basic.xml.usermapping;
import org.apache.guacamole.xml.TagHandler;
import org.apache.guacamole.protocol.GuacamoleConfiguration;
package org.apache.guacamole.net.basic.xml.usermapping;
import org.apache.guacamole.net.basic.auth.UserMapping;
import org.apache.guacamole.xml.TagHandler;
package org.apache.guacamole.net.basic.xml.usermapping;
package org.apache.guacamole.auth.mysql;
package org.apache.guacamole.auth.mysql;
package org.apache.guacamole.auth.mysql;
package org.apache.guacamole.auth.mysql;
package org.apache.guacamole.auth.mysql;
package org.apache.guacamole.auth.ldap;
import org.apache.guacamole.auth.ldap.LDAPAuthenticationProvider;
import org.apache.guacamole.auth.ldap.LDAPAuthenticationProvider;
package org.apache.guacamole.auth.noauth;
package org.apache.guacamole.auth.noauth;
package org.apache.guacamole.net.basic;
import org.apache.guacamole.net.basic.BasicFileAuthenticationProvider;
package org.apache.guacamole;
package org.apache.guacamole;
import org.apache.guacamole.extension.ExtensionModule;
import org.apache.guacamole.log.LogModule;
import org.apache.guacamole.rest.RESTServiceModule;
import org.apache.guacamole.rest.auth.BasicTokenSessionMap;
import org.apache.guacamole.rest.auth.TokenSessionMap;
package org.apache.guacamole;
package org.apache.guacamole;
package org.apache.guacamole;
import org.apache.guacamole.properties.BasicGuacamoleProperties;
package org.apache.guacamole;
package org.apache.guacamole;
package org.apache.guacamole;
package org.apache.guacamole;
"org.apache.guacamole.websocket.WebSocketTunnelModule",
"org.apache.guacamole.websocket.jetty8.WebSocketTunnelModule",
"org.apache.guacamole.websocket.jetty9.WebSocketTunnelModule",
"org.apache.guacamole.websocket.tomcat.WebSocketTunnelModule"
package org.apache.guacamole;
package org.apache.guacamole;
import org.apache.guacamole.rest.ObjectRetrievalService;
import org.apache.guacamole.rest.auth.AuthenticationService;
package org.apache.guacamole.auth;
package org.apache.guacamole.auth;
package org.apache.guacamole.auth.basic;
import org.apache.guacamole.auth.Authorization;
import org.apache.guacamole.auth.UserMapping;
package org.apache.guacamole.auth.basic;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.auth.Authorization;
import org.apache.guacamole.auth.UserMapping;
package org.apache.guacamole.auth.basic;
import org.apache.guacamole.auth.Authorization;
package org.apache.guacamole.auth.basic;
package org.apache.guacamole.auth.basic;
package org.apache.guacamole.auth.basic;
import org.apache.guacamole.auth.UserMapping;
package org.apache.guacamole.auth.basic;
package org.apache.guacamole.auth;
package org.apache.guacamole.extension;
package org.apache.guacamole.extension;
package org.apache.guacamole.extension;
import org.apache.guacamole.resource.ClassPathResource;
import org.apache.guacamole.resource.Resource;
package org.apache.guacamole.extension;
package org.apache.guacamole.extension;
import org.apache.guacamole.auth.basic.BasicFileAuthenticationProvider;
import org.apache.guacamole.properties.BasicGuacamoleProperties;
import org.apache.guacamole.resource.Resource;
import org.apache.guacamole.resource.ResourceServlet;
import org.apache.guacamole.resource.SequenceResource;
import org.apache.guacamole.resource.WebApplicationResource;
package org.apache.guacamole.extension;
import org.apache.guacamole.properties.BasicGuacamoleProperties;
import org.apache.guacamole.resource.ByteArrayResource;
import org.apache.guacamole.resource.Resource;
import org.apache.guacamole.resource.WebApplicationResource;
package org.apache.guacamole.extension;
import org.apache.guacamole.resource.Resource;
package org.apache.guacamole.extension;
package org.apache.guacamole.log;
package org.apache.guacamole;
package org.apache.guacamole.properties;
Class<?> authProviderClass = org.apache.guacamole.GuacamoleClassLoader.getInstance().loadClass(authProviderClassName);
package org.apache.guacamole.properties;
package org.apache.guacamole.properties;
package org.apache.guacamole.properties;
package org.apache.guacamole.resource;
package org.apache.guacamole.resource;
package org.apache.guacamole.resource;
package org.apache.guacamole.resource;
package org.apache.guacamole.resource;
package org.apache.guacamole.resource;
package org.apache.guacamole.resource;
package org.apache.guacamole.resource;
package org.apache.guacamole.rest;
package org.apache.guacamole.rest;
package org.apache.guacamole.rest;
package org.apache.guacamole.rest;
package org.apache.guacamole.rest;
import org.apache.guacamole.GuacamoleSession;
import org.apache.guacamole.rest.connectiongroup.APIConnectionGroup;
package org.apache.guacamole.rest;
package org.apache.guacamole.rest;
import org.apache.guacamole.rest.auth.AuthenticationService;
package org.apache.guacamole.rest;
package org.apache.guacamole.rest;
import org.apache.guacamole.rest.auth.TokenRESTService;
import org.apache.guacamole.rest.connection.ConnectionRESTService;
import org.apache.guacamole.rest.connectiongroup.ConnectionGroupRESTService;
import org.apache.guacamole.rest.activeconnection.ActiveConnectionRESTService;
import org.apache.guacamole.rest.auth.AuthTokenGenerator;
import org.apache.guacamole.rest.auth.AuthenticationService;
import org.apache.guacamole.rest.auth.SecureRandomAuthTokenGenerator;
import org.apache.guacamole.rest.auth.TokenSessionMap;
import org.apache.guacamole.rest.history.HistoryRESTService;
import org.apache.guacamole.rest.language.LanguageRESTService;
import org.apache.guacamole.rest.patch.PatchRESTService;
import org.apache.guacamole.rest.schema.SchemaRESTService;
import org.apache.guacamole.rest.user.UserRESTService;
package org.apache.guacamole.rest.activeconnection;
package org.apache.guacamole.rest.activeconnection;
import org.apache.guacamole.GuacamoleSession;
import org.apache.guacamole.rest.APIPatch;
import org.apache.guacamole.rest.ObjectRetrievalService;
import org.apache.guacamole.rest.PATCH;
import org.apache.guacamole.rest.auth.AuthenticationService;
package org.apache.guacamole.rest.auth;
package org.apache.guacamole.rest.auth;
package org.apache.guacamole.rest.auth;
package org.apache.guacamole.rest.auth;
import org.apache.guacamole.GuacamoleSession;
package org.apache.guacamole.rest.auth;
import org.apache.guacamole.GuacamoleSession;
import org.apache.guacamole.properties.BasicGuacamoleProperties;
package org.apache.guacamole.rest.auth;
package org.apache.guacamole.rest.auth;
import org.apache.guacamole.GuacamoleSession;
import org.apache.guacamole.rest.APIRequest;
package org.apache.guacamole.rest.auth;
import org.apache.guacamole.GuacamoleSession;
package org.apache.guacamole.rest.auth;
package org.apache.guacamole.rest.connection;
package org.apache.guacamole.rest.connection;
package org.apache.guacamole.rest.connection;
import org.apache.guacamole.GuacamoleSession;
import org.apache.guacamole.rest.ObjectRetrievalService;
import org.apache.guacamole.rest.auth.AuthenticationService;
import org.apache.guacamole.rest.history.APIConnectionRecord;
package org.apache.guacamole.rest.connection;
package org.apache.guacamole.rest.connectiongroup;
import org.apache.guacamole.rest.connection.APIConnection;
package org.apache.guacamole.rest.connectiongroup;
package org.apache.guacamole.rest.connectiongroup;
import org.apache.guacamole.GuacamoleSession;
import org.apache.guacamole.rest.ObjectRetrievalService;
import org.apache.guacamole.rest.auth.AuthenticationService;
package org.apache.guacamole.rest.connectiongroup;
import org.apache.guacamole.rest.connection.APIConnection;
package org.apache.guacamole.rest.connectiongroup;
package org.apache.guacamole.rest.history;
package org.apache.guacamole.rest.history;
import org.apache.guacamole.rest.APIError;
import org.apache.guacamole.rest.APIException;
package org.apache.guacamole.rest.history;
import org.apache.guacamole.GuacamoleSession;
import org.apache.guacamole.rest.ObjectRetrievalService;
import org.apache.guacamole.rest.auth.AuthenticationService;
package org.apache.guacamole.rest.history;
package org.apache.guacamole.rest.language;
import org.apache.guacamole.extension.LanguageResourceService;
package org.apache.guacamole.rest.language;
package org.apache.guacamole.rest;
package org.apache.guacamole.rest.patch;
import org.apache.guacamole.extension.PatchResourceService;
import org.apache.guacamole.resource.Resource;
package org.apache.guacamole.rest.patch;
package org.apache.guacamole.rest.permission;
package org.apache.guacamole.rest.permission;
package org.apache.guacamole.rest.schema;
import org.apache.guacamole.GuacamoleSession;
import org.apache.guacamole.rest.ObjectRetrievalService;
import org.apache.guacamole.rest.auth.AuthenticationService;
package org.apache.guacamole.rest.schema;
package org.apache.guacamole.rest.user;
package org.apache.guacamole.rest.user;
package org.apache.guacamole.rest.user;
package org.apache.guacamole.rest.user;
package org.apache.guacamole.rest.user;
import org.apache.guacamole.GuacamoleSession;
import org.apache.guacamole.rest.APIPatch;
import static org.apache.guacamole.rest.APIPatch.Operation.add;
import static org.apache.guacamole.rest.APIPatch.Operation.remove;
import org.apache.guacamole.rest.ObjectRetrievalService;
import org.apache.guacamole.rest.PATCH;
import org.apache.guacamole.rest.auth.AuthenticationService;
import org.apache.guacamole.rest.permission.APIPermissionSet;
package org.apache.guacamole.rest.user;
package org.apache.guacamole.websocket;
import org.apache.guacamole.TunnelRequest;
import org.apache.guacamole.TunnelRequestService;
package org.apache.guacamole.websocket;
import org.apache.guacamole.TunnelLoader;
import org.apache.guacamole.TunnelRequestService;
package org.apache.guacamole.websocket;
import org.apache.guacamole.TunnelRequest;
package org.apache.guacamole.websocket.jetty8;
import org.apache.guacamole.TunnelRequestService;
import org.apache.guacamole.TunnelRequest;
}
package org.apache.guacamole.websocket.jetty8;
import org.apache.guacamole.HTTPTunnelRequest;
import org.apache.guacamole.TunnelRequest;
package org.apache.guacamole.websocket.jetty8;
import org.apache.guacamole.TunnelLoader;
Class.forName("org.apache.guacamole.websocket.jetty8.BasicGuacamoleWebSocketTunnelServlet");
package org.apache.guacamole.websocket.jetty8;
package org.apache.guacamole.websocket.jetty9;
import org.apache.guacamole.TunnelRequestService;
package org.apache.guacamole.websocket.jetty9;
import org.apache.guacamole.TunnelRequestService;
package org.apache.guacamole.websocket.jetty9;
import org.apache.guacamole.TunnelRequestService;
package org.apache.guacamole.websocket.jetty9;
package org.apache.guacamole.websocket.jetty9;
import org.apache.guacamole.TunnelLoader;
Class.forName("org.apache.guacamole.websocket.jetty9.BasicGuacamoleWebSocketTunnelServlet");
package org.apache.guacamole.websocket.jetty9;
import org.apache.guacamole.TunnelRequest;
package org.apache.guacamole.websocket.jetty9;
package org.apache.guacamole.websocket;
package org.apache.guacamole.websocket.tomcat;
import org.apache.guacamole.TunnelRequestService;
import org.apache.guacamole.TunnelRequest;
package org.apache.guacamole.websocket.tomcat;
import org.apache.guacamole.HTTPTunnelRequest;
import org.apache.guacamole.TunnelRequest;
package org.apache.guacamole.websocket.tomcat;
import org.apache.guacamole.TunnelLoader;
Class.forName("org.apache.guacamole.websocket.tomcat.BasicGuacamoleWebSocketTunnelServlet");
package org.apache.guacamole.websocket.tomcat;
"0.9.9-incubating"
package org.apache.guacamole.auth.file;
package org.apache.guacamole.auth.file;
package org.apache.guacamole.auth.file;
package org.apache.guacamole.auth.file;
public class FileAuthenticationProvider extends SimpleAuthenticationProvider {
private final Logger logger = LoggerFactory.getLogger(FileAuthenticationProvider.class);
@Deprecated
public static final String USER_MAPPING_FILENAME = "user-mapping.xml";
public FileAuthenticationProvider() throws GuacamoleException {
if (userMappingFile != null)
logger.warn("The \"basic-user-mapping\" property is deprecated. Please use the \"GUACAMOLE_HOME/user-mapping.xml\" file instead.");
userMappingFile = new File(environment.getGuacamoleHome(), USER_MAPPING_FILENAME);
package org.apache.guacamole.auth.file;
package org.apache.guacamole.auth.file;
package org.apache.guacamole.auth.file;
package org.apache.guacamole.auth.file;
package org.apache.guacamole.auth.file;
import org.apache.guacamole.auth.file.FileAuthenticationProvider;
bindAuthenticationProvider(FileAuthenticationProvider.class);
import org.apache.guacamole.properties.StringSetProperty;
*/
public final StringSetProperty ALLOWED_LANGUAGES = new StringSetProperty() {
@Override
public String getName() { return "allowed-languages"; }
};
parsedAllowedLanguages = environment.getProperty(ALLOWED_LANGUAGES);
import org.apache.guacamole.properties.IntegerGuacamoleProperty;
private final IntegerGuacamoleProperty API_SESSION_TIMEOUT =
new IntegerGuacamoleProperty() {
@Override
public String getName() { return "api-session-timeout"; }
};
sessionTimeoutValue = environment.getProperty(API_SESSION_TIMEOUT, 60);
import org.apache.guacamole.tunnel.TunnelModule;
import org.apache.guacamole.rest.auth.HashTokenSessionMap;
public class GuacamoleServletContextListener extends GuiceServletContextListener {
private final Logger logger = LoggerFactory.getLogger(GuacamoleServletContextListener.class);
sessionMap = new HashTokenSessionMap(environment);
public class HashTokenSessionMap implements TokenSessionMap {
private static final Logger logger = LoggerFactory.getLogger(HashTokenSessionMap.class);
public HashTokenSessionMap(Environment environment) {
package org.apache.guacamole.tunnel;
package org.apache.guacamole.tunnel;
import org.apache.guacamole.tunnel.http.RestrictedGuacamoleHTTPTunnelServlet;
serve("/tunnel").with(RestrictedGuacamoleHTTPTunnelServlet.class);
package org.apache.guacamole.tunnel;
import org.apache.guacamole.GuacamoleClientException;
import org.apache.guacamole.GuacamoleException;
package org.apache.guacamole.tunnel;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleSecurityException;
import org.apache.guacamole.GuacamoleSession;
import org.apache.guacamole.GuacamoleUnauthorizedException;
package org.apache.guacamole.tunnel.http;
import org.apache.guacamole.tunnel.TunnelRequest;
package org.apache.guacamole.tunnel.http;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.tunnel.TunnelRequestService;
public class RestrictedGuacamoleHTTPTunnelServlet extends GuacamoleHTTPTunnelServlet {
private static final Logger logger = LoggerFactory.getLogger(RestrictedGuacamoleHTTPTunnelServlet.class);
package org.apache.guacamole.tunnel.http;
package org.apache.guacamole.tunnel;
package org.apache.guacamole.tunnel.websocket;
import org.apache.guacamole.tunnel.TunnelRequest;
import org.apache.guacamole.tunnel.TunnelRequestService;
import org.apache.guacamole.websocket.GuacamoleWebSocketTunnelEndpoint;
public class RestrictedGuacamoleWebSocketTunnelEndpoint extends GuacamoleWebSocketTunnelEndpoint {
package org.apache.guacamole.tunnel.websocket;
import org.apache.guacamole.tunnel.TunnelLoader;
import org.apache.guacamole.tunnel.TunnelRequestService;
ServerEndpointConfig.Builder.create(RestrictedGuacamoleWebSocketTunnelEndpoint.class, "/websocket-tunnel")
.configurator(new RestrictedGuacamoleWebSocketTunnelEndpoint.Configurator(tunnelRequestServiceProvider))
package org.apache.guacamole.tunnel.websocket;
import org.apache.guacamole.tunnel.TunnelRequest;
package org.apache.guacamole.tunnel.websocket.jetty8;
import org.apache.guacamole.tunnel.http.HTTPTunnelRequest;
import org.apache.guacamole.tunnel.TunnelRequest;
package org.apache.guacamole.tunnel.websocket.jetty8;
import org.apache.guacamole.tunnel.TunnelRequestService;
import org.apache.guacamole.tunnel.TunnelRequest;
public class RestrictedGuacamoleWebSocketTunnelServlet extends GuacamoleWebSocketTunnelServlet {
package org.apache.guacamole.tunnel.websocket.jetty8;
import org.apache.guacamole.tunnel.TunnelLoader;
serve("/websocket-tunnel").with(RestrictedGuacamoleWebSocketTunnelServlet.class);
package org.apache.guacamole.tunnel.websocket.jetty8;
package org.apache.guacamole.tunnel.websocket.jetty9;
private static final Logger logger = LoggerFactory.getLogger(RestrictedGuacamoleWebSocketTunnelServlet.class);
package org.apache.guacamole.tunnel.websocket.jetty9;
import org.apache.guacamole.tunnel.TunnelRequestService;
public class RestrictedGuacamoleWebSocketCreator implements WebSocketCreator {
public RestrictedGuacamoleWebSocketCreator(TunnelRequestService tunnelRequestService) {
return new RestrictedGuacamoleWebSocketTunnelListener(tunnelRequestService);
package org.apache.guacamole.tunnel.websocket.jetty9;
import org.apache.guacamole.tunnel.TunnelRequestService;
public class RestrictedGuacamoleWebSocketTunnelListener extends GuacamoleWebSocketTunnelListener {
public RestrictedGuacamoleWebSocketTunnelListener(TunnelRequestService tunnelRequestService) {
package org.apache.guacamole.tunnel.websocket.jetty9;
import org.apache.guacamole.tunnel.TunnelRequestService;
public class RestrictedGuacamoleWebSocketTunnelServlet extends WebSocketServlet {
factory.setCreator(new RestrictedGuacamoleWebSocketCreator(tunnelRequestService));
package org.apache.guacamole.tunnel.websocket.jetty9;
import org.apache.guacamole.tunnel.TunnelLoader;
serve("/websocket-tunnel").with(RestrictedGuacamoleWebSocketTunnelServlet.class);
package org.apache.guacamole.tunnel.websocket.jetty9;
import org.apache.guacamole.tunnel.TunnelRequest;
package org.apache.guacamole.tunnel.websocket.jetty9;
package org.apache.guacamole.tunnel.websocket;
package org.apache.guacamole.tunnel.websocket.tomcat;
import org.apache.guacamole.tunnel.http.HTTPTunnelRequest;
import org.apache.guacamole.tunnel.TunnelRequest;
package org.apache.guacamole.tunnel.websocket.tomcat;
import org.apache.guacamole.tunnel.TunnelRequestService;
import org.apache.guacamole.tunnel.TunnelRequest;
public class RestrictedGuacamoleWebSocketTunnelServlet extends GuacamoleWebSocketTunnelServlet {
package org.apache.guacamole.tunnel.websocket.tomcat;
import org.apache.guacamole.tunnel.TunnelLoader;
serve("/websocket-tunnel").with(RestrictedGuacamoleWebSocketTunnelServlet.class);
package org.apache.guacamole.tunnel.websocket.tomcat;
"org.apache.guacamole.tunnel.websocket.WebSocketTunnelModule",
"org.apache.guacamole.tunnel.websocket.jetty8.WebSocketTunnelModule",
"org.apache.guacamole.tunnel.websocket.jetty9.WebSocketTunnelModule",
"org.apache.guacamole.tunnel.websocket.tomcat.WebSocketTunnelModule"
Class.forName("org.apache.guacamole.tunnel.websocket.jetty8.RestrictedGuacamoleWebSocketTunnelServlet");
Class.forName("org.apache.guacamole.tunnel.websocket.jetty9.RestrictedGuacamoleWebSocketTunnelServlet");
Class.forName("org.apache.guacamole.tunnel.websocket.tomcat.RestrictedGuacamoleWebSocketTunnelServlet");
catch (LinkageError e) {
throw new GuacamoleException("Authentication provider class cannot be loaded (wrong version of API?).", e);
}
import org.apache.guacamole.tunnel.StreamInterceptingTunnel;
private final Map<String, StreamInterceptingTunnel> tunnels =
new ConcurrentHashMap<String, StreamInterceptingTunnel>();
public Map<String, StreamInterceptingTunnel> getTunnels() {
public void addTunnel(StreamInterceptingTunnel tunnel) {
StreamInterceptingTunnel monitoredTunnel = new StreamInterceptingTunnel(tunnel) {
import org.apache.guacamole.rest.tunnel.TunnelRESTService;
bind(TunnelRESTService.class);
static final String INTERNAL_DATA_OPCODE = "";
import org.apache.guacamole.protocol.GuacamoleInstruction;
remote.sendText(new GuacamoleInstruction(
GuacamoleTunnel.INTERNAL_DATA_OPCODE,
tunnel.getUUID().toString()
).toString());
import org.apache.guacamole.protocol.GuacamoleInstruction;
connection.sendMessage(new GuacamoleInstruction(
GuacamoleTunnel.INTERNAL_DATA_OPCODE,
tunnel.getUUID().toString()
).toString());
import org.apache.guacamole.protocol.GuacamoleInstruction;
remote.sendString(new GuacamoleInstruction(
GuacamoleTunnel.INTERNAL_DATA_OPCODE,
tunnel.getUUID().toString()
).toString());
import org.apache.guacamole.protocol.GuacamoleInstruction;
outbound.writeTextMessage(CharBuffer.wrap(new GuacamoleInstruction(
GuacamoleTunnel.INTERNAL_DATA_OPCODE,
tunnel.getUUID().toString()
).toString()));
private static final long STREAM_WAIT_TIMEOUT = 1000;
stream.wait(STREAM_WAIT_TIMEOUT);
static final String INTERNAL_DATA_OPCODE = "";
import org.apache.guacamole.protocol.GuacamoleInstruction;
remote.sendText(new GuacamoleInstruction(
GuacamoleTunnel.INTERNAL_DATA_OPCODE,
tunnel.getUUID().toString()
).toString());
import org.apache.guacamole.tunnel.StreamInterceptingTunnel;
private final Map<String, StreamInterceptingTunnel> tunnels =
new ConcurrentHashMap<String, StreamInterceptingTunnel>();
public Map<String, StreamInterceptingTunnel> getTunnels() {
public void addTunnel(StreamInterceptingTunnel tunnel) {
import org.apache.guacamole.rest.tunnel.TunnelRESTService;
bind(TunnelRESTService.class);
StreamInterceptingTunnel monitoredTunnel = new StreamInterceptingTunnel(tunnel) {
import org.apache.guacamole.protocol.GuacamoleInstruction;
connection.sendMessage(new GuacamoleInstruction(
GuacamoleTunnel.INTERNAL_DATA_OPCODE,
tunnel.getUUID().toString()
).toString());
import org.apache.guacamole.protocol.GuacamoleInstruction;
remote.sendString(new GuacamoleInstruction(
GuacamoleTunnel.INTERNAL_DATA_OPCODE,
tunnel.getUUID().toString()
).toString());
import org.apache.guacamole.protocol.GuacamoleInstruction;
outbound.writeTextMessage(CharBuffer.wrap(new GuacamoleInstruction(
GuacamoleTunnel.INTERNAL_DATA_OPCODE,
tunnel.getUUID().toString()
).toString()));
private static final Logger logger =
LoggerFactory.getLogger(StreamInterceptingTunnel.class);
private final OutputStreamInterceptingFilter outputStreamFilter =
new OutputStreamInterceptingFilter(this);
logger.debug("Intercepting output stream #{} of tunnel \"{}\".",
outputStreamFilter.interceptStream(index, new BufferedOutputStream(stream));
logger.debug("Intercepted output stream #{} of tunnel \"{}\" ended.",
index, getUUID());
return new FilteredGuacamoleReader(super.acquireReader(), outputStreamFilter);
outputStreamFilter.closeAllInterceptedStreams();
import java.io.InputStream;
import javax.ws.rs.POST;
@POST
@Consumes(MediaType.WILDCARD)
@Path("/{tunnel}/streams/{index}/{filename}")
public void setStreamContents(@QueryParam("token") String authToken,
@PathParam("tunnel") String tunnelUUID,
@PathParam("index") final int streamIndex,
@PathParam("filename") String filename,
InputStream data)
throws GuacamoleException {
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
Map<String, StreamInterceptingTunnel> tunnels = session.getTunnels();
final StreamInterceptingTunnel tunnel = tunnels.get(tunnelUUID);
if (tunnel == null)
throw new GuacamoleResourceNotFoundException("No such tunnel.");
tunnel.interceptStream(streamIndex, data);
}
import java.io.BufferedInputStream;
import java.io.InputStream;
private final InputStreamInterceptingFilter inputStreamFilter =
new InputStreamInterceptingFilter(this);
public void interceptStream(int index, InputStream stream) {
logger.debug("Intercepting input stream #{} of tunnel \"{}\".",
index, getUUID());
inputStreamFilter.interceptStream(index, new BufferedInputStream(stream));
logger.debug("Intercepted input stream #{} of tunnel \"{}\" ended.",
index, getUUID());
}
GuacamoleReader reader = super.acquireReader();
reader = new FilteredGuacamoleReader(reader, inputStreamFilter);
reader = new FilteredGuacamoleReader(reader, outputStreamFilter);
return reader;
inputStreamFilter.closeAllInterceptedStreams();
private final Integer statusCode;
PERMISSION_DENIED(Response.Status.FORBIDDEN),
STREAM_ERROR(Response.Status.BAD_REQUEST);
public APIError(int statusCode, String message) {
this.type       = Type.STREAM_ERROR;
this.message    = message;
this.statusCode = statusCode;
this.expected   = null;
}
this.type       = type;
this.message    = message;
this.statusCode = null;
this.expected   = null;
this.type       = type;
this.message    = message;
this.statusCode = null;
this.expected   = expected;
public Integer getStatusCode() {
return statusCode;
}
import org.apache.guacamole.protocol.GuacamoleStatus;
public APIException(int status, String message) {
this(new APIError(status, message));
}
public APIException(GuacamoleStatus status, String message) {
this(status.getGuacamoleStatusCode(), message);
}
import org.apache.guacamole.tunnel.GuacamoleStreamException;
catch (GuacamoleStreamException e) {
String message = e.getMessage();
if (message == null)
message = "Error reported by stream.";
throw new APIException(
e.getStatus(),
message
);
}
public static GuacamoleStatus fromGuacamoleStatusCode(int code) {
for (GuacamoleStatus status : values()) {
if (status.getGuacamoleStatusCode() == code)
return status;
}
return null;
}
try {
tunnel.interceptStream(streamIndex, output);
}
catch (GuacamoleException e) {
throw new IOException(e);
}
import org.apache.guacamole.protocol.GuacamoleStatus;
int code;
try {
code = Integer.parseInt(status);
}
catch (NumberFormatException e) {
logger.debug("Translating invalid status code \"{}\" to SERVER_ERROR.", status);
code = GuacamoleStatus.SERVER_ERROR.getGuacamoleStatusCode();
}
stream.setStreamError(code, args.get(1));
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.protocol.GuacamoleStatus;
private GuacamoleException streamError = null;
public void setStreamError(GuacamoleException streamError) {
this.streamError = streamError;
}
public void setStreamError(int code, String message) {
GuacamoleStatus status = GuacamoleStatus.fromGuacamoleStatusCode(code);
if (status == null)
status = GuacamoleStatus.SERVER_ERROR;
setStreamError(new GuacamoleStreamException(status, message));
}
public boolean hasStreamError() {
return streamError != null;
}
public GuacamoleException getStreamError() {
return streamError;
}
public void interceptStream(int index, T stream) throws GuacamoleException {
if (interceptedStream.hasStreamError())
throw interceptedStream.getStreamError();
public void interceptStream(int index, OutputStream stream)
throws GuacamoleException {
try {
outputStreamFilter.interceptStream(index, new BufferedOutputStream(stream));
}
finally {
logger.debug("Intercepted output stream #{} of tunnel \"{}\" ended.",
index, getUUID());
}
public void interceptStream(int index, InputStream stream)
throws GuacamoleException {
try {
inputStreamFilter.interceptStream(index, new BufferedInputStream(stream));
}
finally {
logger.debug("Intercepted input stream #{} of tunnel \"{}\" ended.",
index, getUUID());
}
public static GuacamoleStatus fromGuacamoleStatusCode(int code) {
for (GuacamoleStatus status : values()) {
if (status.getGuacamoleStatusCode() == code)
return status;
}
return null;
}
private final Integer statusCode;
PERMISSION_DENIED(Response.Status.FORBIDDEN),
STREAM_ERROR(Response.Status.BAD_REQUEST);
public APIError(int statusCode, String message) {
this.type       = Type.STREAM_ERROR;
this.message    = message;
this.statusCode = statusCode;
this.expected   = null;
}
this.type       = type;
this.message    = message;
this.statusCode = null;
this.expected   = null;
this.type       = type;
this.message    = message;
this.statusCode = null;
this.expected   = expected;
public Integer getStatusCode() {
return statusCode;
}
import org.apache.guacamole.protocol.GuacamoleStatus;
public APIException(int status, String message) {
this(new APIError(status, message));
}
public APIException(GuacamoleStatus status, String message) {
this(status.getGuacamoleStatusCode(), message);
}
import org.apache.guacamole.tunnel.GuacamoleStreamException;
catch (GuacamoleStreamException e) {
String message = e.getMessage();
if (message == null)
message = "Error reported by stream.";
throw new APIException(
e.getStatus(),
message
);
}
import java.io.InputStream;
import javax.ws.rs.POST;
try {
tunnel.interceptStream(streamIndex, output);
}
catch (GuacamoleException e) {
throw new IOException(e);
}
@POST
@Consumes(MediaType.WILDCARD)
@Path("/{tunnel}/streams/{index}/{filename}")
public void setStreamContents(@QueryParam("token") String authToken,
@PathParam("tunnel") String tunnelUUID,
@PathParam("index") final int streamIndex,
@PathParam("filename") String filename,
InputStream data)
throws GuacamoleException {
GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
Map<String, StreamInterceptingTunnel> tunnels = session.getTunnels();
final StreamInterceptingTunnel tunnel = tunnels.get(tunnelUUID);
if (tunnel == null)
throw new GuacamoleResourceNotFoundException("No such tunnel.");
tunnel.interceptStream(streamIndex, data);
}
import java.io.BufferedInputStream;
import java.io.InputStream;
private static final Logger logger =
LoggerFactory.getLogger(StreamInterceptingTunnel.class);
private final InputStreamInterceptingFilter inputStreamFilter =
new InputStreamInterceptingFilter(this);
private final OutputStreamInterceptingFilter outputStreamFilter =
new OutputStreamInterceptingFilter(this);
public void interceptStream(int index, OutputStream stream)
throws GuacamoleException {
logger.debug("Intercepting output stream #{} of tunnel \"{}\".",
try {
outputStreamFilter.interceptStream(index, new BufferedOutputStream(stream));
finally {
logger.debug("Intercepted output stream #{} of tunnel \"{}\" ended.",
index, getUUID());
}
}
public void interceptStream(int index, InputStream stream)
throws GuacamoleException {
logger.debug("Intercepting input stream #{} of tunnel \"{}\".",
index, getUUID());
try {
inputStreamFilter.interceptStream(index, new BufferedInputStream(stream));
}
finally {
logger.debug("Intercepted input stream #{} of tunnel \"{}\" ended.",
index, getUUID());
}
GuacamoleReader reader = super.acquireReader();
reader = new FilteredGuacamoleReader(reader, inputStreamFilter);
reader = new FilteredGuacamoleReader(reader, outputStreamFilter);
return reader;
inputStreamFilter.closeAllInterceptedStreams();
outputStreamFilter.closeAllInterceptedStreams();
recordModel.setUsername(user.getIdentifier());
recordModel.setConnectionName(connection.getName());
recordModel.setUsername(user.getIdentifier());
recordModel.setConnectionName(connection.getName());
private boolean sessionAffinityEnabled;
public boolean isSessionAffinityEnabled() {
return sessionAffinityEnabled;
}
public void setSessionAffinityEnabled(boolean sessionAffinityEnabled) {
this.sessionAffinityEnabled = sessionAffinityEnabled;
}
import org.apache.guacamole.auth.jdbc.connection.ConnectionService;
import org.apache.guacamole.auth.jdbc.tunnel.GuacamoleTunnelService;
import org.apache.guacamole.form.BooleanField;
public static final String ENABLE_SESSION_AFFINITY = "enable-session-affinity";
new NumericField(MAX_CONNECTIONS_PER_USER_NAME),
new BooleanField(ENABLE_SESSION_AFFINITY, "true")
attributes.put(ENABLE_SESSION_AFFINITY,
getModel().isSessionAffinityEnabled() ? "true" : "");
getModel().setSessionAffinityEnabled(
"true".equals(attributes.get(ENABLE_SESSION_AFFINITY)));
public boolean isSessionAffinityEnabled() {
return getModel().isSessionAffinityEnabled();
}
private Collection<String> getPreferredConnections(AuthenticatedUser user,
Collection<String> identifiers) {
for (String identifier : identifiers) {
if (user.isPreferredConnection(identifier))
return Collections.singletonList(identifier);
}
return identifiers;
}
if (connectionGroup.isSessionAffinityEnabled())
identifiers = getPreferredConnections(user, identifiers);
if (connectionGroup.isSessionAffinityEnabled())
user.preferConnection(connection.getIdentifier());
import java.util.Collections;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
private final Set<String> preferredConnections =
Collections.newSetFromMap(new ConcurrentHashMap<String, Boolean>());
public boolean isPreferredConnection(String identifier) {
return preferredConnections.contains(identifier);
}
public void preferConnection(String identifier) {
preferredConnections.add(identifier);
}
private boolean sessionAffinityEnabled;
public boolean isSessionAffinityEnabled() {
return sessionAffinityEnabled;
}
public void setSessionAffinityEnabled(boolean sessionAffinityEnabled) {
this.sessionAffinityEnabled = sessionAffinityEnabled;
}
import org.apache.guacamole.auth.jdbc.connection.ConnectionService;
import org.apache.guacamole.auth.jdbc.tunnel.GuacamoleTunnelService;
import org.apache.guacamole.form.BooleanField;
public static final String ENABLE_SESSION_AFFINITY = "enable-session-affinity";
new NumericField(MAX_CONNECTIONS_PER_USER_NAME),
new BooleanField(ENABLE_SESSION_AFFINITY, "true")
attributes.put(ENABLE_SESSION_AFFINITY,
getModel().isSessionAffinityEnabled() ? "true" : "");
getModel().setSessionAffinityEnabled(
"true".equals(attributes.get(ENABLE_SESSION_AFFINITY)));
public boolean isSessionAffinityEnabled() {
return getModel().isSessionAffinityEnabled();
}
private Collection<String> getPreferredConnections(AuthenticatedUser user,
Collection<String> identifiers) {
for (String identifier : identifiers) {
if (user.isPreferredConnection(identifier))
return Collections.singletonList(identifier);
}
return identifiers;
}
if (connectionGroup.isSessionAffinityEnabled())
identifiers = getPreferredConnections(user, identifiers);
if (connectionGroup.isSessionAffinityEnabled())
user.preferConnection(connection.getIdentifier());
import java.util.Collections;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
private final Set<String> preferredConnections =
Collections.newSetFromMap(new ConcurrentHashMap<String, Boolean>());
public boolean isPreferredConnection(String identifier) {
return preferredConnections.contains(identifier);
}
public void preferConnection(String identifier) {
preferredConnections.add(identifier);
}
import org.apache.guacamole.rest.session.UserContextResourceFactory;
import org.apache.guacamole.rest.session.SessionResource;
import com.google.inject.assistedinject.FactoryModuleBuilder;
bind(SessionResource.class);
install(new FactoryModuleBuilder().build(UserContextResourceFactory.class));
import org.apache.guacamole.GuacamoleClientException;
if (modifiedObject == null)
throw new GuacamoleClientException("Data must be submitted when updating objects.");
if (object == null)
throw new GuacamoleClientException("Data must be submitted when creating objects.");
import org.apache.guacamole.net.auth.UserContext;
create(UserContext userContext, Directory<InternalType> directory,
InternalType object);
return resourceFactory.create(userContext, directory, object);
import org.apache.guacamole.rest.connection.ConnectionModule;
install(new ConnectionModule());
import org.apache.guacamole.rest.directory.DirectoryResource;
import org.apache.guacamole.rest.directory.DirectoryResourceFactory;
import com.google.inject.Inject;
import javax.ws.rs.Path;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.auth.Connection;
import org.apache.guacamole.rest.connection.APIConnection;
@Inject
private DirectoryResourceFactory<Connection, APIConnection> connectionDirectoryResourceFactory;
@Path("connections")
public DirectoryResource<Connection, APIConnection> getConnectionDirectoryResource()
throws GuacamoleException {
return connectionDirectoryResourceFactory.create(userContext,
userContext.getConnectionDirectory());
}
import org.apache.guacamole.rest.connectiongroup.ConnectionGroupModule;
install(new ConnectionGroupModule());
import org.apache.guacamole.net.auth.ConnectionGroup;
import org.apache.guacamole.rest.connectiongroup.APIConnectionGroup;
private DirectoryResourceFactory<Connection, APIConnection>
connectionDirectoryResourceFactory;
@Inject
private DirectoryResourceFactory<ConnectionGroup, APIConnectionGroup>
connectionGroupDirectoryResourceFactory;
@Path("connectionGroups")
public DirectoryResource<ConnectionGroup, APIConnectionGroup> getConnectionGroupDirectoryResource()
throws GuacamoleException {
return connectionGroupDirectoryResourceFactory.create(userContext,
userContext.getConnectionGroupDirectory());
}
import org.apache.guacamole.rest.activeconnection.ActiveConnectionModule;
install(new ActiveConnectionModule());
import org.apache.guacamole.net.auth.ActiveConnection;
import org.apache.guacamole.rest.activeconnection.APIActiveConnection;
@Inject
private DirectoryResourceFactory<ActiveConnection, APIActiveConnection>
activeConnectionDirectoryResourceFactory;
@Path("activeConnections")
public DirectoryResource<ActiveConnection, APIActiveConnection>
getActiveConnectionDirectoryResource() throws GuacamoleException {
return activeConnectionDirectoryResourceFactory.create(userContext,
userContext.getActiveConnectionDirectory());
}
import org.apache.guacamole.rest.user.UserModule;
install(new UserModule());
import org.apache.guacamole.net.auth.User;
import org.apache.guacamole.rest.user.APIUser;
@Inject
private DirectoryResourceFactory<User, APIUser> userDirectoryResourceFactory;
@Path("users")
public DirectoryResource<User, APIUser> getUserDirectoryResource()
throws GuacamoleException {
return userDirectoryResourceFactory.create(userContext,
userContext.getUserDirectory());
}
package org.apache.guacamole.rest.permission;
import org.apache.guacamole.rest.permission.PermissionSetResource;
public PermissionSetResource getPermissions() {
return new PermissionSetResource(user);
import java.util.UUID;
public APIUser createObject(APIUser object) throws GuacamoleException {
if (object.getPassword() == null)
object.setPassword(UUID.randomUUID().toString());
return super.createObject(object);
}
@Override
public class HistoryResource {
private final UserContext userContext;
public HistoryResource(UserContext userContext) {
this.userContext = userContext;
}
@Path("connections")
public List<APIConnectionRecord> getConnectionHistory(
import org.apache.guacamole.rest.history.HistoryResource;
@Path("history")
public HistoryResource getHistoryResource() {
return new HistoryResource(userContext);
}
import org.apache.guacamole.rest.schema.SchemaResource;
@Path("schema")
public SchemaResource getSchemaResource() {
return new SchemaResource(userContext);
}
import org.apache.guacamole.rest.session.SessionDataRESTService;
bind(SessionDataRESTService.class);
public class SessionDataRESTService {
Class<?> superclass = method.getDeclaringClass().getSuperclass();
if (superclass != null) {
try {
return isRESTMethod(superclass.getMethod(method.getName(),
method.getParameterTypes()));
}
catch (NoSuchMethodException e) {
return false;
}
}
import org.apache.guacamole.rest.session.SessionRESTService;
import org.apache.guacamole.rest.session.SessionResourceFactory;
bind(SessionRESTService.class);
install(new FactoryModuleBuilder().build(SessionResourceFactory.class));
import com.google.inject.assistedinject.Assisted;
import com.google.inject.assistedinject.AssistedInject;
public class SessionResource {
private final GuacamoleSession session;
@AssistedInject
public SessionResource(@Assisted GuacamoleSession session) {
this.session = session;
}
@Path("data/{dataSource}")
import javax.ws.rs.Path;
if (Path.class.isAssignableFrom(annotationType))
return true;
import javax.ws.rs.core.MediaType;
super(Response.status(error.getType().getStatus())
.type(MediaType.APPLICATION_JSON)
.entity(error)
.build());
import org.apache.guacamole.rest.tunnel.TunnelCollectionResource;
@Path("tunnels")
public TunnelCollectionResource getTunnelCollectionResource() {
return new TunnelCollectionResource(session);
}
import org.apache.guacamole.net.auth.AuthenticationProvider;
public UserContext getUserContext(String authProviderIdentifier)
throws GuacamoleException {
for (UserContext userContext : getUserContexts()) {
AuthenticationProvider authProvider = userContext.getAuthenticationProvider();
if (authProvider.getIdentifier().equals(authProviderIdentifier))
return userContext;
}
throw new GuacamoleResourceNotFoundException("Session not associated "
}
UserContext userContext = session.getUserContext(authProviderIdentifier);
UserContext userContext = session.getUserContext(authProviderIdentifier);
import org.apache.guacamole.net.auth.AuthenticationProvider;
public UserContext getUserContext(String authProviderIdentifier)
throws GuacamoleException {
for (UserContext userContext : getUserContexts()) {
AuthenticationProvider authProvider = userContext.getAuthenticationProvider();
if (authProvider.getIdentifier().equals(authProviderIdentifier))
return userContext;
}
throw new GuacamoleResourceNotFoundException("Session not associated "
}
import javax.ws.rs.core.MediaType;
super(Response.status(error.getType().getStatus())
.type(MediaType.APPLICATION_JSON)
.entity(error)
.build());
import javax.ws.rs.Path;
if (Path.class.isAssignableFrom(annotationType))
return true;
Class<?> superclass = method.getDeclaringClass().getSuperclass();
if (superclass != null) {
try {
return isRESTMethod(superclass.getMethod(method.getName(),
method.getParameterTypes()));
}
catch (NoSuchMethodException e) {
return false;
}
}
import org.apache.guacamole.rest.session.UserContextResourceFactory;
import org.apache.guacamole.rest.session.SessionRESTService;
import com.google.inject.assistedinject.FactoryModuleBuilder;
import org.apache.guacamole.rest.activeconnection.ActiveConnectionModule;
import org.apache.guacamole.rest.connection.ConnectionModule;
import org.apache.guacamole.rest.connectiongroup.ConnectionGroupModule;
import org.apache.guacamole.rest.session.SessionResourceFactory;
import org.apache.guacamole.rest.user.UserModule;
bind(SessionRESTService.class);
install(new FactoryModuleBuilder().build(SessionResourceFactory.class));
install(new FactoryModuleBuilder().build(UserContextResourceFactory.class));
install(new ActiveConnectionModule());
install(new ConnectionModule());
install(new ConnectionGroupModule());
install(new UserModule());
public class HistoryResource {
private final UserContext userContext;
public HistoryResource(UserContext userContext) {
this.userContext = userContext;
}
@Path("connections")
public List<APIConnectionRecord> getConnectionHistory(
package org.apache.guacamole.rest.permission;
UserContext userContext = session.getUserContext(authProviderIdentifier);
catch (RuntimeException e) {
throw new GuacamoleException(e.getMessage(), e);
}
if (message != null)
logger.error("Unexpected internal error: {}", message);
else
logger.error("An internal error occurred, but did not contain "
"an error message. Enable debug-level logging for "
"details.");
"Unexpected server error."
import org.apache.guacamole.rest.directory.DirectoryResource;
.implement(
new TypeLiteral<DirectoryResource<ActiveConnection, APIActiveConnection>>() {},
ActiveConnectionDirectoryResource.class
)
import org.apache.guacamole.rest.directory.DirectoryResource;
.implement(
new TypeLiteral<DirectoryResource<Connection, APIConnection>>() {},
ConnectionDirectoryResource.class
)
public abstract class DirectoryObjectResource<InternalType extends Identifiable, ExternalType> {
public DirectoryObjectResource(Directory<InternalType> directory, InternalType object,
public abstract class DirectoryResource<InternalType extends Identifiable, ExternalType> {
public DirectoryResource(UserContext userContext, Directory<InternalType> directory,
catch (RuntimeException e) {
throw new GuacamoleException(e.getMessage(), e);
}
if (message != null)
logger.error("Unexpected internal error: {}", message);
else
logger.error("An internal error occurred, but did not contain "
"an error message. Enable debug-level logging for "
"details.");
"Unexpected server error."
import org.apache.guacamole.rest.directory.DirectoryResource;
.implement(
new TypeLiteral<DirectoryResource<ActiveConnection, APIActiveConnection>>() {},
ActiveConnectionDirectoryResource.class
)
import org.apache.guacamole.rest.directory.DirectoryResource;
.implement(
new TypeLiteral<DirectoryResource<Connection, APIConnection>>() {},
ConnectionDirectoryResource.class
)
public abstract class DirectoryObjectResource<InternalType extends Identifiable, ExternalType> {
public DirectoryObjectResource(Directory<InternalType> directory, InternalType object,
public abstract class DirectoryResource<InternalType extends Identifiable, ExternalType> {
public DirectoryResource(UserContext userContext, Directory<InternalType> directory,
public abstract class AbstractActiveConnection extends AbstractIdentifiable
implements ActiveConnection {
public abstract class AbstractAuthenticatedUser extends AbstractIdentifiable
implements AuthenticatedUser {
public abstract class AbstractConnection extends AbstractIdentifiable
implements Connection {
public abstract class AbstractConnectionGroup extends AbstractIdentifiable
implements ConnectionGroup {
public abstract class AbstractUser extends AbstractIdentifiable
implements User {
public abstract class AbstractActiveConnection extends AbstractIdentifiable
implements ActiveConnection {
public abstract class AbstractAuthenticatedUser extends AbstractIdentifiable
implements AuthenticatedUser {
public abstract class AbstractConnection extends AbstractIdentifiable
implements Connection {
public abstract class AbstractConnectionGroup extends AbstractIdentifiable
implements ConnectionGroup {
public abstract class AbstractUser extends AbstractIdentifiable
implements User {
import java.util.Collections;
import java.util.Set;
import org.apache.guacamole.GuacamoleException;
@Override
public Set<String> getSharingProfileIdentifiers()
throws GuacamoleException {
return Collections.<String>emptySet();
}
import java.util.Set;
public Set<String> getSharingProfileIdentifiers() throws GuacamoleException;
public String getSharingProfileIdentifier();
public String getSharingProfileName();
Directory<SharingProfile> getSharingProfileDirectory()
throws GuacamoleException;
Collection<Form> getSharingProfileAttributes();
import org.apache.guacamole.net.auth.SharingProfile;
public Directory<SharingProfile> getSharingProfileDirectory()
throws GuacamoleException {
return new SimpleDirectory<SharingProfile>();
}
@Override
@Override
public Collection<Form> getSharingProfileAttributes() {
return Collections.<Form>emptyList();
}
import java.util.Set;
public Set<String> getSharingProfileIdentifiers() {
throw new UnsupportedOperationException("Operation not supported.");
}
@Override
ObjectPermissionSet getSharingProfilePermissions()
throws GuacamoleException;
CREATE_SHARING_PROFILE,
@Override
public ObjectPermissionSet getSharingProfilePermissions() {
return new SimpleObjectPermissionSet();
}
private String sharingProfileIdentifier;
public String getSharingProfileIdentifier() {
return sharingProfileIdentifier;
}
@Override
public void setSharingProfileIdentifier(String sharingProfileIdentifier) {
this.sharingProfileIdentifier = sharingProfileIdentifier;
}
@Override
String getSharingProfileIdentifier();
void setSharingProfileIdentifier(String sharingProfileIdentifier);
public static String QUERY_PARAMETER = "QUERY_PARAMETER";
public interface ActiveConnection extends Identifiable, Shareable<SharingProfile> {
import org.apache.guacamole.net.auth.SharingProfile;
public Directory<SharingProfile> getSharingProfileDirectory()
throws GuacamoleException {
return new SimpleDirectory<SharingProfile>();
}
@Override
@Override
public Collection<Form> getSharingProfileAttributes() {
return Collections.<Form>emptyList();
}
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleSecurityException;
import org.apache.guacamole.net.auth.credentials.UserCredentials;
private String sharingProfileIdentifier;
this.connectionIdentifier     = activeConnectionRecord.getConnectionIdentifier();
this.sharingProfileIdentifier = activeConnectionRecord.getSharingProfileIdentifier();
this.identifier               = activeConnectionRecord.getUUID().toString();
this.startDate                = activeConnectionRecord.getStartDate();
public String getSharingProfileIdentifier() {
return sharingProfileIdentifier;
}
@Override
public void setSharingProfileIdentifier(String sharingProfileIdentifier) {
this.sharingProfileIdentifier = sharingProfileIdentifier;
}
@Override
public UserCredentials getSharingCredentials(String identifier)
throws GuacamoleException {
throw new GuacamoleSecurityException("Permission denied");
}
@Override
import java.util.Set;
public Set<String> getSharingProfileIdentifiers()
throws GuacamoleException {
return Collections.<String>emptySet();
}
@Override
public String getSharingProfileIdentifier() {
return null;
}
@Override
public String getSharingProfileName() {
return null;
}
@Override
public String getSharingProfileIdentifier() {
return null;
}
@Override
public String getSharingProfileName() {
return null;
}
@Override
import org.apache.guacamole.net.auth.simple.SimpleObjectPermissionSet;
public ObjectPermissionSet getSharingProfilePermissions()
throws GuacamoleException {
return new SimpleObjectPermissionSet();
}
@Override
import java.util.Collections;
import org.apache.guacamole.net.auth.SharingProfile;
import org.apache.guacamole.net.auth.simple.SimpleDirectory;
public Directory<SharingProfile> getSharingProfileDirectory()
throws GuacamoleException {
return new SimpleDirectory<SharingProfile>();
}
@Override
@Override
public Collection<Form> getSharingProfileAttributes() {
return Collections.<Form>emptyList();
}
import org.apache.guacamole.rest.sharingprofile.SharingProfileModule;
install(new SharingProfileModule());
private final String sharingProfileIdentifier;
private final String sharingProfileName;
this.connectionIdentifier     = record.getConnectionIdentifier();
this.connectionName           = record.getConnectionName();
this.sharingProfileIdentifier = record.getSharingProfileIdentifier();
this.sharingProfileName       = record.getSharingProfileName();
this.startDate                = record.getStartDate();
this.endDate                  = record.getEndDate();
this.remoteHost               = record.getRemoteHost();
this.username                 = record.getUsername();
this.active                   = record.isActive();
public String getSharingProfileIdentifier() {
return sharingProfileIdentifier;
}
public String getSharingProfileName() {
return sharingProfileName;
}
private Map<String, Set<ObjectPermission.Type>> sharingProfilePermissions =
new HashMap<String, Set<ObjectPermission.Type>>();
addObjectPermissions(sharingProfilePermissions,   user.getSharingProfilePermissions());
public Map<String, Set<ObjectPermission.Type>> getSharingProfilePermissions() {
return sharingProfilePermissions;
}
public void setSharingProfilePermissions(Map<String, Set<ObjectPermission.Type>> sharingProfilePermissions) {
this.sharingProfilePermissions = sharingProfilePermissions;
}
private static final String SHARING_PROFILE_PERMISSION_PATCH_PATH_PREFIX = "/sharingProfilePermissions/";
PermissionSetPatch<ObjectPermission> sharingProfilePermissionPatch   = new PermissionSetPatch<ObjectPermission>();
else if (path.startsWith(SHARING_PROFILE_PERMISSION_PATCH_PATH_PREFIX)) {
String identifier = path.substring(SHARING_PROFILE_PERMISSION_PATCH_PATH_PREFIX.length());
ObjectPermission.Type type = ObjectPermission.Type.valueOf(patch.getValue());
ObjectPermission permission = new ObjectPermission(type, identifier);
updatePermissionSet(patch.getOp(), sharingProfilePermissionPatch, permission);
}
sharingProfilePermissionPatch.apply(user.getSharingProfilePermissions());
import org.apache.guacamole.net.auth.SharingProfile;
import org.apache.guacamole.rest.sharingprofile.APISharingProfile;
@Inject
private DirectoryResourceFactory<SharingProfile, APISharingProfile>
sharingProfileDirectoryResourceFactory;
@Path("sharingProfiles")
public DirectoryResource<SharingProfile, APISharingProfile>
getSharingProfileDirectoryResource() throws GuacamoleException {
return sharingProfileDirectoryResourceFactory.create(userContext,
userContext.getSharingProfileDirectory());
}
public ObjectPermissionSet getSharingProfilePermissions() throws GuacamoleException {
throw new GuacamoleUnsupportedException("APIUserWrapper does not provide permission access.");
}
@Override
import org.apache.guacamole.tunnel.UserTunnel;
private final Map<String, UserTunnel> tunnels =
new ConcurrentHashMap<String, UserTunnel>();
public Map<String, UserTunnel> getTunnels() {
public void addTunnel(UserTunnel tunnel) {
import org.apache.guacamole.tunnel.UserTunnel;
Map<String, UserTunnel> tunnels = session.getTunnels();
final UserTunnel tunnel = tunnels.get(tunnelUUID);
import org.apache.guacamole.tunnel.UserTunnel;
private final UserTunnel tunnel;
public TunnelResource(UserTunnel tunnel) {
final String authToken, final GuacamoleSession session,
final UserContext context, final TunnelRequest.Type type,
final String id) throws GuacamoleException {
UserTunnel monitoredTunnel = new UserTunnel(context, tunnel) {
return createAssociatedTunnel(tunnel, authToken, session, userContext, type, id);
import org.apache.guacamole.rest.tunnel.TunnelCollectionResourceFactory;
import org.apache.guacamole.rest.tunnel.TunnelResourceFactory;
install(new FactoryModuleBuilder().build(TunnelCollectionResourceFactory.class));
install(new FactoryModuleBuilder().build(TunnelResourceFactory.class));
import org.apache.guacamole.rest.tunnel.TunnelCollectionResourceFactory;
@Inject
private TunnelCollectionResourceFactory tunnelCollectionResourceFactory;
return tunnelCollectionResourceFactory.create(session);
import com.google.inject.Inject;
import com.google.inject.assistedinject.Assisted;
import com.google.inject.assistedinject.AssistedInject;
@Inject
private TunnelResourceFactory tunnelResourceFactory;
@AssistedInject
public TunnelCollectionResource(@Assisted GuacamoleSession session) {
return tunnelResourceFactory.create(tunnel);
import com.google.inject.Inject;
import com.google.inject.assistedinject.Assisted;
import com.google.inject.assistedinject.AssistedInject;
import org.apache.guacamole.net.auth.ActiveConnection;
import org.apache.guacamole.net.auth.UserContext;
import org.apache.guacamole.rest.activeconnection.APIActiveConnection;
import org.apache.guacamole.rest.directory.DirectoryObjectResource;
import org.apache.guacamole.rest.directory.DirectoryObjectResourceFactory;
@Inject
private DirectoryObjectResourceFactory<ActiveConnection, APIActiveConnection>
activeConnectionResourceFactory;
@AssistedInject
public TunnelResource(@Assisted UserTunnel tunnel) {
@Path("activeConnection")
public DirectoryObjectResource<ActiveConnection, APIActiveConnection>
getActiveConnection() throws GuacamoleException {
UserContext userContext = tunnel.getUserContext();
return activeConnectionResourceFactory.create(userContext,
userContext.getActiveConnectionDirectory(),
tunnel.getActiveConnection());
}
import com.google.inject.Inject;
import javax.ws.rs.Path;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.auth.Connection;
import org.apache.guacamole.rest.connection.APIConnection;
import org.apache.guacamole.rest.directory.DirectoryResourceFactory;
private final UserContext userContext;
private final ActiveConnection activeConnection;
@Inject
private DirectoryResourceFactory<Connection, APIConnection>
connectionDirectoryResourceFactory;
@Assisted ActiveConnection activeConnection,
super(directory, activeConnection, translator);
this.userContext = userContext;
this.activeConnection = activeConnection;
}
@Path("connection")
public DirectoryObjectResource<Connection, APIConnection> getConnection()
throws GuacamoleException {
return connectionDirectoryResourceFactory
.create(userContext, userContext.getConnectionDirectory())
.getObjectResource(activeConnection.getConnectionIdentifier());
import javax.ws.rs.GET;
import javax.ws.rs.PathParam;
@GET
@Path("sharingCredentials/{sharingProfile}")
public APIUserCredentials getSharingCredentials(
@PathParam("sharingProfile") String sharingProfileIdentifier)
throws GuacamoleException {
return new APIUserCredentials(activeConnection.getSharingCredentials(sharingProfileIdentifier));
}
import com.google.inject.Inject;
import org.apache.guacamole.rest.directory.DirectoryView;
import org.apache.guacamole.net.auth.SharingProfile;
import org.apache.guacamole.rest.directory.DirectoryResource;
import org.apache.guacamole.rest.directory.DirectoryResourceFactory;
import org.apache.guacamole.rest.sharingprofile.APISharingProfile;
@Inject
private DirectoryResourceFactory<SharingProfile, APISharingProfile>
sharingProfileDirectoryResourceFactory;
@Path("sharingProfiles")
public DirectoryResource<SharingProfile, APISharingProfile>
getSharingProfileDirectoryResource() throws GuacamoleException {
Directory<SharingProfile> sharingProfiles = new DirectoryView<SharingProfile>(
userContext.getSharingProfileDirectory(),
connection.getSharingProfileIdentifiers()
);
return sharingProfileDirectoryResourceFactory.create(userContext, sharingProfiles);
}
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleSecurityException;
import org.apache.guacamole.net.auth.credentials.UserCredentials;
private String sharingProfileIdentifier;
this.connectionIdentifier     = activeConnectionRecord.getConnectionIdentifier();
this.sharingProfileIdentifier = activeConnectionRecord.getSharingProfileIdentifier();
this.identifier               = activeConnectionRecord.getUUID().toString();
this.startDate                = activeConnectionRecord.getStartDate();
public String getSharingProfileIdentifier() {
return sharingProfileIdentifier;
}
@Override
public void setSharingProfileIdentifier(String sharingProfileIdentifier) {
this.sharingProfileIdentifier = sharingProfileIdentifier;
}
@Override
public UserCredentials getSharingCredentials(String identifier)
throws GuacamoleException {
throw new GuacamoleSecurityException("Permission denied");
}
@Override
import java.util.Set;
public Set<String> getSharingProfileIdentifiers()
throws GuacamoleException {
return Collections.<String>emptySet();
}
@Override
public String getSharingProfileIdentifier() {
return null;
}
@Override
public String getSharingProfileName() {
return null;
}
@Override
public String getSharingProfileIdentifier() {
return null;
}
@Override
public String getSharingProfileName() {
return null;
}
@Override
import org.apache.guacamole.net.auth.simple.SimpleObjectPermissionSet;
public ObjectPermissionSet getSharingProfilePermissions()
throws GuacamoleException {
return new SimpleObjectPermissionSet();
}
@Override
import java.util.Collections;
import org.apache.guacamole.net.auth.SharingProfile;
import org.apache.guacamole.net.auth.simple.SimpleDirectory;
public Directory<SharingProfile> getSharingProfileDirectory()
throws GuacamoleException {
return new SimpleDirectory<SharingProfile>();
}
@Override
@Override
public Collection<Form> getSharingProfileAttributes() {
return Collections.<Form>emptyList();
}
import org.apache.guacamole.net.auth.SharingProfile;
public Directory<SharingProfile> getSharingProfileDirectory()
throws GuacamoleException {
return new SimpleDirectory<SharingProfile>();
}
@Override
@Override
public Collection<Form> getSharingProfileAttributes() {
return Collections.<Form>emptyList();
}
public static String QUERY_PARAMETER = "QUERY_PARAMETER";
private String sharingProfileIdentifier;
public String getSharingProfileIdentifier() {
return sharingProfileIdentifier;
}
@Override
public void setSharingProfileIdentifier(String sharingProfileIdentifier) {
this.sharingProfileIdentifier = sharingProfileIdentifier;
}
@Override
import java.util.Collections;
import java.util.Set;
import org.apache.guacamole.GuacamoleException;
@Override
public Set<String> getSharingProfileIdentifiers()
throws GuacamoleException {
return Collections.<String>emptySet();
}
public interface ActiveConnection extends Identifiable, Shareable<SharingProfile> {
String getSharingProfileIdentifier();
void setSharingProfileIdentifier(String sharingProfileIdentifier);
import java.util.Set;
public Set<String> getSharingProfileIdentifiers() throws GuacamoleException;
public String getSharingProfileIdentifier();
public String getSharingProfileName();
ObjectPermissionSet getSharingProfilePermissions()
throws GuacamoleException;
Directory<SharingProfile> getSharingProfileDirectory()
throws GuacamoleException;
Collection<Form> getSharingProfileAttributes();
CREATE_SHARING_PROFILE,
@Override
public ObjectPermissionSet getSharingProfilePermissions() {
return new SimpleObjectPermissionSet();
}
import org.apache.guacamole.net.auth.SharingProfile;
public Directory<SharingProfile> getSharingProfileDirectory()
throws GuacamoleException {
return new SimpleDirectory<SharingProfile>();
}
@Override
@Override
public Collection<Form> getSharingProfileAttributes() {
return Collections.<Form>emptyList();
}
import org.apache.guacamole.tunnel.UserTunnel;
private final Map<String, UserTunnel> tunnels =
new ConcurrentHashMap<String, UserTunnel>();
public Map<String, UserTunnel> getTunnels() {
public void addTunnel(UserTunnel tunnel) {
import org.apache.guacamole.rest.sharingprofile.SharingProfileModule;
import org.apache.guacamole.rest.tunnel.TunnelCollectionResourceFactory;
import org.apache.guacamole.rest.tunnel.TunnelResourceFactory;
install(new FactoryModuleBuilder().build(TunnelCollectionResourceFactory.class));
install(new FactoryModuleBuilder().build(TunnelResourceFactory.class));
install(new SharingProfileModule());
import com.google.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.auth.Connection;
import org.apache.guacamole.rest.connection.APIConnection;
import org.apache.guacamole.rest.directory.DirectoryResourceFactory;
private final UserContext userContext;
private final ActiveConnection activeConnection;
@Inject
private DirectoryResourceFactory<Connection, APIConnection>
connectionDirectoryResourceFactory;
@Assisted ActiveConnection activeConnection,
super(directory, activeConnection, translator);
this.userContext = userContext;
this.activeConnection = activeConnection;
}
@Path("connection")
public DirectoryObjectResource<Connection, APIConnection> getConnection()
throws GuacamoleException {
return connectionDirectoryResourceFactory
.create(userContext, userContext.getConnectionDirectory())
.getObjectResource(activeConnection.getConnectionIdentifier());
}
@GET
@Path("sharingCredentials/{sharingProfile}")
public APIUserCredentials getSharingCredentials(
@PathParam("sharingProfile") String sharingProfileIdentifier)
throws GuacamoleException {
return new APIUserCredentials(activeConnection.getSharingCredentials(sharingProfileIdentifier));
import java.util.Set;
public Set<String> getSharingProfileIdentifiers() {
throw new UnsupportedOperationException("Operation not supported.");
}
@Override
import com.google.inject.Inject;
import org.apache.guacamole.rest.directory.DirectoryView;
import org.apache.guacamole.net.auth.SharingProfile;
import org.apache.guacamole.rest.directory.DirectoryResource;
import org.apache.guacamole.rest.directory.DirectoryResourceFactory;
import org.apache.guacamole.rest.sharingprofile.APISharingProfile;
@Inject
private DirectoryResourceFactory<SharingProfile, APISharingProfile>
sharingProfileDirectoryResourceFactory;
@Path("sharingProfiles")
public DirectoryResource<SharingProfile, APISharingProfile>
getSharingProfileDirectoryResource() throws GuacamoleException {
Directory<SharingProfile> sharingProfiles = new DirectoryView<SharingProfile>(
userContext.getSharingProfileDirectory(),
connection.getSharingProfileIdentifiers()
);
return sharingProfileDirectoryResourceFactory.create(userContext, sharingProfiles);
}
private final String sharingProfileIdentifier;
private final String sharingProfileName;
this.connectionIdentifier     = record.getConnectionIdentifier();
this.connectionName           = record.getConnectionName();
this.sharingProfileIdentifier = record.getSharingProfileIdentifier();
this.sharingProfileName       = record.getSharingProfileName();
this.startDate                = record.getStartDate();
this.endDate                  = record.getEndDate();
this.remoteHost               = record.getRemoteHost();
this.username                 = record.getUsername();
this.active                   = record.isActive();
public String getSharingProfileIdentifier() {
return sharingProfileIdentifier;
}
public String getSharingProfileName() {
return sharingProfileName;
}
private Map<String, Set<ObjectPermission.Type>> sharingProfilePermissions =
new HashMap<String, Set<ObjectPermission.Type>>();
addObjectPermissions(sharingProfilePermissions,   user.getSharingProfilePermissions());
public Map<String, Set<ObjectPermission.Type>> getSharingProfilePermissions() {
return sharingProfilePermissions;
}
public void setSharingProfilePermissions(Map<String, Set<ObjectPermission.Type>> sharingProfilePermissions) {
this.sharingProfilePermissions = sharingProfilePermissions;
}
private static final String SHARING_PROFILE_PERMISSION_PATCH_PATH_PREFIX = "/sharingProfilePermissions/";
PermissionSetPatch<ObjectPermission> sharingProfilePermissionPatch   = new PermissionSetPatch<ObjectPermission>();
else if (path.startsWith(SHARING_PROFILE_PERMISSION_PATCH_PATH_PREFIX)) {
String identifier = path.substring(SHARING_PROFILE_PERMISSION_PATCH_PATH_PREFIX.length());
ObjectPermission.Type type = ObjectPermission.Type.valueOf(patch.getValue());
ObjectPermission permission = new ObjectPermission(type, identifier);
updatePermissionSet(patch.getOp(), sharingProfilePermissionPatch, permission);
}
sharingProfilePermissionPatch.apply(user.getSharingProfilePermissions());
import org.apache.guacamole.rest.tunnel.TunnelCollectionResourceFactory;
@Inject
private TunnelCollectionResourceFactory tunnelCollectionResourceFactory;
return tunnelCollectionResourceFactory.create(session);
import org.apache.guacamole.net.auth.SharingProfile;
import org.apache.guacamole.rest.sharingprofile.APISharingProfile;
@Inject
private DirectoryResourceFactory<SharingProfile, APISharingProfile>
sharingProfileDirectoryResourceFactory;
@Path("sharingProfiles")
public DirectoryResource<SharingProfile, APISharingProfile>
getSharingProfileDirectoryResource() throws GuacamoleException {
return sharingProfileDirectoryResourceFactory.create(userContext,
userContext.getSharingProfileDirectory());
}
import com.google.inject.Inject;
import com.google.inject.assistedinject.Assisted;
import com.google.inject.assistedinject.AssistedInject;
import org.apache.guacamole.tunnel.UserTunnel;
@Inject
private TunnelResourceFactory tunnelResourceFactory;
@AssistedInject
public TunnelCollectionResource(@Assisted GuacamoleSession session) {
Map<String, UserTunnel> tunnels = session.getTunnels();
final UserTunnel tunnel = tunnels.get(tunnelUUID);
return tunnelResourceFactory.create(tunnel);
import com.google.inject.Inject;
import com.google.inject.assistedinject.Assisted;
import com.google.inject.assistedinject.AssistedInject;
import org.apache.guacamole.net.auth.ActiveConnection;
import org.apache.guacamole.net.auth.UserContext;
import org.apache.guacamole.rest.activeconnection.APIActiveConnection;
import org.apache.guacamole.rest.directory.DirectoryObjectResource;
import org.apache.guacamole.rest.directory.DirectoryObjectResourceFactory;
import org.apache.guacamole.tunnel.UserTunnel;
private final UserTunnel tunnel;
@Inject
private DirectoryObjectResourceFactory<ActiveConnection, APIActiveConnection>
activeConnectionResourceFactory;
@AssistedInject
public TunnelResource(@Assisted UserTunnel tunnel) {
@Path("activeConnection")
public DirectoryObjectResource<ActiveConnection, APIActiveConnection>
getActiveConnection() throws GuacamoleException {
UserContext userContext = tunnel.getUserContext();
return activeConnectionResourceFactory.create(userContext,
userContext.getActiveConnectionDirectory(),
tunnel.getActiveConnection());
}
public ObjectPermissionSet getSharingProfilePermissions() throws GuacamoleException {
throw new GuacamoleUnsupportedException("APIUserWrapper does not provide permission access.");
}
@Override
final String authToken, final GuacamoleSession session,
final UserContext context, final TunnelRequest.Type type,
final String id) throws GuacamoleException {
UserTunnel monitoredTunnel = new UserTunnel(context, tunnel) {
return createAssociatedTunnel(tunnel, authToken, session, userContext, type, id);
import org.apache.guacamole.auth.jdbc.connection.ConnectionParameterMapper;
import org.apache.guacamole.auth.jdbc.permission.SharingProfilePermissionMapper;
import org.apache.guacamole.auth.jdbc.sharingprofile.SharingProfileMapper;
import org.apache.guacamole.auth.jdbc.sharingprofile.SharingProfileParameterMapper;
addMapperClass(ConnectionParameterMapper.class);
addMapperClass(SharingProfileMapper.class);
addMapperClass(SharingProfileParameterMapper.class);
addMapperClass(SharingProfilePermissionMapper.class);
public interface ConnectionParameterMapper {
Collection<ConnectionParameterModel> select(@Param("identifier") String identifier);
int insert(@Param("parameters") Collection<ConnectionParameterModel> parameters);
public class ConnectionParameterModel {
private ConnectionParameterMapper parameterMapper;
private Collection<ConnectionParameterModel> getParameterModels(ModeledConnection connection) {
Collection<ConnectionParameterModel> parameterModels = new ArrayList<ConnectionParameterModel>(parameters.size());
ConnectionParameterModel model = new ConnectionParameterModel();
Collection<ConnectionParameterModel> parameterModels = getParameterModels(connection);
Collection<ConnectionParameterModel> parameterModels = getParameterModels(object);
for (ConnectionParameterModel parameter : parameterMapper.select(identifier))
package org.apache.guacamole.auth.jdbc.sharingprofile;
public interface SharingProfileParameterMapper {
Collection<SharingProfileParameterModel> select(@Param("identifier") String identifier);
int insert(@Param("parameters") Collection<SharingProfileParameterModel> parameters);
package org.apache.guacamole.auth.jdbc.sharingprofile;
public class SharingProfileParameterModel {
private String sharingProfileIdentifier;
public String getSharingProfileIdentifier() {
return sharingProfileIdentifier;
public void setSharingProfileIdentifier(String sharingProfileIdentifier) {
this.sharingProfileIdentifier = sharingProfileIdentifier;
import org.apache.guacamole.auth.jdbc.connection.ConnectionParameterModel;
import org.apache.guacamole.auth.jdbc.connection.ConnectionParameterMapper;
private ConnectionParameterMapper parameterMapper;
Collection<ConnectionParameterModel> parameters = parameterMapper.select(connection.getIdentifier());
for (ConnectionParameterModel parameter : parameters)
private String sharingProfileIdentifier;
private String sharingProfileName;
public String getSharingProfileIdentifier() {
return sharingProfileIdentifier;
}
public void setSharingProfileIdentifier(String sharingProfileIdentifier) {
this.sharingProfileIdentifier = sharingProfileIdentifier;
}
public String getSharingProfileName() {
return sharingProfileName;
}
public void setSharingProfileName(String sharingProfileName) {
this.sharingProfileName = sharingProfileName;
}
return model.getSharingProfileIdentifier();
return model.getSharingProfileName();
import org.apache.guacamole.auth.jdbc.permission.SharingProfilePermissionService;
import org.apache.guacamole.auth.jdbc.permission.SharingProfilePermissionSet;
import org.apache.guacamole.auth.jdbc.sharingprofile.ModeledSharingProfile;
import org.apache.guacamole.auth.jdbc.sharingprofile.SharingProfileDirectory;
import org.apache.guacamole.auth.jdbc.sharingprofile.SharingProfileService;
bind(ModeledSharingProfile.class);
bind(SharingProfileDirectory.class);
bind(SharingProfilePermissionSet.class);
bind(SharingProfilePermissionService.class);
bind(SharingProfileService.class);
import org.apache.guacamole.auth.jdbc.sharingprofile.ModeledSharingProfile;
import org.apache.guacamole.auth.jdbc.sharingprofile.SharingProfileDirectory;
@Inject
private SharingProfileDirectory sharingProfileDirectory;
sharingProfileDirectory.init(currentUser);
return sharingProfileDirectory;
return ModeledSharingProfile.ATTRIBUTES;
import org.apache.guacamole.auth.jdbc.permission.SharingProfilePermissionService;
@Inject
private SharingProfilePermissionService sharingProfilePermissionService;
return sharingProfilePermissionService.getPermissionSet(getCurrentUser(), this);
import org.apache.guacamole.auth.jdbc.sharingprofile.SharingProfileService;
@Inject
private SharingProfileService sharingProfileService;
return sharingProfileService.getIdentifiersWithin(getCurrentUser(), getIdentifier());
import org.apache.guacamole.auth.jdbc.connection.ConnectionParameterMapper;
import org.apache.guacamole.auth.jdbc.permission.SharingProfilePermissionMapper;
import org.apache.guacamole.auth.jdbc.permission.SharingProfilePermissionService;
import org.apache.guacamole.auth.jdbc.permission.SharingProfilePermissionSet;
import org.apache.guacamole.auth.jdbc.sharingprofile.ModeledSharingProfile;
import org.apache.guacamole.auth.jdbc.sharingprofile.SharingProfileDirectory;
import org.apache.guacamole.auth.jdbc.sharingprofile.SharingProfileMapper;
import org.apache.guacamole.auth.jdbc.sharingprofile.SharingProfileParameterMapper;
import org.apache.guacamole.auth.jdbc.sharingprofile.SharingProfileService;
addMapperClass(ConnectionParameterMapper.class);
addMapperClass(SharingProfileMapper.class);
addMapperClass(SharingProfileParameterMapper.class);
addMapperClass(SharingProfilePermissionMapper.class);
bind(ModeledSharingProfile.class);
bind(SharingProfileDirectory.class);
bind(SharingProfilePermissionSet.class);
bind(SharingProfilePermissionService.class);
bind(SharingProfileService.class);
public interface ConnectionParameterMapper {
Collection<ConnectionParameterModel> select(@Param("identifier") String identifier);
int insert(@Param("parameters") Collection<ConnectionParameterModel> parameters);
public class ConnectionParameterModel {
private String sharingProfileIdentifier;
private String sharingProfileName;
public String getSharingProfileIdentifier() {
return sharingProfileIdentifier;
}
public void setSharingProfileIdentifier(String sharingProfileIdentifier) {
this.sharingProfileIdentifier = sharingProfileIdentifier;
}
public String getSharingProfileName() {
return sharingProfileName;
}
public void setSharingProfileName(String sharingProfileName) {
this.sharingProfileName = sharingProfileName;
}
private ConnectionParameterMapper parameterMapper;
private Collection<ConnectionParameterModel> getParameterModels(ModeledConnection connection) {
Collection<ConnectionParameterModel> parameterModels = new ArrayList<ConnectionParameterModel>(parameters.size());
ConnectionParameterModel model = new ConnectionParameterModel();
Collection<ConnectionParameterModel> parameterModels = getParameterModels(connection);
Collection<ConnectionParameterModel> parameterModels = getParameterModels(object);
for (ConnectionParameterModel parameter : parameterMapper.select(identifier))
import org.apache.guacamole.auth.jdbc.sharingprofile.SharingProfileService;
@Inject
private SharingProfileService sharingProfileService;
return sharingProfileService.getIdentifiersWithin(getCurrentUser(), getIdentifier());
return model.getSharingProfileIdentifier();
return model.getSharingProfileName();
package org.apache.guacamole.auth.jdbc.sharingprofile;
public interface SharingProfileParameterMapper {
Collection<SharingProfileParameterModel> select(@Param("identifier") String identifier);
int insert(@Param("parameters") Collection<SharingProfileParameterModel> parameters);
package org.apache.guacamole.auth.jdbc.sharingprofile;
public class SharingProfileParameterModel {
private String sharingProfileIdentifier;
public String getSharingProfileIdentifier() {
return sharingProfileIdentifier;
public void setSharingProfileIdentifier(String sharingProfileIdentifier) {
this.sharingProfileIdentifier = sharingProfileIdentifier;
import org.apache.guacamole.auth.jdbc.connection.ConnectionParameterModel;
import org.apache.guacamole.auth.jdbc.connection.ConnectionParameterMapper;
private ConnectionParameterMapper parameterMapper;
Collection<ConnectionParameterModel> parameters = parameterMapper.select(connection.getIdentifier());
for (ConnectionParameterModel parameter : parameters)
import org.apache.guacamole.auth.jdbc.permission.SharingProfilePermissionService;
@Inject
private SharingProfilePermissionService sharingProfilePermissionService;
return sharingProfilePermissionService.getPermissionSet(getCurrentUser(), this);
import org.apache.guacamole.auth.jdbc.sharingprofile.ModeledSharingProfile;
import org.apache.guacamole.auth.jdbc.sharingprofile.SharingProfileDirectory;
@Inject
private SharingProfileDirectory sharingProfileDirectory;
sharingProfileDirectory.init(currentUser);
return sharingProfileDirectory;
return ModeledSharingProfile.ATTRIBUTES;
import com.google.inject.Scopes;
import org.apache.guacamole.auth.jdbc.sharing.SecureRandomShareKeyGenerator;
import org.apache.guacamole.auth.jdbc.sharing.ShareKeyGenerator;
bind(ShareKeyGenerator.class).to(SecureRandomShareKeyGenerator.class).in(Scopes.SINGLETON);
public class AuthenticatedUser extends RemoteAuthenticatedUser {
super(authenticationProvider, credentials);
import org.apache.guacamole.auth.jdbc.sharing.HashSharedConnectionMap;
import org.apache.guacamole.auth.jdbc.sharing.SharedConnectionMap;
bind(SharedConnectionMap.class).to(HashSharedConnectionMap.class).in(Scopes.SINGLETON);
import org.apache.guacamole.auth.jdbc.sharing.ConnectionSharingService;
bind(ConnectionSharingService.class);
import com.google.inject.Inject;
import org.apache.guacamole.auth.jdbc.connection.ModeledConnection;
import org.apache.guacamole.auth.jdbc.sharing.ConnectionSharingService;
@Inject
private ConnectionSharingService sharingService;
private ModeledConnection connection;
this.connection               = activeConnectionRecord.getConnection();
public ModeledConnection getConnection() {
return connection;
}
return connection.getIdentifier();
throw new UnsupportedOperationException("The connection identifier of "
"TrackedActiveConnection is inherited from the underlying "
"connection.");
return sharingService.generateTemporaryCredentials(getCurrentUser(),
this, identifier);
import org.apache.guacamole.auth.jdbc.sharing.ConnectionSharingService;
import org.apache.guacamole.auth.jdbc.sharing.SharedConnectionUser;
import org.apache.guacamole.auth.jdbc.sharing.SharedConnectionUserContext;
import org.apache.guacamole.net.auth.AuthenticatedUser;
@Inject
private Provider<SharedConnectionUserContext> sharedUserContextProvider;
@Inject
private ConnectionSharingService sharingService;
AuthenticatedUser user;
user = sharingService.retrieveSharedConnectionUser(authenticationProvider, credentials);
if (user != null)
return user;
user = userService.retrieveAuthenticatedUser(authenticationProvider, credentials);
public org.apache.guacamole.net.auth.UserContext getUserContext(
AuthenticatedUser authenticatedUser) throws GuacamoleException {
if (authenticatedUser instanceof SharedConnectionUser) {
SharedConnectionUserContext context = sharedUserContextProvider.get();
context.init((SharedConnectionUser) authenticatedUser);
return context;
}
private String connectionID;
this.connectionID             = activeConnectionRecord.getConnectionID();
public String getConnectionID() {
return connectionID;
}
import com.google.inject.Inject;
import org.apache.guacamole.auth.jdbc.tunnel.GuacamoleTunnelService;
@Inject
private GuacamoleTunnelService tunnelService;
return tunnelService.getGuacamoleTunnel(user, activeConnection,
sharingProfile, info);
import org.apache.guacamole.GuacamoleResourceNotFoundException;
import org.apache.guacamole.auth.jdbc.activeconnection.TrackedActiveConnection;
import org.apache.guacamole.auth.jdbc.sharing.SharedConnectionUser;
import org.apache.guacamole.auth.jdbc.sharingprofile.ModeledSharingProfile;
import org.apache.guacamole.auth.jdbc.sharingprofile.SharingProfileParameterMapper;
import org.apache.guacamole.auth.jdbc.sharingprofile.SharingProfileParameterModel;
import org.apache.guacamole.auth.jdbc.user.RemoteAuthenticatedUser;
private ConnectionParameterMapper connectionParameterMapper;
@Inject
private SharingProfileParameterMapper sharingProfileParameterMapper;
protected abstract ModeledConnection acquire(RemoteAuthenticatedUser user,
protected abstract void release(RemoteAuthenticatedUser user,
protected abstract void acquire(RemoteAuthenticatedUser user,
protected abstract void release(RemoteAuthenticatedUser user,
private GuacamoleConfiguration getGuacamoleConfiguration(RemoteAuthenticatedUser user,
Collection<ConnectionParameterModel> parameters = connectionParameterMapper.select(connection.getIdentifier());
private GuacamoleConfiguration getGuacamoleConfiguration(RemoteAuthenticatedUser user,
ModeledSharingProfile sharingProfile, String connectionID) {
GuacamoleConfiguration config = new GuacamoleConfiguration();
config.setConnectionID(connectionID);
Collection<SharingProfileParameterModel> parameters = sharingProfileParameterMapper.select(sharingProfile.getIdentifier());
for (SharingProfileParameterModel parameter : parameters)
config.setParameter(parameter.getName(), parameter.getValue());
TokenFilter tokenFilter = new TokenFilter();
StandardTokens.addStandardTokens(tokenFilter, user.getCredentials());
tokenFilter.filterValues(config.getParameters());
return config;
}
recordModel.setUsername(record.getUsername());
recordModel.setConnectionIdentifier(record.getConnectionIdentifier());
recordModel.setConnectionName(record.getConnectionName());
recordModel.setSharingProfileIdentifier(record.getSharingProfileIdentifier());
recordModel.setSharingProfileName(record.getSharingProfileName());
RemoteAuthenticatedUser user = activeConnection.getUser();
if (activeConnection.isPrimaryConnection()) {
ModeledConnection connection = activeConnection.getConnection();
String identifier = connection.getIdentifier();
String parentIdentifier = connection.getParentIdentifier();
activeConnections.remove(identifier, activeConnection);
activeConnectionGroups.remove(parentIdentifier, activeConnection);
release(user, connection);
}
GuacamoleClientInformation info) throws GuacamoleException {
GuacamoleConfiguration config;
if (activeConnection.isPrimaryConnection()) {
ModeledConnection connection = activeConnection.getConnection();
activeConnections.put(connection.getIdentifier(), activeConnection);
activeConnectionGroups.put(connection.getParentIdentifier(), activeConnection);
config = getGuacamoleConfiguration(activeConnection.getUser(), connection);
}
else {
String connectionID = activeConnection.getConnectionID();
if (connectionID == null)
throw new GuacamoleResourceNotFoundException("No existing connection to be joined.");
config = getGuacamoleConfiguration(activeConnection.getUser(),
activeConnection.getSharingProfile(), connectionID);
}
ConfiguredGuacamoleSocket socket = new ConfiguredGuacamoleSocket(
getUnconfiguredGuacamoleSocket(cleanupTask), config, info);
@Override
@Transactional
public GuacamoleTunnel getGuacamoleTunnel(SharedConnectionUser user,
TrackedActiveConnection activeConnection,
ModeledSharingProfile sharingProfile,
GuacamoleClientInformation info)
throws GuacamoleException {
return assignGuacamoleTunnel(new ActiveConnectionRecord(user, activeConnection, sharingProfile), info);
}
import org.apache.guacamole.auth.jdbc.activeconnection.TrackedActiveConnection;
import org.apache.guacamole.auth.jdbc.sharingprofile.ModeledSharingProfile;
import org.apache.guacamole.auth.jdbc.user.RemoteAuthenticatedUser;
import org.apache.guacamole.protocol.ConfiguredGuacamoleSocket;
private final RemoteAuthenticatedUser user;
private final ModeledSharingProfile sharingProfile;
private String connectionID;
private ActiveConnectionRecord(RemoteAuthenticatedUser user,
ModeledConnectionGroup balancingGroup,
ModeledConnection connection,
ModeledSharingProfile sharingProfile) {
this.user = user;
this.balancingGroup = balancingGroup;
this.connection = connection;
this.sharingProfile = sharingProfile;
}
public ActiveConnectionRecord(RemoteAuthenticatedUser user,
this(user, balancingGroup, connection, null);
public ActiveConnectionRecord(RemoteAuthenticatedUser user,
public ActiveConnectionRecord(RemoteAuthenticatedUser user,
TrackedActiveConnection activeConnection,
ModeledSharingProfile sharingProfile) {
this(user, null, activeConnection.getConnection(), sharingProfile);
this.connectionID = activeConnection.getConnectionID();
}
public RemoteAuthenticatedUser getUser() {
public ModeledSharingProfile getSharingProfile() {
return sharingProfile;
}
public boolean isPrimaryConnection() {
return sharingProfile == null;
}
if (sharingProfile != null)
return sharingProfile.getIdentifier();
if (sharingProfile != null)
return sharingProfile.getName();
return user.getIdentifier();
public GuacamoleTunnel assignGuacamoleTunnel(final ConfiguredGuacamoleSocket socket) {
if (isPrimaryConnection())
this.connectionID = socket.getConnectionID();
public String getConnectionID() {
return connectionID;
}
import org.apache.guacamole.auth.jdbc.activeconnection.TrackedActiveConnection;
import org.apache.guacamole.auth.jdbc.sharing.SharedConnectionUser;
import org.apache.guacamole.auth.jdbc.sharingprofile.ModeledSharingProfile;
GuacamoleTunnel getGuacamoleTunnel(SharedConnectionUser user,
TrackedActiveConnection activeConnection,
ModeledSharingProfile sharingProfile,
GuacamoleClientInformation info)
throws GuacamoleException;
import org.apache.guacamole.auth.jdbc.user.RemoteAuthenticatedUser;
protected ModeledConnection acquire(RemoteAuthenticatedUser user,
String username = user.getIdentifier();
protected void release(RemoteAuthenticatedUser user, ModeledConnection connection) {
activeSeats.remove(new Seat(user.getIdentifier(), connection.getIdentifier()));
protected void acquire(RemoteAuthenticatedUser user,
String username = user.getIdentifier();
protected void release(RemoteAuthenticatedUser user,
activeGroupSeats.remove(new Seat(user.getIdentifier(), connectionGroup.getIdentifier()));
import org.apache.guacamole.GuacamoleSecurityException;
String connectionIdentifier = activeConnection.getConnectionIdentifier();
if (sharingProfile == null || !sharingProfile.getPrimaryConnectionIdentifier().equals(connectionIdentifier))
throw new GuacamoleSecurityException("Permission denied.");
if (!activeConnection.isActive() || connectionID == null)
return tunnel != null && tunnel.isOpen();
import com.google.inject.Scopes;
import org.apache.guacamole.auth.jdbc.sharing.ConnectionSharingService;
import org.apache.guacamole.auth.jdbc.sharing.HashSharedConnectionMap;
import org.apache.guacamole.auth.jdbc.sharing.SecureRandomShareKeyGenerator;
import org.apache.guacamole.auth.jdbc.sharing.ShareKeyGenerator;
import org.apache.guacamole.auth.jdbc.sharing.SharedConnectionMap;
bind(ConnectionSharingService.class);
bind(SharedConnectionMap.class).to(HashSharedConnectionMap.class).in(Scopes.SINGLETON);
bind(ShareKeyGenerator.class).to(SecureRandomShareKeyGenerator.class).in(Scopes.SINGLETON);
import com.google.inject.Inject;
import org.apache.guacamole.auth.jdbc.connection.ModeledConnection;
import org.apache.guacamole.auth.jdbc.sharing.ConnectionSharingService;
@Inject
private ConnectionSharingService sharingService;
private ModeledConnection connection;
private String connectionID;
this.connection               = activeConnectionRecord.getConnection();
this.connectionID             = activeConnectionRecord.getConnectionID();
public ModeledConnection getConnection() {
return connection;
}
public String getConnectionID() {
return connectionID;
}
return connection.getIdentifier();
throw new UnsupportedOperationException("The connection identifier of "
"TrackedActiveConnection is inherited from the underlying "
"connection.");
return sharingService.generateTemporaryCredentials(getCurrentUser(),
this, identifier);
import org.apache.guacamole.GuacamoleResourceNotFoundException;
import org.apache.guacamole.auth.jdbc.activeconnection.TrackedActiveConnection;
import org.apache.guacamole.auth.jdbc.sharing.SharedConnectionUser;
import org.apache.guacamole.auth.jdbc.sharingprofile.ModeledSharingProfile;
import org.apache.guacamole.auth.jdbc.sharingprofile.SharingProfileParameterMapper;
import org.apache.guacamole.auth.jdbc.sharingprofile.SharingProfileParameterModel;
import org.apache.guacamole.auth.jdbc.user.RemoteAuthenticatedUser;
private ConnectionParameterMapper connectionParameterMapper;
@Inject
private SharingProfileParameterMapper sharingProfileParameterMapper;
protected abstract ModeledConnection acquire(RemoteAuthenticatedUser user,
protected abstract void release(RemoteAuthenticatedUser user,
protected abstract void acquire(RemoteAuthenticatedUser user,
protected abstract void release(RemoteAuthenticatedUser user,
private GuacamoleConfiguration getGuacamoleConfiguration(RemoteAuthenticatedUser user,
Collection<ConnectionParameterModel> parameters = connectionParameterMapper.select(connection.getIdentifier());
private GuacamoleConfiguration getGuacamoleConfiguration(RemoteAuthenticatedUser user,
ModeledSharingProfile sharingProfile, String connectionID) {
GuacamoleConfiguration config = new GuacamoleConfiguration();
config.setConnectionID(connectionID);
Collection<SharingProfileParameterModel> parameters = sharingProfileParameterMapper.select(sharingProfile.getIdentifier());
for (SharingProfileParameterModel parameter : parameters)
config.setParameter(parameter.getName(), parameter.getValue());
TokenFilter tokenFilter = new TokenFilter();
StandardTokens.addStandardTokens(tokenFilter, user.getCredentials());
tokenFilter.filterValues(config.getParameters());
return config;
}
recordModel.setUsername(record.getUsername());
recordModel.setConnectionIdentifier(record.getConnectionIdentifier());
recordModel.setConnectionName(record.getConnectionName());
recordModel.setSharingProfileIdentifier(record.getSharingProfileIdentifier());
recordModel.setSharingProfileName(record.getSharingProfileName());
RemoteAuthenticatedUser user = activeConnection.getUser();
if (activeConnection.isPrimaryConnection()) {
ModeledConnection connection = activeConnection.getConnection();
String identifier = connection.getIdentifier();
String parentIdentifier = connection.getParentIdentifier();
activeConnections.remove(identifier, activeConnection);
activeConnectionGroups.remove(parentIdentifier, activeConnection);
release(user, connection);
}
GuacamoleClientInformation info) throws GuacamoleException {
GuacamoleConfiguration config;
if (activeConnection.isPrimaryConnection()) {
ModeledConnection connection = activeConnection.getConnection();
activeConnections.put(connection.getIdentifier(), activeConnection);
activeConnectionGroups.put(connection.getParentIdentifier(), activeConnection);
config = getGuacamoleConfiguration(activeConnection.getUser(), connection);
}
else {
String connectionID = activeConnection.getConnectionID();
if (!activeConnection.isActive() || connectionID == null)
throw new GuacamoleResourceNotFoundException("No existing connection to be joined.");
config = getGuacamoleConfiguration(activeConnection.getUser(),
activeConnection.getSharingProfile(), connectionID);
}
ConfiguredGuacamoleSocket socket = new ConfiguredGuacamoleSocket(
getUnconfiguredGuacamoleSocket(cleanupTask), config, info);
@Override
@Transactional
public GuacamoleTunnel getGuacamoleTunnel(SharedConnectionUser user,
TrackedActiveConnection activeConnection,
ModeledSharingProfile sharingProfile,
GuacamoleClientInformation info)
throws GuacamoleException {
return assignGuacamoleTunnel(new ActiveConnectionRecord(user, activeConnection, sharingProfile), info);
}
import org.apache.guacamole.auth.jdbc.activeconnection.TrackedActiveConnection;
import org.apache.guacamole.auth.jdbc.sharingprofile.ModeledSharingProfile;
import org.apache.guacamole.auth.jdbc.user.RemoteAuthenticatedUser;
import org.apache.guacamole.protocol.ConfiguredGuacamoleSocket;
private final RemoteAuthenticatedUser user;
private final ModeledSharingProfile sharingProfile;
private String connectionID;
private ActiveConnectionRecord(RemoteAuthenticatedUser user,
ModeledConnectionGroup balancingGroup,
ModeledConnection connection,
ModeledSharingProfile sharingProfile) {
this.user = user;
this.balancingGroup = balancingGroup;
this.connection = connection;
this.sharingProfile = sharingProfile;
}
public ActiveConnectionRecord(RemoteAuthenticatedUser user,
this(user, balancingGroup, connection, null);
public ActiveConnectionRecord(RemoteAuthenticatedUser user,
public ActiveConnectionRecord(RemoteAuthenticatedUser user,
TrackedActiveConnection activeConnection,
ModeledSharingProfile sharingProfile) {
this(user, null, activeConnection.getConnection(), sharingProfile);
this.connectionID = activeConnection.getConnectionID();
}
public RemoteAuthenticatedUser getUser() {
public ModeledSharingProfile getSharingProfile() {
return sharingProfile;
}
public boolean isPrimaryConnection() {
return sharingProfile == null;
}
if (sharingProfile != null)
return sharingProfile.getIdentifier();
if (sharingProfile != null)
return sharingProfile.getName();
return user.getIdentifier();
return tunnel != null && tunnel.isOpen();
public GuacamoleTunnel assignGuacamoleTunnel(final ConfiguredGuacamoleSocket socket) {
if (isPrimaryConnection())
this.connectionID = socket.getConnectionID();
public String getConnectionID() {
return connectionID;
}
import org.apache.guacamole.auth.jdbc.activeconnection.TrackedActiveConnection;
import org.apache.guacamole.auth.jdbc.sharing.SharedConnectionUser;
import org.apache.guacamole.auth.jdbc.sharingprofile.ModeledSharingProfile;
GuacamoleTunnel getGuacamoleTunnel(SharedConnectionUser user,
TrackedActiveConnection activeConnection,
ModeledSharingProfile sharingProfile,
GuacamoleClientInformation info)
throws GuacamoleException;
import org.apache.guacamole.auth.jdbc.user.RemoteAuthenticatedUser;
protected ModeledConnection acquire(RemoteAuthenticatedUser user,
String username = user.getIdentifier();
protected void release(RemoteAuthenticatedUser user, ModeledConnection connection) {
activeSeats.remove(new Seat(user.getIdentifier(), connection.getIdentifier()));
protected void acquire(RemoteAuthenticatedUser user,
String username = user.getIdentifier();
protected void release(RemoteAuthenticatedUser user,
activeGroupSeats.remove(new Seat(user.getIdentifier(), connectionGroup.getIdentifier()));
public class AuthenticatedUser extends RemoteAuthenticatedUser {
super(authenticationProvider, credentials);
import org.apache.guacamole.auth.jdbc.sharing.ConnectionSharingService;
import org.apache.guacamole.auth.jdbc.sharing.SharedConnectionUser;
import org.apache.guacamole.auth.jdbc.sharing.SharedConnectionUserContext;
import org.apache.guacamole.net.auth.AuthenticatedUser;
@Inject
private Provider<SharedConnectionUserContext> sharedUserContextProvider;
@Inject
private ConnectionSharingService sharingService;
AuthenticatedUser user;
user = sharingService.retrieveSharedConnectionUser(authenticationProvider, credentials);
if (user != null)
return user;
user = userService.retrieveAuthenticatedUser(authenticationProvider, credentials);
public org.apache.guacamole.net.auth.UserContext getUserContext(
AuthenticatedUser authenticatedUser) throws GuacamoleException {
if (authenticatedUser instanceof SharedConnectionUser) {
SharedConnectionUserContext context = sharedUserContextProvider.get();
context.init((SharedConnectionUser) authenticatedUser);
return context;
}
connectionMap.add(new SharedConnectionDefinition(activeConnection,
sharingProfile, key));
public void add(SharedConnectionDefinition definition) {
String shareKey = definition.getShareKey();
connectionMap.put(shareKey, definition);
private final String shareKey;
ModeledSharingProfile sharingProfile, String shareKey) {
this.shareKey = shareKey;
public String getShareKey() {
return shareKey;
}
public void add(SharedConnectionDefinition definition);
private SharedConnectionDefinition definition;
this.definition = definition;
return definition.getSharingProfile().getName();
Connection primaryConnection = definition.getActiveConnection().getConnection();
config.setProtocol(primaryConnection.getConfiguration().getProtocol());
return tunnelService.getGuacamoleTunnel(user, definition, info);
import org.apache.guacamole.auth.jdbc.sharing.SharedConnectionDefinition;
if (connectionID == null)
SharedConnectionDefinition definition,
return assignGuacamoleTunnel(
new ActiveConnectionRecord(user, definition.getActiveConnection(),
definition.getSharingProfile()), info);
import org.apache.guacamole.auth.jdbc.sharing.SharedConnectionDefinition;
SharedConnectionDefinition definition,
private ActiveConnectionRecord connectionRecord;
this.connectionRecord = activeConnectionRecord;
connectionRecord, identifier);
import org.apache.guacamole.auth.jdbc.tunnel.ActiveConnectionRecord;
ActiveConnectionRecord activeConnection,
import org.apache.guacamole.auth.jdbc.tunnel.ActiveConnectionRecord;
private final ActiveConnectionRecord activeConnection;
public SharedConnectionDefinition(ActiveConnectionRecord activeConnection,
public ActiveConnectionRecord getActiveConnection() {
ActiveConnectionRecord activeConnection,
activeConnection.registerShareKey(key);
SharedConnectionDefinition definition = connectionMap.remove(key);
if (definition == null)
return null;
definition.invalidate();
return definition;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
private final Logger logger = LoggerFactory.getLogger(SharedConnectionDefinition.class);
private final SharedObjectManager<GuacamoleTunnel> tunnels =
new SharedObjectManager<GuacamoleTunnel>() {
@Override
protected void cleanup(GuacamoleTunnel tunnel) {
try {
tunnel.close();
}
catch (GuacamoleException e) {
logger.debug("Unable to close tunnel of shared connection.", e);
}
}
};
public void registerTunnel(GuacamoleTunnel tunnel) {
tunnels.register(tunnel);
}
public void invalidate() {
tunnels.invalidate();
}
@Inject
private Provider<ActiveConnectionRecord> activeConnectionRecordProvider;
activeConnection.invalidate();
ActiveConnectionRecord connectionRecord = activeConnectionRecordProvider.get();
connectionRecord.init(user, connection);
return assignGuacamoleTunnel(connectionRecord, info);
ActiveConnectionRecord connectionRecord = activeConnectionRecordProvider.get();
connectionRecord.init(user, connectionGroup, connection);
return assignGuacamoleTunnel(connectionRecord, info);
ActiveConnectionRecord connectionRecord = activeConnectionRecordProvider.get();
connectionRecord.init(user, definition.getActiveConnection(),
definition.getSharingProfile());
GuacamoleTunnel tunnel = assignGuacamoleTunnel(connectionRecord, info);
definition.registerTunnel(tunnel);
return tunnel;
import com.google.inject.Inject;
import org.apache.guacamole.auth.jdbc.sharing.SharedConnectionMap;
import org.apache.guacamole.auth.jdbc.sharing.SharedObjectManager;
private RemoteAuthenticatedUser user;
private ModeledConnectionGroup balancingGroup;
private ModeledConnection connection;
private ModeledSharingProfile sharingProfile;
@Inject
private SharedConnectionMap connectionMap;
private final SharedObjectManager<String> shareKeyManager =
new SharedObjectManager<String>() {
@Override
protected void cleanup(String key) {
connectionMap.remove(key);
}
};
private void init(RemoteAuthenticatedUser user,
public void init(RemoteAuthenticatedUser user,
init(user, balancingGroup, connection, null);
public void init(RemoteAuthenticatedUser user,
init(user, null, connection);
public void init(RemoteAuthenticatedUser user,
init(user, null, activeConnection.getConnection(), sharingProfile);
public void registerShareKey(String key) {
shareKeyManager.register(key);
}
public void invalidate() {
shareKeyManager.invalidate();
}
private ActiveConnectionRecord connectionRecord;
this.connectionRecord = activeConnectionRecord;
connectionRecord, identifier);
import org.apache.guacamole.auth.jdbc.tunnel.ActiveConnectionRecord;
ActiveConnectionRecord activeConnection,
connectionMap.add(new SharedConnectionDefinition(activeConnection,
sharingProfile, key));
activeConnection.registerShareKey(key);
public void add(SharedConnectionDefinition definition) {
String shareKey = definition.getShareKey();
connectionMap.put(shareKey, definition);
SharedConnectionDefinition definition = connectionMap.remove(key);
if (definition == null)
return null;
definition.invalidate();
return definition;
private SharedConnectionDefinition definition;
this.definition = definition;
return definition.getSharingProfile().getName();
Connection primaryConnection = definition.getActiveConnection().getConnection();
config.setProtocol(primaryConnection.getConfiguration().getProtocol());
return tunnelService.getGuacamoleTunnel(user, definition, info);
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.auth.jdbc.tunnel.ActiveConnectionRecord;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
private final Logger logger = LoggerFactory.getLogger(SharedConnectionDefinition.class);
private final ActiveConnectionRecord activeConnection;
private final String shareKey;
private final SharedObjectManager<GuacamoleTunnel> tunnels =
new SharedObjectManager<GuacamoleTunnel>() {
@Override
protected void cleanup(GuacamoleTunnel tunnel) {
try {
tunnel.close();
}
catch (GuacamoleException e) {
logger.debug("Unable to close tunnel of shared connection.", e);
}
}
};
public SharedConnectionDefinition(ActiveConnectionRecord activeConnection,
ModeledSharingProfile sharingProfile, String shareKey) {
this.shareKey = shareKey;
public ActiveConnectionRecord getActiveConnection() {
public String getShareKey() {
return shareKey;
}
public void registerTunnel(GuacamoleTunnel tunnel) {
tunnels.register(tunnel);
}
public void invalidate() {
tunnels.invalidate();
}
public void add(SharedConnectionDefinition definition);
import org.apache.guacamole.auth.jdbc.sharing.SharedConnectionDefinition;
@Inject
private Provider<ActiveConnectionRecord> activeConnectionRecordProvider;
activeConnection.invalidate();
if (connectionID == null)
ActiveConnectionRecord connectionRecord = activeConnectionRecordProvider.get();
connectionRecord.init(user, connection);
return assignGuacamoleTunnel(connectionRecord, info);
ActiveConnectionRecord connectionRecord = activeConnectionRecordProvider.get();
connectionRecord.init(user, connectionGroup, connection);
return assignGuacamoleTunnel(connectionRecord, info);
SharedConnectionDefinition definition,
ActiveConnectionRecord connectionRecord = activeConnectionRecordProvider.get();
connectionRecord.init(user, definition.getActiveConnection(),
definition.getSharingProfile());
GuacamoleTunnel tunnel = assignGuacamoleTunnel(connectionRecord, info);
definition.registerTunnel(tunnel);
return tunnel;
import com.google.inject.Inject;
import org.apache.guacamole.auth.jdbc.sharing.SharedConnectionMap;
import org.apache.guacamole.auth.jdbc.sharing.SharedObjectManager;
private RemoteAuthenticatedUser user;
private ModeledConnectionGroup balancingGroup;
private ModeledConnection connection;
private ModeledSharingProfile sharingProfile;
@Inject
private SharedConnectionMap connectionMap;
private final SharedObjectManager<String> shareKeyManager =
new SharedObjectManager<String>() {
@Override
protected void cleanup(String key) {
connectionMap.remove(key);
}
};
private void init(RemoteAuthenticatedUser user,
public void init(RemoteAuthenticatedUser user,
init(user, balancingGroup, connection, null);
public void init(RemoteAuthenticatedUser user,
init(user, null, connection);
public void init(RemoteAuthenticatedUser user,
ActiveConnectionRecord activeConnection,
init(user, null, activeConnection.getConnection(), sharingProfile);
public void registerShareKey(String key) {
shareKeyManager.register(key);
}
public void invalidate() {
shareKeyManager.invalidate();
}
import org.apache.guacamole.auth.jdbc.sharing.SharedConnectionDefinition;
SharedConnectionDefinition definition,
import org.apache.guacamole.GuacamoleResourceNotFoundException;
ActiveConnection activeConnection = tunnel.getActiveConnection();
if (activeConnection == null)
throw new GuacamoleResourceNotFoundException("No readable active connection for tunnel.");
userContext.getActiveConnectionDirectory(), activeConnection);
String username = user.getIdentifier();
boolean includeSensitiveInformation =
isAdmin || username.equals(record.getUsername());
activeConnection.init(user, record, includeSensitiveInformation);
String username = user.getIdentifier();
boolean includeSensitiveInformation =
isAdmin || username.equals(record.getUsername());
activeConnection.init(user, record, includeSensitiveInformation);
import org.apache.guacamole.GuacamoleResourceNotFoundException;
ActiveConnection activeConnection = tunnel.getActiveConnection();
if (activeConnection == null)
throw new GuacamoleResourceNotFoundException("No readable active connection for tunnel.");
userContext.getActiveConnectionDirectory(), activeConnection);
public JDBCAuthenticationProviderModule(JDBCEnvironment environment) {
this.authProvider = user.getAuthenticationProvider();
return getCurrentUser().getAuthenticationProvider();
new JDBCAuthenticationProviderModule(environment)
new JDBCAuthenticationProviderModule(environment)
public JDBCAuthenticationProviderModule(JDBCEnvironment environment) {
this.authProvider = user.getAuthenticationProvider();
return getCurrentUser().getAuthenticationProvider();
new JDBCAuthenticationProviderModule(environment)
new JDBCAuthenticationProviderModule(environment)
import javax.xml.bind.DatatypeConverter;
return DatatypeConverter.printHexBinary(bytes);
import javax.xml.bind.DatatypeConverter;
return DatatypeConverter.printHexBinary(bytes);
import javax.xml.stream.events.Characters;
identifiers = ObjectModel.filterIdentifiers(identifiers);
import java.util.ArrayList;
import java.util.Collection;
public static boolean isValidIdentifier(String identifier) {
if (identifier.isEmpty())
return false;
if (!Character.isDigit(identifier.charAt(i)))
return false;
}
return true;
}
public static Collection<String> filterIdentifiers(Collection<String> identifiers) {
Collection<String> validIdentifiers = new ArrayList<String>(identifiers.size());
for (String identifier : identifiers) {
if (ObjectModel.isValidIdentifier(identifier))
validIdentifiers.add(identifier);
}
return validIdentifiers;
}
import javax.xml.stream.events.Characters;
identifiers = ObjectModel.filterIdentifiers(identifiers);
import java.util.ArrayList;
import java.util.Collection;
public static boolean isValidIdentifier(String identifier) {
if (identifier.isEmpty())
return false;
if (!Character.isDigit(identifier.charAt(i)))
return false;
}
return true;
}
public static Collection<String> filterIdentifiers(Collection<String> identifiers) {
Collection<String> validIdentifiers = new ArrayList<String>(identifiers.size());
for (String identifier : identifiers) {
if (ObjectModel.isValidIdentifier(identifier))
validIdentifiers.add(identifier);
}
return validIdentifiers;
}
import org.apache.guacamole.auth.jdbc.JDBCAuthenticationProvider;
public class MySQLAuthenticationProvider extends JDBCAuthenticationProvider {
public MySQLAuthenticationProvider() {
super(new MySQLInjectorProvider());
import org.apache.guacamole.auth.jdbc.JDBCAuthenticationProvider;
public class PostgreSQLAuthenticationProvider extends JDBCAuthenticationProvider {
public PostgreSQLAuthenticationProvider() {
super(new PostgreSQLInjectorProvider());
public abstract class InjectedAuthenticationProvider implements AuthenticationProvider {
private final AuthenticationProviderService authProviderService;
public InjectedAuthenticationProvider(JDBCInjectorProvider injectorProvider,
Class<? extends AuthenticationProviderService> authProviderServiceClass)
throws GuacamoleException {
Injector injector = injectorProvider.get();
authProviderService = injector.getInstance(authProviderServiceClass);
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.auth.jdbc.InjectedAuthenticationProvider;
import org.apache.guacamole.auth.jdbc.JDBCAuthenticationProviderService;
public class MySQLAuthenticationProvider extends InjectedAuthenticationProvider {
public MySQLAuthenticationProvider() throws GuacamoleException {
super(new MySQLInjectorProvider(), JDBCAuthenticationProviderService.class);
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.auth.jdbc.InjectedAuthenticationProvider;
import org.apache.guacamole.auth.jdbc.JDBCAuthenticationProviderService;
public class PostgreSQLAuthenticationProvider extends InjectedAuthenticationProvider {
public PostgreSQLAuthenticationProvider() throws GuacamoleException {
super(new PostgreSQLInjectorProvider(), JDBCAuthenticationProviderService.class);
import org.apache.guacamole.auth.jdbc.InjectedAuthenticationProvider;
import org.apache.guacamole.auth.jdbc.JDBCAuthenticationProviderService;
public class MySQLAuthenticationProvider extends InjectedAuthenticationProvider {
super(new MySQLInjectorProvider(), JDBCAuthenticationProviderService.class);
import org.apache.guacamole.auth.jdbc.InjectedAuthenticationProvider;
import org.apache.guacamole.auth.jdbc.JDBCAuthenticationProviderService;
public class PostgreSQLAuthenticationProvider extends InjectedAuthenticationProvider {
super(new PostgreSQLInjectorProvider(), JDBCAuthenticationProviderService.class);
public UserContext getUserContext(AuthenticationProvider authenticationProvider,
AuthenticatedUser authenticatedUser) throws GuacamoleException;
return authProviderService.getUserContext(this, authenticatedUser);
public UserContext getUserContext(AuthenticationProvider authenticationProvider,
ModeledUser user = userService.retrieveUser(authenticationProvider, authenticatedUser);
AuthenticationProvider authenticationProvider,
private final AuthenticationProvider modelAuthenticationProvider;
public AuthenticatedUser(org.apache.guacamole.net.auth.AuthenticatedUser authenticatedUser,
AuthenticationProvider modelAuthenticationProvider, ModeledUser user) {
super(authenticatedUser.getAuthenticationProvider(), authenticatedUser.getCredentials());
this.modelAuthenticationProvider = modelAuthenticationProvider;
this.user = user;
}
this.modelAuthenticationProvider = authenticationProvider;
public AuthenticationProvider getModelAuthenticationProvider() {
return modelAuthenticationProvider;
}
return getCurrentUser().getModelAuthenticationProvider();
public ModeledUser retrieveUser(AuthenticationProvider authenticationProvider,
org.apache.guacamole.net.auth.AuthenticatedUser authenticatedUser) {
user.setCurrentUser(new AuthenticatedUser(authenticatedUser,
authenticationProvider, user));
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
public ObjectPermission retrievePermission(ModeledAuthenticatedUser user,
public Set<ObjectPermission> retrievePermissions(ModeledAuthenticatedUser user,
public Collection<String> retrieveAccessibleIdentifiers(ModeledAuthenticatedUser user,
public ObjectPermissionSet getPermissionSet(ModeledAuthenticatedUser user,
public void createPermissions(ModeledAuthenticatedUser user,
public void deletePermissions(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
public TrackedActiveConnection retrieveObject(ModeledAuthenticatedUser user,
public Collection<TrackedActiveConnection> retrieveObjects(ModeledAuthenticatedUser user,
public void deleteObject(ModeledAuthenticatedUser user, String identifier)
public Set<String> getIdentifiers(ModeledAuthenticatedUser user)
public TrackedActiveConnection createObject(ModeledAuthenticatedUser user,
public void updateObject(ModeledAuthenticatedUser user, TrackedActiveConnection object)
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
public void init(ModeledAuthenticatedUser currentUser,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
InternalType retrieveObject(ModeledAuthenticatedUser user, String identifier)
Collection<InternalType> retrieveObjects(ModeledAuthenticatedUser user,
InternalType createObject(ModeledAuthenticatedUser user, ExternalType object)
void deleteObject(ModeledAuthenticatedUser user, String identifier)
void updateObject(ModeledAuthenticatedUser user, InternalType object)
Set<String> getIdentifiers(ModeledAuthenticatedUser user) throws GuacamoleException;
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
protected abstract InternalType getObjectInstance(ModeledAuthenticatedUser currentUser,
protected abstract ModelType getModelInstance(ModeledAuthenticatedUser currentUser,
protected abstract boolean hasCreatePermission(ModeledAuthenticatedUser user)
protected boolean hasObjectPermission(ModeledAuthenticatedUser user,
protected abstract ObjectPermissionSet getPermissionSet(ModeledAuthenticatedUser user)
protected Collection<InternalType> getObjectInstances(ModeledAuthenticatedUser currentUser,
protected void beforeCreate(ModeledAuthenticatedUser user,
protected void beforeUpdate(ModeledAuthenticatedUser user,
protected void beforeDelete(ModeledAuthenticatedUser user,
public InternalType retrieveObject(ModeledAuthenticatedUser user,
public Collection<InternalType> retrieveObjects(ModeledAuthenticatedUser user,
protected Collection<ObjectPermissionModel> getImplicitPermissions(ModeledAuthenticatedUser user,
public InternalType createObject(ModeledAuthenticatedUser user, ExternalType object)
public void deleteObject(ModeledAuthenticatedUser user, String identifier)
public void updateObject(ModeledAuthenticatedUser user, InternalType object)
public Set<String> getIdentifiers(ModeledAuthenticatedUser user)
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
protected Collection<String> getModifiedGroups(ModeledAuthenticatedUser user,
protected boolean canUpdateModifiedGroups(ModeledAuthenticatedUser user,
protected void beforeCreate(ModeledAuthenticatedUser user,
protected void beforeUpdate(ModeledAuthenticatedUser user,
protected void beforeDelete(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
public void init(ModeledAuthenticatedUser currentUser, ModelType model) {
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
private ModeledAuthenticatedUser currentUser;
public void init(ModeledAuthenticatedUser currentUser) {
public ModeledAuthenticatedUser getCurrentUser() {
public void setCurrentUser(ModeledAuthenticatedUser currentUser) {
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
protected ModeledConnection getObjectInstance(ModeledAuthenticatedUser currentUser,
protected ConnectionModel getModelInstance(ModeledAuthenticatedUser currentUser,
protected boolean hasCreatePermission(ModeledAuthenticatedUser user)
protected ObjectPermissionSet getPermissionSet(ModeledAuthenticatedUser user)
protected void beforeCreate(ModeledAuthenticatedUser user,
protected void beforeUpdate(ModeledAuthenticatedUser user,
public ModeledConnection createObject(ModeledAuthenticatedUser user, Connection object)
public void updateObject(ModeledAuthenticatedUser user, ModeledConnection object)
public Set<String> getIdentifiersWithin(ModeledAuthenticatedUser user,
public Map<String, String> retrieveParameters(ModeledAuthenticatedUser user,
public List<ConnectionRecord> retrieveHistory(ModeledAuthenticatedUser user,
public List<ConnectionRecord> retrieveHistory(ModeledAuthenticatedUser user,
public GuacamoleTunnel connect(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
private ModeledAuthenticatedUser currentUser;
public void init(ModeledAuthenticatedUser currentUser, ConnectionModel connectionModel) {
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
protected ModeledConnectionGroup getObjectInstance(ModeledAuthenticatedUser currentUser,
protected ConnectionGroupModel getModelInstance(ModeledAuthenticatedUser currentUser,
protected boolean hasCreatePermission(ModeledAuthenticatedUser user)
protected ObjectPermissionSet getPermissionSet(ModeledAuthenticatedUser user)
protected void beforeCreate(ModeledAuthenticatedUser user,
protected void beforeUpdate(ModeledAuthenticatedUser user,
public Set<String> getIdentifiersWithin(ModeledAuthenticatedUser user,
public GuacamoleTunnel connect(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
protected boolean canReadPermissions(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
public ObjectPermissionSet getPermissionSet(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
public ObjectPermissionSet getPermissionSet(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
protected boolean canAlterPermissions(ModeledAuthenticatedUser user, ModeledUser targetUser,
public void createPermissions(ModeledAuthenticatedUser user, ModeledUser targetUser,
public void deletePermissions(ModeledAuthenticatedUser user, ModeledUser targetUser,
public ObjectPermission retrievePermission(ModeledAuthenticatedUser user,
public Collection<String> retrieveAccessibleIdentifiers(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
public Set<PermissionType> retrievePermissions(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
ObjectPermission retrievePermission(ModeledAuthenticatedUser user,
Collection<String> retrieveAccessibleIdentifiers(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
public void init(ModeledAuthenticatedUser currentUser, ModeledUser user) {
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
PermissionSetType getPermissionSet(ModeledAuthenticatedUser user,
Set<PermissionType> retrievePermissions(ModeledAuthenticatedUser user,
void createPermissions(ModeledAuthenticatedUser user, ModeledUser targetUser,
void deletePermissions(ModeledAuthenticatedUser user, ModeledUser targetUser,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
public ObjectPermissionSet getPermissionSet(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
public SystemPermissionSet getPermissionSet(ModeledAuthenticatedUser user,
public void createPermissions(ModeledAuthenticatedUser user, ModeledUser targetUser,
public void deletePermissions(ModeledAuthenticatedUser user, ModeledUser targetUser,
public SystemPermission retrievePermission(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
public void init(ModeledAuthenticatedUser currentUser, ModeledUser user) {
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
public ObjectPermissionSet getPermissionSet(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
public UserCredentials generateTemporaryCredentials(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
protected ModeledSharingProfile getObjectInstance(ModeledAuthenticatedUser currentUser,
protected SharingProfileModel getModelInstance(ModeledAuthenticatedUser currentUser,
protected boolean hasCreatePermission(ModeledAuthenticatedUser user)
protected ObjectPermissionSet getPermissionSet(ModeledAuthenticatedUser user)
protected void beforeCreate(ModeledAuthenticatedUser user,
protected void beforeUpdate(ModeledAuthenticatedUser user,
public ModeledSharingProfile createObject(ModeledAuthenticatedUser user, SharingProfile object)
public void updateObject(ModeledAuthenticatedUser user, ModeledSharingProfile object)
public Set<String> getIdentifiersWithin(ModeledAuthenticatedUser user,
public Map<String, String> retrieveParameters(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
private Collection<String> getPreferredConnections(ModeledAuthenticatedUser user,
private List<ModeledConnection> getBalancedConnections(ModeledAuthenticatedUser user,
public Collection<ActiveConnectionRecord> getActiveConnections(ModeledAuthenticatedUser user)
public GuacamoleTunnel getGuacamoleTunnel(final ModeledAuthenticatedUser user,
public GuacamoleTunnel getGuacamoleTunnel(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
public Collection<ActiveConnectionRecord> getActiveConnections(ModeledAuthenticatedUser user)
GuacamoleTunnel getGuacamoleTunnel(ModeledAuthenticatedUser user,
GuacamoleTunnel getGuacamoleTunnel(ModeledAuthenticatedUser user,
import org.apache.guacamole.net.auth.AuthenticatedUser;
public class ModeledAuthenticatedUser extends RemoteAuthenticatedUser {
public ModeledAuthenticatedUser(AuthenticatedUser authenticatedUser,
public ModeledAuthenticatedUser(AuthenticationProvider authenticationProvider,
public void init(ModeledAuthenticatedUser currentUser) {
import org.apache.guacamole.net.auth.AuthenticatedUser;
protected ModeledUser getObjectInstance(ModeledAuthenticatedUser currentUser,
protected UserModel getModelInstance(ModeledAuthenticatedUser currentUser,
protected boolean hasCreatePermission(ModeledAuthenticatedUser user)
protected ObjectPermissionSet getPermissionSet(ModeledAuthenticatedUser user)
protected void beforeCreate(ModeledAuthenticatedUser user, UserModel model)
protected void beforeUpdate(ModeledAuthenticatedUser user,
getImplicitPermissions(ModeledAuthenticatedUser user, UserModel model) {
protected void beforeDelete(ModeledAuthenticatedUser user, String identifier) throws GuacamoleException {
public ModeledAuthenticatedUser retrieveAuthenticatedUser(AuthenticationProvider authenticationProvider,
user.setCurrentUser(new ModeledAuthenticatedUser(authenticationProvider, user, credentials));
AuthenticatedUser authenticatedUser) {
if (authenticatedUser instanceof ModeledAuthenticatedUser)
return ((ModeledAuthenticatedUser) authenticatedUser).getUser();
user.setCurrentUser(new ModeledAuthenticatedUser(authenticatedUser,
import org.apache.guacamole.auth.jdbc.user.ModeledUserContext;
bind(ModeledUserContext.class);
import org.apache.guacamole.auth.jdbc.user.ModeledUserContext;
private Provider<ModeledUserContext> userContextProvider;
public ModeledUserContext getUserContext(AuthenticationProvider authenticationProvider,
ModeledUserContext context = userContextProvider.get();
public class ModeledUserContext extends RestrictedObject
AuthenticatedUser authenticatedUser, Credentials credentials)
throws GuacamoleException {
AuthenticatedUser authenticatedUser,
Credentials credentials) throws GuacamoleException {
AuthenticatedUser authenticatedUser,
Credentials credentials) throws GuacamoleException;
AuthenticatedUser authorizedUser, Credentials credentials)
throws GuacamoleException {
AuthenticatedUser authenticatedUser, Credentials credentials)
return authProvider.updateUserContext(context, authenticatedUser, credentials);
AuthenticatedUser authenticatedUser, Credentials credentials)
throws GuacamoleException {
UserContext userContext = authProvider.updateUserContext(oldUserContext, authenticatedUser, credentials);
List<UserContext> userContexts = getUserContexts(existingSession, authenticatedUser, credentials);
closeConnection(session, GuacamoleStatus.SERVER_ERROR);
closeConnection(connection, GuacamoleStatus.SERVER_ERROR);
closeConnection(session, GuacamoleStatus.SERVER_ERROR);
closeConnection(outbound, GuacamoleStatus.SERVER_ERROR);
closeConnection(session, GuacamoleStatus.SERVER_ERROR);
closeConnection(connection, GuacamoleStatus.SERVER_ERROR);
closeConnection(session, GuacamoleStatus.SERVER_ERROR);
closeConnection(outbound, GuacamoleStatus.SERVER_ERROR);
public UserContext getUserContext(AuthenticationProvider authenticationProvider,
AuthenticatedUser authenticatedUser) throws GuacamoleException;
return authProviderService.getUserContext(this, authenticatedUser);
import org.apache.guacamole.auth.jdbc.user.ModeledUserContext;
bind(ModeledUserContext.class);
import org.apache.guacamole.auth.jdbc.user.ModeledUserContext;
private Provider<ModeledUserContext> userContextProvider;
public ModeledUserContext getUserContext(AuthenticationProvider authenticationProvider,
ModeledUser user = userService.retrieveUser(authenticationProvider, authenticatedUser);
ModeledUserContext context = userContextProvider.get();
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
public ObjectPermission retrievePermission(ModeledAuthenticatedUser user,
public Set<ObjectPermission> retrievePermissions(ModeledAuthenticatedUser user,
public Collection<String> retrieveAccessibleIdentifiers(ModeledAuthenticatedUser user,
public ObjectPermissionSet getPermissionSet(ModeledAuthenticatedUser user,
public void createPermissions(ModeledAuthenticatedUser user,
public void deletePermissions(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
public TrackedActiveConnection retrieveObject(ModeledAuthenticatedUser user,
public Collection<TrackedActiveConnection> retrieveObjects(ModeledAuthenticatedUser user,
public void deleteObject(ModeledAuthenticatedUser user, String identifier)
public Set<String> getIdentifiers(ModeledAuthenticatedUser user)
public TrackedActiveConnection createObject(ModeledAuthenticatedUser user,
public void updateObject(ModeledAuthenticatedUser user, TrackedActiveConnection object)
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
public void init(ModeledAuthenticatedUser currentUser,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
InternalType retrieveObject(ModeledAuthenticatedUser user, String identifier)
Collection<InternalType> retrieveObjects(ModeledAuthenticatedUser user,
InternalType createObject(ModeledAuthenticatedUser user, ExternalType object)
void deleteObject(ModeledAuthenticatedUser user, String identifier)
void updateObject(ModeledAuthenticatedUser user, InternalType object)
Set<String> getIdentifiers(ModeledAuthenticatedUser user) throws GuacamoleException;
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
protected abstract InternalType getObjectInstance(ModeledAuthenticatedUser currentUser,
protected abstract ModelType getModelInstance(ModeledAuthenticatedUser currentUser,
protected abstract boolean hasCreatePermission(ModeledAuthenticatedUser user)
protected boolean hasObjectPermission(ModeledAuthenticatedUser user,
protected abstract ObjectPermissionSet getPermissionSet(ModeledAuthenticatedUser user)
protected Collection<InternalType> getObjectInstances(ModeledAuthenticatedUser currentUser,
protected void beforeCreate(ModeledAuthenticatedUser user,
protected void beforeUpdate(ModeledAuthenticatedUser user,
protected void beforeDelete(ModeledAuthenticatedUser user,
public InternalType retrieveObject(ModeledAuthenticatedUser user,
public Collection<InternalType> retrieveObjects(ModeledAuthenticatedUser user,
protected Collection<ObjectPermissionModel> getImplicitPermissions(ModeledAuthenticatedUser user,
public InternalType createObject(ModeledAuthenticatedUser user, ExternalType object)
public void deleteObject(ModeledAuthenticatedUser user, String identifier)
public void updateObject(ModeledAuthenticatedUser user, InternalType object)
public Set<String> getIdentifiers(ModeledAuthenticatedUser user)
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
protected Collection<String> getModifiedGroups(ModeledAuthenticatedUser user,
protected boolean canUpdateModifiedGroups(ModeledAuthenticatedUser user,
protected void beforeCreate(ModeledAuthenticatedUser user,
protected void beforeUpdate(ModeledAuthenticatedUser user,
protected void beforeDelete(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
public void init(ModeledAuthenticatedUser currentUser, ModelType model) {
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
private ModeledAuthenticatedUser currentUser;
public void init(ModeledAuthenticatedUser currentUser) {
public ModeledAuthenticatedUser getCurrentUser() {
public void setCurrentUser(ModeledAuthenticatedUser currentUser) {
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
protected ModeledConnection getObjectInstance(ModeledAuthenticatedUser currentUser,
protected ConnectionModel getModelInstance(ModeledAuthenticatedUser currentUser,
protected boolean hasCreatePermission(ModeledAuthenticatedUser user)
protected ObjectPermissionSet getPermissionSet(ModeledAuthenticatedUser user)
protected void beforeCreate(ModeledAuthenticatedUser user,
protected void beforeUpdate(ModeledAuthenticatedUser user,
public ModeledConnection createObject(ModeledAuthenticatedUser user, Connection object)
public void updateObject(ModeledAuthenticatedUser user, ModeledConnection object)
public Set<String> getIdentifiersWithin(ModeledAuthenticatedUser user,
public Map<String, String> retrieveParameters(ModeledAuthenticatedUser user,
public List<ConnectionRecord> retrieveHistory(ModeledAuthenticatedUser user,
public List<ConnectionRecord> retrieveHistory(ModeledAuthenticatedUser user,
public GuacamoleTunnel connect(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
private ModeledAuthenticatedUser currentUser;
public void init(ModeledAuthenticatedUser currentUser, ConnectionModel connectionModel) {
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
protected ModeledConnectionGroup getObjectInstance(ModeledAuthenticatedUser currentUser,
protected ConnectionGroupModel getModelInstance(ModeledAuthenticatedUser currentUser,
protected boolean hasCreatePermission(ModeledAuthenticatedUser user)
protected ObjectPermissionSet getPermissionSet(ModeledAuthenticatedUser user)
protected void beforeCreate(ModeledAuthenticatedUser user,
protected void beforeUpdate(ModeledAuthenticatedUser user,
public Set<String> getIdentifiersWithin(ModeledAuthenticatedUser user,
public GuacamoleTunnel connect(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
protected boolean canReadPermissions(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
public ObjectPermissionSet getPermissionSet(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
public ObjectPermissionSet getPermissionSet(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
protected boolean canAlterPermissions(ModeledAuthenticatedUser user, ModeledUser targetUser,
public void createPermissions(ModeledAuthenticatedUser user, ModeledUser targetUser,
public void deletePermissions(ModeledAuthenticatedUser user, ModeledUser targetUser,
public ObjectPermission retrievePermission(ModeledAuthenticatedUser user,
public Collection<String> retrieveAccessibleIdentifiers(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
public Set<PermissionType> retrievePermissions(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
ObjectPermission retrievePermission(ModeledAuthenticatedUser user,
Collection<String> retrieveAccessibleIdentifiers(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
public void init(ModeledAuthenticatedUser currentUser, ModeledUser user) {
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
PermissionSetType getPermissionSet(ModeledAuthenticatedUser user,
Set<PermissionType> retrievePermissions(ModeledAuthenticatedUser user,
void createPermissions(ModeledAuthenticatedUser user, ModeledUser targetUser,
void deletePermissions(ModeledAuthenticatedUser user, ModeledUser targetUser,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
public ObjectPermissionSet getPermissionSet(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
public SystemPermissionSet getPermissionSet(ModeledAuthenticatedUser user,
public void createPermissions(ModeledAuthenticatedUser user, ModeledUser targetUser,
public void deletePermissions(ModeledAuthenticatedUser user, ModeledUser targetUser,
public SystemPermission retrievePermission(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
public void init(ModeledAuthenticatedUser currentUser, ModeledUser user) {
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
public ObjectPermissionSet getPermissionSet(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
public UserCredentials generateTemporaryCredentials(ModeledAuthenticatedUser user,
AuthenticationProvider authenticationProvider,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
protected ModeledSharingProfile getObjectInstance(ModeledAuthenticatedUser currentUser,
protected SharingProfileModel getModelInstance(ModeledAuthenticatedUser currentUser,
protected boolean hasCreatePermission(ModeledAuthenticatedUser user)
protected ObjectPermissionSet getPermissionSet(ModeledAuthenticatedUser user)
protected void beforeCreate(ModeledAuthenticatedUser user,
protected void beforeUpdate(ModeledAuthenticatedUser user,
public ModeledSharingProfile createObject(ModeledAuthenticatedUser user, SharingProfile object)
public void updateObject(ModeledAuthenticatedUser user, ModeledSharingProfile object)
public Set<String> getIdentifiersWithin(ModeledAuthenticatedUser user,
public Map<String, String> retrieveParameters(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
private Collection<String> getPreferredConnections(ModeledAuthenticatedUser user,
private List<ModeledConnection> getBalancedConnections(ModeledAuthenticatedUser user,
public Collection<ActiveConnectionRecord> getActiveConnections(ModeledAuthenticatedUser user)
public GuacamoleTunnel getGuacamoleTunnel(final ModeledAuthenticatedUser user,
public GuacamoleTunnel getGuacamoleTunnel(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
public Collection<ActiveConnectionRecord> getActiveConnections(ModeledAuthenticatedUser user)
GuacamoleTunnel getGuacamoleTunnel(ModeledAuthenticatedUser user,
GuacamoleTunnel getGuacamoleTunnel(ModeledAuthenticatedUser user,
public class ModeledUserContext extends RestrictedObject
public void init(ModeledAuthenticatedUser currentUser) {
return getCurrentUser().getModelAuthenticationProvider();
import org.apache.guacamole.net.auth.AuthenticatedUser;
protected ModeledUser getObjectInstance(ModeledAuthenticatedUser currentUser,
protected UserModel getModelInstance(ModeledAuthenticatedUser currentUser,
protected boolean hasCreatePermission(ModeledAuthenticatedUser user)
protected ObjectPermissionSet getPermissionSet(ModeledAuthenticatedUser user)
protected void beforeCreate(ModeledAuthenticatedUser user, UserModel model)
protected void beforeUpdate(ModeledAuthenticatedUser user,
getImplicitPermissions(ModeledAuthenticatedUser user, UserModel model) {
protected void beforeDelete(ModeledAuthenticatedUser user, String identifier) throws GuacamoleException {
public ModeledAuthenticatedUser retrieveAuthenticatedUser(AuthenticationProvider authenticationProvider,
user.setCurrentUser(new ModeledAuthenticatedUser(authenticationProvider, user, credentials));
public ModeledUser retrieveUser(AuthenticationProvider authenticationProvider,
AuthenticatedUser authenticatedUser) {
if (authenticatedUser instanceof ModeledAuthenticatedUser)
return ((ModeledAuthenticatedUser) authenticatedUser).getUser();
user.setCurrentUser(new ModeledAuthenticatedUser(authenticatedUser,
authenticationProvider, user));
protected boolean isValidIdentifier(String identifier) {
if (identifier.isEmpty())
return false;
if (!Character.isDigit(identifier.charAt(i)))
return false;
}
return true;
}
protected Collection<String> filterIdentifiers(Collection<String> identifiers) {
Collection<String> validIdentifiers = new ArrayList<String>(identifiers.size());
for (String identifier : identifiers) {
if (isValidIdentifier(identifier))
validIdentifiers.add(identifier);
}
return validIdentifiers;
}
identifiers = filterIdentifiers(identifiers);
@Override
protected boolean isValidIdentifier(String identifier) {
return true;
}
protected boolean isValidIdentifier(String identifier) {
if (identifier.isEmpty())
return false;
if (!Character.isDigit(identifier.charAt(i)))
return false;
}
return true;
}
protected Collection<String> filterIdentifiers(Collection<String> identifiers) {
Collection<String> validIdentifiers = new ArrayList<String>(identifiers.size());
for (String identifier : identifiers) {
if (isValidIdentifier(identifier))
validIdentifiers.add(identifier);
}
return validIdentifiers;
}
identifiers = filterIdentifiers(identifiers);
@Override
protected boolean isValidIdentifier(String identifier) {
return true;
}
AuthenticatedUser authenticatedUser, Credentials credentials)
throws GuacamoleException {
AuthenticatedUser authenticatedUser,
Credentials credentials) throws GuacamoleException {
AuthenticatedUser authenticatedUser,
Credentials credentials) throws GuacamoleException;
AuthenticatedUser authorizedUser, Credentials credentials)
throws GuacamoleException {
AuthenticatedUser authenticatedUser, Credentials credentials)
return authProvider.updateUserContext(context, authenticatedUser, credentials);
AuthenticatedUser authenticatedUser, Credentials credentials)
throws GuacamoleException {
UserContext userContext = authProvider.updateUserContext(oldUserContext, authenticatedUser, credentials);
List<UserContext> userContexts = getUserContexts(existingSession, authenticatedUser, credentials);
import org.apache.guacamole.auth.jdbc.sharing.connection.SharedConnectionDefinition;
import org.apache.guacamole.auth.jdbc.sharing.user.SharedAuthenticatedUser;
public SharedAuthenticatedUser retrieveSharedConnectionUser(
if (connectionMap.get(shareKey) == null)
return new SharedAuthenticatedUser(authProvider, credentials, shareKey);
import org.apache.guacamole.auth.jdbc.sharing.connection.SharedConnectionDefinition;
import org.apache.guacamole.auth.jdbc.sharing.user.SharedAuthenticatedUser;
import org.apache.guacamole.auth.jdbc.sharing.user.SharedUserContext;
private Provider<SharedUserContext> sharedUserContextProvider;
public SharedUserContext getUserContext(
SharedAuthenticatedUser sharedAuthenticatedUser;
if (authenticatedUser instanceof SharedAuthenticatedUser)
sharedAuthenticatedUser = (SharedAuthenticatedUser) authenticatedUser;
else
sharedAuthenticatedUser = new SharedAuthenticatedUser(authenticatedUser);
SharedUserContext context = sharedUserContextProvider.get();
context.init(authenticationProvider, sharedAuthenticatedUser);
String shareKey = sharedAuthenticatedUser.getShareKey();
if (shareKey != null)
context.registerShareKey(shareKey);
return context;
import org.apache.guacamole.auth.jdbc.sharing.connection.SharedConnectionDefinition;
package org.apache.guacamole.auth.jdbc.sharing.connection;
import org.apache.guacamole.auth.jdbc.sharing.connectiongroup.SharedRootConnectionGroup;
import org.apache.guacamole.auth.jdbc.user.RemoteAuthenticatedUser;
private RemoteAuthenticatedUser user;
public void init(RemoteAuthenticatedUser user, SharedConnectionDefinition definition) {
return definition.getShareKey();
return SharedRootConnectionGroup.IDENTIFIER;
package org.apache.guacamole.auth.jdbc.sharing.connection;
import org.apache.guacamole.auth.jdbc.sharing.SharedObjectManager;
package org.apache.guacamole.auth.jdbc.sharing.user;
import org.apache.guacamole.auth.jdbc.sharing.connection.SharedConnectionDirectory;
import org.apache.guacamole.auth.jdbc.sharing.connectiongroup.SharedRootConnectionGroup;
import org.apache.guacamole.auth.jdbc.user.RemoteAuthenticatedUser;
public class SharedUserContext implements UserContext {
@Inject
private SharedConnectionDirectory connectionDirectory;
public void init(AuthenticationProvider authProvider, RemoteAuthenticatedUser user) {
this.authProvider = authProvider;
this.connectionDirectory.init(user);
this.rootGroup = new SharedRootConnectionGroup(this);
this.self = new SharedUser(user, this);
public void registerShareKey(String shareKey) {
connectionDirectory.registerShareKey(shareKey);
}
import org.apache.guacamole.auth.jdbc.sharing.connection.SharedConnectionDefinition;
public GuacamoleTunnel getGuacamoleTunnel(RemoteAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.sharing.connection.SharedConnectionDefinition;
import org.apache.guacamole.auth.jdbc.user.RemoteAuthenticatedUser;
GuacamoleTunnel getGuacamoleTunnel(RemoteAuthenticatedUser user,
public UserContext updateUserContext(AuthenticationProvider authenticationProvider,
UserContext context, AuthenticatedUser authenticatedUser,
Credentials credentials) throws GuacamoleException;
return authProviderService.updateUserContext(this, context,
authenticatedUser, credentials);
import org.apache.guacamole.net.auth.UserContext;
@Override
public UserContext updateUserContext(AuthenticationProvider authenticationProvider,
UserContext context, AuthenticatedUser authenticatedUser,
Credentials credentials) throws GuacamoleException {
return context;
}
public String getShareKey(Credentials credentials) {
HttpServletRequest request = credentials.getRequest();
if (request == null)
return null;
return request.getParameter(SHARE_KEY_NAME);
}
String shareKey = getShareKey(credentials);
if (shareKey == null || connectionMap.get(shareKey) == null)
import org.apache.guacamole.net.auth.UserContext;
@Override
public UserContext updateUserContext(AuthenticationProvider authenticationProvider,
UserContext context, AuthenticatedUser authenticatedUser,
Credentials credentials) throws GuacamoleException {
String shareKey = sharingService.getShareKey(credentials);
if (shareKey != null)
((SharedUserContext) context).registerShareKey(shareKey);
return context;
}
public static final String CONNECTION_OWNER = "jdbc-shared-by";
String sharedBy = definition.getActiveConnection().getUser().getIdentifier();
return Collections.<String, String>singletonMap(CONNECTION_OWNER, sharedBy);
return definition.getActiveConnection().getConnection().getName();
return Type.ORGANIZATIONAL;
public UserContext updateUserContext(AuthenticationProvider authenticationProvider,
UserContext context, AuthenticatedUser authenticatedUser,
Credentials credentials) throws GuacamoleException;
return authProviderService.updateUserContext(this, context,
authenticatedUser, credentials);
import org.apache.guacamole.net.auth.UserContext;
@Override
public UserContext updateUserContext(AuthenticationProvider authenticationProvider,
UserContext context, AuthenticatedUser authenticatedUser,
Credentials credentials) throws GuacamoleException {
return context;
}
import org.apache.guacamole.auth.jdbc.sharing.connection.SharedConnectionDefinition;
import org.apache.guacamole.auth.jdbc.sharing.user.SharedAuthenticatedUser;
public String getShareKey(Credentials credentials) {
HttpServletRequest request = credentials.getRequest();
if (request == null)
return null;
return request.getParameter(SHARE_KEY_NAME);
}
public SharedAuthenticatedUser retrieveSharedConnectionUser(
String shareKey = getShareKey(credentials);
if (shareKey == null || connectionMap.get(shareKey) == null)
return new SharedAuthenticatedUser(authProvider, credentials, shareKey);
import org.apache.guacamole.auth.jdbc.sharing.connection.SharedConnectionDefinition;
import org.apache.guacamole.auth.jdbc.sharing.user.SharedAuthenticatedUser;
import org.apache.guacamole.auth.jdbc.sharing.user.SharedUserContext;
import org.apache.guacamole.net.auth.UserContext;
private Provider<SharedUserContext> sharedUserContextProvider;
public SharedUserContext getUserContext(
SharedAuthenticatedUser sharedAuthenticatedUser;
if (authenticatedUser instanceof SharedAuthenticatedUser)
sharedAuthenticatedUser = (SharedAuthenticatedUser) authenticatedUser;
else
sharedAuthenticatedUser = new SharedAuthenticatedUser(authenticatedUser);
SharedUserContext context = sharedUserContextProvider.get();
context.init(authenticationProvider, sharedAuthenticatedUser);
String shareKey = sharedAuthenticatedUser.getShareKey();
if (shareKey != null)
context.registerShareKey(shareKey);
return context;
}
@Override
public UserContext updateUserContext(AuthenticationProvider authenticationProvider,
UserContext context, AuthenticatedUser authenticatedUser,
Credentials credentials) throws GuacamoleException {
String shareKey = sharingService.getShareKey(credentials);
if (shareKey != null)
((SharedUserContext) context).registerShareKey(shareKey);
return context;
import org.apache.guacamole.auth.jdbc.sharing.connection.SharedConnectionDefinition;
package org.apache.guacamole.auth.jdbc.sharing.connection;
import org.apache.guacamole.auth.jdbc.sharing.connectiongroup.SharedRootConnectionGroup;
import org.apache.guacamole.auth.jdbc.user.RemoteAuthenticatedUser;
public static final String CONNECTION_OWNER = "jdbc-shared-by";
private RemoteAuthenticatedUser user;
public void init(RemoteAuthenticatedUser user, SharedConnectionDefinition definition) {
return definition.getShareKey();
return definition.getActiveConnection().getConnection().getName();
return SharedRootConnectionGroup.IDENTIFIER;
String sharedBy = definition.getActiveConnection().getUser().getIdentifier();
return Collections.<String, String>singletonMap(CONNECTION_OWNER, sharedBy);
package org.apache.guacamole.auth.jdbc.sharing.connection;
import org.apache.guacamole.auth.jdbc.sharing.SharedObjectManager;
package org.apache.guacamole.auth.jdbc.sharing.user;
import org.apache.guacamole.auth.jdbc.sharing.connection.SharedConnectionDirectory;
import org.apache.guacamole.auth.jdbc.sharing.connectiongroup.SharedRootConnectionGroup;
import org.apache.guacamole.auth.jdbc.user.RemoteAuthenticatedUser;
public class SharedUserContext implements UserContext {
@Inject
private SharedConnectionDirectory connectionDirectory;
public void init(AuthenticationProvider authProvider, RemoteAuthenticatedUser user) {
this.authProvider = authProvider;
this.connectionDirectory.init(user);
this.rootGroup = new SharedRootConnectionGroup(this);
this.self = new SharedUser(user, this);
public void registerShareKey(String shareKey) {
connectionDirectory.registerShareKey(shareKey);
}
import org.apache.guacamole.auth.jdbc.sharing.connection.SharedConnectionDefinition;
public GuacamoleTunnel getGuacamoleTunnel(RemoteAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.sharing.connection.SharedConnectionDefinition;
import org.apache.guacamole.auth.jdbc.user.RemoteAuthenticatedUser;
GuacamoleTunnel getGuacamoleTunnel(RemoteAuthenticatedUser user,
import java.util.Collection;
import org.apache.guacamole.rest.sharingprofile.APISharingProfile;
private Collection<APISharingProfile> sharingProfiles;
public Collection<APISharingProfile> getSharingProfiles() {
return sharingProfiles;
}
public void setSharingProfiles(Collection<APISharingProfile> sharingProfiles) {
this.sharingProfiles = sharingProfiles;
}
import org.apache.guacamole.net.auth.Directory;
import org.apache.guacamole.net.auth.SharingProfile;
import org.apache.guacamole.net.auth.User;
import org.apache.guacamole.rest.sharingprofile.APISharingProfile;
private final ObjectPermissionSet connectionPermissions;
private final ObjectPermissionSet sharingProfilePermissions;
private final Directory<Connection> connectionDirectory;
private final Directory<ConnectionGroup> connectionGroupDirectory;
private final Directory<SharingProfile> sharingProfileDirectory;
private final Map<String, APIConnection> retrievedConnections =
new HashMap<String, APIConnection>();
APIConnection apiConnection = new APIConnection(connection);
retrievedConnections.put(connection.getIdentifier(), apiConnection);
children.add(apiConnection);
private void addSharingProfiles(Collection<SharingProfile> sharingProfiles)
throws GuacamoleException {
for (SharingProfile sharingProfile : sharingProfiles) {
String primaryConnectionIdentifier = sharingProfile.getPrimaryConnectionIdentifier();
APIConnection primaryConnection = retrievedConnections.get(primaryConnectionIdentifier);
if (primaryConnection != null) {
Collection<APISharingProfile> children = primaryConnection.getSharingProfiles();
if (children == null) {
children = new ArrayList<APISharingProfile>();
primaryConnection.setSharingProfiles(children);
}
children.add(new APISharingProfile(sharingProfile));
}
else
logger.debug("Sharing profile \"{}\" cannot be added to the "
"tree: primary connection \"{}\" does not actually "
"exist.", sharingProfile.getIdentifier(),
primaryConnectionIdentifier);
}
private void addConnectionGroupDescendants(Collection<ConnectionGroup> parents,
if (permissions != null && !permissions.isEmpty())
childConnectionIdentifiers = connectionPermissions.getAccessibleObjects(
permissions, childConnectionIdentifiers);
Collection<Connection> childConnections = connectionDirectory.getAll(childConnectionIdentifiers);
addConnectionDescendants(childConnections, permissions);
Collection<ConnectionGroup> childConnectionGroups = connectionGroupDirectory.getAll(childConnectionGroupIdentifiers);
addConnectionGroupDescendants(childConnectionGroups, permissions);
}
}
private void addConnectionDescendants(Collection<Connection> connections,
List<ObjectPermission.Type> permissions)
throws GuacamoleException {
if (connections.isEmpty())
return;
Collection<String> identifiers = new ArrayList<String>();
for (Connection connection : connections)
identifiers.addAll(connection.getSharingProfileIdentifiers());
if (permissions != null && !permissions.isEmpty())
identifiers = sharingProfilePermissions.getAccessibleObjects(
permissions, identifiers);
if (!identifiers.isEmpty()) {
Collection<SharingProfile> sharingProfiles = sharingProfileDirectory.getAll(identifiers);
addSharingProfiles(sharingProfiles);
User self = userContext.self();
this.connectionPermissions = self.getConnectionPermissions();
this.sharingProfilePermissions = self.getSharingProfilePermissions();
this.connectionDirectory = userContext.getConnectionDirectory();
this.connectionGroupDirectory = userContext.getConnectionGroupDirectory();
this.sharingProfileDirectory = userContext.getSharingProfileDirectory();
addConnectionGroupDescendants(Collections.singleton(root), permissions);
import java.util.Collection;
import org.apache.guacamole.rest.sharingprofile.APISharingProfile;
private Collection<APISharingProfile> sharingProfiles;
public Collection<APISharingProfile> getSharingProfiles() {
return sharingProfiles;
}
public void setSharingProfiles(Collection<APISharingProfile> sharingProfiles) {
this.sharingProfiles = sharingProfiles;
}
import org.apache.guacamole.net.auth.Directory;
import org.apache.guacamole.net.auth.SharingProfile;
import org.apache.guacamole.net.auth.User;
import org.apache.guacamole.rest.sharingprofile.APISharingProfile;
private final ObjectPermissionSet connectionPermissions;
private final ObjectPermissionSet sharingProfilePermissions;
private final Directory<Connection> connectionDirectory;
private final Directory<ConnectionGroup> connectionGroupDirectory;
private final Directory<SharingProfile> sharingProfileDirectory;
private final Map<String, APIConnection> retrievedConnections =
new HashMap<String, APIConnection>();
APIConnection apiConnection = new APIConnection(connection);
retrievedConnections.put(connection.getIdentifier(), apiConnection);
children.add(apiConnection);
private void addSharingProfiles(Collection<SharingProfile> sharingProfiles)
throws GuacamoleException {
for (SharingProfile sharingProfile : sharingProfiles) {
String primaryConnectionIdentifier = sharingProfile.getPrimaryConnectionIdentifier();
APIConnection primaryConnection = retrievedConnections.get(primaryConnectionIdentifier);
if (primaryConnection != null) {
Collection<APISharingProfile> children = primaryConnection.getSharingProfiles();
if (children == null) {
children = new ArrayList<APISharingProfile>();
primaryConnection.setSharingProfiles(children);
}
children.add(new APISharingProfile(sharingProfile));
}
else
logger.debug("Sharing profile \"{}\" cannot be added to the "
"tree: primary connection \"{}\" does not actually "
"exist.", sharingProfile.getIdentifier(),
primaryConnectionIdentifier);
}
private void addConnectionGroupDescendants(Collection<ConnectionGroup> parents,
if (permissions != null && !permissions.isEmpty())
childConnectionIdentifiers = connectionPermissions.getAccessibleObjects(
permissions, childConnectionIdentifiers);
Collection<Connection> childConnections = connectionDirectory.getAll(childConnectionIdentifiers);
addConnectionDescendants(childConnections, permissions);
Collection<ConnectionGroup> childConnectionGroups = connectionGroupDirectory.getAll(childConnectionGroupIdentifiers);
addConnectionGroupDescendants(childConnectionGroups, permissions);
}
}
private void addConnectionDescendants(Collection<Connection> connections,
List<ObjectPermission.Type> permissions)
throws GuacamoleException {
if (connections.isEmpty())
return;
Collection<String> identifiers = new ArrayList<String>();
for (Connection connection : connections)
identifiers.addAll(connection.getSharingProfileIdentifiers());
if (permissions != null && !permissions.isEmpty())
identifiers = sharingProfilePermissions.getAccessibleObjects(
permissions, identifiers);
if (!identifiers.isEmpty()) {
Collection<SharingProfile> sharingProfiles = sharingProfileDirectory.getAll(identifiers);
addSharingProfiles(sharingProfiles);
User self = userContext.self();
this.connectionPermissions = self.getConnectionPermissions();
this.sharingProfilePermissions = self.getSharingProfilePermissions();
this.connectionDirectory = userContext.getConnectionDirectory();
this.connectionGroupDirectory = userContext.getConnectionGroupDirectory();
this.sharingProfileDirectory = userContext.getSharingProfileDirectory();
addConnectionGroupDescendants(Collections.singleton(root), permissions);
@GET
@Path("sharingProfileAttributes")
public Collection<Form> getSharingProfileAttributes()
throws GuacamoleException {
return userContext.getSharingProfileAttributes();
}
private Collection<Form> connectionForms;
private Collection<Form> sharingProfileForms;
public ProtocolInfo(String name, Collection<Form> connectionForms,
Collection<Form> sharingProfileForms) {
this.name = name;
this.connectionForms = connectionForms;
this.sharingProfileForms = sharingProfileForms;
}
this(null);
this(name, new ArrayList<Form>());
this(name, forms, new ArrayList<Form>(forms));
public Collection<Form> getConnectionForms() {
return connectionForms;
public void setConnectionForms(Collection<Form> connectionForms) {
this.connectionForms = connectionForms;
public Collection<Form> getSharingProfileForms() {
return sharingProfileForms;
}
public void setSharingProfileForms(Collection<Form> sharingProfileForms) {
this.sharingProfileForms = sharingProfileForms;
}
@GET
@Path("sharingProfileAttributes")
public Collection<Form> getSharingProfileAttributes()
throws GuacamoleException {
return userContext.getSharingProfileAttributes();
}
private Collection<Form> connectionForms;
private Collection<Form> sharingProfileForms;
public ProtocolInfo(String name, Collection<Form> connectionForms,
Collection<Form> sharingProfileForms) {
this.name = name;
this.connectionForms = connectionForms;
this.sharingProfileForms = sharingProfileForms;
}
this(null);
this(name, new ArrayList<Form>());
this(name, forms, new ArrayList<Form>(forms));
public Collection<Form> getConnectionForms() {
return connectionForms;
public void setConnectionForms(Collection<Form> connectionForms) {
this.connectionForms = connectionForms;
public Collection<Form> getSharingProfileForms() {
return sharingProfileForms;
}
public void setSharingProfileForms(Collection<Form> sharingProfileForms) {
this.sharingProfileForms = sharingProfileForms;
}
public class SecureRandomShareKeyGenerator extends SecureRandom
implements ShareKeyGenerator {
private static final int KEY_LENGTH = 44;
private static final char[] URL_SAFE_BASE64_DIGITS = {
'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_'
};
char[] key = new char[KEY_LENGTH];
key[i] = URL_SAFE_BASE64_DIGITS[next(6)];
return new String(key);
public static final String ANONYMOUS_IDENTIFIER = "";
this.identifier = AuthenticatedUser.ANONYMOUS_IDENTIFIER;
public class SecureRandomShareKeyGenerator extends SecureRandom
implements ShareKeyGenerator {
private static final int KEY_LENGTH = 44;
private static final char[] URL_SAFE_BASE64_DIGITS = {
'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_'
};
char[] key = new char[KEY_LENGTH];
key[i] = URL_SAFE_BASE64_DIGITS[next(6)];
return new String(key);
this.identifier = AuthenticatedUser.ANONYMOUS_IDENTIFIER;
public static final String ANONYMOUS_IDENTIFIER = "";
public int getMaxResults() throws GuacamoleException {
return environment.getProperty(
LDAPGuacamoleProperties.LDAP_MAX_SEARCH_RESULTS,
1000
);
}
public static final IntegerGuacamoleProperty LDAP_MAX_SEARCH_RESULTS = new IntegerGuacamoleProperty() {
@Override
public String getName() { return "ldap-max-search-results"; }
};
import com.novell.ldap.LDAPSearchConstraints;
LDAPSearchConstraints constraints = new LDAPSearchConstraints();
constraints.setMaxResults(confService.getMaxResults());
false,
constraints
import java.util.HashSet;
import java.util.Set;
private Set<String> sharingProfileIdentifiers = new HashSet<String>();
public Set<String> getSharingProfileIdentifiers() {
return sharingProfileIdentifiers;
}
public void setSharingProfileIdentifiers(Set<String> sharingProfileIdentifiers) {
this.sharingProfileIdentifiers = sharingProfileIdentifiers;
}
return getModel().getSharingProfileIdentifiers();
import java.util.HashSet;
import java.util.Set;
private Set<String> connectionIdentifiers = new HashSet<String>();
private Set<String> connectionGroupIdentifiers = new HashSet<String>();
public Set<String> getConnectionIdentifiers() {
return connectionIdentifiers;
}
public void setConnectionIdentifiers(Set<String> connectionIdentifiers) {
this.connectionIdentifiers = connectionIdentifiers;
}
public Set<String> getConnectionGroupIdentifiers() {
return connectionGroupIdentifiers;
}
public void setConnectionGroupIdentifiers(Set<String> connectionGroupIdentifiers) {
this.connectionGroupIdentifiers = connectionGroupIdentifiers;
}
return getModel().getConnectionIdentifiers();
return getModel().getConnectionGroupIdentifiers();
driverProperties.setProperty("allowMultiQueries", "true");
driverProperties.setProperty("characterEncoding", "UTF-8");
driverProperties.setProperty("characterEncoding", "UTF-8");
import org.apache.guacamole.rest.directory.DirectoryObjectResource;
import org.apache.guacamole.rest.directory.DirectoryObjectResourceFactory;
@Inject
private DirectoryObjectResourceFactory<User, APIUser> userResourceFactory;
@Path("self")
public DirectoryObjectResource<User, APIUser> getSelfResource()
throws GuacamoleException {
return userResourceFactory.create(userContext,
userContext.getUserDirectory(), userContext.self());
}
this.userDirectory = new SimpleDirectory<User>();
import java.util.HashSet;
import java.util.Set;
private Set<String> sharingProfileIdentifiers = new HashSet<String>();
public Set<String> getSharingProfileIdentifiers() {
return sharingProfileIdentifiers;
}
public void setSharingProfileIdentifiers(Set<String> sharingProfileIdentifiers) {
this.sharingProfileIdentifiers = sharingProfileIdentifiers;
}
return getModel().getSharingProfileIdentifiers();
import java.util.HashSet;
import java.util.Set;
private Set<String> connectionIdentifiers = new HashSet<String>();
private Set<String> connectionGroupIdentifiers = new HashSet<String>();
public Set<String> getConnectionIdentifiers() {
return connectionIdentifiers;
}
public void setConnectionIdentifiers(Set<String> connectionIdentifiers) {
this.connectionIdentifiers = connectionIdentifiers;
}
public Set<String> getConnectionGroupIdentifiers() {
return connectionGroupIdentifiers;
}
public void setConnectionGroupIdentifiers(Set<String> connectionGroupIdentifiers) {
this.connectionGroupIdentifiers = connectionGroupIdentifiers;
}
return getModel().getConnectionIdentifiers();
return getModel().getConnectionGroupIdentifiers();
driverProperties.setProperty("characterEncoding", "UTF-8");
driverProperties.setProperty("allowMultiQueries", "true");
driverProperties.setProperty("characterEncoding", "UTF-8");
this.userDirectory = new SimpleDirectory<User>();
import org.apache.guacamole.rest.directory.DirectoryObjectResource;
import org.apache.guacamole.rest.directory.DirectoryObjectResourceFactory;
@Inject
private DirectoryObjectResourceFactory<User, APIUser> userResourceFactory;
@Path("self")
public DirectoryObjectResource<User, APIUser> getSelfResource()
throws GuacamoleException {
return userResourceFactory.create(userContext,
userContext.getUserDirectory(), userContext.self());
}
public abstract class ChildObjectModel extends ObjectModel {
public ChildObjectModel() {
public abstract class ModeledChildDirectoryObject<ModelType extends ChildObjectModel>
public abstract class ModeledChildDirectoryObjectService<InternalType extends ModeledChildDirectoryObject<ModelType>,
ExternalType extends Identifiable, ModelType extends ChildObjectModel>
protected abstract ObjectPermissionSet getParentPermissionSet(
ModeledAuthenticatedUser user) throws GuacamoleException;
protected Collection<String> getModifiedParents(ModeledAuthenticatedUser user,
Collection<String> parents = new ArrayList<String>(2);
if (oldParentIdentifier != null) parents.add(oldParentIdentifier);
if (parentIdentifier    != null) parents.add(parentIdentifier);
return parents;
protected boolean canUpdateModifiedParents(ModeledAuthenticatedUser user,
Collection<String> modifiedParents = getModifiedParents(user, identifier, model);
if (!modifiedParents.isEmpty()) {
ObjectPermissionSet permissionSet = getParentPermissionSet(user);
Collection<String> updateableParents = permissionSet.getAccessibleObjects(
modifiedParents
return updateableParents.size() == modifiedParents.size();
if (!canUpdateModifiedParents(user, null, model))
if (!canUpdateModifiedParents(user, model.getIdentifier(), model))
if (!canUpdateModifiedParents(user, identifier, null))
import org.apache.guacamole.auth.jdbc.base.ChildObjectModel;
public class ConnectionModel extends ChildObjectModel {
import org.apache.guacamole.auth.jdbc.base.ModeledChildDirectoryObjectService;
public class ConnectionService extends ModeledChildDirectoryObjectService<ModeledConnection, Connection, ConnectionModel> {
protected ObjectPermissionSet getParentPermissionSet(ModeledAuthenticatedUser user)
throws GuacamoleException {
return user.getUser().getConnectionGroupPermissions();
}
@Override
import org.apache.guacamole.auth.jdbc.base.ModeledChildDirectoryObject;
public class ModeledConnection extends ModeledChildDirectoryObject<ConnectionModel>
import org.apache.guacamole.auth.jdbc.base.ChildObjectModel;
public class ConnectionGroupModel extends ChildObjectModel {
import org.apache.guacamole.auth.jdbc.base.ModeledChildDirectoryObjectService;
public class ConnectionGroupService extends ModeledChildDirectoryObjectService<ModeledConnectionGroup,
protected ObjectPermissionSet getParentPermissionSet(ModeledAuthenticatedUser user)
throws GuacamoleException {
return user.getUser().getConnectionGroupPermissions();
}
@Override
import org.apache.guacamole.auth.jdbc.base.ModeledChildDirectoryObject;
public class ModeledConnectionGroup extends ModeledChildDirectoryObject<ConnectionGroupModel>
import org.apache.guacamole.auth.jdbc.base.ModeledChildDirectoryObject;
extends ModeledChildDirectoryObject<SharingProfileModel>
return getModel().getParentIdentifier();
getModel().setParentIdentifier(identifier);
@Param("parentIdentifier") String parentIdentifier,
import org.apache.guacamole.auth.jdbc.base.ChildObjectModel;
public class SharingProfileModel extends ChildObjectModel {
import org.apache.guacamole.auth.jdbc.base.ModeledChildDirectoryObjectService;
extends ModeledChildDirectoryObjectService<ModeledSharingProfile,
protected ObjectPermissionSet getParentPermissionSet(ModeledAuthenticatedUser user)
throws GuacamoleException {
return user.getUser().getConnectionPermissions();
}
@Override
SharingProfileModel existing = sharingProfileMapper.selectOneByName(model.getParentIdentifier(), model.getName());
SharingProfileModel existing = sharingProfileMapper.selectOneByName(model.getParentIdentifier(), model.getName());
public abstract class ChildObjectModel extends ObjectModel {
public ChildObjectModel() {
public abstract class ModeledChildDirectoryObject<ModelType extends ChildObjectModel>
public abstract class ModeledChildDirectoryObjectService<InternalType extends ModeledChildDirectoryObject<ModelType>,
ExternalType extends Identifiable, ModelType extends ChildObjectModel>
protected abstract ObjectPermissionSet getParentPermissionSet(
ModeledAuthenticatedUser user) throws GuacamoleException;
protected Collection<String> getModifiedParents(ModeledAuthenticatedUser user,
Collection<String> parents = new ArrayList<String>(2);
if (oldParentIdentifier != null) parents.add(oldParentIdentifier);
if (parentIdentifier    != null) parents.add(parentIdentifier);
return parents;
protected boolean canUpdateModifiedParents(ModeledAuthenticatedUser user,
Collection<String> modifiedParents = getModifiedParents(user, identifier, model);
if (!modifiedParents.isEmpty()) {
ObjectPermissionSet permissionSet = getParentPermissionSet(user);
Collection<String> updateableParents = permissionSet.getAccessibleObjects(
modifiedParents
return updateableParents.size() == modifiedParents.size();
if (!canUpdateModifiedParents(user, null, model))
if (!canUpdateModifiedParents(user, model.getIdentifier(), model))
if (!canUpdateModifiedParents(user, identifier, null))
import org.apache.guacamole.auth.jdbc.base.ChildObjectModel;
public class ConnectionModel extends ChildObjectModel {
import org.apache.guacamole.auth.jdbc.base.ModeledChildDirectoryObjectService;
public class ConnectionService extends ModeledChildDirectoryObjectService<ModeledConnection, Connection, ConnectionModel> {
protected ObjectPermissionSet getParentPermissionSet(ModeledAuthenticatedUser user)
throws GuacamoleException {
return user.getUser().getConnectionGroupPermissions();
}
@Override
import org.apache.guacamole.auth.jdbc.base.ModeledChildDirectoryObject;
public class ModeledConnection extends ModeledChildDirectoryObject<ConnectionModel>
import org.apache.guacamole.auth.jdbc.base.ChildObjectModel;
public class ConnectionGroupModel extends ChildObjectModel {
import org.apache.guacamole.auth.jdbc.base.ModeledChildDirectoryObjectService;
public class ConnectionGroupService extends ModeledChildDirectoryObjectService<ModeledConnectionGroup,
protected ObjectPermissionSet getParentPermissionSet(ModeledAuthenticatedUser user)
throws GuacamoleException {
return user.getUser().getConnectionGroupPermissions();
}
@Override
import org.apache.guacamole.auth.jdbc.base.ModeledChildDirectoryObject;
public class ModeledConnectionGroup extends ModeledChildDirectoryObject<ConnectionGroupModel>
import org.apache.guacamole.auth.jdbc.base.ModeledChildDirectoryObject;
extends ModeledChildDirectoryObject<SharingProfileModel>
return getModel().getParentIdentifier();
getModel().setParentIdentifier(identifier);
@Param("parentIdentifier") String parentIdentifier,
import org.apache.guacamole.auth.jdbc.base.ChildObjectModel;
public class SharingProfileModel extends ChildObjectModel {
import org.apache.guacamole.auth.jdbc.base.ModeledChildDirectoryObjectService;
extends ModeledChildDirectoryObjectService<ModeledSharingProfile,
protected ObjectPermissionSet getParentPermissionSet(ModeledAuthenticatedUser user)
throws GuacamoleException {
return user.getUser().getConnectionPermissions();
}
@Override
SharingProfileModel existing = sharingProfileMapper.selectOneByName(model.getParentIdentifier(), model.getName());
SharingProfileModel existing = sharingProfileMapper.selectOneByName(model.getParentIdentifier(), model.getName());
"0.9.10-incubating"
"0.9.10-incubating"
public int getMaxResults() throws GuacamoleException {
return environment.getProperty(
LDAPGuacamoleProperties.LDAP_MAX_SEARCH_RESULTS,
1000
);
}
public static final IntegerGuacamoleProperty LDAP_MAX_SEARCH_RESULTS = new IntegerGuacamoleProperty() {
@Override
public String getName() { return "ldap-max-search-results"; }
};
import com.novell.ldap.LDAPSearchConstraints;
LDAPSearchConstraints constraints = new LDAPSearchConstraints();
constraints.setMaxResults(confService.getMaxResults());
false,
constraints
import org.apache.guacamole.auth.jdbc.sharing.user.SharedAuthenticatedUser;
@Inject
private JDBCEnvironment environment;
if (user == null) {
if (authenticatedUser instanceof SharedAuthenticatedUser)
return null;
if (!environment.isUserRequired())
return null;
throw new GuacamoleInvalidCredentialsException("Invalid login",
CredentialsInfo.USERNAME_PASSWORD);
}
public abstract boolean isUserRequired() throws GuacamoleException;
private static final boolean DEFAULT_USER_REQUIRED = false;
public boolean isUserRequired() throws GuacamoleException {
return getProperty(
MySQLGuacamoleProperties.MYSQL_USER_REQUIRED,
DEFAULT_USER_REQUIRED
);
}
@Override
public static final BooleanGuacamoleProperty MYSQL_USER_REQUIRED = new BooleanGuacamoleProperty() {
@Override
public String getName() { return "mysql-user-required"; }
};
private static final boolean DEFAULT_USER_REQUIRED = false;
public boolean isUserRequired() throws GuacamoleException {
return getProperty(
PostgreSQLGuacamoleProperties.POSTGRESQL_USER_REQUIRED,
DEFAULT_USER_REQUIRED
);
}
@Override
public static final BooleanGuacamoleProperty
POSTGRESQL_USER_REQUIRED = new BooleanGuacamoleProperty() {
@Override
public String getName() { return "postgresql-user-required"; }
};
import org.apache.guacamole.auth.jdbc.sharing.user.SharedAuthenticatedUser;
@Inject
private JDBCEnvironment environment;
if (user == null) {
if (authenticatedUser instanceof SharedAuthenticatedUser)
return null;
if (!environment.isUserRequired())
return null;
throw new GuacamoleInvalidCredentialsException("Invalid login",
CredentialsInfo.USERNAME_PASSWORD);
}
public abstract boolean isUserRequired() throws GuacamoleException;
private static final boolean DEFAULT_USER_REQUIRED = false;
public boolean isUserRequired() throws GuacamoleException {
return getProperty(
MySQLGuacamoleProperties.MYSQL_USER_REQUIRED,
DEFAULT_USER_REQUIRED
);
}
@Override
public static final BooleanGuacamoleProperty MYSQL_USER_REQUIRED = new BooleanGuacamoleProperty() {
@Override
public String getName() { return "mysql-user-required"; }
};
private static final boolean DEFAULT_USER_REQUIRED = false;
public boolean isUserRequired() throws GuacamoleException {
return getProperty(
PostgreSQLGuacamoleProperties.POSTGRESQL_USER_REQUIRED,
DEFAULT_USER_REQUIRED
);
}
@Override
public static final BooleanGuacamoleProperty
POSTGRESQL_USER_REQUIRED = new BooleanGuacamoleProperty() {
@Override
public String getName() { return "postgresql-user-required"; }
};
import org.webjars.servlet.WebjarsServlet;
bind(WebjarsServlet.class).in(Scopes.SINGLETON);
serve("/webjars/*").with(WebjarsServlet.class);
import org.webjars.servlet.WebjarsServlet;
bind(WebjarsServlet.class).in(Scopes.SINGLETON);
serve("/webjars/*").with(WebjarsServlet.class);
import org.webjars.servlet.WebjarsServlet;
bind(WebjarsServlet.class).in(Scopes.SINGLETON);
serve("/webjars/*").with(WebjarsServlet.class);
import org.apache.guacamole.auth.jdbc.user.UserModel;
UserModel userModel = user.getModel();
if (userModel.isExpired())
userService.resetExpiredPassword(user, authenticatedUser.getCredentials());
public void resetExpiredPassword(ModeledUser user, Credentials credentials)
throws GuacamoleException {
UserModel userModel = user.getModel();
String username = user.getIdentifier();
HttpServletRequest request = credentials.getRequest();
String newPassword = request.getParameter(NEW_PASSWORD_PARAMETER);
String confirmNewPassword = request.getParameter(CONFIRM_NEW_PASSWORD_PARAMETER);
if (newPassword == null || confirmNewPassword == null) {
logger.info("The password of user \"{}\" has expired and must be reset.", username);
throw new GuacamoleInsufficientCredentialsException("LOGIN.INFO_PASSWORD_EXPIRED", EXPIRED_PASSWORD);
}
if (newPassword.equals(credentials.getPassword()))
throw new GuacamoleClientException("LOGIN.ERROR_PASSWORD_SAME");
if (newPassword.isEmpty())
throw new GuacamoleClientException("LOGIN.ERROR_PASSWORD_BLANK");
if (!newPassword.equals(confirmNewPassword))
throw new GuacamoleClientException("LOGIN.ERROR_PASSWORD_MISMATCH");
userModel.setExpired(false);
user.setPassword(newPassword);
userMapper.update(userModel);
logger.info("Expired password of user \"{}\" has been reset.", username);
}
import org.apache.guacamole.auth.jdbc.user.UserModel;
UserModel userModel = user.getModel();
if (userModel.isExpired())
userService.resetExpiredPassword(user, authenticatedUser.getCredentials());
public void resetExpiredPassword(ModeledUser user, Credentials credentials)
throws GuacamoleException {
UserModel userModel = user.getModel();
String username = user.getIdentifier();
HttpServletRequest request = credentials.getRequest();
String newPassword = request.getParameter(NEW_PASSWORD_PARAMETER);
String confirmNewPassword = request.getParameter(CONFIRM_NEW_PASSWORD_PARAMETER);
if (newPassword == null || confirmNewPassword == null) {
logger.info("The password of user \"{}\" has expired and must be reset.", username);
throw new GuacamoleInsufficientCredentialsException("LOGIN.INFO_PASSWORD_EXPIRED", EXPIRED_PASSWORD);
}
if (newPassword.equals(credentials.getPassword()))
throw new GuacamoleClientException("LOGIN.ERROR_PASSWORD_SAME");
if (newPassword.isEmpty())
throw new GuacamoleClientException("LOGIN.ERROR_PASSWORD_BLANK");
if (!newPassword.equals(confirmNewPassword))
throw new GuacamoleClientException("LOGIN.ERROR_PASSWORD_MISMATCH");
userModel.setExpired(false);
user.setPassword(newPassword);
userMapper.update(userModel);
logger.info("Expired password of user \"{}\" has been reset.", username);
}
UserVerificationService verificationService =
injector.getInstance(UserVerificationService.class);
verificationService.verifyAuthenticatedUser(authenticatedUser);
bind(UserVerificationService.class);
public class UserVerificationService {
import org.apache.guacamole.auth.duo.api.DuoService;
bind(DuoService.class);
import org.apache.guacamole.auth.duo.api.DuoService;
private DuoService duoService;
duoService.createSignedRequest(authenticatedUser));
if (!duoService.isValidSignedResponse(authenticatedUser, signedResponse))
import org.apache.guacamole.auth.duo.api.DuoService;
bind(DuoService.class);
import org.apache.guacamole.auth.duo.api.DuoService;
private DuoService duoService;
duoService.createSignedRequest(authenticatedUser));
if (!duoService.isValidSignedResponse(authenticatedUser, signedResponse))
import org.apache.guacamole.GuacamoleClientException;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleResourceNotFoundException;
import org.apache.guacamole.GuacamoleSecurityException;
import org.apache.guacamole.net.auth.credentials.GuacamoleCredentialsException;
import org.apache.guacamole.net.auth.credentials.GuacamoleInsufficientCredentialsException;
import org.apache.guacamole.net.auth.credentials.GuacamoleInvalidCredentialsException;
import org.apache.guacamole.tunnel.GuacamoleStreamException;
BAD_REQUEST,
INVALID_CREDENTIALS,
INSUFFICIENT_CREDENTIALS,
INTERNAL_ERROR,
NOT_FOUND,
PERMISSION_DENIED,
STREAM_ERROR;
public static Type fromGuacamoleException(GuacamoleException exception) {
if (exception instanceof GuacamoleInsufficientCredentialsException)
return INSUFFICIENT_CREDENTIALS;
if (exception instanceof GuacamoleInvalidCredentialsException)
return INVALID_CREDENTIALS;
if (exception instanceof GuacamoleSecurityException)
return PERMISSION_DENIED;
if (exception instanceof GuacamoleResourceNotFoundException)
return NOT_FOUND;
if (exception instanceof GuacamoleClientException)
return BAD_REQUEST;
if (exception instanceof GuacamoleStreamException)
return STREAM_ERROR;
return INTERNAL_ERROR;
public APIError(GuacamoleException exception) {
this.type = Type.fromGuacamoleException(exception);
this.message = exception.getMessage();
if (exception instanceof GuacamoleCredentialsException) {
GuacamoleCredentialsException credentialsException = (GuacamoleCredentialsException) exception;
this.expected = credentialsException.getCredentialsInfo().getFields();
}
else
this.expected = null;
if (exception instanceof GuacamoleStreamException) {
GuacamoleStreamException streamException = (GuacamoleStreamException) exception;
this.statusCode = streamException.getStatus().getGuacamoleStatusCode();
}
else
this.statusCode = null;
import org.apache.guacamole.GuacamoleException;
public APIException(Response.Status status, GuacamoleException exception) {
super(Response.status(status)
.entity(new APIError(exception))
import javax.ws.rs.WebApplicationException;
import javax.ws.rs.core.Response;
public Object invoke(MethodInvocation invocation) throws WebApplicationException {
throw new APIException(Response.Status.FORBIDDEN, e);
throw new APIException(Response.Status.NOT_FOUND, e);
throw new APIException(Response.Status.BAD_REQUEST, e);
throw new APIException(Response.Status.INTERNAL_SERVER_ERROR, e);
}
catch (Throwable t) {
String message = t.getMessage();
logger.debug("Unexpected error in REST endpoint.", t);
throw new APIException(Response.Status.INTERNAL_SERVER_ERROR,
new GuacamoleException("Unexpected internal error.", t));
import javax.ws.rs.core.Response;
import org.apache.guacamole.GuacamoleClientException;
Response.Status.BAD_REQUEST,
new GuacamoleClientException(String.format("Invalid sort property: \"%s\"", value))
import org.apache.guacamole.language.Translatable;
import org.apache.guacamole.language.TranslatableMessage;
private final TranslatableMessage translatableMessage;
if (exception instanceof Translatable) {
Translatable translatable = (Translatable) exception;
this.translatableMessage = translatable.getTranslatableMessage();
}
else
this.translatableMessage = new TranslatableMessage(this.message);
public TranslatableMessage getTranslatableMessage() {
return translatableMessage;
}
ExternalType object, ModelType model) throws GuacamoleException {
super.beforeCreate(user, object, model);
ExternalType object, ModelType model) throws GuacamoleException {
beforeCreate(user, object, model);
Connection object, ConnectionModel model)
throws GuacamoleException {
super.beforeCreate(user, object, model);
ConnectionGroup object, ConnectionGroupModel model)
throws GuacamoleException {
super.beforeCreate(user, object, model);
SharingProfile object, SharingProfileModel model)
throws GuacamoleException {
super.beforeCreate(user, object, model);
protected void beforeCreate(ModeledAuthenticatedUser user, User object,
UserModel model) throws GuacamoleException {
super.beforeCreate(user, object, model);
InternalType object, ModelType model) throws GuacamoleException {
super.beforeUpdate(user, object, model);
InternalType object, ModelType model) throws GuacamoleException {
beforeUpdate(user, object, model);
ModeledConnection object, ConnectionModel model)
throws GuacamoleException {
super.beforeUpdate(user, object, model);
ModeledConnectionGroup object, ConnectionGroupModel model)
throws GuacamoleException {
super.beforeUpdate(user, object, model);
ModeledSharingProfile object, SharingProfileModel model)
throws GuacamoleException {
super.beforeUpdate(user, object, model);
ModeledUser object, UserModel model) throws GuacamoleException {
super.beforeUpdate(user, object, model);
import org.apache.guacamole.auth.jdbc.security.PasswordPolicyService;
bind(PasswordPolicyService.class);
import org.apache.guacamole.auth.jdbc.security.PasswordPolicy;
public abstract PasswordPolicy getPasswordPolicy();
import org.apache.guacamole.auth.jdbc.security.PasswordPolicyService;
@Inject
private PasswordPolicyService passwordPolicyService;
if (object.getPassword() != null)
passwordPolicyService.verifyPassword(object.getIdentifier(), object.getPassword());
if (object.getPassword() != null)
passwordPolicyService.verifyPassword(object.getIdentifier(), object.getPassword());
passwordPolicyService.verifyPassword(username, newPassword);
import org.apache.guacamole.auth.jdbc.security.PasswordPolicy;
@Override
public PasswordPolicy getPasswordPolicy() {
return new MySQLPasswordPolicy(this);
}
import org.apache.guacamole.auth.jdbc.security.PasswordPolicy;
@Override
public PasswordPolicy getPasswordPolicy() {
return new PostgreSQLPasswordPolicy(this);
}
userModel.setPasswordSalt(saltService.generateSalt());
userModel.setPasswordHash(saltService.generateSalt());
import java.sql.Timestamp;
private Timestamp passwordDate;
public Timestamp getPasswordDate() {
return passwordDate;
}
public void setPasswordDate(Timestamp passwordDate) {
this.passwordDate = passwordDate;
}
import org.apache.guacamole.auth.jdbc.security.PasswordPolicyService;
@Inject
private PasswordPolicyService passwordPolicyService;
if (userModel.isExpired() || passwordPolicyService.isPasswordExpired(userModel))
int getMinimumAge() throws GuacamoleException;
int getMaximumAge() throws GuacamoleException;
import java.util.concurrent.TimeUnit;
import org.apache.guacamole.auth.jdbc.user.UserModel;
private long getPasswordAge(UserModel user) {
long currentTime = System.currentTimeMillis();
long lastResetTime = user.getPasswordDate().getTime();
return TimeUnit.DAYS.convert(currentTime - lastResetTime, TimeUnit.MILLISECONDS);
}
public void verifyPasswordAge(UserModel user) throws GuacamoleException {
PasswordPolicy policy = environment.getPasswordPolicy();
long minimumAge = policy.getMinimumAge();
long passwordAge = getPasswordAge(user);
if (passwordAge < minimumAge)
throw new PasswordTooYoungException("Password was already recently changed.",
minimumAge - passwordAge);
}
public boolean isPasswordExpired(UserModel user)
throws GuacamoleException {
PasswordPolicy policy = environment.getPasswordPolicy();
int maxPasswordAge = policy.getMaximumAge();
if (maxPasswordAge == 0)
return false;
return getPasswordAge(user) >= maxPasswordAge;
}
import java.sql.Timestamp;
model.setPasswordDate(new Timestamp(System.currentTimeMillis()));
if (object.getPassword() != null) {
if (!user.getUser().isAdministrator())
passwordPolicyService.verifyPasswordAge(model);
model.setPasswordDate(new Timestamp(System.currentTimeMillis()));
}
private static final IntegerGuacamoleProperty MIN_AGE =
new IntegerGuacamoleProperty() {
@Override
public String getName() { return "mysql-user-password-min-age"; }
};
private static final IntegerGuacamoleProperty MAX_AGE =
new IntegerGuacamoleProperty() {
@Override
public String getName() { return "mysql-user-password-max-age"; }
};
public int getMinimumAge() throws GuacamoleException {
return environment.getProperty(MIN_AGE, 0);
}
@Override
public int getMaximumAge() throws GuacamoleException {
return environment.getProperty(MAX_AGE, 0);
}
@Override
private static final IntegerGuacamoleProperty MIN_AGE =
new IntegerGuacamoleProperty() {
@Override
public String getName() { return "postgresql-user-password-min-age"; }
};
private static final IntegerGuacamoleProperty MAX_AGE =
new IntegerGuacamoleProperty() {
@Override
public String getName() { return "postgresql-user-password-max-age"; }
};
public int getMinimumAge() throws GuacamoleException {
return environment.getProperty(MIN_AGE, 0);
}
@Override
public int getMaximumAge() throws GuacamoleException {
return environment.getProperty(MAX_AGE, 0);
}
@Override
if (userModel.isExpired() || passwordPolicyService.isPasswordExpired(user))
import org.apache.guacamole.auth.jdbc.user.ModeledUser;
private long getPasswordAge(ModeledUser user) {
long lastResetTime = user.getPreviousPasswordDate().getTime();
public void verifyPasswordAge(ModeledUser user) throws GuacamoleException {
public boolean isPasswordExpired(ModeledUser user)
import java.sql.Timestamp;
private Timestamp previousPasswordDate = null;
public void setModel(UserModel model) {
super.setModel(model);
this.previousPasswordDate = model.getPasswordDate();
}
@Override
userModel.setPasswordDate(new Timestamp(System.currentTimeMillis()));
}
public Timestamp getPreviousPasswordDate() {
return previousPasswordDate;
passwordPolicyService.verifyPasswordAge(object);
import org.apache.guacamole.auth.jdbc.user.PasswordRecordModel;
PasswordRecordModel previousPassword = user.getPreviousPassword();
if (previousPassword == null)
return 0;
long lastResetTime = previousPassword.getPasswordDate().getTime();
private PasswordRecordModel previousPassword = null;
if (model.getPasswordHash() != null)
this.previousPassword = new PasswordRecordModel(model);
public PasswordRecordModel getPreviousPassword() {
return previousPassword;
import org.apache.guacamole.auth.jdbc.user.PasswordRecordMapper;
addMapperClass(PasswordRecordMapper.class);
int getHistorySize() throws GuacamoleException;
import org.apache.guacamole.auth.jdbc.user.PasswordRecordMapper;
@Inject
private PasswordRecordMapper passwordRecordMapper;
public void recordPreviousPassword(ModeledUser user)
throws GuacamoleException {
PasswordPolicy policy = environment.getPasswordPolicy();
int historySize = policy.getHistorySize();
if (historySize <= 0)
return;
passwordRecordMapper.insert(user.getPreviousPassword(), historySize);
}
passwordPolicyService.recordPreviousPassword(object);
private static final IntegerGuacamoleProperty HISTORY_SIZE =
new IntegerGuacamoleProperty() {
@Override
public String getName() { return "mysql-user-password-history-size"; }
};
public int getHistorySize() throws GuacamoleException {
return environment.getProperty(HISTORY_SIZE, 0);
}
@Override
private static final IntegerGuacamoleProperty HISTORY_SIZE =
new IntegerGuacamoleProperty() {
@Override
public String getName() { return "postgresql-user-password-history-size"; }
};
public int getHistorySize() throws GuacamoleException {
return environment.getProperty(HISTORY_SIZE, 0);
}
@Override
import java.util.Arrays;
import java.util.List;
@Inject
private PasswordEncryptionService encryptionService;
private boolean matchesPreviousPasswords(String password, String username,
int historySize) {
if (historySize <= 0)
return false;
List<PasswordRecordModel> history = passwordRecordMapper.select(username, historySize);
for (PasswordRecordModel record : history) {
byte[] hash = encryptionService.createPasswordHash(password, record.getPasswordSalt());
if (Arrays.equals(hash, record.getPasswordHash()))
return true;
}
return false;
}
int historySize = policy.getHistorySize();
if (matchesPreviousPasswords(password, username, historySize))
throw new PasswordReusedException(
"Password matches a previously-used password.", historySize);
import org.apache.guacamole.auth.jdbc.connection.GuacamoleProxyConfiguration;
import org.apache.guacamole.environment.Environment;
private static final String DEFAULT_GUACD_HOSTNAME = "localhost";
private static final int DEFAULT_GUACD_PORT = 4822;
public GuacamoleProxyConfiguration getDefaultGuacamoleProxyConfiguration()
throws GuacamoleException {
return new GuacamoleProxyConfiguration(
getProperty(Environment.GUACD_HOSTNAME, DEFAULT_GUACD_HOSTNAME),
getProperty(Environment.GUACD_PORT, DEFAULT_GUACD_PORT),
getProperty(Environment.GUACD_SSL, false)
);
}
import org.apache.guacamole.auth.jdbc.connection.GuacamoleProxyConfiguration.EncryptionMethod;
private String proxyHostname;
private Integer proxyPort;
private EncryptionMethod proxyEncryptionMethod;
public String getProxyHostname() {
return proxyHostname;
}
public void setProxyHostname(String proxyHostname) {
this.proxyHostname = proxyHostname;
}
public Integer getProxyPort() {
return proxyPort;
}
public void setProxyPort(Integer proxyPort) {
this.proxyPort = proxyPort;
}
public EncryptionMethod getProxyEncryptionMethod() {
return proxyEncryptionMethod;
}
public void setProxyEncryptionMethod(EncryptionMethod proxyEncryptionMethod) {
this.proxyEncryptionMethod = proxyEncryptionMethod;
}
import org.apache.guacamole.auth.jdbc.connection.GuacamoleProxyConfiguration.EncryptionMethod;
import org.apache.guacamole.form.EnumField;
import org.apache.guacamole.form.TextField;
public static final String GUACD_HOSTNAME_NAME = "guacd-hostname";
public static final String GUACD_PORT_NAME = "guacd-port";
public static final String GUACD_ENCRYPTION_NAME = "guacd-encryption";
public static final String GUACD_ENCRYPTION_VALUE_NONE = "none";
public static final String GUACD_ENCRYPTION_VALUE_SSL = "ssl";
public static final Form GUACD_PARAMETERS = new Form("guacd", Arrays.<Field>asList(
new TextField(GUACD_HOSTNAME_NAME),
new NumericField(GUACD_PORT_NAME),
new EnumField(GUACD_ENCRYPTION_NAME, Arrays.asList(
"",
GUACD_ENCRYPTION_VALUE_NONE,
GUACD_ENCRYPTION_VALUE_SSL
))
));
CONCURRENCY_LIMITS,
GUACD_PARAMETERS
attributes.put(GUACD_HOSTNAME_NAME, getModel().getProxyHostname());
attributes.put(GUACD_PORT_NAME, NumericField.format(getModel().getProxyPort()));
EncryptionMethod encryptionMethod = getModel().getProxyEncryptionMethod();
if (encryptionMethod == null)
attributes.put(GUACD_ENCRYPTION_NAME, null);
else {
switch (encryptionMethod) {
case NONE:
attributes.put(GUACD_ENCRYPTION_NAME, GUACD_ENCRYPTION_VALUE_NONE);
break;
case SSL:
attributes.put(GUACD_ENCRYPTION_NAME, GUACD_ENCRYPTION_VALUE_SSL);
break;
default:
attributes.put(GUACD_ENCRYPTION_NAME, null);
}
}
getModel().setProxyHostname(attributes.get(GUACD_HOSTNAME_NAME));
try { getModel().setProxyPort(NumericField.parse(attributes.get(GUACD_PORT_NAME))); }
catch (NumberFormatException e) {
logger.warn("Not setting guacd port: {}", e.getMessage());
logger.debug("Unable to parse numeric attribute.", e);
}
String encryptionMethod = attributes.get(GUACD_ENCRYPTION_NAME);
if (GUACD_ENCRYPTION_VALUE_NONE.equals(encryptionMethod))
getModel().setProxyEncryptionMethod(EncryptionMethod.NONE);
else if (GUACD_ENCRYPTION_VALUE_SSL.equals(encryptionMethod))
getModel().setProxyEncryptionMethod(EncryptionMethod.SSL);
else
getModel().setProxyEncryptionMethod(null);
public GuacamoleProxyConfiguration getGuacamoleProxyConfiguration()
throws GuacamoleException {
GuacamoleProxyConfiguration defaultConfig = environment.getDefaultGuacamoleProxyConfiguration();
String hostname = getModel().getProxyHostname();
Integer port = getModel().getProxyPort();
EncryptionMethod encryptionMethod = getModel().getProxyEncryptionMethod();
return new GuacamoleProxyConfiguration(
hostname         != null ? hostname         : defaultConfig.getHostname(),
port             != null ? port             : defaultConfig.getPort(),
encryptionMethod != null ? encryptionMethod : defaultConfig.getEncryptionMethod()
);
}
import org.apache.guacamole.GuacamoleServerException;
import org.apache.guacamole.auth.jdbc.connection.GuacamoleProxyConfiguration;
private GuacamoleSocket getUnconfiguredGuacamoleSocket(
GuacamoleProxyConfiguration proxyConfig,
Runnable socketClosedCallback) throws GuacamoleException {
switch (proxyConfig.getEncryptionMethod()) {
case SSL:
return new ManagedSSLGuacamoleSocket(
proxyConfig.getHostname(),
proxyConfig.getPort(),
socketClosedCallback
);
case NONE:
return new ManagedInetGuacamoleSocket(
proxyConfig.getHostname(),
proxyConfig.getPort(),
socketClosedCallback
);
}
throw new GuacamoleServerException("Unimplemented encryption method.");
ModeledConnection connection = activeConnection.getConnection();
getUnconfiguredGuacamoleSocket(connection.getGuacamoleProxyConfiguration(),
cleanupTask), config, info);
import com.google.inject.Guice;
import com.google.inject.Injector;
private final Injector injector;
public OAuthAuthenticationProvider() throws GuacamoleException {
injector = Guice.createInjector(
new OAuthAuthenticationProviderModule(this)
);
}
AuthenticationProviderService authProviderService = injector.getInstance(AuthenticationProviderService.class);
return authProviderService.authenticateUser(credentials);
super(OAUTH_CODE_PARAMETER_NAME, "GUAC_OAUTH_CODE");
import com.google.inject.Provider;
import javax.servlet.http.HttpServletRequest;
import org.apache.guacamole.auth.oauth.user.AuthenticatedUser;
@Inject
private Provider<AuthenticatedUser> authenticatedUserProvider;
String code = null;
HttpServletRequest request = credentials.getRequest();
if (request != null)
code = request.getParameter(OAuthCodeField.PARAMETER_NAME);
if (code != null) {
AuthenticatedUser authenticatedUser = authenticatedUserProvider.get();
authenticatedUser.init("STUB", credentials);
return authenticatedUser;
}
public static final String PARAMETER_NAME = "code";
super(PARAMETER_NAME, "GUAC_OAUTH_CODE");
import org.apache.guacamole.auth.oauth.conf.ConfigurationService;
import org.apache.guacamole.auth.oauth.form.OAuthCodeField;
import org.apache.guacamole.auth.oauth.conf.ConfigurationService;
package org.apache.guacamole.auth.oauth.conf;
package org.apache.guacamole.auth.oauth.conf;
package org.apache.guacamole.auth.oauth.form;
public String getTokenEndpoint() throws GuacamoleException {
return environment.getRequiredProperty(OAuthGuacamoleProperties.OAUTH_TOKEN_ENDPOINT);
}
public static final StringGuacamoleProperty OAUTH_TOKEN_ENDPOINT =
new StringGuacamoleProperty() {
@Override
public String getName() { return "oauth-token-endpoint"; }
};
import org.apache.guacamole.auth.oauth.token.TokenResponse;
import org.apache.guacamole.auth.oauth.token.TokenService;
@Inject
private TokenService tokenService;
TokenResponse response = tokenService.getTokenFromCode(code);
logger.debug("RESPONSE: {}", response);
import com.sun.jersey.api.client.Client;
import com.sun.jersey.api.client.config.ClientConfig;
import com.sun.jersey.api.client.config.DefaultClientConfig;
import org.apache.guacamole.auth.oauth.token.TokenService;
import org.codehaus.jackson.jaxrs.JacksonJaxbJsonProvider;
import org.codehaus.jackson.map.DeserializationConfig;
private final Client client;
ClientConfig clientConfig = new DefaultClientConfig();
clientConfig.getSingletons().add(new JacksonJaxbJsonProvider()
.configure(DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES, false)
);
this.client = Client.create(clientConfig);
bind(TokenService.class);
bind(Client.class).toInstance(client);
import org.apache.guacamole.auth.oauth.form.OAuthTokenField;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.form.Field;
import org.apache.guacamole.net.auth.Credentials;
import org.apache.guacamole.net.auth.credentials.CredentialsInfo;
import org.apache.guacamole.net.auth.credentials.GuacamoleInvalidCredentialsException;
String token = null;
token = request.getParameter(OAuthTokenField.PARAMETER_NAME);
if (token != null) {
new OAuthTokenField(
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.auth.AuthenticatedUser;
import org.apache.guacamole.net.auth.AuthenticationProvider;
import org.apache.guacamole.net.auth.Credentials;
import org.apache.guacamole.net.auth.UserContext;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.environment.Environment;
import org.apache.guacamole.environment.LocalEnvironment;
import org.apache.guacamole.net.auth.AuthenticationProvider;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.environment.Environment;
import org.apache.guacamole.properties.StringGuacamoleProperty;
import java.util.UUID;
import org.apache.guacamole.form.Field;
public class OAuthTokenField extends Field {
public static final String PARAMETER_NAME = "id_token";
public OAuthTokenField(String authorizationEndpoint, String clientID,
super(PARAMETER_NAME, "GUAC_OAUTH_TOKEN");
"&response_type=id_token"
import org.apache.guacamole.net.auth.AbstractAuthenticatedUser;
import org.apache.guacamole.net.auth.AuthenticationProvider;
import org.apache.guacamole.net.auth.Credentials;
import org.apache.guacamole.auth.oauth.token.TokenValidationService;
import org.apache.guacamole.auth.oauth.user.AuthenticatedUser;
@Inject
private TokenValidationService tokenService;
authenticatedUser.init(tokenService.processUsername(token), credentials);
import org.apache.guacamole.auth.oauth.token.TokenValidationService;
bind(TokenValidationService.class);
public String getIssuer() throws GuacamoleException {
return environment.getRequiredProperty(OAuthGuacamoleProperties.OAUTH_ISSUER);
}
public String getJWKSEndpoint() throws GuacamoleException {
return environment.getRequiredProperty(OAuthGuacamoleProperties.OAUTH_JWKS_ENDPOINT);
}
public String getUsernameClaimType() throws GuacamoleException {
return environment.getRequiredProperty(OAuthGuacamoleProperties.OAUTH_USERNAME_CLAIM_TYPE);
}
public static final StringGuacamoleProperty OAUTH_JWKS_ENDPOINT =
new StringGuacamoleProperty() {
@Override
public String getName() { return "oauth-jwks-endpoint"; }
};
public static final StringGuacamoleProperty OAUTH_ISSUER =
new StringGuacamoleProperty() {
@Override
public String getName() { return "oauth-issuer"; }
};
public static final StringGuacamoleProperty OAUTH_USERNAME_CLAIM_TYPE =
new StringGuacamoleProperty() {
@Override
public String getName() { return "oauth-username-claim-type"; }
};
import java.math.BigInteger;
import java.security.SecureRandom;
private static final SecureRandom random = new SecureRandom();
private static String generateNonce() {
return new BigInteger(130, random).toString(32);
}
AuthenticatedUser authenticatedUser, Credentials credentials)
throws GuacamoleException {
